require({cache:{
'idx/form/FilteringSelect':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define([
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/dom-class",
	"dojo/dom-style",
	"dojo/window",
	"dojo/has",
	"dijit/_WidgetsInTemplateMixin",
	"dijit/form/FilteringSelect",
	"idx/widget/HoverHelpTooltip",
	"./_CompositeMixin",
	"./_CssStateMixin",
	"./_AutoCompleteA11yMixin",
	// ====================================================================================================================
	// ------
	// Load _TemplatePlugableMixin and PlatformPluginRegistry if on "mobile" or if on desktop, but using the 
	// platform-plugable API.  Any prior call to PlaformPluginRegistry.setGlobalTargetPlatform() or 
	// PlatformPluginRegistry.setRegistryDefaultPlatform() sets "platform-plugable" property for dojo/has.
	// ------
	"idx/has!#mobile?idx/_TemplatePlugableMixin:#platform-plugable?idx/_TemplatePlugableMixin", 
	"idx/has!#mobile?idx/PlatformPluginRegistry:#platform-plugable?idx/PlatformPluginRegistry",
	
	// ------
	// We want to load the desktop template unless we are using the mobile implementation.
	// ------
	"idx/has!#idx_form_FilteringSelect-desktop?dojo/text!./templates/ComboBox.html" 	// desktop widget, load the template
		+ ":#idx_form_FilteringSelect-mobile?"											// mobile widget, don't load desktop template
		+ ":#desktop?dojo/text!./templates/ComboBox.html"								// global desktop platform, load template
		+ ":#mobile?"																	// global mobile platform, don't load
		+ ":dojo/text!./templates/ComboBox.html", 										// no dojo/has features, load the template
			
	// ------
	// Load the mobile plugin according to build-time/runtime dojo/has features
	// ------
	"idx/has!#idx_form_FilteringSelect-mobile?./plugins/phone/FilteringSelectPlugin"		// mobile widget, load the plugin
		+ ":#idx_form_FilteringSelect-desktop?"												// desktop widget, don't load plugin
		+ ":#mobile?./plugins/phone/FilteringSelectPlugin"									// global mobile platform, load plugin
		+ ":"																				// no features, don't load plugin

], function(declare, lang, domClass, domStyle, winUtils, has, _WidgetsInTemplateMixin, FilteringSelect, 
	HoverHelpTooltip, _CompositeMixin, _CssStateMixin, _AutoCompleteA11yMixin, 
	TemplatePlugableMixin, PlatformPluginRegistry, desktopTemplate, MobilePlugin) {
	
	var baseClassName = "idx.form.FilteringSelect";
	if (has("mobile") || has("platform-plugable")) {
		baseClassName = baseClassName + "Base";
	}
	
	var iForm = lang.getObject("idx.oneui.form", true); // for backward compatibility with IDX 1.2

	/**
	 * @name idx.form.FilteringSelect
	 * @class idx.form.FilteringSelect is implemented according to IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y27&vsub=*&hsub=*&openpanes=0000010000">Combo Boxes Standard</a></b>.
	 * It is a composite widget which enhanced dijit.form.FilteringSelect with following features:
	 * <ul>
	 * <li>Built-in label</li>
	 * <li>Built-in label positioning</li>
	 * <li>Built-in hint</li>
	 * <li>Built-in hint positioning</li>
	 * <li>Built-in required attribute</li>
	 * <li>One UI theme support</li>
	 * </ul>
	 * @augments dijit.form.FilteringSelect
	 * @augments idx.form._CompositeMixin
	 * @augments idx.form._CssStateMixin
	 */
	iForm.FilteringSelect = declare(baseClassName, [FilteringSelect, _CompositeMixin, _CssStateMixin,_AutoCompleteA11yMixin],
	/**@lends idx.form.FilteringSelect.prototype*/
	{
		
		baseClass: "idxFilteringSelectWrap",
		
		oneuiBaseClass: "dijitTextBox dijitComboBox",
		
		templateString: desktopTemplate,
		
		selectOnClick: true,
		
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},
		/**
		 * Defect 11885
		 * overwrite the method in _CompositeMixin
		 * @param {Object} v
		 */
		_setPlaceHolderAttr: function(){
			this._placeholder = false;
			this.inherited(arguments);
		},
		
		postCreate: function() {
			this.dropDownClass = FilteringSelect.prototype.dropDownClass;
			this.inherited(arguments);
			//Defect 11821, remove the aria-labelledby attribute from the dom node
			this.domNode.removeAttribute("aria-labelledby");
			this.connect(this, "_onFocus", function(){
				if (this.message && this._hasBeenBlurred && (!this._refocusing)) {
					this.displayMessage(this.message);
				}
			});
			this._resize();
			//
			//A11y defect to remove the aria-labelledby when the label is empty
			//

			var islabelEmpty = /^\s*$/.test(this.label);
			if ( islabelEmpty ){
				this.oneuiBaseNode.removeAttribute("aria-labelledby");
				this.compLabelNode.innerHTML = "hidden";
			}
		},
		/**
		 * Provides a method to return focus to the widget without triggering
		 * revalidation.  This is typically called when the validation tooltip
		 * is closed.
		 */
		refocus: function() {
			this._refocusing = true;
			this.focus();
			this._refocusing = false;
		},
		
			
		_isEmpty: function(){
			return (/^\s*$/.test(this.textbox.value || ""));
		},

		_onBlur: function(){
			this.inherited(arguments);
			this.validate(this.focused);
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			//	Overwrite dijit.form.FilteringSelect._openResultList to focus the selected
			//	item when open the menu.
			this.inherited(arguments);

			// Use following code to get child nodes.
			var nodes = this.dropDown.containerNode.childNodes;
			
			// Focus the selected item
			if(!this._lastInput && this.focusNode.value && this.dropDown.items){
				for(var i = 0; i < nodes.length; i++){
					var item = this.dropDown.items[nodes[i].getAttribute("item")];
					if(item){
						var value = this.store._oldAPI ?	// remove getValue() for 2.0 (old dojo.data API)
								this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
						value = value.toString();
						if(value == this.displayedValue){
							this.dropDown._setSelectedAttr(nodes[i]);
							winUtils.scrollIntoView(this.dropDown.selected);
							break;
						}
					}
				}
			}
			
			
			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},
		
		_onInputContainerEnter: function(){
			domClass.toggle(this.oneuiBaseNode, "dijitComboBoxInputContainerHover", true);
		},
		
		_onInputContainerLeave: function(){
			domClass.toggle(this.oneuiBaseNode, "dijitComboBoxInputContainerHover", false);
		},
		
		displayMessage: function(/*String*/ message, /*Boolean*/ force){
			if(message){
				if(!this.messageTooltip){
					this.messageTooltip = new HoverHelpTooltip({
						connectId: [this.iconNode],
						label: message,
						position: this.tooltipPosition,
						forceFocus: false
					});
				}else{
					this.messageTooltip.set("label", message);
				}
				if(this.focused || force){
					var node = domStyle.get(this.iconNode, "visibility") == "hidden" ? this.oneuiBaseNode : this.iconNode;
					this.messageTooltip.open(node);
				}
			}else{
				this.messageTooltip && this.messageTooltip.close();
			}
		}
	});

	if ( has("mobile") || has("platform-plugable")) {
	
		var pluginRegistry = PlatformPluginRegistry.register("idx/form/FilteringSelect", 
				{	
					desktop: "inherited",	// no plugin for desktop, use inherited methods  
				 	mobile: MobilePlugin	// use the mobile plugin if loaded
				});
		var localDropDownClass = iForm.FilteringSelect.prototype.dropDownClass;
		if (MobilePlugin && MobilePlugin.prototype && MobilePlugin.prototype.dropDownClass){
			localDropDownClass = MobilePlugin.prototype.dropDownClass;
		}
		iForm.FilteringSelect = declare("idx.form.FilteringSelect",[iForm.FilteringSelect, TemplatePlugableMixin, _WidgetsInTemplateMixin], {
			/**
		     * Set the template path for the desktop template in case the template was not 
		     * loaded initially, but is later needed due to an instance being constructed 
		     * with "desktop" platform.
	     	 */
			templatePath: require.toUrl("idx/form/templates/ComboBox.html"),  
		
			// set the plugin registry
			pluginRegistry: pluginRegistry,
			/**
			 * 
			 */
			inProcessInput: false,
			/**
			 * Dot Not Call inherited function in the plugin stub method
			 */
			postCreate: function(){
				this.dropDownClass = localDropDownClass;
				return this.doWithPlatformPlugin(arguments, "postCreate", "postCreate");
			},
			/**
			 * Stub Plugable method
			 */
			onCloseButtonClick: function(){
				return this.doWithPlatformPlugin(arguments, "onCloseButtonClick", "onCloseButtonClick");
			},
			/**
			 * 
			 * @param {Object} item
			 * @param {Object} checked
			 */
			onCheckStateChanged: function(item, checked){
				return this.doWithPlatformPlugin(arguments, "onCheckStateChanged", "onCheckStateChanged",item, checked);
			},
			/**
			 * Stub Plugable method
			 */
			loadDropDown: function(){
				return this.doWithPlatformPlugin(arguments, "loadDropDown", "loadDropDown");
			},
			/**
			 * 
			 */
			_onBlur: function(){
				return this.doWithPlatformPlugin(arguments, "_onBlur", "_onBlur");
			},
			/**
			 * Stub Plugable method
			 */
			openDropDown: function(){
				return this.doWithPlatformPlugin(arguments, "openDropDown", "openDropDown");
			},
			closeDropDown:function(){
				return this.doWithPlatformPlugin(arguments, "closeDropDown", "closeDropDown");
			},
			/**
			 * Stub Plugable method
			 */
			_createDropDown : function(){
				return this.doWithPlatformPlugin(arguments, "_createDropDown", "_createDropDown");
			},
			/**
			 * Stub Plugable method
			 */
			displayMessage: function(message){
				return this.doWithPlatformPlugin(arguments, "displayMessage", "displayMessage",message);
			},
			/**
			 * Stub Plugable method
			 * @param {Object} helpText
			 */
			_setHelpAttr: function(helpText){
				return this.doWithPlatformPlugin(arguments, "_setHelpAttr", "_setHelpAttr",helpText);
			}
		});
	}
	
	return iForm.FilteringSelect;

});

},
'dijit/form/TextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("mozilla")
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	"../main"	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, on, has,
			_FormValueWidget, _TextBoxMixin, template, dijit){

	// module:
	//		dijit/form/TextBox

	var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie") < 9){
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the defer gives IE a chance to render the TextBox and to deal with font inheritance
				this.defer(function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
					 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				});
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = domConstruct.create('span', {
					// dijitInputField class gives placeHolder same padding as the input field
					// parent node already has dijitInputField class but it doesn't affect this <span>
					// since it's position: absolute.
					className: 'dijitPlaceHolder dijitInputField'
				}, this.textbox, 'after');
				this.own(
					on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
					on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
						// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
						// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
						this.focus();
					}))
				);
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
			this._updatePlaceHolder();
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened
			//		See if the placeHolder text should be removed or added while editing.
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();

			if(has("mozilla")){
				if(this.selectOnClick){
					// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie") < 9){
		TextBox.prototype._isTextSelected = function(){
			var range = this.ownerDocument.selection.createRange();
			var parent = range.parentElement();
			return parent == this.textbox && range.text.length > 0;
		};

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}

	if(has("dojo-bidi")){
		TextBox = declare("dijit.form.TextBox", TextBox, {
			_setPlaceHolderAttr: function(v){
				this.inherited(arguments);
				this.applyTextDir(this._phspan);
			}
		});
	}

	return TextBox;
});

},
'dijit/_base/scroll':function(){
define([
	"dojo/window", // windowUtils.scrollIntoView
	"../main"	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/scroll

	/*=====
	return {
		// summary:
		//		Back compatibility module, new code should use windowUtils directly instead of using this module.
	};
	=====*/

	dijit.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
		// summary:
		//		Scroll the passed node into view, if it is not already.
		//		Deprecated, use `windowUtils.scrollIntoView` instead.

		windowUtils.scrollIntoView(node, pos);
	};
});

},
'dijit/_TemplatedMixin':function(){
define([
	"dojo/cache",	// dojo.cache
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/string", // string.substitute string.trim
	"./_AttachMixin"
], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
});

},
'curam/util/UimDialog':function(){
/*
 * Copyright 2010-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.   
 * 06-Jul-2011  KW  [CR00275353] Correctly set the o3rpu value in openUrl()
 *                                function.
 * 01-Feb-2011  MV  [CR00250399] Fix the call to openModalDialog() function.
 * 21-Jan-2011  MV  [CR00243263] Fix the new openUrl function to return
 *    the dialog object. 
 * 14-Jan-2011  MK  [CR00240138] Added the openUrl() function. 
 * 13-Jan-2011  MV  [CR00241667] Added ready() function, updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the get() function.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */

define(["curam/util/RuntimeContext",
        "curam/util/external",
        "curam/util",
        "curam/define",
        "curam/dialog",
        "curam/util/DialogObject"
        ], function(RuntimeContext, external) {
  
  /**
   * @name curam.util.UimDialog
   * @namespace Provides the ability to open UIM content in a Curam dialog
   * and interact with the dialog window.<p/>
   * 
   * The API provides support for both opening a UIM page in a new dialog
   * and for accessing a dialog which is already open. See the <code>open()</code>
   * and <code>get()</code> functions.<p/>
   *  
   * It is required that the UIM page you are opening in the dialog resides
   * on the same Internet domain as the page the API is used from.<p/>
   * 
   * Example:<p/>
   * <pre>
   * dojo.require('curam.util.UimDialog');
   * 
   * var dialogObject = curam.util.UimDialog.open(
   *   'MyPage.do', { myParam:'1' }, {width:500,height:300});
   * 
   * dialogObject.registerBeforeCloseHandler(function() { alert("test"); });
   * dialogObject.registerOnDisplayHandler(function() {
   *   setTimeout(1000, function() { dialogObject.close() });
   * });
   * </pre><p/>
   *
   * It is possible to execute custom code on dialog open and/or close.<p/>
   * 
   * To add a customised handler function to a supported event:<ul>
   * <li>Make the UimDialog API call to open or get the dialog, which will
   *  return a {@link curam.util.DialogObject} object.
   * <li>This object will let you register handlers for the supported
   * <code>OnDisplay</code> and <code>BeforeClose</code> events.</li></ul>
   * <p/>
   * 
   * Lastly you can close the dialog by calling the <code>close()</code>
   * function.<p/>
   */





















  curam.define.singleton("curam.util.UimDialog",
  /**
   * @lends curam.util.UimDialog.prototype
   */
  {
    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, without
     *              the query string.
     * @param {Object} pageParameters An object containing the required page
     *      parameters, or null if no page parameters are required.
     *      The following format is expected:
     *                        <code>{ param1Name:"value", param2Name:248 }</code>
     *      The infrastructure handles URL-encoding the values so do NOT encode
     *      them yourself.
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *      
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    open: function(path, pageParameters, dialogSize) {    
      var url = path + curam.util.makeQueryString(pageParameters);    
      return this.openUrl(url, dialogSize);
    },

    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, including
     *              the query string.
     *              
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    openUrl: function(url, dialogSize) {












      // generate a unique token, this is to be used to retrieve the
      // correct dialogID
      var uimToken = curam.util.getCacheBusterParameter();

      // create dialog object to be returned to the user
      var myDialogObject = new curam.util.DialogObject(uimToken);

      var windowOptions = null;
      if (dialogSize) {
        windowOptions = "width=" + dialogSize.width
        + ",height=" + dialogSize.height;
      }

      // call into modal logic with unique token
      curam.util.openModalDialog({ href: this._addRpu(url) },
          windowOptions, null, null, uimToken);

      return myDialogObject;
    },
    
    _addRpu: function(url) {
      var newUrl = url;
      
      if (curam.tab.inTabbedUI()) {
        // we are in tabbed UI, set RPU to the active tab content iframe
        var iframe = curam.tab.getContentPanelIframe();
        if (iframe) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(iframe.contentWindow));
        }

      } else if (external.inExternalApp()) {
        // we are in the external application, try to get parent UIM iframe
        var parent = external.getUimParentWindow();
        if (parent) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(parent));
        }
      }
      // else - unable to set RPU, this is valid for example in ext app fragment
      // scenarios

      return newUrl;
    },
    
    /**
     * Returns a dialog object corresponding to the runtime context
     * of the calling page.
     * 
     * If the calling page is not loaded in a dialog or the dialog infrastructure
     * is not yet initialized then exception will be thrown. In this case use the
     * ready() function to execute your code at the right point in time. 
     * 
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    get: function() {
      if (curam.dialog._id == null) {
        throw "Dialog infrastructure not ready.";
      }
      return new curam.util.DialogObject(null, curam.dialog._id);
    },

    /**
     * Executes the callback function when the dialog infrastructure
     * in the current runtime context becomes ready. If the infrastructure
     * is ready by the time this function is called, then the callback function
     * is executed immediately.
     * 
     * @param {Function} callback
     *    The function to run.
     */
    ready: function(callback) {
      if (curam.dialog._id == null) {
        // Dialog infrastructure not ready.
        dojo.subscribe("/curam/dialog/ready", callback);

      } else {
        // infrastructure ready - call the code now
        callback();
      }
    },

    /**
     * @private
     */
    _getDialogFrameWindow: function(dialogId) {
      var dialogWidget = window.top.dijit.byId(dialogId);
      return dialogWidget.uimController.getIFrame().contentWindow;
    }
  });
  
  return curam.util.UimDialog;
});

},
'curam/util/DialogObject':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.util.DialogObject
 * @namespace Provides access to a dialog instance.
 * 
 */
define(["dojo/_base/declare",
        "curam/dialog",
        "curam/util"
        ], function(declare) { 
/*
 * Modification History
 * --------------------
 * 30-Oct-2014  MV  [CR00448178] Fix handler deregistration.
 * 05-Feb-2013  MV  [CR00366128] Fix documentation comment.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 13-Jan-2011  MV  [CR00241667] Added close() function. Updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the registerOnDisplayHandler() function.
 * 04-Nov-2010  MV  [CR00229849] Unsubscribe handlers in the right context.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */


var DialogObject = declare("curam.util.DialogObject", null, 
/** @lends curam.util.DialogObject.prototype */{  

    /**
     * Holds ID of the dialog in the current context.
     * @private
     */
    _id: null,
    
    /**
     * Constructor takes the input token and uses it to listen for a 
     * specific publish event which will return the dialogId for the
     * opened dialog.
     *
     * @constructor
     * @private
     */
    constructor: function(tokenValue, id) {
      if (!id) {
        var unSubConstructor = 
          window.top.dojo.subscribe(
            "/curam/dialog/uim/opened/" + tokenValue, this, function(dialogID) {
          this._id = dialogID;
          window.top.dojo.unsubscribe(unSubConstructor);
        });
      
      } else {
        this._id = id;
      }
    },
    
    /**
     * Registers a custom function that will be called before the dialog
     * is closed.
     * 
     * @param {Function} handler The handler function for the BeforeClose event.
     */
    registerBeforeCloseHandler: function(handler) {
      var unSubClose = 
        window.top.dojo.subscribe(
          "/curam/dialog/BeforeClose", this, function(dialogID) {
            if (dialogID == this._id) {
              window.top.dojo.unsubscribe(unSubClose);
              handler();
            }
      });
    },
    
    /**
     * Registers a custom handler for the onDispaly event of the dialog. 
     * If the handler is registered after the dialog has been displayed, then
     * it is executed immediately.
     * 
     * @param handler
     *    The handler function for the dialog OnDisplay event. The handler
     *    will be passed the size object in the following form:
     *    {width: 125, height: 236}
     */
    registerOnDisplayHandler: function(handler) {
      if (curam.dialog._displayed == true) {
        handler(curam.dialog._size);
        
      } else {
        var ut = window.top.dojo.subscribe(
            "/curam/dialog/displayed", this, function(dialogID, size) {
              if (dialogID == this._id) {
                window.top.dojo.unsubscribe(ut);
                handler(size);
              }
            });
      }
    },
    
    /**
     * Closes the dialog, optionally refreshing or redirecting the parent window.
     * 
     * @param {Boolean} [refreshParent=false] Should the parent be refreshed
     *              when this dialog closes?
     * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
     *      should be redirected to when this dialog closes. Alternatively
     *      a full URL including the page parameters can be passed.
     * @param {Object} [pageParameters] Page parameters to be used when
     *        redirecting the parent to the new page. The following format
     *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
     *        The infrastructure handles URL-encoding the values so do NOT encode
     *        them yourself.
     *        If full URL is specified then the pageParameters are ignored.
     */
    close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
        /*optional*/ pageParameters) {
      
      var win = curam.util.UimDialog._getDialogFrameWindow(this._id);
      var parentWindow = win.curam.dialog.getParentWindow(win);
      if (refreshParent && !newPageIdOrFullUrl) {
        win.curam.dialog.forceParentRefresh();
        curam.dialog.doRedirect(parentWindow, null);
        
      } else if (newPageIdOrFullUrl) {
        var newParentUrl = newPageIdOrFullUrl;
        // distinguish between pageId and full URL
        if (newPageIdOrFullUrl.indexOf("Page.do") == -1) {
          newParentUrl = newPageIdOrFullUrl + "Page.do"
              + curam.util.makeQueryString(pageParameters);
        }
  
        curam.dialog.doRedirect(parentWindow, newParentUrl);
      }
  
      curam.dialog.closeModalDialog();
    }
  });
  
  return DialogObject;  
});

},
'dijit/_CssStateMixin':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant()
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/touch",
	"dojo/_base/window", // win.body
	"./a11yclick",
	"./registry"
], function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry){

	// module:
	//		dijit/_CssStateMixin

	var CssStateMixin = declare("dijit._CssStateMixin", [], {
		// summary:
		//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
		//		state changes, and also higher-level state changes such becoming disabled or selected.
		//
		// description:
		//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
		//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
		//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
		//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
		//
		//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
		//
		//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
		//		within the widget).

		/*=====
		 // cssStateNodes: [protected] Object
		 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
		 //		need CSS classes applied on mouse hover/press and focus.
		 //
		 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
		 //		(like "dijitUpArrowButton"). Example:
		 //	|		{
		 //	|			"upArrowButton": "dijitUpArrowButton",
		 //	|			"downArrowButton": "dijitDownArrowButton"
		 //	|		}
		 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
		 //		is hovered, etc.
		 cssStateNodes: {},
		 =====*/

		// hovering: [readonly] Boolean
		//		True if cursor is over this widget
		hovering: false,

		// active: [readonly] Boolean
		//		True if mouse was pressed while over this widget, and hasn't been released yet
		active: false,

		_applyAttributes: function(){
			// This code would typically be in postCreate(), but putting in _applyAttributes() for
			// performance: so the class changes happen before DOM is inserted into the document.
			// Change back to postCreate() in 2.0.  See #11635.

			this.inherited(arguments);

			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
				this.watch(attr, lang.hitch(this, "_setStateClass"));
			}, this);

			// Track hover and active mouse events on widget root node, plus possibly on subnodes
			for(var ap in this.cssStateNodes || {}){
				this._trackMouseState(this[ap], this.cssStateNodes[ap]);
			}
			this._trackMouseState(this.domNode, this.baseClass);

			// Set state initially; there's probably no hover/active/focus state but widget might be
			// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
			this._setStateClass();
		},

		_cssMouseEvent: function(/*Event*/ event){
			// summary:
			//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
			//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

			if(!this.disabled){
				switch(event.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						this._set("hovering", true);
						this._set("active", this._mouseDown);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						this._set("hovering", false);
						this._set("active", false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						this._set("active", true);
						break;
					case "mouseup":
					case "dojotouchend":
					case "MSPointerUp":
					case "pointerup":
					case "keyup":
						this._set("active", false);
						break;
				}
			}
		},

		_setStateClass: function(){
			// summary:
			//		Update the visual state of the widget by setting the css classes on this.domNode
			//		(or this.stateNode if defined) by combining this.baseClass with
			//		various suffixes that represent the current widget state(s).
			//
			// description:
			//		In the case where a widget has multiple
			//		states, it sets the class based on all possible
			//		combinations.  For example, an invalid form widget that is being hovered
			//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
			//
			//		The widget may have one or more of the following states, determined
			//		by this.state, this.checked, this.valid, and this.selected:
			//
			//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
			//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
			//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
			//		- Selected - ex: currently selected tab will have this.selected==true
			//
			//		In addition, it may have one or more of the following states,
			//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
			//
			//		- Disabled	- if the widget is disabled
			//		- Active		- if the mouse (or space/enter key?) is being pressed down
			//		- Focused		- if the widget has focus
			//		- Hover		- if the mouse is over the widget

			// Compute new set of classes
			var newStateClasses = this.baseClass.split(" ");

			function multiply(modifier){
				newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
					return c + modifier;
				}), "dijit" + modifier);
			}

			if(!this.isLeftToRight()){
				// For RTL mode we need to set an addition class like dijitTextBoxRtl.
				multiply("Rtl");
			}

			var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
			if(this.checked){
				multiply(checkedState);
			}
			if(this.state){
				multiply(this.state);
			}
			if(this.selected){
				multiply("Selected");
			}
			if(this._opened){
				multiply("Opened");
			}

			if(this.disabled){
				multiply("Disabled");
			}else if(this.readOnly){
				multiply("ReadOnly");
			}else{
				if(this.active){
					multiply("Active");
				}else if(this.hovering){
					multiply("Hover");
				}
			}

			if(this.focused){
				multiply("Focused");
			}

			// Remove old state classes and add new ones.
			// For performance concerns we only write into domNode.className once.
			var tn = this.stateNode || this.domNode,
				classHash = {};	// set of all classes (state and otherwise) for node

			array.forEach(tn.className.split(" "), function(c){
				classHash[c] = true;
			});

			if("_stateClasses" in this){
				array.forEach(this._stateClasses, function(c){
					delete classHash[c];
				});
			}

			array.forEach(newStateClasses, function(c){
				classHash[c] = true;
			});

			var newClasses = [];
			for(var c in classHash){
				newClasses.push(c);
			}
    /* CURAM-FIX: replace followig line - only set className if classes are changed */
		// tn.className = newClasses.join(" ");
    var cls = newClasses.join(" ");
    if(cls != tn.className){
      tn.className = cls;
    }
    /* END CURAM-FIX */

			this._stateClasses = newStateClasses;
		},

		_subnodeCssMouseEvent: function(node, clazz, evt){
			// summary:
			//		Handler for hover/active mouse event on widget's subnode
			if(this.disabled || this.readOnly){
				return;
			}

			function hover(isHovering){
				domClass.toggle(node, clazz + "Hover", isHovering);
			}

			function active(isActive){
				domClass.toggle(node, clazz + "Active", isActive);
			}

			function focused(isFocused){
				domClass.toggle(node, clazz + "Focused", isFocused);
			}

			switch(evt.type){
				case "mouseover":
				case "MSPointerOver":
				case "pointerover":
					hover(true);
					break;
				case "mouseout":
				case "MSPointerOut":
				case "pointerout":
					hover(false);
					active(false);
					break;
				case "mousedown":
				case "touchstart":
				case "MSPointerDown":
				case "pointerdown":
				case "keydown":
					active(true);
					break;
				case "mouseup":
				case "MSPointerUp":
				case "pointerup":
				case "dojotouchend":
				case "keyup":
					active(false);
					break;
				case "focus":
				case "focusin":
					focused(true);
					break;
				case "blur":
				case "focusout":
					focused(false);
					break;
			}
		},

		_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
			// summary:
			//		Track mouse/focus events on specified node and set CSS class on that node to indicate
			//		current state.   Usually not called directly, but via cssStateNodes attribute.
			// description:
			//		Given class=foo, will set the following CSS class on the node
			//
			//		- fooActive: if the user is currently pressing down the mouse button while over the node
			//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
			//		- fooFocus: if the node is focused
			//
			//		Note that it won't set any classes if the widget is disabled.
			// node: DomNode
			//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
			//		is handled specially and automatically just by mixing in this class.
			// clazz: String
			//		CSS class name (ex: dijitSliderUpArrow)

			// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
			// when node is hovered/active
			node._cssState = clazz;
		}
	});

	domReady(function(){
		// Document level listener to catch hover etc. events on widget root nodes and subnodes.
		// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
		// have been hovered or unhovered (try test_Accordion.html)

		function pointerHandler(evt, target, relatedTarget){
			// Handler for mouseover, mouseout, a11yclick.press and a11click.release events

			// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
			// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
			// such events shouldn't be interpreted as a mouseleave on the widget.
			if(relatedTarget && dom.isDescendant(relatedTarget, target)){
				return;
			}

			for(var node = target; node && node != relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.domNode){
							// event on the widget's root node
							widget._cssMouseEvent(evt);
						}else{
							// event on widget's sub-node
							widget._subnodeCssMouseEvent(node, node._cssState, evt);
						}
					}
				}
			}
		}

		var body = win.body(), activeNode;

		// Handle pointer related events (i.e. mouse or touch)
		on(body, touch.over, function(evt){
			// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, touch.out, function(evt){
			// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, a11yclick.press, function(evt){
			// Save the a11yclick.press target to reference when the a11yclick.release comes.
			activeNode = evt.target;
			pointerHandler(evt, activeNode)
		});
		on(body, a11yclick.release, function(evt){
			// The release event could come on a separate node than the press event, if for example user slid finger.
			// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
			pointerHandler(evt, activeNode);
			activeNode = null;
		});

		// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
		// However, don't track focus events on the widget root nodes, because focus is tracked via the
		// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
		// nodes or a subwidget's node or a popup node, etc.)
		// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
		on(body, "focusin, focusout", function(evt){
			var node = evt.target;
			if(node._cssState && !node.getAttribute("widgetId")){
				var widget = registry.getEnclosingWidget(node);
				if(widget){
					widget._subnodeCssMouseEvent(node, node._cssState, evt);
				}
			}
		});
	});

	return CssStateMixin;
});

},
'dijit/layout/ScrollingTabController':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/fx", // Animation
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/query", // query
	"dojo/dom-attr",
	 "curam/debug",
	"dojo/sniff", // has("ie"), has("webkit"), has("quirks")
	"../registry",	// registry.byId()
	"dojo/text!./templates/ScrollingTabController.html",
	"dojo/text!./templates/_ScrollingTabControllerButton.html",
	"./TabController",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_WidgetsInTemplateMixin",
	"../Menu",
	"../MenuItem",
	"../form/Button",
	"../_HasDropDown",
	"dojo/NodeList-dom", // NodeList.style
	"../a11yclick"	// template uses ondijitclick (not for keyboard support, but for responsive touch support)
], function(array, declare, domClass, domGeometry, domStyle, fx, lang, on, query, domattr, debug, has,
	registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin,
	Menu, MenuItem, Button, _HasDropDown){

// module:
//		dijit/layout/ScrollingTabController

/* CURAM-FIX: Performance fixes and extension to support for disabling and hiding tabs */

var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	baseClass: "dijitTabController dijitScrollingTabController",

	templateString: tabControllerTemplate,

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	// Override default behavior mapping class to DOMNode
	_setClassAttr: { node: "containerNode", type: "class" },
	
       /* CURAM-FIX: added class member variable */
	_tabsWidth: -1,

	/* CURAM-FIX: added class member variable */
       _tablistMenuItemIdSuffix: "_stcMi",


	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
       domClass.add(n, "tabStrip-disabled");
		}

		domClass.add(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// TabController is hidden until it finishes drawing, to give
		// a less visually jumpy instantiation.   When it's finished, set visibility to ""
		// to that the tabs are hidden/shown depending on the container's visibility setting.

		/* CURAM-FIX: don't touch visibility - this is slow in IE7
		 * this goes with a change in the HTML template, which now doesn't set
		 * visibility: hidden */
		// domStyle.set(this.domNode, "visibility", "");

		this._postStartup = true;

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
      this.own(on(this.containerNode, "attrmodified-label, attrmodified-iconclass",
        lang.hitch(this,
          function(evt){
				if(this._dim){
					this.resize(this._dim);
				}
		                       
				/* CURAM-FIX: addition */
		                          // When a label is changed, the size cache should be invalidated
		                          this.bustSizeCache = true;
		                          this._tabsWidth = -1;
		                          // Clear the cached width of a button
				evt.detail.widget.domNode._width = 0;
				/* END CURAM-FIX */
				
			})));
		},

		onAddChild: function(page, insertIndex){
			this.inherited(arguments);

                        /* CURAM-FIX: addition */
                        var pageID = page.id;
                        // When a child is added, the size cache should be invalidated
                        this.bustSizeCache = true;
                        this._tabsWidth = -1;
                        /* END CURAM-FIX */			

		/* CURAM-FIX: addition to enable tab hiding/disabling
		 * because this function has been created as a local variable, "this" has
		 * to be passed as a parameter. See calls to getMenuItem below.
		 * TODO: why was this created as a local variable? Can the function be
		 * attached to the class? Or should we hitch it in the class below?
		 * For now, "this" will be supplied as a parameter. Lowest risk change.
		 */
		    var getMenuItem = function(pid, theRealThis) {
		      var menuItem = null;
		      if (theRealThis._menuBtn.dropDown) {
		        var menuItemNode = dojo.query(pid + theRealThis._tablistMenuItemIdSuffix,
		            theRealThis._menuBtn.dropDown.domNode)[0];
		        if (menuItemNode) {
		          menuItem = dijit.byNode(menuItemNode);
		        }
		      }
		      return menuItem;
		    };

		    // update the menuItem visibility when the button visibility is updated
		    this.pane2button(pageID).connect(this.pane2button(pageID), "_setCuramVisibleAttr",
		      lang.hitch(this, function() {
		        var menuItem = getMenuItem(pageID, this);
		        if(menuItem) {
		          this._setCuramVisibility(menuItem, pageID);
		        }
		      }));

		    // update the menuItem availability when the button availability is updated
      this.pane2button(pageID).connect(this.pane2button(pageID), "_setCuramDisabledAttr",
        lang.hitch(this,
          function() {
		      // getMenuItem
		      var menuItem = getMenuItem(pageID, this);
		      if(menuItem) {
		        this._setCuramAvailability(menuItem, pageID);
		      }
		    }));
		/* END CURAM-FIX */


		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		domStyle.set(this.containerNode, "width",
			(domStyle.get(this.containerNode, "width") + 200) + "px");
		this.containerNode._width = 0; //  Invalidate the cached width of the wrapper
	},

	/* CURAM-FIX: added functions needed by Curam specific code */    
	_setCuramVisibility: function(menuItem, pageId) {
	      var visible = this.pane2button(pageId).curamVisible;
	      if (visible) {
	        dojo.replaceClass(menuItem.domNode, "visible", "hidden");
	      } else {
	        dojo.replaceClass(menuItem.domNode, "hidden", "visible");
	      }
	    },

	    _setCuramAvailability: function(menuItem, pageId) {
	      var enabled = !this.pane2button(pageId).curamDisabled;
	          menuItem.disabled = !enabled;
	          if (enabled) {
	            dojo.replaceClass(menuItem.domNode, "enabled", "disabled");

	          } else {
	            dojo.replaceClass(menuItem.domNode, "disabled", "enabled");
	          }
	     },
	    
	    /**
	     * Checks if we have cached the width for this node, and returns it if so
	     * Otherwise measures the width.
	     * @param node The node to measure.
	     * @returns The node width.
	     */
	    _getNodeWidth: function(node) {
	      if(!node._width){
	        node._width = domStyle.get(node, "width");
	      }
	      return node._width;
	    },

	    destroyRendering: function(preserveDom) {
      array.forEach(this._attachPoints,
        function (point) {
	        delete this[point];
        },
        this);
	      this._attachPoints = [];
	      array.forEach(this._attachEvents, this.disconnect, this);
	      this.attachEvents = [];
	    },
	    
	    destroy: function() {
	      if (this._menuBtn) {
	        this._menuBtn._curamOwnerController = null;
	      }
	      
	      this.inherited(arguments);
	    },
	/* END CURAM-FIX */
	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
			var button = this.pane2button(page.id);
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
			
		/* CURAM-FIX: addition */
		// When a child is removed, the size cache should be invalidated
		this.bustSizeCache = true;
		this._tabsWidth = -1;
		/* END CURAM-FIX */
			
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		/* CURAM-FIX: subscription to the tab title setting event to adjust the tab 
		   scroll buttons subsequently */
		this.subscribe("tab.title.name.finished", this._measureBtns);
		/* END CURAM-FIX */
		this._btnWidth = 0;
      this._buttons =
        query("> .tabStripButton", this.domNode).filter(
          function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
		                /* CURAM-FIX: replace next line to use getMarginBoxSimple() */
                                // this._btnWidth += domGeometry.getMarginSize(btn).w;
		                this._btnWidth += domGeometry.getMarginBoxSimple(btn).w;
		            //set node title
		                domattr.set(this._menuBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navMenu.title"));
		                
		           //role presentation for menuBtn
		                domattr.set(this._menuBtn, "role", "presentation");
		                
		          //sets tabindex attribute for the menuBtn
		              domattr.set(this._menuBtn, "tabindex", 0);
		                
		        return true;
				
			}else{
				domStyle.set(btn, "display", "none");
				return false;
			}
		}, this);
		/* CURAM-FIX: addition next line */
	      this._menuBtn._curamOwnerController = this;
	},
		  
	_getTabsWidth: function(){
	      /* CURAM-FIX: addition */
	      if(this._tabsWidth > -1){
	        return this._tabsWidth;
	      }
	      /* END CURAM-FIX */
	      
		var children = this.getChildren();
		if(children.length){
			var /* CURAM-FIX: comment this out: leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode, */
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			/* CURAM-FIX: comment out the next line and replace with the next addition
                         * to remove one call to leftTab.offsetLeft */
			// return rightTab.offsetLeft + domStyle.get(rightTab, "width") - leftTab.offsetLeft;
			var rightWidth = this._getNodeWidth(rightTab);
			if(this.isLeftToRight()){	                
	                this._tabsWidth = rightTab.offsetLeft + rightWidth;
			}else{
				var leftTab = children[children.length - 1].domNode;
		    	this._tabsWidth = rightTab.offsetLeft + rightWidth - leftTab.offsetLeft;
			}
	                return this._tabsWidth;
	                /* END CURAM-FIX */
			
		}else{
			return 0;
		}
	},


	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || domStyle.get(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	/* CURAM-FIX: additional method to re-measure tab controller to
    adjust tab scroll buttons	*/
	_measureBtns: function() {
      // summary:
	  // triggers controller size adjustment following tab name set to
	  // draw tab scrolling buttons once the correct width value is known.
	  if (this._enableBtn() && this._rightBtn.domNode.style.display == "none") {
	    this.resize(this._dim);
	    if (this.isLeftToRight()) {
	      this._rightBtn.set("disabled", true);
	    } else {
	      this._leftBtn.set("disabled", true);
		}
      }
	},
	/* END CURAM-FIX */

	/* CURAM-FIX: IE7 related optimizations to code around using the expensive
         * offsetWidth/offsetHeight calls
         */
	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

    	      /* CURAM-FIX: addition - If there are no children, just hide the tab bar */
    	      if(dojo.query("> *", this.containerNode).length < 1){
    	        if(this.domNode.style.height != "1px"){
    	          domStyle.set(this.domNode, "height", "1px");
    	        }
    	        return;
    	      }
    	      // If the width is the same, do nothing
    	      if(!this.bustSizeCache && this._dim && dim && this._dim.w == dim.w){
    	        return;
    	      }
    	      this.bustSizeCache = false;
    
    	      // curam.debug.log(bundle.getProperty("curam.dojo-hacks.msg"), this.domNode);
    	      this.scrollNodeHeight = this.scrollNodeHeight || this.scrollNode.offsetHeight;
    	      /* END CURAM_FIX */

	      // Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		/* CURAM-FIX: replace expensive call to offsetHeight */
                // cb.h = this.scrollNode.offsetHeight;
		cb.h = this.scrollNodeHeight;
		domGeometry.setContentSize(this.domNode, cb);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
			this._leftBtn.region = "left";
			this._rightBtn.region = "right";
			this._menuBtn.region = this.isLeftToRight() ? "right" : "left";
		  // set node title
		      domattr.set(this._leftBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navLeft.title"));
		 // set node title
		      domattr.set(this._rightBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navRight.title"));
		    
		 //role presentation for the Navigation right button
		      domattr.set(this._rightBtn, "role", "presentation");
		    
		 //role presentation for the Navigation left button
		      domattr.set(this._leftBtn, "role", "presentation");
		      
		/* CURAM-FIX: replace the following statement*/ 
                //layoutUtils.layoutChildren(this.domNode, this._contentBox,
                  // [this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

                // fakeWidget property tells the layout code not to bother updating
	        // this JSON object with the widget size
	        var childDims;
	        if(enable){
	          childDims = dijit.layout.utils.layoutChildren(this.domNode, this._contentBox,
	            [this._menuBtn, this._leftBtn, this._rightBtn,
	             {domNode: this.scrollNode, layoutAlign: "client", fakeWidget: true}]);
	        } else {
	          childDims = dijit.layout.utils.layoutChildren(this.domNode, this._contentBox,
	            [{domNode: this.scrollNode, layoutAlign: "client", fakeWidget: true}]);
	        }
	        this.scrollNode._width = childDims.client.w;
	        /* END CURAM-FIX */

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());

		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},


	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
      return (this.isLeftToRight() || has("ie") < 8 || (has("trident") && has("quirks")) || has("webkit"))
               ? this.scrollNode.scrollLeft
               : domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width")
                   + (has("trident") || has("edge") ? -1 : 1) * this.scrollNode.scrollLeft;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
      if(this.isLeftToRight() || has("ie") < 8 || (has("trident") && has("quirks")) || has("webkit")){
			return val;
		}else{
			var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
        return (has("trident") || has("edge") ? -1 : 1) * (val - maxScroll);
		}
	},

	/* CURAM-FIX: Overriding this method to skip getting the scroll position
         * which can be expensive */
    onSelectChild: function(/*dijit._Widget*/ page, /*Boolean*/ tabContainerFocused){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

			var tab = this.pane2button(page.id);
			if(!tab){
				return;
			}

		var node = tab.domNode;

		// Save the selection
		if(node != this._selectedTab){
			this._selectedTab = node;

			// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
			if(this._postResize){
				/* CURAM-FIX: addition Curam customized this to skip getting the scroll if not required */
				var scrollNodeWidth = this._getNodeWidth(this.scrollNode);
				if(this._getTabsWidth() < scrollNodeWidth){
                                    tab.onClick(null);
                                    /* CURAM-FIX rtc231858 focus required for screen readers */
                                    tab.focus();
                                    /* END CURAM-FIX  focus required for screen readers */
				} else {
					/* END CURAM-FIX */
					var sl = this._getScroll();

					if(sl > node.offsetLeft ||
							/* CURAM-FIX: replace following line */
							// sl + domStyle.get(this.scrollNode, "width") <
							sl + scrollNodeWidth <
							/* CURAM-FIX: replace following line */
							// node.offsetLeft + domStyle.get(node, "width")){
							node.offsetLeft + this._getNodeWidth(node)) {
								//this.createSmoothScroll().play(); older version
								var anim = this.createSmoothScroll();
								if(tabContainerFocused){
									anim.onEnd = function(){
										// Focus is on hidden tab or previously selected tab label.  Move to current tab label.
										tab.focus();
									};
								}
								anim.play();
					} else if(tabContainerFocused){
						// Focus is on hidden tab or previously selected tab label.  Move to current tab label.
						tab.focus();
					}
					/* CURAM-FIX: addition */
				}
				/* END CURAM-FIX */
			}
		}
		this.inherited(arguments);
		/**
		 * Keep track that the user is navigating through tabs in the navigation tab. 
		 * The tab button will be used by the doSetFocus to keep the focus on the 
		 * tab button instead of focusing on the first editable field.
		 * **/
		var tabButton = document.activeElement;
		if (typeof tabButton !== 'undefined' && tabButton != null) {
		  if (tabButton.className == "tabLabel" && (query(tabButton).closest(".nav-panel")).length > 0) {
			  curam.util.setTabButtonClicked(tabButton);
		  }
		}
	},


	/* CURAM-FIX: Overriding this method to stop using offsetLeft and dojo.style calls
         * which can be expensive.
         */
	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			/* CURAM-FIX: replace the style call in next two lines by faster function */
		        // scrollNodeWidth = domStyle.get(this.scrollNode, "width"),		// about 500px
			// containerWidth = domStyle.get(this.containerNode, "width"),	// 50,000px
		        scrollNodeWidth = this._getNodeWidth(this.scrollNode),     // about 500px
		        containerWidth = this._getNodeWidth(this.containerNode),   // 50,000px
		        /* END CURAM-FIX */
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				//There is a padding of 10px at right of tabs list. See ".rtl .soria .appTabContainer .dijitTabContainerTop-tabs"
				//  in \TIVOB\client\CoreInf\CuramCDEJ\lib\curam\web\themes\soria_rtl\css\ApplicationTabContainer_rtl.css
				//  This padding is not included in the calculations. So, Decrease the minimum scroll value here.
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,  // 10px for padding of the wrapper
	                        /* CURAM-FIX: replace following line */      
				//max: this.isLeftToRight() ?
               //  children[children.length-1].domNode.offsetLeft + domStyle.get(children[children.length-1].domNode, "width")) - scrollNodeWidth :
				//	maxPossibleScroll
		                max: this.isLeftToRight() ? tabsWidth - scrollNodeWidth : maxPossibleScroll 
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},


	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
			var pos = (n.offsetLeft + domStyle.get(n, "width") / 2) - scrollNodeWidth / 2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new fx.Animation({
				beforeBegin: function(){
						if(this.curve){
							delete this.curve;
						}
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new fx._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

			return anim; // dojo/_base/fx/Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !domClass.contains(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
			this.doSlide(-1, this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
			//		If the direction is 1, the widget scrolls to the right, if it is -1,
			//		it scrolls to the left.

			if(node && domClass.contains(node, "dijitTabDisabled")){
				return;
			}

		var sWidth = domStyle.get(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: buttonTemplate,

		// Override inherited tabIndex: 0 from dijit/form/Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
		isFocusable: function(){
			return false;
		}
	});

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerButton", [Button, ScrollingTabControllerButtonMixin]);

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerMenuButton", [Button, _HasDropDown, ScrollingTabControllerButtonMixin], {
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new Menu({
			id: this.containerId + "_menu",
				ownerDocument: this.ownerDocument,
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		});
		var container = registry.byId(this.containerId);
      array.forEach(container.getChildren(),
        function(page){
          var menuItem =
            new MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
					disabled: page.disabled,
					ownerDocument: this.ownerDocument,
				dir: page.dir,
				lang: page.lang,
					textDir: page.textDir || container.textDir,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		
		/* CURAM-FIX: set the right visibility and availability
		 * on newly loaded menu items
		 */
      dojo.forEach(this.dropDown.getChildren(),
          lang.hitch(this,
              function(menuItem) {
                  var pageId = menuItem.id.split(
                      this._curamOwnerController._tablistMenuItemIdSuffix)[0];
                      this._curamOwnerController._setCuramAvailability(menuItem, pageId);
                      this._curamOwnerController._setCuramVisibility(menuItem, pageId);
                      dojo.connect(menuItem, "destroy", function() {
                        setDynState = null;
                      });
                }));		      
		/* END CURAM-FIX */
		
		callback();
	},


	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
				this._popupStateNode.removeAttribute("aria-owns");	// remove ref to node that we are about to delete
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

return ScrollingTabController;
});

},
'dijit/place':function(){
define([
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

},
'dijit/_HasDropDown':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"./registry", // registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focus, popup, _FocusMixin){


	// module:
	//		dijit/_HasDropDown

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the aria-expanded class on.
		//		Also sets popupActive class but that will be removed in 2.0.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width.
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: -1,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below", "above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subclass
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown/touchstart on the arrow icon.

			if(this.disabled || this.readOnly){
				return;
			}

			// Prevent default to stop things like text selection, but don't stop propagation, so that:
			//		1. TimeTextBox etc. can focus the <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			//
			// Also, don't call preventDefault() on MSPointerDown event (on IE10) because that prevents the button
			// from getting focus, and then the focus manager doesn't know what's going on (#17262)
			if(e.type != "MSPointerDown" && e.type != "pointerdown"){
				e.preventDefault();
			}

			this.own(on.once(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")));

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback on mouseup/touchend after mousedown/touchstart on the arrow icon.
			//		Note that this function is called regardless of what node the event occurred on (but only after
			//		a mousedown/touchstart on the arrow).
			//
			//		If the drop down is a simple menu and the cursor is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser `<select>` nodes:
			//
			//		1. mouse down on the select node (probably on the arrow)
			//		2. move mouse to a menu item while holding down the mouse button
			//		3. mouse up.  this selects the menu item as though the user had clicked it.

			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				// Focus the dropdown widget unless it's a menu (in which case autoFocus is set to false).
				// Even if it's a menu, we need to focus it if this is a fake mouse event caused by the user typing
				// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
				// If this.hovering is false then it's presumably actually a keyboard event.
				if(dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))){
					// Do it on a delay so that we don't steal back focus from the dropdown.
					this._focusDropDownTimer = this.defer(function(){
						dropDown.focus();
						delete this._focusDropDownTimer;
					});
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// defer() needed to make it work on IE (test DateTextBox)
				if(this.focus){
					this.defer("focus");
				}
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// The drop down was already opened on mousedown/keydown; just need to stop the event
			if(this._stopClickEvents){
				e.stopPropagation();
				e.preventDefault();
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
				"after": this.isLeftToRight() ? "Right" : "Left",
				"before": this.isLeftToRight() ? "Left" : "Right",
				"above": "Up",
				"below": "Down",
				"left": "Left",
				"right": "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keyboard events

			this.inherited(arguments);

			var keyboardEventNode = this.focusNode || this.domNode;
			this.own(
				on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")),
				on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")),
				on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")),
				on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp"))
			);
		},

		destroy: function(){
			// If dropdown is open, close it, to avoid leaving dijit/focus in a strange state.
			// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
			if(this._opened){
				this.closeDropDown(true);
			}

			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){
				return;
			}
			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					e.stopPropagation();
					e.preventDefault();
					return;
				}
			}
			if(d && this._opened && e.keyCode == keys.ESCAPE){
				this.closeDropDown();
				e.stopPropagation();
				e.preventDefault();
			}else if(!this._opened &&
				(e.keyCode == keys.DOWN_ARROW ||
					// ignore unmodified SPACE if _KeyNavMixin has active searching in progress
					( (e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
						//ignore enter and space if the event is for a text input
						((target.tagName || "").toLowerCase() !== 'input' ||
							(target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				e.stopPropagation();
				e.preventDefault();
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					this.defer(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
			// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
			// popup the keyboard on mobile.
			this.closeDropDown(false);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){
				return;
			}
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				this._origStyle = ddNode.style.cssText;
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					this.focus();
				}
				popup.close(this.dropDown);
				this._opened = false;
			}

			if(this._origStyle){
				this.dropDown.domNode.style.cssText = this._origStyle;
				delete this._origStyle;
			}
		}
	});
});

},
'curam/util/Request':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration
 * 04-Mar-2014  MV  [CR00421036] Use new LocalConfig API to read options, make
 *      login page detector configurable, add documentation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

define(['dojo/_base/xhr',
        'curam/debug',
        "curam/util/ResourceBundle",
        "curam/inspection/Layer",
        'curam/util/LocalConfig'
        ], function(xhr, debug, bundle, layer, localConfig) {

        var requestBundle = new bundle("curam.application.Request");

      // holds custom login page detector function, if one was provided
      // by the API client
      _isLoginPage = null,
        
      /**
       * Check for a login page based on the presence of this HTML tag:
       * <form action="j_security_check" ...>
       * 
       * @param request The XHR request object.
       * @return True if the response is a login page, otherwise False.
       */
      isLoginPage = function(request) {
        // if custom login page detector was provided use it
        if (_isLoginPage) {
          return _isLoginPage(request);

        // or fall back to default detection method
        } else {
          return request.responseText.indexOf(
              "action=\"j_security_check\"") > 0;
        }
      },

      errorDisplayHookpoint = function(err, ioargs) {
        if (isLoginPage(ioargs.xhr)) {
          // session timeout scenario
          debug.log(requestBundle.getProperty('sessionExpired'));
        } else {
          // display generic error message
          debug.log(requestBundle.getProperty('ajaxError'));
        }

        // log the error
        debug.log(err);
        debug.log('HTTP status was: ' + ioargs.xhr.status);
      },
      
      _xhr = function(method, args) {
        var ajaxDebugMode =
                localConfig.readOption('ajaxDebugMode', 'false') == 'true';

        var error = args.error;
        
        // only enable common error handling if debug mode is on
        if (ajaxDebugMode) {
          args.error = function(err, ioargs) {
            if (args.errorHandlerOverrideDefault !== true) {
              errorDisplayHookpoint(err, ioargs);
            }

            // make sure custom error handler gets called, if there is one
            if (error) {
              error(err, ioargs);
            }
          };
        }

        var deferred = method(args);
        return deferred;
      };

  /**
   * @name curam.util.Request
   * @namespace AJAX request API with common error handling and login page
   * detection. It is designed as a near drop-in replacement for the dojo.xhr*
   * group of functions.
   * <p/>
   * By default this API will behave exactly like it's dojo.xhr* counterpart.
   * <p/>
   * But if the "curam.trace.javascript.ajax.report" application property is set
   * to true then common error reporting is used, causing every AJAX request
   * failure to be reported to the user in a friendly dialog with details
   * written to the JavaScript trace log (if it is enabled).<br/>
   * Session timeouts will be reported differently, asking the user to log
   * in again.
   * <p/>
   * Note that by default the common reporting will work alongside any custom
   * error handlers specified by the API client. However if
   * the "errorHandlerOverrideDefault" property is present on the args
   * object and is set to true, then a provided custom error handler will
   * override the default handling provided by this API.
   */
  var Request = 
    /**
     * @lends curam.util.Request.prototype
     */
    {
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html">dojo.xhrPost</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the post() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html#dojo-xhrpost-supported-object-properties">dojo.xhrPost documentation</a>
       * @returns {dojo.Deferred} Same return type as get(). See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      post: function(args) {
        return _xhr(xhr.post, args);
      },
      
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html">dojo.xhrGet</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the get() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#dojo-xhrget-supported-object-properties">dojo.xhrGet documentation</a>
       * @returns {dojo.Deferred} See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      get: function(args) {
        return _xhr(xhr.get, args);
      },
      
      /**
       * Allows to optionally customize the way to detect that a response
       * from an AJAX request is a login page.
       * 
       * This is optional and if custom detector function is not provided
       * the API will by default recognize login pages that contain a HTML form
       * that submits into the standard "j_security_check" mechanism.
       * 
       * If null is passed the default detection method will be used.
       * 
       * @param {function(dojoXhrRequestObject)::boolean} detectorFunction
       *        The function to be used for detecting login page based on the
       *        <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#handling-status-codes">Dojo XHR
       *        request object.</a>
       */
      setLoginPageDetector: function(detectorFunction) {
        _isLoginPage = detectorFunction;
      },
      
      checkLoginPage: function(args) {
        return isLoginPage(args);
      }
     };
    layer.register("curam/util/Request", Request);

  return Request;
});

},
'dijit/_MenuBase':function(){
define([
	"dojo/_base/array", // array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/mouse", // mouse.enter, mouse.leave
	"dojo/on",
	"dojo/window",
	"./a11yclick",
	"./registry",
	"./_Widget",
	"./_CssStateMixin",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick,
			registry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/_MenuBase

	return declare("dijit._MenuBase", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {
		// summary:
		//		Abstract base class for Menu and MenuBar.
		//		Subclass should implement _onUpArrow(), _onDownArrow(), _onLeftArrow(), and _onRightArrow().

		// selected: dijit/MenuItem
		//		Currently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.
		//		If a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if
		//		this Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because
		//		"selected" is not merely "hovered".
		selected: null,
		_setSelectedAttr: function(item){
			if(this.selected != item){
				if(this.selected){
					this.selected._setSelected(false);
					this._onChildDeselect(this.selected);
				}
				if(item){
					item._setSelected(true);
				}
				this._set("selected", item);
			}
		},

		// activated: [readonly] Boolean
		//		This Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,
		//		so mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the
		//		menu is not active (ie no dropdown) until an item is clicked.
		activated: false,
		_setActivatedAttr: function(val){
			domClass.toggle(this.domNode, "dijitMenuActive", val);
			domClass.toggle(this.domNode, "dijitMenuPassive", !val);
			this._set("activated", val);
		},

		// parentMenu: [readonly] Widget
		//		pointer to menu that displayed me
		parentMenu: null,

		// popupDelay: Integer
		//		After a menu has been activated (by clicking on it etc.), number of milliseconds before hovering
		//		(without clicking) another MenuItem causes that MenuItem's popup to automatically open.
		popupDelay: 500,

		// passivePopupDelay: Integer
		//		For a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause
		//		the popup to open.  Default is Infinity, meaning you need to click the menu to open it.
		passivePopupDelay: Infinity,

		// autoFocus: Boolean
		//		A toggle to control whether or not a Menu gets focused when opened as a drop down from a MenuBar
		//		or DropDownButton/ComboButton.   Note though that it always get focused when opened via the keyboard.
		autoFocus: false,

		childSelector: function(/*DOMNode*/ node){
			// summary:
			//		Selector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children
			//		like MenuSeparator.  If subclass overrides to a string (ex: "> *"), the subclass must require dojo/query.
			// tags:
			//		protected

			var widget = registry.byNode(node);
			return node.parentNode == this.containerNode && widget && widget.focus;
		},

		postCreate: function(){
			var self = this,
				matches = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
			this.own(
				on(this.containerNode, on.selector(matches, mouse.enter), function(){
					self.onItemHover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, mouse.leave), function(){
					self.onItemUnhover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, a11yclick), function(evt){
					self.onItemClick(registry.byNode(this), evt);
					evt.stopPropagation();
				}),
				on(this.containerNode, on.selector(matches, "focusin"), function(){
					self._onItemFocus(registry.byNode(this));
				})
			);
			this.inherited(arguments);
		},

		onKeyboardSearch: function(/*MenuItem*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		Attach point for notification about when a menu item has been searched for
			//		via the keyboard search mechanism.
			// tags:
			//		protected
			this.inherited(arguments);
			if(!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))){
				this.onItemClick(item, evt);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//		-1: a high priority match and stop searching
			//		 0: no match
			//		 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			if(!!item.shortcutKey){
				// accessKey matches have priority
				return searchString == item.shortcutKey.toLowerCase() ? -1 : 0;
			}
			return this.inherited(arguments) ? 1 : 0; // change return value of -1 to 1 so that searching continues
		},

		onExecute: function(){
			// summary:
			//		Attach point for notification about when a menu item has been executed.
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them, because they are about to execute the onClick handler.  In
			//		general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
			// summary:
			//		Attach point for notification about when the user cancels the current menu
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them.  In general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		_moveToPopup: function(/*Event*/ evt){
			// summary:
			//		This handles the right arrow key (left arrow key on RTL systems),
			//		which will either open a submenu, or move to the next item in the
			//		ancestor MenuBar
			// tags:
			//		private

			if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
				this.onItemClick(this.focusedChild, evt);
			}else{
				var topMenu = this._getTopMenu();
				if(topMenu && topMenu._isMenuBar){
					topMenu.focusNext();
				}
			}
		},

		_onPopupHover: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This handler is called when the mouse moves over the popup.
			// tags:
			//		private

			// if the mouse hovers over a menu popup that is in pending-close state,
			// then stop the close operation.
			// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)

			// highlight the parent menu item pointing to this popup (in case user temporarily moused over another MenuItem)
			this.set("selected", this.currentPopupItem);

			// cancel the pending close (if there is one) (in case user temporarily moused over another MenuItem)
			this._stopPendingCloseTimer();
		},

		onItemHover: function(/*MenuItem*/ item){
			// summary:
			//		Called when cursor is over a MenuItem.
			// tags:
			//		protected

			// Don't do anything unless user has "activated" the menu by:
			//		1) clicking it
			//		2) opening it from a parent menu (which automatically activates it)

			if(this.activated){
				this.set("selected", item);
				if(item.popup && !item.disabled && !this.hover_timer){
					this.hover_timer = this.defer(function(){
						this._openItemPopup(item);
					}, this.popupDelay);
				}
			}else if(this.passivePopupDelay < Infinity){
				if(this.passive_hover_timer){
					this.passive_hover_timer.remove();
				}
				this.passive_hover_timer = this.defer(function(){
					this.onItemClick(item, {type: "click"});
				}, this.passivePopupDelay);
			}

			this._hoveredChild = item;

			item._set("hovering", true);
		},

		_onChildDeselect: function(item){
			// summary:
			//		Called when a child MenuItem becomes deselected.   Setup timer to close its popup.

			this._stopPopupTimer();

			// Setup timer to close all popups that are open and descendants of this menu.
			// Will be canceled if user quickly moves the mouse over the popup.
			if(this.currentPopupItem == item){
				this._stopPendingCloseTimer();
				this._pendingClose_timer = this.defer(function(){
					this._pendingClose_timer = null;
					this.currentPopupItem = null;
					item._closePopup(); // this calls onClose
				}, this.popupDelay);
			}
		},

		onItemUnhover: function(/*MenuItem*/ item){
			// summary:
			//		Callback fires when mouse exits a MenuItem
			// tags:
			//		protected

			if(this._hoveredChild == item){
				this._hoveredChild = null;
			}

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
				this.passive_hover_timer = null;
			}

			item._set("hovering", false);
		},

		_stopPopupTimer: function(){
			// summary:
			//		Cancels the popup timer because the user has stop hovering
			//		on the MenuItem, etc.
			// tags:
			//		private

			if(this.hover_timer){
				this.hover_timer = this.hover_timer.remove();
			}
		},

		_stopPendingCloseTimer: function(){
			// summary:
			//		Cancels the pending-close timer because the close has been preempted
			// tags:
			//		private
			if(this._pendingClose_timer){
				this._pendingClose_timer = this._pendingClose_timer.remove();
			}
		},

		_getTopMenu: function(){
			// summary:
			//		Returns the top menu in this chain of Menus
			// tags:
			//		private
			for(var top = this; top.parentMenu; top = top.parentMenu){}
			return top;
		},

		onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
			// summary:
			//		Handle clicks on an item.
			// tags:
			//		private

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
			}

			this.focusChild(item);

			if(item.disabled){
				return false;
			}

			if(item.popup){
				this.set("selected", item);
				this.set("activated", true);
				var byKeyboard = /^key/.test(evt._origType || evt.type) ||
					(evt.clientX == 0 && evt.clientY == 0);	// detects accessKey like ALT+SHIFT+F, where type is "click"
				this._openItemPopup(item, byKeyboard);
			}else{
				// before calling user defined handler, close hierarchy of menus
				// and restore focus to place it was when menu was opened
				this.onExecute();

				// user defined handler for click
				item._onClick ? item._onClick(evt) : item.onClick(evt);
			}
		},

		_openItemPopup: function(/*dijit/MenuItem*/ from_item, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath the current menu item, and optionally focus first item
			// tags:
			//		protected

			if(from_item == this.currentPopupItem){
				// Specified popup is already being shown, so just return
				return;
			}
			if(this.currentPopupItem){
				// If another popup is currently shown, then close it
				this._stopPendingCloseTimer();
				this.currentPopupItem._closePopup();
			}
			this._stopPopupTimer();

			var popup = from_item.popup;
			popup.parentMenu = this;

			// detect mouseover of the popup to handle lazy mouse movements that temporarily focus other menu items\c
			this.own(this._mouseoverHandle = on.once(popup.domNode, "mouseover", lang.hitch(this, "_onPopupHover")));

			var self = this;
			from_item._openPopup({
				parent: this,
				orient: this._orient || ["after", "before"],
				onCancel: function(){ // called when the child menu is canceled
					if(focus){
						// put focus back on my node before focused node is hidden
						self.focusChild(from_item);
					}

					// close the submenu (be sure this is done _after_ focus is moved)
					self._cleanUp();
				},
				onExecute: lang.hitch(this, "_cleanUp", true),
				onClose: function(){
					// Remove handler created by onItemHover
					if(self._mouseoverHandle){
						self._mouseoverHandle.remove();
						delete self._mouseoverHandle;
					}
				}
			}, focus);

			this.currentPopupItem = from_item;

			// TODO: focusing a popup should clear tabIndex on Menu (and it's child MenuItems), so that neither
			// TAB nor SHIFT-TAB returns to the menu.  Only ESC or ENTER should return to the menu.
		},

		onOpen: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback when this menu is opened.
			//		This is called by the popup manager as notification that the menu
			//		was opened.
			// tags:
			//		private

			this.isShowingNow = true;
			this.set("activated", true);
		},

		onClose: function(){
			// summary:
			//		Callback when this menu is closed.
			//		This is called by the popup manager as notification that the menu
			//		was closed.
			// tags:
			//		private

			this.set("activated", false);
			this.set("selected", null);
			this.isShowingNow = false;
			this.parentMenu = null;
		},

		_closeChild: function(){
			// summary:
			//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
			// tags:
			//		private
			this._stopPopupTimer();

			if(this.currentPopupItem){
				// If focus is on a descendant MenuItem then move focus to me,
				// because IE doesn't like it when you display:none a node with focus,
				// and also so keyboard users don't lose control.
				// Likely, immediately after a user defined onClick handler will move focus somewhere
				// else, like a Dialog.
				if(this.focused){
					domAttr.set(this.selected.focusNode, "tabIndex", this.tabIndex);
					this.selected.focusNode.focus();
				}

				// Close all popups that are open and descendants of this menu
				this.currentPopupItem._closePopup();
				this.currentPopupItem = null;
			}
		},

		_onItemFocus: function(/*MenuItem*/ item){
			// summary:
			//		Called when child of this Menu gets focus from:
			//
			//		1. clicking it
			//		2. tabbing into it
			//		3. being opened by a parent menu.
			//
			//		This is not called just from mouse hover.

			if(this._hoveredChild && this._hoveredChild != item){
				this.onItemUnhover(this._hoveredChild);	// any previous mouse movement is trumped by focus selection
			}
			this.set("selected", item);
		},

		_onBlur: function(){
			// summary:
			//		Called when focus is moved away from this Menu and it's submenus.
			// tags:
			//		protected

			this._cleanUp(true);
			this.inherited(arguments);
		},

		_cleanUp: function(/*Boolean*/ clearSelectedItem){
			// summary:
			//		Called when the user is done with this menu.  Closes hierarchy of menus.
			// tags:
			//		private

			this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
			if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
				this.set("activated", false);
			}

			if(clearSelectedItem){
				this.set("selected", null);
			}
		}
	});
});

},
'curam/dialog':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define(["dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/on",
        "dojo/sniff",
        "curam/inspection/Layer",
        "curam/util",
        "curam/debug",
        "curam/util/external",
        "curam/util/Refresh",
        "curam/tab",
        "curam/util/RuntimeContext",
        "curam/util/ScreenContext",
        "curam/define",
        "curam/util/onLoad",
        "dojo/dom-class",
	    "dojo/query",
	    "dojo/NodeList-traverse"], 
	    
	    function(dom, domAttr, domConstruct, on, has, layer, util, trace, external, refresh, tab, runtimeContext, screenContext, define, onload, domClass, query) {


/*
 * Modification History
 * --------------------
 * 09-Mar-2022  CM  [RTC276771] Include the forceParentLocaleRefresh function for new user-locale-selector.jspx file.
 * 11-Aug-2011  SK  [RTC272800] Progress Spinner invocation changed.
 * 15-Jun-2021  SK  [RTC272800] Changes in logging to prevent the memory picture distortion by the DevTools.
 * 03-Jun-2021  BD  [RTC271240] Moved returnFocusToPopupActionAnchorElement function to util.js.
 * 05-May-2021  BD	[RTC266244] Updated unload signal  moving code to CuramCarbonModal JS and 
 * Updated selector from the method curam.dialog._returnFocusToPopupActionAnchorElement.
 * 25-Feb-2021  JD	[RTC266244] Removed checks for IE11 when calling curam.dialog._returnFocusToPopupActionAnchorElement in
 * initModal().
 * 31-Jan-2021 BOS  [RTC267877] Updates for carbon modal.
 * 09-Jan-2020  FN	[RTC254490] Adding some logic in initModal() when using IE11 to focus on correct element once a popup is closing.
 * 10-Oct-2019  CM  [RTC253438] Add check for modals exiting an IEG script to use the dojo.addOnUnload event, as modals
 *                              exiting an IEG script weren't closing correctly in IE11 browsers.
 * 07-Aug-2019  SH  [RTC238154] Do not proceed with submitting a form in formSubmitHandler if event return value is false.
 * 01-Jul-2019  GG [RTC245742] Added call to util.extendXHR in initModal to allow the update of SessionStorage timeout value.
 * 31-May-2019  GG  [RTC244768] Fixing an issue in the agenda player pages when a validation message is displayed.
 * 24-Oct-2018	CMC [RTC225885] Fixing accessibility issue where initial focus was not  
 * 							    being placed correctly on the first editable page element.
 * 20-Sep-2018  CM  [RTC227605] Add method _stylingAddedToMandatoryIconHelp to add class to mandatory-icon-help
 					when wizard progress bar exists.
 * 10-Set-2018  BD  [RTC227106] Included methods _createSpanContainingInformationOnCurrentWizardTab and _screenReaderAnnounceCurrentTabOnWizard
 *                              from ModalDialog.js to dialog.js.
 * 21-Aug-2018  BD  [RTC229425] Removed the handler to the unload event after it happen
 *                  to avoid memory leak.
 * 11-Aug-2018  SK  [RTC234604] The back-button functionality related changes.
 * 11-Jun-2018  BD  [RTC-185627] Added the UA context when the screen context 
 * is created and it is an UA application.
 * 22-Jun-2017  BD  [RTC-198658] Changed method  topic closeModalDialog
 * adding the topic /curam/dialog/close/appExitConfirmation.
 * 05-May-2016  SK  [CR00479312] Removed cm layer usage.
 * 27-Feb-2015  AB  [CR00458854] TEC-17714 Added 'option' variable to the
 * closeModalDialog function so we can pass that variable to the
 * "/curam/dialog/close" event.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.
 * 10-Jul-2013  KW  [CR00391894] Remove reference o3_artificial_post parameter.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 11-Mar-2013  MV  [CR00373738] Remove change to close dialog when page
 *    is loaded. We'll do it differently in curam/ModalDialog.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 24-Sep-2012  MV  [CR00345119] Revert the change to the function used for
 *      detecting when page unloads in a modal.
 * 24-Jul-2012  MK  [CR00336401] Wrapped contents of the closeModalDialog
 *    method in dojo.ready to prevent it closing the model before the page has
 *    finished loading.
 * 07-Feb-2012  MV  [CR00301458] Code cleanup.
 * 15-Sept-2011 MK  [CR00287680] Change the function that is used to detect a 
 *      page unloading in a modal. Changing from addOnUnload to addOnWindowUnload
 * 02-Aug-2011  MV  [CR00283023] Refactored modalEventHandler to allow
 *      unit testing. Avoid unwanted refresh when parent is an Action.do page.
 * 29-Jul-2011  MV [CR00269970] Add support for refreshing based on submit with
 *      inline page as parent. 
 * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
 *                    panel on submit.
 * 28-Jan-2011  MV  [CR00245381] Catch Access denied error when accessing
 *    external sites.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 13-Jan-2011  MV  [CR00241667] Fire event when the dialog infrastructure
 *    is ready.
 * 05-Jan-2011  SK  [CR00239843] Previous page id parameter is not added any
 *                  longer to the form submits from Agenda Player.
 * 12-Jan-2011  SK  [CR00241719] Added the option to close modal without
 *                               the parent redirect.
 * 29-Nov-2010  MV  [CR00232623] Add in a hack to properly unregister a handler
 *    on page unload when using agenda player.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 19-Nov-2010 MV [CR00231655] Store the display status and dialog size
 *     in the runtime context.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 27-Oct-2010  MV  [CR00224488] Refactor for the dialog closing to work well
 *    with new HTML structure.
 * 26-Oct-2010  SK  [CR00224193] The situation where the dialog is opened from
 *                               non-page parent is now handled correctly.
   * 14-Oct-2010  MV  [CR00223441] Move functions to util namespace. Remove
 *    double invoking of a function.
 * 07-Oct-2010  MV  [CR00221605] Refactor for dialogs to work with the generic
 *    key handler that submits the page when Enter is pressed.
 * 17-Sep-2010  MV  [CR00220607] Removed a dead branch of code.
 * 27-Aug-2010  MV  [CR00217499] Refactored to remove hacks previously needed
 *                    to support the agenda player. Documentation comments
 *                    switched to jsdoc.
 * 21-Jul-2010  MV  [CR00211225] Indicate in the `onLoad` context that modal
 *                    is closing.
 * 24-Jun-2010  AF  [CR00202526] Removing reference to content-panel class name
 *                               in the calculateHeightByContents method.
 * 24-Jun-2010  MV  [CR00203864] Add debug output to autoheight calculation.
 * 09-Jun-2010  MV  [CR00202971] Remove the curam.iframeLoaded event,
 *                               add the height calculation function.
 * 04-Jun-2010  MV  [CR00202412] Simplify getting event identifier.
 * 23-Apr-2010  MV  [CR00194352] Fix screen context handling for HTML forms.
 * 11-Feb-2010  MV  [CR00188844] Add event identifier to the iframeLoaded event.
 * 11-Dec-2009  MV  [CR00173949] Remove the "SrPopUp" window name.
 * 24-Nov-2009  MV  [CR00175899] Only call the closeModal function if there
 *                                are no informational messages.
 * 20-Nov-2009  MV  [CR00175581] Replace curam.tab.refreshCurrentTab() call
   *                               with the correct util.redirectWindow().
   * 20-Nov-2009  MV  [CR00175615] Use the util.firePageSubmittedEvent
 *                                function.
 * 03-Sep-2009  MLB [CR00164883] Updated to refresh the current tab for user
 *                  preferences.
 * 07-Aug-2009  MV  [CR00164029] Notify the tabbed UI refresh mechanism
                                on submit. Reverted the previous change as now
                                the refresh is working as expected.
 * 23-Jul-2009  MV  [CR00162771] Updated to not refresh parent window when
 *                  in Tabbed UI.
 */
  
/**
 * @namespace Functions related to the Curam dialog support for UIMs.
 */
curam.define.singleton("curam.dialog", {
  MODAL_PREV_FLAG: "o3modalprev",
  MODAL_PREV_FLAG_INPUT: "curam_dialog_prev_marker",
  FORCE_CLOSE: false,
  ERROR_MESSAGES_HEADER: "error-messages-header",

  /**
   * Keeps track of the hierarchy of window objects for the open dialogs.
   * @private
   */
  _hierarchy: [],

  /**
   * ID of the dialog for the current context.
   * @private
   */
  _id: null,

  /**
   * @private
   */
  _displayedHandlerUnsToken: null,

  /**
   * True if the dialog has been displayed, false otherwise.
   * @private
   */
  _displayed: false,

  /**
   * Holds the current size of the dialog or null if it was not yet published.
   * @private
   */
  _size: null,

  /**
   * Indicates if the dialog should close without the parent redirection. 
   * @private
   */
  _justClose: false,
  
  /**
   * Indicates if the dialog is exiting an IEG script.
   * @private
   */
  _modalExitingIEGScript: false,

  validTargets: {
    "_top":true,"_self":true
  },

  
  /**
   * 
   * @param pageId - page containing modal's content.
   * @param messagesExist
   * @param parentHrefOnClose - If the modal is closing, this property will be 
   * used to reload the parent. If It is null then window.location.href will be used instead.
   */ 
  initModal: function(pageId, messagesExist, parentHrefOnClose) {
    curam.dialog.pageId = pageId;
    curam.dialog.messagesExist = messagesExist;
    var loaded = false;
    var p1;
    util.extendXHR();
    //trace.logLocalized(["curam.dialog: "], "rangeMessage");

      var topWin = util.getTopmostWindow();
    // receive the ID of the dialog
    var isIdSet = false;
    var unsToken = topWin.dojo.subscribe(
        "/curam/dialog/SetId", this, function(dialogId) {
            trace.log("curam.dialog: " 
              + trace.getProperty("curam.dialog.id"), dialogId);
          //trace.logLocalized(["curam.dialog: ", "curam.dialog.id"], dialogId); // FIXME
          curam.dialog._id = dialogId;
          isIdSet = true;

          topWin.dojo.unsubscribe(unsToken);
        });

    // trigger the dialog infrastructure init
    // also sets the dialog ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!isIdSet) {
      // unsubscribe, the modal infrastructure already initialized
      // or nobody listening for this particular event
      trace.log("curam.dialog: " + trace.getProperty("curam.dialog.no.id")); // FIXME
      //trace.logLocalized(["curam.dialog: "], "curam.dialog.no.id"); 
      topWin.dojo.unsubscribe(unsToken);
    }

    if(curam.dialog.closeDialog(false, parentHrefOnClose)) {
      // Do not do any more modal processing. Either the body is hidden off to
      // the left of the screen and messages are being displayed, or the window
      // has been closed.
      return;
    }

    // let us know when we are displayed
    curam.dialog._displayedHandlerUnsToken =
          util.getTopmostWindow().dojo.subscribe(
        "/curam/dialog/displayed", null, function(dialogID, size) {
          if (dialogID == curam.dialog._id) {
            curam.dialog._displayed = true;
            curam.dialog._size = size;

              util.getTopmostWindow().dojo.unsubscribe(
                curam.dialog._displayedHandlerUnsToken);
            curam.dialog._displayedHandlerUnsToken = null;
          }
        });
    // a hack to unsubscribe for agenda pages
    if (jsScreenContext == undefined) {
      var jsScreenContext = this.jsScreenContext;
      if (!jsScreenContext) {
        jsScreenContext = new screenContext();
        jsScreenContext.addContextBits("MODAL");
        //[RTC-244768] - It sets the correct context for all pages within an agenda player.
		if(dojo.global.jsScreenContext.hasContextBits('AGENDA'))
		{
		  jsScreenContext.addContextBits("AGENDA");
		}
        //[RTC-185627] - If it is an EXTAPP, the context for it is added to the screencontext object.
        curam.util.external.inExternalApp() && jsScreenContext.addContextBits("EXTAPP");
      }
    }
    if (jsScreenContext.hasContextBits("AGENDA")
        || jsScreenContext.hasContextBits("TREE")) {

      dojo.addOnUnload(function() {
        util.getTopmostWindow().dojo.unsubscribe(
          curam.dialog._displayedHandlerUnsToken);
        curam.dialog._displayedHandlerUnsToken = null;
      });
    }

    //Wait for the page to load, then add onClick and onKey listeners to the
    //body element
    dojo.addOnLoad(function() {
    // Handle clicks in the dialog window
      util.connect(dojo.body(), "onclick", curam.dialog.modalEventHandler);

      // setup the forms in the page
     for (var i = 0; i < document.forms.length; i++) {
      var form = document.forms[i];
      curam.dialog.addFormInput(form, 'hidden', 'o3frame', 'modal');

      var ctxField = dom.byId('o3ctx');
      var sc = new curam.util.ScreenContext(jsScreenContext.getValue());
      sc.addContextBits("ACTION|ERROR");
      ctxField.value = sc.getValue();

        util.connect(form, "onsubmit", curam.dialog.formSubmitHandler);
      }

      // mark as modal window - for later detection
      // by util.isModalWindow()
      window.curamModal = true;
    });

    if (curam.util.isExitingIEGScriptInModalWindow()) {

      delete curam.util.getTopmostWindow().exitingIEGScript;
      	
      dojo.addOnUnload(function() {

        util.getTopmostWindow().dojo.publish(
  	            "/curam/dialog/iframeUnloaded", [ curam.dialog._id, window ]);
        });

      } else {
  	      
        var signal = on(window, 'unload', function() {

        signal.remove();
        util.getTopmostWindow().dojo.publish(
                 "/curam/dialog/iframeUnloaded", [ curam.dialog._id, window ]);
                
        });
    } 

    if (isIdSet) {
      dojo.publish("/curam/dialog/ready");
    }
  },

  /**
   * Sets a variable to true for uim pages existing an IEG script. 
   * 
   */
  setVariableForModalExitingIEGScript: function() {

    _modalExitingIEGScript = true;
  },

  closeDialog: function(force, parentHrefOnClose) {
    if(force) {
      curam.dialog.forceClose();
    }
    var closeFunction = curam.dialog.checkClose(curam.dialog.pageId, parentHrefOnClose);
    if(closeFunction) {
        util.onLoad.addPublisher(function(context) {
        context.modalClosing = true;
      });

      //If the dialog window should close, but informational messages exist,
      //delay the closing of the window. Add a class to the messages to make
      //them visible, and place a button under them to close the window.action
      //If no messages exist, then just close the window, and optionally
      //redirect the parent page.
      if(curam.dialog.messagesExist) {
        dojo.addOnLoad(function(){
            var errMsgContainer = dom.byId(util.ERROR_MESSAGES_CONTAINER);
            var errMsgNode = dom.byId(util.ERROR_MESSAGES_LIST);
          var errMsgHeaderNode = dom.byId(curam.dialog.ERROR_MESSAGES_HEADER);

          if(errMsgNode && errMsgHeaderNode) {
            //Save the messages locally, to be loaded by the next page that loads
            //which should be the parent page. The closeFunction is called
            //once the messages have been saved.
              util.saveInformationalMsgs(closeFunction);

            //Disable loading of informational messages in the popup,
            //so it doesn't run. This prevents a race condition which would wipe
            //out the messages before the parent page loads.
              util.disableInformationalLoad();

          } else {
            closeFunction();
          }
        });

      } else {
        //If no error messages exist, just run the close function.
        closeFunction();
      }
      //Return true, stating that the dialog is closing.
      return true;
    }
    //Return false, that the dialog is not closing.
    return false;
  },

  addFormInput: function(form, type, name, value) {
    return domConstruct.create("input", {
      "type": type,
      "name": name,
      "value": value
    }, form);
  },

  /**
   * Checks if the window should be closed. If the window should close, this
   * function returns another function which, when executed, closes the dialog,
   * and optionally redirects the parent page. If the window should not close,
   * it returns false.
   */
  checkClose: function(pageId, parentHrefOnClose) {
    if (curam.dialog._justClose) {
      return function() {
        curam.dialog.closeModalDialog();
      };
    }
	
    var parentWindow = curam.dialog.getParentWindow(window);
    if (!parentWindow) {
      return false;
    }

    //Check if the page is in a modal dialog, and if it is, whether or not
    //it should be closed.
    var href;
    if(parentHrefOnClose){
      href = curam.util.retrieveBaseURL() + parentHrefOnClose;
    }else{
      href = window.location.href;
    }
    
    
    var prevFlag = curam.dialog.MODAL_PREV_FLAG;

    var oldPageId = util.getUrlParamValue(href, prevFlag);
    var doClose = true;
    if (oldPageId) {
      if (parentWindow) {
        // If the URL parameter MODAL_PREV_FLAG is set, and is not the same
        // as the current page id, then shut down the dialog and redirect
        // the parent page the current URL. Remove the MODAL_PREV_FLAG
        if(oldPageId == pageId) {
          doClose=false;
        }
      }
    
    } else {
      doClose = false;
    }

      var scReq = util.getUrlParamValue(href, "o3ctx");
    if (scReq) {
      var sc = new curam.util.ScreenContext();
      sc.setContext(scReq);
      if (sc.hasContextBits('TREE|ACTION')) {
        doClose=false;
      }
    }

    if (doClose || curam.dialog.FORCE_CLOSE) {
      if (!curam.dialog.FORCE_CLOSE) {
        if (oldPageId=="user-prefs-editor") {
          return function() {
            if (parentWindow && parentWindow.location
                               !== util.getTopmostWindow().location) {
              curam.dialog.doRedirect(parentWindow);
            }
            curam.dialog.closeModalDialog();
          };
        }
        return function() {
            var rp = util.removeUrlParam;
          // Remove the modal and prevent cache flags from the url
          // before telling the parent to change it's location.
            href = rp(rp(rp(href, prevFlag), "o3frame"),util.PREVENT_CACHE_FLAG);
            href = util.adjustTargetContext(parentWindow, href);
          if (parentWindow && parentWindow.location
                                 !== util.getTopmostWindow().location) {
            curam.dialog.doRedirect(parentWindow, href, true);

          } else {
            curam.tab.getTabController().handleLinkClick(href);
          }
          curam.dialog.closeModalDialog();
        };

      } else {
        return function() {
          // In case there are some informational messages on the modal dialog,
          // make sure they are loaded in to the parent page, even if it
          // isn't refreshed.
            if (parentWindow !== util.getTopmostWindow()) {
            parentWindow.curam.util.loadInformationalMsgs();
          } //otherwise nowhere to show them
          
          curam.dialog.closeModalDialog();
        };
      }
    }
    return false;
  },

  /**
   * Returns the parent window of either the current window or of the specified
   * window.
   *
   * @param {window} [child] If specified, the dialog hierarchy will be used
   *      to look up the parent window.
   */
  getParentWindow: function(/*optional*/child) {
    if (!child) {
    	trace.log(["curam.dialog.getParentWindow():", 
                   trace.getProperty("curam.dialog.no.child"),
                   window.location ? ' '+ window.location.href : '[no location]'].join(' '));
        trace.log("returning as parent = ", window.parent.location.href);
      return window.parent;
    }
    ///trace.logLocalized(["curam.dialog.getParentWindow(): ", "curam.dialog.child"], child.location.href);
    var hierarchy = curam.dialog._getDialogHierarchy();
    if (hierarchy) {
      for (var i = 0; i < hierarchy.length; i++) {
        if (hierarchy[i] == child) {
          // the child found in the stack, parent is at the previous index
          var realParent = (i > 0) ? hierarchy[i - 1] : hierarchy[0];
          trace.log(["curam.dialog.getParentWindow():",
                       trace.getProperty("curam.dialog.parent.window"),
                       realParent.location ? realParent.location.href : '[no location]'].join(' '));
          return realParent;
        }
      }
      // the child NOT found in the stack
      /*trace.logLocalized(["curam.dialog.getParentWindow(): ", 
        "curam.dialog.child.not.found"], child.location.href);
      trace.logLocalized(["curam.dialog.getParentWindow(): ", 
        "curam.dialog.hierarchy"], hierarchy);*/
      var ret = hierarchy.length > 0 ? hierarchy[hierarchy.length - 1] : undefined;
      trace.log(["curam.dialog.getParentWindow():", 
                 trace.getProperty("curam.dialog.returning.parent"), 
                 ret ? ret.location.href : "undefined"].join(' '));
      return ret;
    }
   
  },

  /**
   * Dialog hierarchy is a way for the code to keep track of parent/opener
   * windows for the open modal dialogs. The window.parent property
   * cannot be used for this purpose, because for dojo dialogs it is always
   * pointing at the same parent window, so it does not reflect the real
   * dialog hierarchy.
   *
   * The hierarchy is implemented as a simple stack of consecutive window
   * objects.
   *
   * @returns Array The hierarchy of window objects.
   * @private
   */
  _getDialogHierarchy: function() {
    // the hierarchy is stored in the topmost window - the truly global context
    // TODO: Lookd like refactoring here using promises e.t.c to have
    // this converted to AMD the fucntions that depend on this one need to
    // behvae async too -- BOS
    var topmostWindow = util.getTopmostWindow();
    topmostWindow.require(["curam/dialog"]);
    return topmostWindow.curam.dialog._hierarchy;
  },

  /**
   * Pushes the specified window onto the dialog hierarchy stack,
   * unless the window is already part of the stack.
   */
  pushOntoDialogHierarchy: function(newParent) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if (hierarchy && dojo.indexOf(hierarchy, newParent) < 0) {
      hierarchy.push(newParent);
        trace.log(trace.getProperty("curam.dialog.add.hierarchy"), 
          newParent.location.href);
        trace.log(trace.getProperty("curam.dialog.full.hierarchy") + hierarchy.reduce(function(acc, hwin) {
           return acc + '[' + (hwin.location.href || '-') + ']';
        }), '');
    }
  },

  /**
   * Removes the specified window from the dialog hierarchy stack.
   *
   * @param child The window object to remove from the dialog hierarchy.
   */
  removeFromDialogHierarchy: function(child) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if(!child || hierarchy[hierarchy.length - 1] == child) {
      hierarchy.pop();

    } else {
        trace.log("curam.dialog.removeFromDialogHierarchy(): " 
          + trace.getProperty("curam.dialog.ignore.request"));
      try {
          trace.log(child.location.href);
      
      } catch(e) {
        // in scenarios where we open external site in a dialog, this call
        // causes Access denied exception - we just  catch it and continue
          trace.log(e.message);
      }
    }
  },

  stripPageOrActionFromUrl: function(url) {
    var idx = url.lastIndexOf("Page.do");
    var len = 7;
    if(idx < 0) {
      idx = url.lastIndexOf("Action.do");
      len = 9;
    }
    if(idx < 0) {
      idx = url.lastIndexOf("Frame.do");
      len = 8;
    }
    if(idx > -1 && idx == url.length - len){
      return url.substring(0, idx);
    }
    return url;
  },

  /**
   * @private
   * 
   * @param href
   * @param rtc
   * @param stripPageOrAction
   * @returns {Boolean}
   */
  _isSameBaseUrl: function(href, rtc, stripPageOrAction) {
    if(href && href.indexOf('#') == 0){return true;}
    var hrefSplit = href.split("?");
    var hereSplit = rtc.getHref().split("?");

    //If one url is relative, and the other is absolute, compensate by removing
    //everything except what's after the last "/"
    if(hrefSplit[0].indexOf("/") < 0) {
      var parts = hereSplit[0].split("/");
      hereSplit[0] = parts[parts.length -1];
    }
    if(hereSplit[0].indexOf("/") < 0) {
      var parts = hrefSplit[0].split("/");
      hrefSplit[0] = parts[parts.length -1];
    }

    if (stripPageOrAction && stripPageOrAction == true) {
      hrefSplit[0] = curam.dialog.stripPageOrActionFromUrl(hrefSplit[0]);
      hereSplit[0] = curam.dialog.stripPageOrActionFromUrl(hereSplit[0]);
    }

    if(hrefSplit[0] == hereSplit[0]){
      return true;
    }

    return false;
  },

  modalEventHandler: function(event) {
    curam.dialog._doHandleModalEvent(event,
        new curam.util.RuntimeContext(window),
        curam.dialog.closeModalDialog,
        curam.dialog.doRedirect);
  },

  _showSpinnerInDialog: function() {
    // Display Progress Spinner on submit.
	curam.util.getTopmostWindow().dojo.publish("/curam/dialog/spinner");
  },
  
  /**
   * Hanldes the specified event.
   * 
   * @param e The event to handle.
   * @param rtc Runtime context.
   * @param closeDialog The function to be called to close the dialog.
   * @param doRedirect The function to be called to redirect the parent window
   *    to a new location.
   * @returns {Boolean} True if the event should continue, false if it should
   *    be stopped.
   */
  _doHandleModalEvent: function(e, rtc, closeDialog, doRedirect) {
    var target = e.target;
      var u = util;
      
    switch(target.tagName) {
      case 'INPUT':
        // If the user clicks a submit control, copy its "keepModal" attribute
        // on to the form it is in so that can be read by the onSubmit handler
        if(domAttr.get(target, "type") == "submit"
            && typeof target.form != "undefined") {

          target.form.setAttribute("keepModal", target.getAttribute("keepModal"));
          curam.dialog._showSpinnerInDialog();
          
        }
        return true;

      case 'IMG': case 'SPAN': case 'DIV':
        target = query(target).closest('A')[0];
        //target = target.parentNode;
        if (target == null) {
          return;
        }
        //If the IMG, SPAN or DIV node has an anchor tag parent, leave it run
        //into the 'A' case after changing the target to the parent anchor tag.
      case 'A': case 'BUTTON':
        // If the target is an anchor tag, just get out of the switch statement
        // and keep going in the function, unless the anchor tag is a
        // dynamically generated tag used to replace a submit button.
        // This replacement is done in util.replaceSubmitButton function.
        if(target._submitButton) {
          target._submitButton.form.setAttribute("keepModal",
              target._submitButton.getAttribute("keepModal"));
          curam.dialog._showSpinnerInDialog();
          return;
        }
        
        break;
      default:
        //If we're not interested in this tag, ignore the event
        return true;
    }
    var stopEvent = dojo.stopEvent;
    
    var href = target.getAttribute("href") || target.getAttribute("data-href");

    // handling the case of a cancel link where there is no o3rpu
    if (href == '') {
      closeDialog();
      return false;
    }
    
    // If the anchor tag does not have a href, we simply cancel the event.
    // Any onlick handlers attached directly to the anchor element will have
    // completed by the time this handler is called.
    if (!href) {
      return false;
    }

    if (href.indexOf("javascript") == 0) {
      return false;
    }
    var ctx = jsScreenContext;
    ctx.addContextBits('MODAL');

    //If the anchor tag is trying to open a new window, open it separately,
    //and do not change this page, or redirect the parent
    var targetWindow = target.getAttribute("target");
    if(targetWindow && !curam.dialog.validTargets[targetWindow]) {
      return true;
    }
    //Make sure that file download links do not close the modal dialog.
    //Instead, create an iframe on the fly, and set it's source to the file
    //that is to be downloaded.
    if(href && href.indexOf("/servlet/FileDownload?") > -1) {
      var iframe = domConstruct.create("iframe", {
        src: href
      }, dojo.body());
      iframe.style.display = 'none';
      stopEvent(e);
      return false;
    }

    //If the link is to a URL outside the Curam application, open the link in
    //a new window.
    if(domClass.contains(target, "external-link")) {
      return true;
    }

    // If the link is not going to result in the page changing,
    // then do nothing
      if(util.isSameUrl(href, null, rtc)) {
      // If the link is not simply linking in this page, then redirect the page.
      // otherwise just let the page jump to the local anchor tag.
      if(href.indexOf("#") < 0) {
         href = u.replaceUrlParam(href, "o3frame", "modal");
         href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
         doRedirect(window, href);
         return false;
      }
      return true;
    }
    if(href && curam.dialog._isSameBaseUrl(href, rtc, true)
        && !target.getAttribute("keepModal")){

      target.setAttribute("keepModal", "true");
    }

    var parentWindow = curam.dialog.getParentWindow(rtc.contextObject());
    
    if(target && target.getAttribute) {
      stopEvent(e);

      //If the link has the 'keepModal' attribute set to true, then
      // the new page should be opened in the same modal dialog.
      if(target.getAttribute("keepModal") == "true") {
        href = u.replaceUrlParam(href, "o3frame", "modal");
        href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
        doRedirect(window, href);

      // Otherwise the dialog will close and target will be opened in the parent
      // page
      } else if(parentWindow) {
        href = u.removeUrlParam(href, "o3frame");
        href = u.removeUrlParam(href, curam.dialog.MODAL_PREV_FLAG);
        
        if (parentWindow.location !== util.getTopmostWindow().location) {
          var parentRtc = new curam.util.RuntimeContext(parentWindow);
          var phref = parentRtc.getHref(); 
          phref = u.removeUrlParam(phref, "o3frame");
          
          // only redirect if the parent window is not already on the target
          // page 

          // for submitted action pages in the parent window only comapare
          // the base URL, ignoring any page parameters, because they are not
          // included in the Action.do type URL anyway
          if (util.isActionPage(phref)) {
            if (!curam.dialog._isSameBaseUrl(href, parentRtc, true)) {
              href = u.adjustTargetContext(parentWindow, href);
              doRedirect(parentWindow, href);
            }
            
          // for all other pages compare full URLS and only redirect if
          // the same page is not already loaded
          } else {
            if (!util.isSameUrl(href, phref)) {
              href = u.adjustTargetContext(parentWindow, href);
              curam.dialog.doRedirect(parentWindow, href);
            }
          }
        
        } else {
          //no tab opened
          var tabContext = new curam.util.ScreenContext('TAB');
          href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
          curam.tab.getTabController().handleLinkClick(href);
        }

        closeDialog();
      }

      return false;
    }

    if (parentWindow && typeof(target) == "undefined" || target == null
      || target == "_self" || target == "") {
      stopEvent(e);
      href = href.replace(/[&?]o3frame=modal/g, "")
        .replace("%3Fo3frame%3Dmodal", "")
        .replace("?o3frame%3Dmodal", "");
      //modal closes, so the context should be replaced by the previous.
        href = util.updateCtx(href);
        if (parentWindow.location !== util.getTopmostWindow().location) {
        doRedirect(parentWindow, href);
      
      } else {
        //no tab opened
        var tabContext = new curam.util.ScreenContext('TAB');
        href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
        curam.tab.getTabController().handleLinkClick(href);
      }
      
      closeDialog();
      return false;
    }

    //In this case, the page wants to open a popup window
    return true;
  },

  /**
   * This listener handles the onSubmit event of all forms on the page.
   * It adds the current page ID to the URL as the 'oldPageId' parameter
   * and if the window should be closed, it adds the 'MODAL_PREV_FLAG=true'
   * parameter to the URL.
   */
  formSubmitHandler: function(e) {
    // If the event that is submitting this form has a return value of false
    // (eg from a validation) then stop form submission. 
    if (e.type == "submit" && e.defaultPrevented) {
      curam.util.getTopmostWindow().dojo.publish("/curam/progress/unload");
      return false;
    }

    var parentWindow = curam.dialog.getParentWindow(window);
    if(typeof parentWindow == "undefined") {
      return true;
    }

    e.target.method="post";
    e.target.setAttribute("target", window.name);
    var action = e.target.action;

    var prevFlag = curam.dialog.MODAL_PREV_FLAG;
    var flagInputId = curam.dialog.MODAL_PREV_FLAG_INPUT;
      var u = util;

    // If the input has previously been written to the form, delete it.
    // This is to handle multiple submissions, which can happen if an exception
    // is thrown during submission.
    var input = dom.byId(flagInputId);
    if(input) {
      input.parentNode.removeChild(input);
    }

    // Set the page id in the url if the following page should close the modal
    // dialog if the id has changed. Add a hidden input to the form too, which
    // will be used if the form is a multi-part post containing a file.
    if(e.target.getAttribute("keepModal") != "true"
         && !jsScreenContext.hasContextBits('AGENDA')) {
      var multipart = 'multipart/form-data';
      if(e.target.enctype == multipart || e.target.encoding==multipart) {
        e.target.action = u.removeUrlParam(action, prevFlag);
        input = curam.dialog.addFormInput(e.target, "hidden", prevFlag,
                                          curam.dialog.pageId);
        input.setAttribute("id", flagInputId);
        input.id = flagInputId;

      } else {
        e.target.action = u.replaceUrlParam(action, prevFlag, curam.dialog.pageId);
      }

    } else {
      e.target.action = u.removeUrlParam(action, prevFlag);
    }

    //Tell the parent page that the modal it opened has submitted a form, so
    //that if the user clicks a 'Cancel' link later, the parent page will
    //refresh itself.
    parentWindow.curam.util.invalidatePage();

    // Hook into the overall tabbed UI refresh mechanism (except for external
    // application).
    if (!jsScreenContext.hasContextBits("EXTAPP")) {
      util.firePageSubmittedEvent("dialog");
    }
    return true;
  },

  /**
   * If this is called in the document head, then initModal will shut down
   * no matter what the conditions. This is like a window.close call,
   * except it will refresh the parent if necessary.
   */
  forceClose: function() {
    curam.dialog.FORCE_CLOSE = true;
  },

  /**
   * If this is called in the document head, then any call to
     * util.redirectWindow in the parent window will only refresh it,
   * instead of redirecting it to another URL.  This is primarily used
   * in the user preferences dialog.
   */
  forceParentRefresh: function() {
    var parentWindow = curam.dialog.getParentWindow(window);
    if(!parentWindow){return;}
    parentWindow.curam.util.FORCE_REFRESH = true;
  },
  

  /**
   * If this is called in the document head, then any call to
   * curam.util.redirectWindow in the parent window will refresh it, instead
   * of redirecting it to another URL. The locale in the URL will be replaced
   * by locale from the passed href. This is used in the user locale selector
   * dialog.
   */
  forceParentLocaleRefresh: function(){
	var parentWindow=curam.dialog.getParentWindow(window);
	 if(!parentWindow){return;}
	parentWindow.curam.util.LOCALE_REFRESH=true;
  },

  closeModalDialog: function(option) {
    var topmostWindow = util.getTopmostWindow();
    if (curam.dialog._displayedHandlerUnsToken != null) {
      topmostWindow.dojo.unsubscribe(curam.dialog._displayedHandlerUnsToken);
      curam.dialog._displayedHandlerUnsToken = null;
    }

    var isExtApp = curam.util.getTopmostWindow().dojo.global.jsScreenContext.hasContextBits("EXTAPP");
    if ((typeof(curam.dialog._id) == "undefined" || curam.dialog._id == null || !isExtApp) && window.frameElement) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.dialog._id=modalID;
      trace.log("curam.dialog.closeModalDialog() " 
          + trace.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    util.getTopmostWindow().dojo.publish(
            "/curam/dialog/close/appExitConfirmation", [ curam.dialog._id ]);
    trace.log("publishing /curam/dialog/close/appExitConfirmation for ", curam.dialog._id);
    
    
    trace.log("publishing /curam/dialog/close for ", curam.dialog._id);
    util.getTopmostWindow().dojo.publish(
        "/curam/dialog/close", [ curam.dialog._id, option ]);
  },

  /**
   * Parses the window options string.
   *
   * @returns An object with window option properties. In case no windowOptions
   *          were passed if, empty object (with no properties) is returned.
   */
  parseWindowOptions: function(windowOptions) {
    var opts = {};

    if(windowOptions) {
        trace.log("curam.dialog.parseWindowOptions " 
          + trace.getProperty("curam.dialog.parsing"), windowOptions);
      var tokens = windowOptions.split(',');
      var splitToken;
      for(var i = 0; i < tokens.length; i++) {
        splitToken = tokens[i].split('=');
        opts[splitToken[0]] = splitToken[1];
      }
        trace.log("done:", dojo.toJson(opts));

    } else {
        trace.log("curam.dialog.parseWindowOptions " 
          + trace.getProperty("curam.dialog.no.options"));
    }

    return opts;
  },

  /**
   * Redirects to a new URL in the specified context.
   * 
   * @param context The runtime context in which the redirect will take place.
   * @param [href] URL of the target page or null.
   * @param [force] Indicates if the refresh should take place even
   *    if the href is the same as the current href.
   * @param [ignoreFrames] If true, then any other frames on the page are
   *    not refreshed.
   */
  doRedirect: function(context, href, force, ignoreFrames) {
    window.curamDialogRedirecting = true;
    if (!curam.util.getTopmostWindow().dojo.global.jsScreenContext.hasContextBits("EXTAPP")) {
      curam.util.getTopmostWindow().dojo.publish("/curam/CuramCarbonModal/redirectingModal");
    }
    context.curam.util.redirectWindow(href, force, ignoreFrames);
  },
  
  /**
   * Called on dialog display time. Creates a span containing information
   * on the current wizard tab after the user has clicked next or back, then 
   * adds this span to an aria live region so it can be announced by a screen reader. 
   * Implemented specifically for RTC Defect 227106. Where present, the wizard tab  
   * title and descrition will be read out along with a description of the
   * first cluster if this cluster does not contain a title.
   */
  _screenReaderAnnounceCurrentTabOnWizard: function() {
	var wizardProgressBar = dom.byId("wizard-progress-bar");
	if (wizardProgressBar) {	
		var hiddenAriaLiveElement = dom.byId("hideAriaLiveElement");
		if (typeof hiddenAriaLiveElement != null) {
			this._createSpanContainingInformationOnCurrentWizardTab(wizardProgressBar, hiddenAriaLiveElement);
		}
	 }
  }, 
  
  /**
   * Adds a new styling class to the mandatory icon help label, if both this label and 
   * the wizard progress bar exists.
   */

  _stylingAddedToMandatoryIconHelp: function() {
        var wizardProgressBar = dom.byId("wizard-progress-bar");
        var mandatoryIconHelp = dojo.query(".mandatory-icon-help")[0];
    
        if (wizardProgressBar && mandatoryIconHelp) {
          domClass.add(mandatoryIconHelp, "wizard-progress-bar-exists");
        }
   
        
  },
  
  /**
   * Creates the span containing any reuqired information on the 
   * current wizard tab which should be announned by a screen reader. 
   */
  _createSpanContainingInformationOnCurrentWizardTab: function (wizardProgressBar, hiddenAriaLiveElement) {
		var elementContainingWizardInfoToBeRead = null;
		var description = '';
		var BLANK_SPACE = " ";
		var title = query(".title", wizardProgressBar)[0] && query(".title", wizardProgressBar)[0].innerText;
		var desc =  query(".desc", wizardProgressBar)[0] && query(".desc", wizardProgressBar)[0].innerText;
		if(title && title != ''){
			description += title;
		}
		if(desc && desc != ''){
			description != '' ? description += BLANK_SPACE :'';
			description += desc; 
		}
								
		var pagecontent = dom.byId("content");
		var firstClusterOnPage = query(".cluster,.list", pagecontent)[0];
		if (firstClusterOnPage) {
		  if (typeof query(".collapse-title", firstClusterOnPage)[0] == 'undefined' ||
			  query(".collapse-title", firstClusterOnPage)[0].innerHTML == "") {
		      if (typeof query(".description", firstClusterOnPage)[0] != 'undefined') {
			      if (query(".description", firstClusterOnPage)[0].innerHTML !== "") {
			           // If the modal has a wizard progress bar and the first cluster or list has a description
			           // but no title this description should be announced. 
			          var clusterDescription = query(".description", firstClusterOnPage)[0];  	
			          if (clusterDescription && clusterDescription.innerText !== "") {
			        	  description != '' ? description += BLANK_SPACE :'';
			        	  description += query(".description", firstClusterOnPage)[0].innerText; 
			          }
			      }
		      }
			}
		}else{
			// If the modal has a wizard progress bar and the first table child is a TR with field
			//this description should be announced.  	  
			    var firstTrWithFieldLabel = query("tr:first-child > td.field.last-cell", pagecontent)[0]; 
			    if(firstTrWithFieldLabel && firstTrWithFieldLabel.innerText !== "" ){
			       description != '' ? description += BLANK_SPACE :'';	
			       description += firstTrWithFieldLabel.innerText; 
			    }							 
		}
		
		if(description){
		   // Add the span containing information on the current tab to the hidden
		  // aria live element so it will be read by a screen reader.
		  elementContainingWizardInfoToBeRead = domConstruct.create("span",{innerHTML: description });
		  setTimeout(function () { domConstruct.place(elementContainingWizardInfoToBeRead, hiddenAriaLiveElement); }, 1000);
		}
  },
  
  closeGracefully: function() {
    curam.dialog._justClose = true;
  },
  

   
  });
  layer.register("curam/dialog", this);

  return curam.dialog; 
});
},
'dijit/focus':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-class",
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"./main"		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'dojo/i18n':function(){
define(["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json", "module"],
	function(dojo, require, has, array, config, lang, xhr, json, module){

	// module:
	//		dojo/i18n

	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	 1 || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule = dojo.i18n =
			{
				// summary:
				//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
				// description:
				//		We choose to include our own plugin to leverage functionality already contained in dojo
				//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
				//		allows foreign AMD loaders to be used without their plugins.
			},

		nlsRe =
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales = function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// summary:
			//		return a vector of module ids containing all available locales with respect to the target locale
			//		For example, assuming:
			//
			//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
			//		-  bundlePath is "myPackage/nls"
			//		- bundleName is "myBundle"
			//
			//		Then a locale argument of "fr-ca" would return
			//
			//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			//
			//		Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available

			for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
				current += (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
					result.specificity = current;
				}
			}
			return result;
		},

		cache = {},

		getBundleName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
			return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// summary:
			//		get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
					availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i = 1; i<availableLocales.length; i++){
						current = lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target = bundlePathAndName + "/" + locale;
					cache[target] = current;
					current.$locale = availableLocales.specificity;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// summary:
			//		id may be relative.
			//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
			//		therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			// summary:
			//		id is in one of the following formats
			//
			//		1. <path>/nls/<bundle>
			//			=> load the bundle, localized to config.locale; load all bundles localized to
			//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//		2. <path>/nls/<locale>/<bundle>
			//			=> load then return the bundle localized to <locale>
			//
			//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//			=> for config.locale and all config.extraLocale, load all bundles found
			//			in the best-matching bundle rollup. A value of 1 is returned, which
			//			is meaningless other than to say the plugin is executing the requested
			//			preloads
			//
			//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
			//
			//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//			<path>/nls/<bundle>/<locale>
			//
			//		will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			//		Given this algorithm, other machinery can provide fast load paths be preplacing
			//		values in the plugin's cache, which is public. When a load is demanded the
			//		cache is inspected before starting any loading. Explicitly placing values in the plugin
			//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			//		plugin what additional localized bundles are required for a particular locale. These
			//		additional locales are loaded and a mix of the root and each progressively-specific
			//		locale is returned. For example:
			//
			//		1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			//		2. The loader demands load(some/path/nls/someBundle)
			//
			//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//		ab-cd-ef as...
			//
			//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//		  			require("some/path/nls/ab/someBundle")),
			//					require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//		This value is inserted into the cache and published to the loader at the
			//		key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			//		(further preload requests will be serviced) until all ongoing preloading has completed.
			//
			//		The preload signature instructs the plugin that a special rollup module is available that contains
			//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			//		are available. Here is an example:
			//
			//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			//		This indicates the following rollup modules are available:
			//
			//			some/path/nls/someModule_ROOT
			//			some/path/nls/someModule_ab
			//			some/path/nls/someModule_ab-cd-ef
			//
			//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
			//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
			//
			//			define({
			//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			//			});
			//
			//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			//			require(["some/path/nls/someModule_ab"], function(rollup){
			//				for(var p in rollup){
			//					var id = p + "/ab",
			//					cache[id] = rollup[p];
			//					define(id, rollup[p]);
			//				}
			//			});
			//
			//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			//		load accordingly.
			//
			//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
			//		provided. Further, the builder will include the following cache entry in the cache associated with
			//		any layer.
			//
			//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			//		The *now special cache module instructs the loader to apply the provided function to context-require
			//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
			//		requests until all preloading is complete.
			//
			//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			//		where the target locale has a single segment and a layer depends on a single bundle:
			//
			//		Without Preloads:
			//
			//		1. Layer loads root bundle.
			//		2. bundle is demanded; plugin loads single localized bundle.
			//
			//		With Preloads:
			//
			//		1. Layer causes preloading of target bundle.
			//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.

			if(has("dojo-preload-i18n-Api")){
				var split = id.split("*"),
					preloadDemand = split[1] == "preload";
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1, require);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || waitForPreloads(id, require, load)){
					return;
				}
			}

			var match = nlsRe.exec(id),
				bundlePath = match[1] + "/",
				bundleName = match[5] || match[4],
				bundlePathAndName = bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale =	localeSpecified || dojo.locale || "",
				loadTarget = bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				};
			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-unit-tests")){
		var unitTests = thisModule.unitTests = [];
	}

	if(has("dojo-preload-i18n-Api") ||  1 ){
		var normalizeLocale = thisModule.normalizeLocale = function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid, contextRequire){
				return ( 1  &&  1 ) ?
					contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
				// summary:
				//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
				// description:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would only load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.

				// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
				// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
				// itself may have been mapped.
				contextRequire = contextRequire || require;

				function doRequire(mid, callback){
					if(isXd(mid, contextRequire) || guaranteedAmdFormat){
						contextRequire([mid], callback);
					}else{
						syncRequire([mid], callback, contextRequire);
					}
				}

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return;
						}
						parts.pop();
					}
					func("ROOT");
				}

					function preloadingAddLock(){
						preloading++;
					}

					function preloadingRelLock(){
						--preloading;
						while(!preloading && preloadWaitQueue.length){
							load.apply(null, preloadWaitQueue.shift());
						}
					}

					function cacheId(path, name, loc, require){
						// path is assumed to have a trailing "/"
						return require.toAbsMid(path + name + "/" + loc)
					}

					function preload(locale){
						locale = normalizeLocale(locale);
						forEachLocale(locale, function(loc){
							if(array.indexOf(localesGenerated, loc) >= 0){
								var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
								preloadingAddLock();
								doRequire(mid, function(rollup){
									for(var p in rollup){
										var bundle = rollup[p],
											match = p.match(/(.+)\/([^\/]+)$/),
											bundleName, bundlePath;
											
											// If there is no match, the bundle is not a regular bundle from an AMD layer.
											if (!match){continue;}

											bundleName = match[2];
											bundlePath = match[1] + "/";

										// backcompat
										if(!bundle._localized){continue;}

										var localized;
										if(loc === "ROOT"){
											var root = localized = bundle._localized;
											delete bundle._localized;
											root.root = bundle;
											cache[require.toAbsMid(p)] = root;
										}else{
											localized = bundle._localized;
											cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
										}

										if(loc !== locale){
											// capture some locale variables
											function improveBundle(bundlePath, bundleName, bundle, localized){
												// locale was not flattened and we've fallen back to a less-specific locale that was flattened
												// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
												// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
												// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
												// version of the bundle.
												//
												// Remember, different bundles may have different sets of locales available.
												//
												// we are really falling back on the regular algorithm here, but--hopefully--starting with most
												// of the required bundles already on board as given by the rollup and we need to "manually" load
												// only one locale from a few bundles...or even better...we won't find anything better to load.
												// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
												//
												// note: this feature is only available in async mode

												// inspect the loaded bundle that came from the rollup to see if something better is available
												// for any bundle in a rollup, more-specific available locales are given at localized.
												var requiredBundles = [],
													cacheIds = [];
												forEachLocale(locale, function(loc){
													if(localized[loc]){
														requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
														cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
													}
												});

												if(requiredBundles.length){
													preloadingAddLock();
													contextRequire(requiredBundles, function(){
														// requiredBundles was constructed by forEachLocale so it contains locales from 
														// less specific to most specific. 
														// the loop starts with the most specific locale, the last one.
														for(var i = requiredBundles.length - 1; i >= 0 ; i--){
															bundle = lang.mixin(lang.clone(bundle), arguments[i]);
															cache[cacheIds[i]] = bundle;
														}
														// this is the best possible (maybe a perfect match, maybe not), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
														preloadingRelLock();
													});
												}else{
													// this is the best possible (definitely not a perfect match), accept it
													cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
												}
											}
											improveBundle(bundlePath, bundleName, bundle, localized);
										}
									}
									preloadingRelLock();
								});
								return true;
							}
							return false;
						});
					}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			},

			checkForLegacyModules = function()
				{};
	}

	if( 1 ){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var amdValue = {},
			evalBundle =
				// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
				new Function(
					"__bundle",				   // the bundle to evalutate
					"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
					"__mid",				   // the mid that __bundle is intended to define
					"__amdValue",

					// returns one of:
					//		1 => the bundle was an AMD bundle
					//		a legacy bundle object that is the value of __mid
					//		instance of Error => could not figure out how to evaluate bundle

					  // used to detect when __bundle calls define
					  "var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
					+ "	   require = function(){define.called = 1;};"

					+ "try{"
					+		"define.called = 0;"
					+		"eval(__bundle);"
					+		"if(define.called==1)"
								// bundle called define; therefore signal it's an AMD bundle
					+			"return __amdValue;"

					+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
								// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
					+			"return __checkForLegacyModules;"

					+ "}catch(e){}"
					// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
					// either way, re-eval *after* surrounding with parentheses

					+ "try{"
					+		"return eval('('+__bundle+')');"
					+ "}catch(e){"
					+		"return e;"
					+ "}"
				),

			syncRequire = function(deps, callback, require){
				var results = [];
				array.forEach(deps, function(mid){
					var url = require.toUrl(mid + ".js");

					function load(text){
						var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
						if(result===amdValue){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							results.push(cache[url] = amdValue.result);
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle = require.syncLoadNls(mid);
						// need to check for legacy module here because there might be a legacy module for a
						// less specific locale (which was not looked up during the first checkForLegacyModules
						// call in load()).
						// Also need to reverse the locale and the module name in the mid because syncRequire
						// deps parameters uses the AMD style package/nls/locale/module while legacy code uses
						// package/nls/module/locale.
						if(!bundle){
							bundle = checkForLegacyModules(mid.replace(/nls\/([^\/]*)\/([^\/]*)$/, "nls/$2/$1"));
						}
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url] = {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url] = {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			};

		checkForLegacyModules = function(target){
			// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
			for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
			if(object){
				result = object[names[i]];
				if(!result){
					// fallback for incorrect bundle build of 1.6
					result = object[names[i].replace(/-/g,"_")];
				}
				if(result){
					cache[target] = result;
				}
			}
			return result;
		};

		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var result,
				l10nName = getBundleName(moduleName, bundleName, locale);
			load(
				l10nName,

				// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
				// Since this legacy function does not have the concept of a reference module, resolve with respect to this
				// dojo/i18n module, which, itself may have been mapped.
				(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),

				function(result_){ result = result_; }
			);
			return result;
		};

		if(has("dojo-unit-tests")){
			unitTests.push(function(doh){
				doh.register("tests.i18n.unit", function(t){
					var check;

					check = evalBundle("{prop:1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("({prop:1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("{'prop-x':1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("define({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("define('some/module', {'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("this is total nonsense and should throw an error", checkForLegacyModules, "nonsense", amdValue);
					t.is(check instanceof Error, true);
				});
			});
		}
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache,
		getL10nName: getL10nName
	});
});

},
'dijit/hccss':function(){
define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
});

},
'curam/util/LocalConfig':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2021. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 04-Feb-2021  BOS [RTC267998]  Make the code more defensive to guard
 * against the local configuration being available for some reason.
 * 04-Mar-2014  MV  [CR00421036] Added implementation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

/**
 * @name curam.util.LocalConfig
 * @namespace Provides support for accessing application properties
 *    from JavaScript and overriding their values locally.
 *      <p/>
 *    The basic idea is that desired options are determined at application
 *    init time (in the main app page) and they are "seeded" using this API.
 *    From then on JavaScript code can access the values of these options.
 *      <p/>
 *    It is then possible to override individual option values and the API
 *    will persist the overrides in local Web storage. This allows
 *    for individual users to control the behaviour of the application
 *    without the need to set options globally for all users in admin pages.
 *      <p/>
 *    Please note the option values and overrides are stored in the "top"
 *    browser window, even if the API is used from nested iframes.
 */
define([
        ], function() {
  
  // the code below ensures we store the values globally
  var globalName = function(name) {
        return 'curam_util_LocalConfig_' + name;
      },
      initGlobal = function(name, value) {
        var gName = globalName(name);
        
        // only initialize if it doesn't already exist!
        if (typeof top[gName] === 'undefined') {
          top[gName] = value;
        }
        
        return top[gName];
      },
      getGlobal = function(name) {
        return top && top !=null ? top[globalName(name)] : undefined;
      };
  
  initGlobal('seedValues', {}),
  initGlobal('overrides', {});
  
  var _checkIsString = function(value, valName) {
    if (typeof value !== 'undefined' && typeof value !== 'string') {
      throw new Error('Invalid ' + valName + ' type: ' + typeof value
          + '; expected string');
    }
  };
  
  var LocalConfig =
  /**
   * @lends curam.util.LocalConfig.prototype
   */
  {
    /**
     * Sets the "global" value for the option.
     * This can be later overriden to provide a local value. 
     *
     * @param name Name of the option to set.
     * @param value Value of the option to set. If this is undefined
     *  then default value will be used instead.
     * @param defaultValue Default value to be used if value is not specified.
     */
    seedOption: function(name, value, defaultValue) {
      _checkIsString(value, 'value');
      _checkIsString(defaultValue, 'defaultValue');
      
      // code below treats null as a valid value to be used
      getGlobal('seedValues')[name] =
          (typeof value !== 'undefined') ? value : defaultValue;
    },
    
    /**
     * Sets local override for the value of given option.
     * The override is persisted to local Web storage, if available.
     * 
     * @param name Name of the option to override.
     * @param value The local value to be used.
     */
    overrideOption: function(name, value) {
      _checkIsString(value, 'value');

      // persist the value, if possible
      if(typeof(Storage) !== "undefined") {
        localStorage[name] = value;

      // otherwise just store in memory - override will not be permanent
      } else {
        getGlobal('overrides')[name] = value;
      }
    },
    
    /**
     * Reads the value of the given option. It takes the values in the following
     * precedence order. The first that is found is returned.
     * <ul>
     * <li>override from local persistent Web storage</li>
     * <li>override from session memory</li>
     * <li>the global value</li>
     * <li>return the provided default value</li>
     * </ul>
     * 
     * @param name Name of the option to read.
     * @param defaultValue Default value to return if value is not set.
     * @returns Value of the option or provided default value.
     */
    readOption: function(name, defaultValue) {
      var seedValues = getGlobal('seedValues');
	  var overridesValues = getGlobal('overrides');
      _checkIsString(defaultValue, 'defaultValue');

      var finalValue = null;

      // use local persistent value, if possible and if available
      if (typeof(Storage) !== "undefined"
          && localStorage && typeof localStorage[name] !== 'undefined') {
        finalValue = localStorage[name];
    
      // otherwise fall back to local non-persistent override
      } else if (overridesValues && typeof overridesValues[name] !== 'undefined') {
        finalValue = overridesValues[name];
  
      // otherwise fall back to the seed value
      } else if (seedValues && typeof seedValues[name] !== 'undefined') {
        finalValue = seedValues[name];
  
      // otherwise fall back to the specified default value
      } else {
        finalValue = defaultValue;
      }

      return finalValue;
    },
    
    /**
     * Completely removes the option from configuration.
     * After using this method the readOption() will return the provided
     * default value.
     *
     * @param name Name of the option to clear.
     */
    clearOption: function(name) {
      if(typeof(Storage) !== "undefined") {
        localStorage.removeItem(name);
      }
      delete getGlobal('overrides')[name];
      delete getGlobal('seedValues')[name];
    }
  };
  
  return LocalConfig;
  
});

},
'curam/widget/_HasDropDown':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 14-May-2019  JD  [RTC242058]  Initial version.
   */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"dijit/registry", // registry.byNode()
	"dijit/focus",
	"dijit/popup",
	"dijit/_FocusMixin",
	"dijit/a11y",
	"dijit/_HasDropDown",
	"curam/util"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focusUtil, popup, _FocusMixin, a11y){


	// module:
	//		dijit/_HasDropDown

	return declare("curam.widget._HasDropDown", [dijit._HasDropDown], {
		
		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				
				// CURAM-FIX: Added evt object as parameter
				onCancel: function(evt){
					self.closeDropDown(evt, true);
				},
				// END CURAM-FIX:
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				this._origStyle = ddNode.style.cssText;
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		/* CURAM-FIX: overriding default dojo focus behaviour*/
		closeDropDown: function(/*Event*/ evt, /*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected
			

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					
					// Look for the next node to focus on
					var nodeToFocusOn = this._getNextFocusableNode(
							evt, this.ownerDocument, this.focusNode);
					
					// If the next node to focus on is found, focus on that.
					// Otherwise, focus on the focusNode of the widget.
					if(nodeToFocusOn.focus){
						nodeToFocusOn.focus();
					} else {
						this.focus();
					}
				
				}
				popup.close(this.dropDown);
				this._opened = false;
			}
			
			if(this._origStyle){
				this.dropDown.domNode.style.cssText = this._origStyle;
				delete this._origStyle;
			}
		},
		
		// Find the next or previous focusable node depending on whether TAB or SHIFT-TAB was pressed.
		// If one is not found, the current focused node is returned.
		_getNextFocusableNode: function(evt, document, currentFocusableNode) {
			
			var nodeToFocusOn = currentFocusableNode;
			var topWindow = curam.util.getTopmostWindow();
			
			// If the TAB key is pressed.
			if(evt && evt.keyCode == keys.TAB){

				// Get all the focusable elements in the current document
				var focusable = this._findFocusableElementsInDocument(document);
				var focusableLength = focusable.length;
				// Get the index of the current focused node.
				var indexOfNode = focusable.indexOf(currentFocusableNode);
								
				if(indexOfNode > -1){
					
					  // If the SHIFT button was not clicked
					  if(!evt.shiftKey){
						  
						  indexOfNode++;
						  var nextNode = null;
						  for(var i = indexOfNode; i < focusable.length; i++){
							  // If the node is not hidden by a parent element and is not a dijitMenuItem
							  if(focusable[i].offsetParent !== null && !domClass.contains(focusable[i], "dijitMenuItem")){
								  nextNode = focusable[i];
								  break;
							  }
						  }
						  
						  if(nextNode && nextNode.nodeName.toLowerCase() !== "iframe") {
							  
							  nodeToFocusOn = nextNode;
						  } else if(nextNode && nextNode.nodeName.toLowerCase() === "iframe"){
							  
							  // Find the focusable node in the iframe. Returns null if no node is found.
							  nextNode = this._findFocusableElementInIframe(nextNode, evt.shiftKey);
							  
							  // The node to focus on has been found.
							  if(nextNode) {
								  nodeToFocusOn = nextNode;
							  }
						  } else if(this.ownerDocument !== topWindow.document){
							  
							  // It's possible the widget is the last focusable element within
							  // a nested iframe. In this case, the focus should move to the next
							  // focusable element in the parent window.
							  var currentDocument = this.ownerDocument;
							  while(currentDocument !== topWindow.document && !nextNode){
								  
								  // Get parent document and check for focusable element there!
								  // If not found, check to see if there is another parent window
								  // and retrieve it's document, then repeat.
								  var parentWindow = window.parent;
								  var parentDocument = parentWindow.document || parentWindow.contentDocument || parentWindow.contentWindow.document;
								  nextNode = this._findFocusableElementInParentDocument(parentDocument, evt.shiftKey);
								  currentDocument = parentDocument;
							  }
							  
							  if(nextNode){
								  // The node to focus on has been found.
								  nodeToFocusOn = nextNode;
							  }
						  }
						  
					  } else {
						  
						  // If SHIFT-TAB was pressed
						  indexOfNode--;
						  var previousNode = null;
						  for(var i = indexOfNode; i > -1; i--){
							  // If the node is not hidden by a parent element.
							  if(focusable[i].offsetParent !== null){
								  previousNode = focusable[i];
								  break;
							  }
						  }
						  
						  if(previousNode && previousNode.nodeName.toLowerCase() !== "iframe") {
							  
							  nodeToFocusOn = previousNode;
						  } else if(previousNode && previousNode.nodeName.toLowerCase() === "iframe"){
							  
							  // Find the focusable node in the iframe. Returns null if no node is found.
							  previousNode = this._findFocusableElementInIframe(previousNode, evt.shiftKey);
							  
							  // The node to focus on has been found.
							  if(previousNode) {
								  nodeToFocusOn = previousNode;
							  }
						  } else if(this.ownerDocument !== topWindow.document){
							  
							  // It's possible the widget is the first focusable element within
							  // a nested iframe. In this case, the focus should move to the previous
							  // focusable element in the parent window.
							  var currentDocument = this.ownerDocument;
							  while(currentDocument !== topWindow.document && !previousNode){
								  
								  // Get parent document and check for focusable element there!
								  // If not found, check to see if there is another parent window
								  // and retrieve it's document, then repeat.
								  var parentWindow = window.parent;
								  var parentDocument = parentWindow.document || parentWindow.contentDocument || parentWindow.contentWindow.document;
								  previousNode = this._findFocusableElementInParentDocument(parentDocument, evt.shiftKey);
								  currentDocument = parentDocument;
							  }
							  
							  if(previousNode){
								  // The node to focus on has been found.
								  nodeToFocusOn = previousNode;
							  }
							  
						  }
						  
					  }
				}
				
			}
			
			// Either the next/previous focusable node or the current focusable node.
			return nodeToFocusOn;
			
		},
		
		// Finds all focusable elements in a given document.
		_findFocusableElementsInDocument: function(document) {
			
			// This finds any native focusable elements, with the exception
			// of buttons with the class dijitTabCloseButton as well as anything
			// that has a tabIndex greater than -1.
			var focusableDomElements = document.querySelectorAll(
					'button:not(.dijitTabCloseButton), [href], input, select, object, iframe, area, textarea, [tabindex]:not([tabindex="-1"])');
			var focusable = [];

			for(var i = 0; i < focusableDomElements.length; i++){
				// If the element itself is shown and is a native tabbable
				// element or has a tabIndex greater than -1, add it to the array.
				if(a11y._isElementShown(focusableDomElements[i])) {
					if(a11y.isTabNavigable(focusableDomElements[i])){
						focusable.push(focusableDomElements[i]);
					} else if(focusableDomElements[i].nodeName.toLowerCase() === "iframe"){
						// If the element is an iframe add it to the array regardless as the nested
						// elements could be focusable.
						focusable.push(focusableDomElements[i]);
					}
				}
				
			}
			
			return focusable;
		},
		
		// Find a focusable element in the document of the parent window.
		// The element selected will depend on whether the SHIFT key was pressed.
		_findFocusableElementInParentDocument: function(document, shiftKeyPressed){
		  
		  var parentFocusable = this._findFocusableElementsInDocument(document);
		  var currentIframeFound = false;
		  var indexOfIframe = 0;
		  var focusNode = null;

		  if(!shiftKeyPressed) {
			  for(var i = 0; i < parentFocusable.length; i++){
			    
			    // Looking to find the index of the current iframe
			    if(parentFocusable[i].nodeName.toLowerCase() === "iframe"){
			      if(parentFocusable[i].contentDocument === this.ownerDocument){
			        currentIframeFound = true;
			        indexOfIframe = i;
			        break;
			      }
			    }
	
			  }
		  } else {
			  for(var i = parentFocusable.length - 1; i > -1; i--){
			    
			    // Looking to find the index of the current iframe
			    if(parentFocusable[i].nodeName.toLowerCase() === "iframe"){
			      if(parentFocusable[i].contentDocument === this.ownerDocument){
			        currentIframeFound = true;
			        indexOfIframe = i;
			        break;
			      }
			    }
	
			  }
		  }
		  
		  if(currentIframeFound){

		    // Find the next focusable element that occurrs after
		    // the current iframe.
		    if(!shiftKeyPressed) {
			    indexOfIframe++;
			    for(var i = indexOfIframe; i < parentFocusable.length; i++){
			      if(parentFocusable[i].offsetParent !== null){
			        focusNode = parentFocusable[i];
			        break;
			      }
			    }
			  } else {
			    // Find the previous focusable element that occurred before
			    // the current iframe.
			    indexOfIframe--;
			    for(var i = indexOfIframe; i > -1; i--){
			      if(parentFocusable[i].offsetParent !== null){
			        focusNode = parentFocusable[i];
			        break;
			      }
			    }
			}
		    
		    // If the element found is another iframe, look for a focusable element in here.
		    if(focusNode && focusNode.nodeName.toLowerCase() === "iframe"){
		      focusNode = this._findFocusableElementInIframe(focusNode, shiftKeyPressed);
		    }
		    
		  }
		  
		  return focusNode;
		   
		  
		},
		
		// Finds a focusable element within a given iframe. If the supplied node is not
		// an iframe, it just returns that node. If the supplied node is an iframe,
		// but no focusable elements are found, null is returned.
		_findFocusableElementInIframe: function(node, shiftKeyPressed){
			
			var iframeNode = node;
			
			while(iframeNode && iframeNode.nodeName.toLowerCase() === "iframe"){
				  
			  // Get the iframe document and find the focusable elements within.
			  var iframeDoc = iframeNode.contentDocument || iframeNode.contentWindow.document;
			  var iframeFocusable = this._findFocusableElementsInDocument(iframeDoc);
			  if(iframeFocusable.length > 0){

			  if(!shiftKeyPressed){
				  
				  // If the next node is an iframe element, we want to focus on the
				  // first focusbale element within the iframe.
				  // If the first focusable element is a another iframe, then find the
				  // first focusbable element within that.
			      indexOfNode = 0;
				  // Navigate forwards through the iframe elements.
			      for(var i = indexOfNode; i < iframeFocusable.length; i++){
			        // If the node is not hidden by a parent element.
			        if(iframeFocusable[i].offsetParent !== null){
			          iframeNode = iframeFocusable[i];
			          break;
			        }
			      }
			    } else {
				  // If the previous node is an iframe element, we want to focus on the
				  // last focusbale element within the iframe.
				  // If the last focusable element is a another iframe, then find the
				  // last focusbable element within that.
			    	
			      indexOfNode = iframeFocusable.length - 1;
			      // Work backwards through the iframes elements.
			      for(var i = indexOfNode; i > -1; i--){
			        // If the element is not hidden by a parent element.
			        if(iframeFocusable[i].offsetParent !== null){
			          iframeNode = iframeFocusable[i];
			          break;
			        }
			      }
			    }
			  } else {
			    // Need to cater for empty iframes. This prevents infinite loop.
			    iframeNode = null;
			  }
			  
			}
			
			return iframeNode;
			
		}
		/* END CURAM-FIX */
		
	});
});

},
'idx/form/_AutoCompleteA11yMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define([
	"dojo/_base/declare" // declare
],function(declare){
	return declare("idx.form._AutoCompleteA11yMixin",[],{
		_showResultList: function(){
			var temp = this.domNode;
			this.domNode = this.oneuiBaseNode;
			this.inherited(arguments);
			this.domNode = temp;
		},
		
		closeDropDown: function(){
			var temp = this.domNode;
			this.domNode = this.oneuiBaseNode;
			this.inherited(arguments);
			this.domNode = temp;
		},
		
		_announceOption: function(){
			this.inherited(arguments);
			this.focusNode.removeAttribute("aria-activedescendant");
		}
	});
});

},
'dijit/form/_ComboBoxMenuMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/i18n!./nls/ComboBox"
], function(array, declare, domAttr, has, i18n){

	// module:
	//		dijit/form/_ComboBoxMenuMixin

	var ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		// tags:
		//		private

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this._set("value", value);
			this.onChange(value);
		},

		onClick: function(/*DomNode*/ node){
			if(node == this.previousButton){
				this._setSelectedAttr(null);
				this.onPage(-1);
			}else if(node == this.nextButton){
				this._setSelectedAttr(null);
				this.onPage(1);
			}else{
				this.onChange(node);
			}
		},

		// stubs
		onChange: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user selected an option.
			// tags:
			//		callback
		},

		onPage: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._setSelectedAttr(null);
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit/form/FilteringSelect`.

			var menuitem = this._createMenuItem();
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					menuitem.ownerDocument.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&#160;";	// &nbsp;
			}

			return menuitem;
		},

		createOptions: function(results, options, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of items
			// options:
			//		The options to the query function of the store
			//
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			this.items = results;

			// display "Previous . . ." button
			this.previousButton.style.display = (options.start == 0) ? "none" : "";
			domAttr.set(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			array.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.setAttribute("item", i);	// index to this.items; use indirection to avoid mem leak
				domAttr.set(menuitem, "id", this.id + i);
				this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			// Try to determine if we should show 'more'...
			if(results.total && !results.total.then && results.total != -1){
				if((options.start + options.count) < results.total){
					displayMore = true;
				}else if((options.start + options.count) > results.total && options.count == results.length){
					// Weird return from a data store, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					// And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(options.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			domAttr.set(this.nextButton, "id", this.id + "_next");
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			var container = this.containerNode;
			while(container.childNodes.length > 2){
				container.removeChild(container.childNodes[container.childNodes.length - 2]);
			}
			this._setSelectedAttr(null);
		},

		highlightFirstOption: function(){
			// summary:
			//		Highlight the first real item in the list (not Previous Choices).
			this.selectFirstNode();
		},

		highlightLastOption: function(){
			// summary:
			//		Highlight the last real item in the list (not More Choices).
			this.selectLastNode();
		},

		selectFirstNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.previousButton){
				this.selectNextNode();
			}
		},

		selectLastNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.nextButton){
				this.selectPreviousNode();
			}
		},

		getHighlightedOption: function(){
			return this.selected;
		}
	});

	if(has("dojo-bidi")){
		ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin", ComboBoxMenuMixin, {
			_createOption: function(){
				var menuitem = this.inherited(arguments);

				// update menuitem.dir if BidiSupport was required
				this.applyTextDir(menuitem);

				return menuitem;
			}
		});
	}

	return ComboBoxMenuMixin;
});

},
'dijit/form/_SearchMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/string", // string.substitute
	"dojo/when",
	"../registry"	// registry.byId
], function(declare, keys, lang, query, string, when, registry){

	// module:
	//		dijit/form/_SearchMixin


	return declare("dijit.form._SearchMixin", null, {
		// summary:
		//		A mixin that implements the base functionality to search a store based upon user-entered text such as
		//		with `dijit/form/ComboBox` or `dijit/form/FilteringSelect`
		// tags:
		//		protected

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies maximum number of search results to return per query
		pageSize: Infinity,

		// store: [const] dojo/store/api/Store
		//		Reference to data provider object used by this ComboBox.
		//		The store must accept an object hash of properties for its query. See `query` and `queryExpr` for details.
		store: null,

		// fetchProperties: Object
		//		Mixin to the store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to `store` to initially filter the items.
		//		ComboBox overwrites any reference to the `searchAttr` and sets it to the `queryExpr` with the user's input substituted.
		query: {},

		// list: [const] String
		//		Alternate to specifying a store.  Id of a dijit/form/DataList widget.
		list: "",
		_setListAttr: function(list){
			// Avoid having list applied to the DOM node, since it has native meaning in modern browsers
			this._set("list", list);
		},

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 200,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// queryExpr: String
		//		This specifies what query is sent to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the results are only exact matches, a "starting with" match,
		//		etc.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the query should ignore case when matching possible items
		ignoreCase: true,

		_patternToRegExp: function(pattern){
			// summary:
			//		Helper function to convert a simple pattern to a regular expression for matching.
			// description:
			//		Returns a regular expression object that conforms to the defined conversion rules.
			//		For example:
			//
			//		- ca*   -> /^ca.*$/
			//		- *ca*  -> /^.*ca.*$/
			//		- *c\*a*  -> /^.*c\*a.*$/
			//		- *c\*a?*  -> /^.*c\*a..*$/
			//
			//		and so on.
			// pattern: string
			//		A simple matching pattern to convert that follows basic rules:
			//
			//		- * Means match anything, so ca* means match anything starting with ca
			//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
			//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
			//
			//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
			//		represented by \\ to be treated as an ordinary \ character instead of an escape.

			return new RegExp("^" + pattern.replace(/(\\.)|(\*)|(\?)|\W/g, function(str, literal, star, question){
				return star ? ".*" : question ? "." : literal ? literal : "\\" + str;
			}) + "$", this.ignoreCase ? "mi" : "m");
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				this.searchTimer = this.searchTimer.remove();
			}
			if(this._queryDeferHandle){
				this._queryDeferHandle = this._queryDeferHandle.remove();
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){
					this._cancelingQuery = true;
					this._fetchHandle.abort();
					this._cancelingQuery = false;
				}
				if(this._fetchHandle.cancel){
					this._cancelingQuery = true;
					this._fetchHandle.cancel();
					this._cancelingQuery = false;
				}
				this._fetchHandle = null;
			}
		},

		_processInput: function(/*Event*/ evt){
			// summary:
			//		Handles input (keyboard/paste) events
			if(this.disabled || this.readOnly){ return; }
			var key = evt.charOrCode;

			var doSearch = false;
			this._prev_key_backspace = false;

			switch(key){
				case keys.DELETE:
				case keys.BACKSPACE:
					this._prev_key_backspace = true;
					this._maskValidSubsetError = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..) shouldn't start a search..
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				if(!this.store){
					this.onSearch();
				}else{
					this.searchTimer = this.defer("_startSearchFromInput", 1);
				}
			}
		},

		onSearch: function(/*===== results, query, options =====*/){
			// summary:
			//		Callback when a search completes.
			//
			// results: Object
			//		An array of items from the originating _SearchMixin's store.
			//
			// query: Object
			//		A copy of the originating _SearchMixin's query property.
			//
			// options: Object
			//		The additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.
			//
			// tags:
			//		callback
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value);
		},

		_startSearch: function(/*String*/ text){
			// summary:
			//		Starts a search for elements matching text (text=="" means to return all items),
			//		and calls onSearch(...) when the search completes, to display the results.

			this._abortQuery();
			var
				_this = this,
				// Setup parameters to be passed to store.query().
				// Create a new query to prevent accidentally querying for a hidden
				// value from FilteringSelect's keyField
				query = lang.clone(this.query), // #5970
				options = {
					start: 0,
					count: this.pageSize,
					queryOptions: {		// remove for 2.0
						ignoreCase: this.ignoreCase,
						deep: true
					}
				},
				qs = string.substitute(this.queryExpr, [text.replace(/([\\\*\?])/g, "\\$1")]),
				q,
				startQuery = function(){
					var resPromise = _this._fetchHandle = _this.store.query(query, options);
					if(_this.disabled || _this.readOnly || (q !== _this._lastQuery)){
						return;
					} // avoid getting unwanted notify
					when(resPromise, function(res){
						_this._fetchHandle = null;
						if(!_this.disabled && !_this.readOnly && (q === _this._lastQuery)){ // avoid getting unwanted notify
							when(resPromise.total, function(total){
								res.total = total;
								var pageSize = _this.pageSize;
								if(isNaN(pageSize) || pageSize > res.total){ pageSize = res.total; }
								// Setup method to fetching the next page of results
								res.nextPage = function(direction){
									//	tell callback the direction of the paging so the screen
									//	reader knows which menu option to shout
									options.direction = direction = direction !== false;
									options.count = pageSize;
									if(direction){
										options.start += res.length;
										if(options.start >= res.total){
											options.count = 0;
										}
									}else{
										options.start -= pageSize;
										if(options.start < 0){
											options.count = Math.max(pageSize + options.start, 0);
											options.start = 0;
										}
									}
									if(options.count <= 0){
										res.length = 0;
										_this.onSearch(res, query, options);
									}else{
										startQuery();
									}
								};
								_this.onSearch(res, query, options);
							});
						}
					}, function(err){
						_this._fetchHandle = null;
						if(!_this._cancelingQuery){	// don't treat canceled query as an error
							console.error(_this.declaredClass + ' ' + err.toString());
						}
					});
				};

			lang.mixin(options, this.fetchProperties);

			// Generate query
			if(this.store._oldAPI){
				// remove this branch for 2.0
				q = qs;
			}else{
				// Query on searchAttr is a regex for benefit of dojo/store/Memory,
				// but with a toString() method to help dojo/store/JsonRest.
				// Search string like "Co*" converted to regex like /^Co.*$/i.
				q = this._patternToRegExp(qs);
				q.toString = function(){ return qs; };
			}

			// set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this._lastQuery = query[this.searchAttr] = q;
			this._queryDeferHandle = this.defer(startQuery, this.searchDelay);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var list = this.list;
				if(list){
					this.store = registry.byId(list);
				}
			}
			this.inherited(arguments);
		}
	});
});

},
'dojo/parser':function(){
define([
	"require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window",
		"./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./query", "./on", "./ready"
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval("(" + text + ")");
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
	var _ctorMap = {};

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		var ts = types.join();
		if(!_ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					(contextRequire ? contextRequire(t) : require(t)))));
			}
			var ctor = mixins.shift();
			_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return _ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojoType";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			if(rootNode && typeof rootNode != "string" && !("nodeType" in rootNode)){
				// If called as parse(options) rather than parse(), parse(rootNode), or parse(rootNode, options)...
				options = rootNode;
				rootNode = options.rootNode;
			}
			var root = rootNode ? dom.byId(rootNode) : dwindow.body();
			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if( 1 ){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
});

},
'dijit/form/ToggleButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

	// module:
	//		dijit/form/ToggleButton


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons.

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'dojo/date/stamp':function(){
define(["../_base/lang", "../_base/array"], function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
});

},
'dojo/Stateful':function(){
define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});

},
'dijit/form/_AutoCompleterMixin':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/keys",
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/regexp", // regexp.escapeString
	"dojo/sniff", // has("ie")
	"./DataList",
	"./_TextBoxMixin", // defines _TextBoxMixin.selectInputText
	"./_SearchMixin"
], function(aspect, declare, domAttr, keys, lang, query, regexp, has, DataList, _TextBoxMixin, SearchMixin){

	// module:
	//		dijit/form/_AutoCompleterMixin

	var AutoCompleterMixin = declare("dijit.form._AutoCompleterMixin", SearchMixin, {
		// summary:
		//		A mixin that implements the base functionality for `dijit/form/ComboBox`/`dijit/form/FilteringSelect`
		// description:
		//		All widgets that mix in dijit/form/_AutoCompleterMixin must extend `dijit/form/_FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo/store/api/Store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		//		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(has("ie")){
				// in the case of a mouse click in a popup being handled,
				// then the document.selection is not the textarea, but the popup
				// var r = document.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = element.ownerDocument.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character", 0);
				ntr.move("character", 0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g, "").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			_TextBoxMixin.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			this.domNode.setAttribute("aria-disabled", value ? "true" : "false");
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			if(evt.charCode >= 32){
				return;
			} // alphanumeric reserved for searching

			var key = evt.charCode || evt.keyCode;

			// except for cutting/pasting case - ctrl + x/v
			if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
				return; // throw out spurious events
			}

			var pw = this.dropDown;
			var highlighted = null;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//
			//	1. when drop down is not yet shown:
			//		- if user presses the down arrow key, call loadDropDown()
			//	2. when drop down is already displayed:
			//		- on ESC key, call closeDropDown()
			//		- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(evt.altKey || evt.ctrlKey || evt.metaKey){
				return;
			} // don't process keys with modifiers  - but we want shift+TAB

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					evt.stopPropagation();
					evt.preventDefault();
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}
						// prevent submit if ENTER was to choose an item
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
				// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
						break;
					}
					if(highlighted){
						this._selectOption(highlighted);
					}
				// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			//		Fill in the textbox with the first item from the drop down
			//		list, and highlight the characters that were
			//		auto-completed. For example, if user typed "CA" and the
			//		drop down list appeared, the textbox would be changed to
			//		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			_TextBoxMixin.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase ? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
				// only try to extend if we added the last character at the end of the input
				if((cpos + 1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					_TextBoxMixin.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				_TextBoxMixin.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			var wasSelected = this.dropDown.getHighlightedOption();
			this.dropDown.clearResultList();
			if(!results.length && options.start == 0){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}
			this._nextSearch = this.dropDown.onPage = lang.hitch(this, function(direction){
				results.nextPage(direction !== -1);
				this.focus();
			});

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			this.dropDown.createOptions(
				results,
				options,
				lang.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if("direction" in options){
				if(options.direction){
					this.dropDown.highlightFirstOption();
				}else if(!options.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(query[this.searchAttr].toString())){
				this._announceOption(this.dropDown.containerNode.firstChild.nextSibling); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).
			this.closeDropDown(true);
			this.openDropDown();
			this.domNode.setAttribute("aria-expanded", "true");
		},

		loadDropDown: function(/*Function*/ /*===== callback =====*/){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				this.domNode.setAttribute("aria-expanded", "false");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					this._handleOnChange(this.value, true);
				}
				this._refreshState();
			}
			// Remove aria-activedescendant since it may not be removed if they select with arrows then blur with mouse
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			var value = '';
			if(item){
				if(!displayedValue){
					displayedValue = this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
						this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
				}
				value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
			}
			this.set('value', value, priorityChange, displayedValue, item);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				var item = this.dropDown.items[node.getAttribute("item")];
				newValue = (this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
					this.store.getValue(item, this.searchAttr) : item[this.searchAttr]).toString();
				this.set('item', item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._handleOnChange(this.value, true);
			// Remove aria-activedescendant since the drop down is no loner visible
			// after closeDropDown() but _announceOption() adds it back in
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this.item = undefined; // undefined means item needs to be set
			this.inherited(arguments);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
					dropDownConstructor = lang.isString(this.dropDownClass) ?
						lang.getObject(this.dropDownClass, false) : this.dropDownClass;
				this.dropDown = new dropDownConstructor({
					onChange: lang.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir,
					textDir: this.textDir
				});
			}
			this._lastInput = key; // Store exactly what was entered by the user.
			this.inherited(arguments);
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit/form/_ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.store && this.srcNodeRef){
				var srcNodeRef = this.srcNodeRef;
				// if user didn't specify store, then assume there are option tags
				this.store = new DataList({}, srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native Select
				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						// remove getValue() for 2.0 (old dojo.data API)
						this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
					}
				}
			}
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label = query('label[for="' + this.id + '"]');
			if(label.length){
				if(!label[0].id){
					label[0].id = this.id + "_label";
				}
				this.domNode.setAttribute("aria-labelledby", label[0].id);

			}
			this.inherited(arguments);
			aspect.after(this, "onSearch", lang.hitch(this, "_openResultList"), true);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._lastInput);
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
			// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = regexp.escapeString(find); // escape regexp special chars
			//If < appears in label, and user presses t, we don't want to highlight the t in the escaped "&lt;"
			//first find out every occurrences of "find", wrap each occurrence in a pair of "\uFFFF" characters (which
			//should not appear in any string). then html escape the whole string, and replace '\uFFFF" with the
			//HTML highlight markup.
			return this._escapeHtml(label.replace(
				new RegExp((i == 0 ? "^" : "") + "(" + find + ")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'\uFFFF$1\uFFFF')).replace(
				/\uFFFF([^\uFFFF]+)\uFFFF/g, '<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: `&<>"'`
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;"); //balance"
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(item, store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// item: Object
			//		The item from the store
			// store: dojo/store/api/Store
			//		The store.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354).
			// Remove getValue() for 2.0 (old dojo.data API)
			return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) :
				item[this.labelAttr || this.searchAttr]).toString(); // String
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", item || null); // value not looked up in store
			if(value == null /* or undefined */){
				value = '';
			} // null translates to blank
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		AutoCompleterMixin.extend({
			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir, needed for the dropDown's textDir update.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private
				this.inherited(arguments);
				// update the drop down also (_ComboBoxMenuMixin)
				if(this.dropDown){
					this.dropDown._set("textDir", textDir);
				}
			}
		});
	}

	return AutoCompleterMixin;
});

},
'dojo/NodeList-traverse':function(){
define(["./query", "./_base/lang", "./_base/array"], function(dquery, lang, array){

// module:
//		dojo/NodeList-traverse

/*=====
return function(){
	// summary:
	//		Adds chainable methods to dojo/query() / NodeList instances for traversing the DOM
};
=====*/

var NodeList = dquery.NodeList;

lang.extend(NodeList, {
	_buildArrayFromCallback: function(/*Function*/ callback){
		// summary:
		//		builds a new array of possibly differing size based on the input list.
		//		Since the returned array is likely of different size than the input array,
		//		the array's map function cannot be used.
		var ary = [];
		for(var i = 0; i < this.length; i++){
			var items = callback.call(this[i], this[i], ary);
			if(items){
				ary = ary.concat(items);
			}
		}
		return ary;	//Array
	},

	_getUniqueAsNodeList: function(/*Array*/ nodes){
		// summary:
		//		given a list of nodes, make sure only unique
		//		elements are returned as our NodeList object.
		//		Does not call _stash().
		var ary = [];
		//Using for loop for better speed.
		for(var i = 0, node; node = nodes[i]; i++){
			//Should be a faster way to do this. dojo/query has a private
			//_zip function that may be inspirational, but there are pathways
			//in query that force nozip?
			if(node.nodeType == 1 && array.indexOf(ary, node) == -1){
				ary.push(node);
			}
		}
		return this._wrap(ary, null, this._NodeListCtor);	 // dojo/NodeList
	},

	_getUniqueNodeListWithParent: function(/*Array*/ nodes, /*String*/ query){
		// summary:
		//		gets unique element nodes, filters them further
		//		with an optional query and then calls _stash to track parent NodeList.
		var ary = this._getUniqueAsNodeList(nodes);
		ary = (query ? dquery._filterResult(ary, query) : ary);
		return ary._stash(this);  // dojo/NodeList
	},

	_getRelatedUniqueNodes: function(/*String?*/ query, /*Function*/ callback){
		// summary:
		//		cycles over all the nodes and calls a callback
		//		to collect nodes for a possible inclusion in a result.
		//		The callback will get two args: callback(node, ary),
		//		where ary is the array being used to collect the nodes.
		return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  // dojo/NodeList
	},

	children: function(/*String?*/ query){
		// summary:
		//		Returns all immediate child elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the child elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all immediate child elements for the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".container").children();
		//	|	});
		//		returns the four divs that are children of the container div.
		//		Running this code:
		//	|	dojo.query(".container").children(".red");
		//		returns the two divs that have the class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return lang._toArray(node.childNodes);
		}); // dojo/NodeList
	},

	closest: function(/*String*/ query, /*String|DOMNode?*/ root){
		// summary:
		//		Returns closest parent that matches query, including current node in this
		//		dojo/NodeList if it matches the query.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// root:
		//		If specified, query is relative to "root" rather than document body.
		// returns:
		//		the closest parent that matches the query, including the current
		//		node in this dojo/NodeList if it matches the query.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		//	|		<div class="red">Red One</div>
		//	|		Some Text
		//	|		<div class="blue">Blue One</div>
		//	|		<div class="red">Red Two</div>
		//	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".red").closest(".container");
		//	|	});
		//		returns the div with class "container".
		return this._getRelatedUniqueNodes(null, function(node, ary){
			do{
				if(dquery._filterResult([node], query, root).length){
					return node;
				}
			}while(node != root && (node = node.parentNode) && node.nodeType == 1);
			return null; //To make rhino strict checking happy.
		}); // dojo/NodeList
	},

	parent: function(/*String?*/ query){
		// summary:
		//		Returns immediate parent elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the parent elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		immediate parent elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".text").parent();
		//	|	});
		//		returns the two divs with class "blue".
		//		Running this code:
		//	|		query(".text").parent(".first");
		//		returns the one div with class "blue" and "first".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return node.parentNode;
		}); // dojo/NodeList
	},

	parents: function(/*String?*/ query){
		// summary:
		//		Returns all parent elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the child elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all parent elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".text").parents();
		//	|	});
		//		returns the two divs with class "blue", the div with class "container",
		// 	|	the body element and the html element.
		//		Running this code:
		//	|		query(".text").parents(".container");
		//		returns the one div with class "container".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			while(node.parentNode){
				node = node.parentNode;
				pary.push(node);
			}
			return pary;
		}); // dojo/NodeList
	},

	siblings: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").siblings();
		//	|	});
		//		returns the two divs with class "red" and the other div
		// 	|	with class "blue" that does not have "first".
		//		Running this code:
		//	|		query(".first").siblings(".red");
		//		returns the two div with class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var nodes = (node.parentNode && node.parentNode.childNodes);
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i] != node){
					pary.push(nodes[i]);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	next: function(/*String?*/ query){
		// summary:
		//		Returns the next element for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the next elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		the next element for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").next();
		//	|	});
		//		returns the div with class "red" and has innerHTML of "Red Two".
		//		Running this code:
		//	|	dojo.query(".last").next(".red");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var next = node.nextSibling;
			while(next && next.nodeType != 1){
				next = next.nextSibling;
			}
			return next;
		}); // dojo/NodeList
	},

	nextAll: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements that come after the nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements that come after the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red next">Red Two</div>
		// 	|		<div class="blue next">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").nextAll();
		//	|	});
		//		returns the two divs with class of "next".
		//		Running this code:
		//	|		query(".first").nextAll(".red");
		//		returns the one div with class "red" and innerHTML "Red Two".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var next = node;
			while((next = next.nextSibling)){
				if(next.nodeType == 1){
					pary.push(next);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	prev: function(/*String?*/ query){
		// summary:
		//		Returns the previous element for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the previous elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		the previous element for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").prev();
		//	|	});
		//		returns the div with class "red" and has innerHTML of "Red One".
		//		Running this code:
		//	|		query(".first").prev(".blue");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var prev = node.previousSibling;
			while(prev && prev.nodeType != 1){
				prev = prev.previousSibling;
			}
			return prev;
		}); // dojo/NodeList
	},

	prevAll: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements that come before the nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		The returned nodes will be in reverse DOM order -- the first node in the list will
		//		be the node closest to the original node/NodeList.
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements that come before the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".second").prevAll();
		//	|	});
		//		returns the two divs with class of "prev".
		//		Running this code:
		//	|		query(".first").prevAll(".red");
		//		returns the one div with class "red prev" and innerHTML "Red One".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var prev = node;
			while((prev = prev.previousSibling)){
				if(prev.nodeType == 1){
					pary.push(prev);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	andSelf: function(){
		// summary:
		//		Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".second").prevAll().andSelf();
		//	|	});
		//		returns the two divs with class of "prev", as well as the div with class "second".
		return this.concat(this._parent);	// dojo/NodeList
	},

	//Alternate methods for the :first/:last/:even/:odd pseudos.
	first: function(){
		// summary:
		//		Returns the first node in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the first node in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".blue").first();
		//	|	});
		//		returns the div with class "blue" and "first".
		return this._wrap(((this[0] && [this[0]]) || []), this); // dojo/NodeList
	},

	last: function(){
		// summary:
		//		Returns the last node in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the last node in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|	query(".blue").last();
		//	|	});
		//		returns the last div with class "blue",
		return this._wrap((this.length ? [this[this.length - 1]] : []), this); // dojo/NodeList
	},

	even: function(){
		// summary:
		//		Returns the even nodes in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the even nodes in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".interior").even();
		//	|	});
		//		returns the two divs with class "blue"
		return this.filter(function(item, i){
			return i % 2 != 0;
		}); // dojo/NodeList
	},

	odd: function(){
		// summary:
		//		Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the odd nodes in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".interior").odd();
		//	|	});
		//		returns the two divs with class "red"
		return this.filter(function(item, i){
			return i % 2 == 0;
		}); // dojo/NodeList
	}
});

return NodeList;
});

},
'idx/form/_CompositeMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define([
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/aspect",
	"dojo/dom-attr",
	"dojo/dom",
	"dojo/dom-construct",
	"dojo/dom-geometry",
	"dojo/i18n", 
	"dojo/query", 
	"dojo/dom-class", 
	"dojo/dom-style",
	"dojo/on",
	"dijit/_base/wai", 
	"idx/widget/HoverHelpTooltip",
	"../util",
	"../string"
	//"./_FocusManager" // Not able to extend in dojo1.10
], function(declare, lang, aspect, domAttr, dom, domConstruct, domGeometry, i18n, query, domClass, domStyle, on, wai, HoverHelpTooltip, iUtil, iString, _focusManager) {
	/**
	 * @public
	 * @name idx.form._CompositeMixin
	 * @class Mix-in class to provide customized label, hint, unit, and field layout, implemented according to 
	 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y29&vsub=*&hsub=*&openpanes=0000010000">Text Areas & Fields</a></b>.
	 * It takes the assumption that a composite widget will follow the dom structure below
	 * <br>
	 &lt;div class="idxComposite"&gt;
		&lt;div class="idxLabel"&gt;
			&lt;span&gt;*&lt;/span&gt;
				&lt;label dojotAttachPoint="compLabelNode"&gt;Label Text&lt;/label&gt;
		&lt;/div&gt;
		&lt;div&gt;other dom structure...&lt;/div&gt;&lt;div dojoAttachPoint="compUnitNode"&gt;unit text&lt;/div&gt;
		&lt;div dojoAttachPoint="compHintNode" class="idxHint dijitHidden"&gt;hint text&lt;/div&gt;
	 &lt;/div>
	 * <br>
	 * @aguments idx.form._FocusManager
	 */

	
	return declare("idx.form._CompositeMixin", null, 
	/**@lends idx.form._CompositeMixin#*/
	{
		/**
		 * Layout of the label and the field, "horizontal" or "vertical", implemented according to 
		 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y16&vsub=*&hsub=*&openpanes=0000011100">Field & Label Alignment</a></b>
		 * @type String
		 * @default "horizontal"
		 */
		labelAlignment: "horizontal",
		
		/**
		 * Label text
		 * @type String
		 */
		label: "",
		
		/**
		 * Width from the left of label to the left of corresponding field, this parameter works in the composite widget layout of "horizontal".
		 * @type String | Number
		 */
		labelWidth: "",
		
		/**
		 * Width of the field with a hidden validation icon
		 * @type String | Number
		 */
		fieldWidth: "",
		
		/**
		 * For input widgets only. The position of the hint text: "inside" / "outside", inner the field input or not.
		 * @type String
		 * @default "inside"
		 */
		hintPosition: "inside",
		
		/**
		 * For input widgets only. The hint text.
		 * @type String
		 */
		hint: "",
		
		/**
		 * Indicates that it's a required field or not. A required field will have a red asterisk.
		 * implemented according to 
	 	 * IBM One UI(tm) <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y17&vsub=*&hsub=*&openpanes=0000011100">Required Fields</a></b>.
		 * @type boolean
		 * @default false
		 */
		required: false,
		
		/**
		 * The text of unit for the numerical value input widget.
		 * @type String
		 */
		unit: "",
		
		/**
		 * Focus manager for all composite widget
		 * @type idx.form.FocusManager
		 * @private
		 */
		/** _focusManager: _focusManager **/
		
		
		/**
		 * Help message popup from help icon follows label.
		 * @type String
		 */
		help:"",
		
		_errorIconWidth: 27,
		
		postMixInProperties: function(){
			this.tooltipPosition = ["after-centered", "above"];
			this.inherited(arguments);
		},
		
		/**
		 * Handles resizing form widgets.
		 */
		resize: function() {
			
			if(this._holdResize()){
				return;
			}
			domStyle.set(this.domNode, {visibility: "hidden"});
			// if percentage style width then clear the label and field widths so the parent container
			// has the opportunity to resize
			if (iUtil.isPercentage(this._styleWidth)) {
				domStyle.set(this.labelWrap, {width: ""});
				domStyle.set(this.oneuiBaseNode, {width: ""});
			}
			
			// schedule a resize
			if (this._resizeTimeout) {
				clearTimeout(this._resizeTimeout);
				delete this._resizeTimeout;
			}
			this._resizeTimeout = setTimeout(lang.hitch(this, this._resize), 250);
		},
		/**
		 * Check if resize action should be hold, by widget visibility and applied width
		 */
		_holdResize: function(widgetInvisible){
			if(!this.domNode){return true;}
			if(!(this.labelWidth || this.fieldWidth || this._styleWidth)){
				domStyle.set(this.labelWrap, {width: ""});
				domStyle.set(this.oneuiBaseNode, {width: ""});				
				return true;
			}
			var swFixed = (this._styleWidth && !iUtil.isPercentage(this._styleWidth)),
				fwFixed = (this.fieldWidth && !iUtil.isPercentage(this.fieldWidth)),
				lwFixed = (this.labelWidth && !iUtil.isPercentage(this.labelWidth)),
				widthFixed = swFixed || (fwFixed&&lwFixed),				
				widgetInvisible = domGeometry.getContentBox(this.domNode).w <= 0;
				
			return (widthFixed && this._resized) || // If widget width is fixed, and widget has been resized of fit, then skip.
				(!widthFixed) && widgetInvisible; // If widget is invisible with percentage width, then skip.
		},
		/**
		 * Handles deferring the resize until the widget is started.  This function returns true
		 * if the resize should be deferred.
		 */
		_deferResize: function() {
			// check if the widget has no fixed width -- there is no point in resizing until the widget's 
			// DOM node is properly placed in the DOM since percentage width cannot be computed  before that
			if (!this._started) {
				// if we have not yet created a resize callback on "startup", then use aspect to do that
				if (!this._resizeHandle) {
					this._resizeHandle = aspect.after(this, "startup", lang.hitch(this, this._resize));
				}
				return true; // defer until startup
			}
			else {
				// if we are started and previously created a resizeHandle, then remove it
				if (this._resizeHandle) {
					this._resizeHandle.remove();
					delete this._resizeHandle;
				}
				
				return false;
			}	
		},
		
		_resize: function(){
			if (this._resizeTimeout) { 
				clearTimeout(this._resizeTimeout); 
				delete this._resizeTimeout; 
			}
			var deferring = this._deferResize();
			if (deferring) {
				return;
			}
			if(this._holdResize()){
				return;
			}
			
			var labelWidth = this.labelWidth,
				fieldWidth = this.fieldWidth,
				styleWidth = this._styleWidth;

			var	realWidth = domGeometry.getContentBox(this.domNode).w,
				realWidth = ((realWidth <= 0) && styleWidth)? iUtil.normalizedLength(styleWidth,this.domNode) : realWidth;

			if (!styleWidth) {
				if (iUtil.isPercentage(labelWidth)) domStyle.set(this.labelWrap, "width", "");
				if (iUtil.isPercentage(fieldWidth)) domStyle.set(this.oneuiBaseNode, "width", "");				
			}
			
			if(this.label && this.labelAlignment == "horizontal"){
				if(labelWidth){
					if(iUtil.isPercentage(labelWidth)){
						labelWidth = Math.floor(realWidth * parseInt(labelWidth)/100) - 10;
					}
					domStyle.set(this.labelWrap, "width", iUtil.normalizedLength(labelWidth,this.domNode) + "px");
				} else {
					domStyle.set(this.labelWrap, "width", "");
				}
				if(fieldWidth){
					var isFieldWidthPercentage = iUtil.isPercentage(fieldWidth);
					if(isFieldWidthPercentage){
						fieldWidth = Math.floor(realWidth * parseInt(fieldWidth)/100);
					}
					domStyle.set(this.oneuiBaseNode, "width", 
						iUtil.normalizedLength(fieldWidth,this.domNode) - (isFieldWidthPercentage ? (this._errorIconWidth + 2) : 0) + "px");
				} else {
					domStyle.set(this.oneuiBaseNode, "width", "");
				}
				if (styleWidth && !fieldWidth) {
					var compLabelWidth = domGeometry.getMarginBox(this.labelWrap).w;
					var compFieldWidth = realWidth - this._errorIconWidth - compLabelWidth - 2;
					if (compFieldWidth > 0) {
						domStyle.set(this.oneuiBaseNode, "width", compFieldWidth + "px");
					}
				}
			}else{
				if(styleWidth){
					domStyle.set(this.oneuiBaseNode, "width", realWidth - this._errorIconWidth - 2 + "px");
				}else if(fieldWidth && !iUtil.isPercentage(fieldWidth)){
					domStyle.set(this.oneuiBaseNode, "width", iUtil.normalizedLength(fieldWidth,this.domNode) + "px");
				} else {
					domStyle.set(this.oneuiBaseNode, "width", "");
				}
			}
			this._resizeHint();
			domStyle.set(this.domNode, {visibility: ""});
			this._resized = true;
		},
		_resizeHint: function(){
			if(this.hint && (this.hintPosition == "outside") && this._created){
				var inputWidth = domStyle.get(this.fieldWrap || this.oneuiBaseNode, "width")/*valication icon placeholder*/;
				domStyle.set(this.compHintNode, "width", inputWidth? inputWidth + "px" : "");
			}
		},
		_setStyleAttr: function(style){
			// If there's no label share the widget width with field,
			// field would occupy whole widget width if "width" is specified in given style.
			this.inherited(arguments);
			this._styleWidth = iUtil.getValidCSSWidth(style);
			this._created && this._resize();
		},
				/**
		 * Set the width of label, the width is from the start of label to the start of the field.
		 * @public
		 * @param {string | number} width 
		 * Unit of "pt","em","px" will be normalized to "px", and "px" by default for numeral value.
		 */
		_setLabelWidthAttr: function(/*String | Integer*/width){
			domStyle.set(this.labelWrap, "width", typeof width === "number" ? width + "px" : width);
			this._set("labelWidth", width);
			this._created && this._resize();
		},
		
		/**
		 * Set the width of field with a hidden validation icon.
		 * @public
		 * @param {string | number} width 
		 * Unit of "pt","em","px" will be normalized to "px", and "px" by default for numeral value.
		 */
		_setFieldWidthAttr: function(/*String | Integer*/width){
			if(!iUtil.isPercentage(width)){
				domStyle.set(this.oneuiBaseNode, "width", typeof width === "number" ? width + "px" : width);
			}
			this._set("fieldWidth", width);
			this._created && this._resize();
		},
		
		/**
		 * Set the alignment for the label and field,  update the style of the label node to make 
		 * it be at the right place.
		 * @public
		 * @param {string} alignment
		 * The alignment of the label and field. Can be "vertical" or "horizontal".
		 * If "vertical" is used, the label is put above the TextBox.
		 * If "horizontal" is used, the label is put on the left of the TextBox (on
		 * the right of the TextBox if RTL language is used).
		 */
		_setLabelAlignmentAttr: function(/*String*/ alignment){
			var h = alignment == "horizontal";
			domClass.toggle(this.labelWrap, "dijitInline", h);
			query(".idxCompContainer", this.domNode).toggleClass("dijitInline", h);
			this._set("labelAlignment", alignment);
			this._resize();
		},
		
		_setupHelpListener: function() {
			if (this._helpListener) return;
			var blurHandler = function(e) {
				if (this.widget.helpTooltip) {
					this.widget.helpTooltip.close(true);
				}
				if (this.handle) {
					this.handle.remove();
					delete this.handle;
					this.widget._blurHandler = null;
				}
			};
			var keyHandler = function(e) {
				var charOrCode = e.keyCode;
				if(e.type == "keydown"){
					if(e.ctrlKey && e.shiftKey && (charOrCode == 191) && this.helpTooltip && this._help) {
						this.helpTooltip.open(this.helpNode);
				
						if (e.target && !this._blurHandler) {
							var scope = {
									handle: null,
									widget: this
							};
							this._blurHandler = scope.handle = on(e.target, "blur", lang.hitch(scope, blurHandler));
						}
					}
				}
			};
			var node = (this.oneuiBaseNode) ? this.oneuiBaseNode : this.focusNode;
			if (node) {
				this._keyListener = this.own(on(node, "keydown", lang.hitch(this, keyHandler)));
			}
		},
		
		_setHelpAttr: function(/*String*/ helpText){
			this.help = helpText; // set the help to what the caller provided
			this._help = helpText = iString.nullTrim(helpText); // set the internal value to the trimmed version
			if (helpText) {
				if (!this.helpNode) {
					this.helpNode = domConstruct.toDom("<div class='dijitInline idxTextBoxHoverHelp'><span class='idxHelpIconAltText'>?</span></div>");
					domConstruct.place(this.helpNode, this.compLabelNode, "after");
					this.helpTooltip = new HoverHelpTooltip({
						connectId: [this.helpNode],
						label: helpText,
						position: ['above', 'below'],
						forceFocus: false,
						textDir: this.textDir
					});
					this._setupHelpListener();
					
				}
				else {
					this._setupHelpListener();
					this.helpTooltip.set("label", helpText);
					domClass.remove(this.helpNode, "dijitHidden");
				}
			}
			else {
				if (this.helpNode) {
					this.helpTooltip.set("label", "");
					domClass.add(this.helpNode, "dijitHidden");
				}
			}
		},
		
		/**
		 * Set the label text. Update the content of the label node.
		 * @public
		 * @param {string} label
		 * The text will be displayed as the content of the label. If text is null or
		 * empty string, nothing would be displayed.
		 */
		_setLabelAttr: function(/*String*/ label){
			this.compLabelNode.innerHTML = label;
			var islabelEmpty = /^\s*$/.test(label);
			domAttr[islabelEmpty?"remove":"set"](this.compLabelNode, "for", this.id);
			domClass.toggle(this.labelWrap, "dijitHidden", islabelEmpty);
			this._set("label", label);
		},
		
		/**
		 * Set this field as a required field or not. If this field is required,
		 * a red asterisk will be shown at the start of label.
		 * @public
		 * @param {boolean} required
		 */
		_setRequiredAttr: function(/*Boolean*/ required){
			wai.setWaiState(this.focusNode, "required", required + "");
			this._set("required", required);
			this._refreshState();
		},
		
		_refreshState: function(){
			if(!this._created){return;}
			if(this.disabled){
				this._set("state", "");
			}else if(this.required && this._isEmpty(this.value) && (this.state == "")){
				this._set("state", "Incomplete");
			}
		},
		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this.focused);
			// Workaround for idt ValidationTextBox defect of #12517
			if(this.focusNode && (!this._hasBeenBlurred)){
				domAttr.remove(this.focusNode, "aria-invalid");
			}
		},
		
		/**
		 * Set position of the hint text. If position is "outside", update the content
		 * of the hint node. If position is "inside" and the value of the TextBox is
		 * null, set the value of the TextBox to the hintText
		 * @protected
		 * @param {string} position
		 * The position of the label. Can be "outside" or "inside".
		 * If "outside" is used, the hint text is put below the TextBox.
		 * If "inside" is used and the TextBox has a value, display the value in the TextBox. Once
		 * the value of the TextBox is null, display the hint text inside the TextBox in a specified
		 * color (e.g: gray).
		 */
		_setHintPositionAttr: function(/*String*/ position){
			if(!this.compHintNode){ return; }
			this._set("hintPosition", position);
			domClass.toggle(this.compHintNode, "dijitVisible", position != "inside");
			this.set("hint", this.hint);
			this._resizeHint();
		},
		
		/**
		 * Set the hint text
		 * @public
		 * @param {string} hint
		 * The text will be displayed inside or below the TextBox per the "position" attribute.
		 */
		_setHintAttr: function(/*String*/ hint){
			this.set("placeHolder", this.hintPosition == "inside" ? hint : "");
			if(!this.compHintNode){ return; }
			this.compHintNode.innerHTML = this.hintPosition == "inside" ? "" : hint;
			
			if(this.hintPosition == "outside"){
				domAttr.set(this.compHintNode, "id", this.id + "_hint_outside");
			}
			if(this._placeholder === undefined || this._placeholder === false){
				wai.setWaiState(this.focusNode, "describedby", this.id + "_hint_" + this.hintPosition);
			}
			this._set("hint", hint);
			this._resizeHint();
		},
		
		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(v === null || v === undefined){
				v = "";
			}
			if(this.focusNode.placeholder !== undefined && this._placeholder !== false){
				domAttr.set(this.focusNode, "placeholder", v);
				this._placeholder = v;
			}else{
				if(!this._phspan){
					this._attachPoints.push('_phspan');
					this._phspan = domConstruct.create('span',{
						className:'dijitPlaceHolder dijitInputField',
						id: this.id + "_hint_inside"
					},this.focusNode,'after');
				}
				this._phspan.innerHTML = "";
				this._phspan.appendChild(document.createTextNode(v));
				this._phspan.style.display=(this.placeHolder&&!this.focused&&!this.textbox.value)?"":"none";
			}
		},
		
		/**
		 * Set the text of unit
		 * @public
		 * @param {string} unit
		 * The unit will be displayed on the right of the input box(on the left of the input
		 * box if RTL language is used).
		 */
		_setUnitAttr: function(/*String*/ unit){
			if(!this.compUnitNode){ return; }
			this.compUnitNode.innerHTML = unit;
			domClass.toggle(this.compUnitNode, "dijitHidden", /^\s*$/.test(unit));
			this._set("unit", unit);
		},
		/**_isValidFocusNode: function(mousedownNode){
			return dom.isDescendant(mousedownNode, this.oneuiBaseNode) ||
				!dom.isDescendant(mousedownNode, this.domNode);
		},**/
		
		/**
		 * Reset the value and state of the composite widget.
		 * @public
		 */
		reset: function(){
			this.set("state", this.required ? "Incomplete" : "");
			this.message = "";
			this.inherited(arguments);
		},
		/**
		 * Validate value, directly get focus and show error if turn out to be invalid.
		 * @public
		 */
		validateAndFocus: function(){
			if(this.validate && !this.disabled){
				var hasBeenBlurred = this._hasBeenBlurred;
				this._hasBeenBlurred = true;
				var valid = this.validate();
				if(!valid){
					this.focus();
				}
				this._hasBeenBlurred = hasBeenBlurred
				return valid;
			}
			return true;
		}
	});
});

},
'dijit/form/MappedTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("msapp")
	"dojo/dom-construct", // domConstruct.place
	"./ValidationTextBox"
], function(declare, has, domConstruct, ValidationTextBox){

	// module:
	//		dijit/form/MappedTextBox

	return declare("dijit.form.MappedTextBox", ValidationTextBox, {
		// summary:
		//		A dijit/form/ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit/form/MappedTextBox.serialize() method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// We want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting for IE.
			this.nameAttrSetting = "";
		},

		// Remap name attribute to be mapped to hidden node created in buildRendering(), rather than this.focusNode
		_setNameAttr: "valueNode",

		serialize: function(val /*=====, options =====*/){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// val: anything
			// options: Object?
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit/form/TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit/_TemplatedMixin/buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than relying on _setNameAttr custom setter above
			// to make query(input[name=...]) work on IE. (see #8660).
			// But not doing that for Windows 8 Store apps because it causes a security exception (see #16452).
			this.valueNode = domConstruct.place("<input type='hidden'" +
				((this.name && !has("msapp")) ? ' name="' + this.name.replace(/"/g, "&quot;") + '"' : "") + "/>",
				this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit/form/ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/ComboBoxMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/Deferred",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin
	"dojo/store/util/QueryResults",
	"./_AutoCompleterMixin",
	"./_ComboBoxMenu",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template){


	// module:
	//		dijit/form/ComboBoxMixin

	return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {
		// summary:
		//		Provides main functionality of ComboBox widget

		// dropDownClass: [protected extension] Function String
		//		Dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: _ComboBoxMenu,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: template,

		baseClass: "dijitTextBox dijitComboBox",

		/*=====
		// store: [const] dojo/store/api/Store|dojo/data/api/Read
		//		Reference to data provider object used by this ComboBox.
		//
		//		Should be dojo/store/api/Store, but dojo/data/api/Read supported
		//		for backwards compatibility.
		store: null,
		=====*/

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		_setHasDownArrowAttr: function(/*Boolean*/ val){
			this._set("hasDownArrow", val);
			this._buttonNode.style.display = val ? "" : "none";
		},

		_showResultList: function(){
			// hide the tooltip
			this.displayMessage("");
			this.inherited(arguments);
		},

		_setStoreAttr: function(store){
			// For backwards-compatibility, accept dojo.data store in addition to dojo/store/api/Store.  Remove in 2.0.
			if(!store.get){
				lang.mixin(store, {
					_oldAPI: true,
					get: function(id){
						// summary:
						//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
						//		Like dojo/store/DataStore.get() except returns native item.
						var deferred = new Deferred();
						this.fetchItemByIdentity({
							identity: id,
							onItem: function(object){
								deferred.resolve(object);
							},
							onError: function(error){
								deferred.reject(error);
							}
						});
						return deferred.promise;
					},
					query: function(query, options){
						// summary:
						//		Queries the store for objects.   Like dojo/store/DataStore.query()
						//		except returned Deferred contains array of native items.
						var deferred = new Deferred(function(){ fetchHandle.abort && fetchHandle.abort(); });
						deferred.total = new Deferred();
						var fetchHandle = this.fetch(lang.mixin({
							query: query,
							onBegin: function(count){
								deferred.total.resolve(count);
							},
							onComplete: function(results){
								deferred.resolve(results);
							},
							onError: function(error){
								deferred.reject(error);
							}
						}, options));
						return QueryResults(deferred);
					}
				});
			}
			this._set("store", store);
		},

		postMixInProperties: function(){
			// Since _setValueAttr() depends on this.store, _setStoreAttr() needs to execute first.
			// Unfortunately, without special code, it ends up executing second.
			var store = this.params.store || this.store;
			if(store){
				this._setStoreAttr(store);
			}

			this.inherited(arguments);

			// User may try to access this.store.getValue() etc.  in a custom labelFunc() function.
			// It's not available with the new data store for handling inline <option> tags, so add it.
			if(!this.params.store && this.store && !this.store._oldAPI){
				var clazz = this.declaredClass;
				lang.mixin(this.store, {
					getValue: function(item, attr){
						kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
						return item[attr];
					},
					getLabel: function(item){
						kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
						return item.name;
					},
					fetch: function(args){
						kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
						var shim = ["dojo/data/ObjectStore"];	// indirection so it doesn't get rolled into a build
						require(shim, lang.hitch(this, function(ObjectStore){
							new ObjectStore({objectStore: this}).fetch(args);
						}));
					}
				});
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this.focusNode.setAttribute("aria-autocomplete", this.autoComplete ? "both" : "list");
		}
	});
});

},
'dijit/form/_TextBoxMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/sniff",	// has("ie"), has("dojo-bidi")
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	"dojo/on", // on
	"../main"    // for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, has, keys, lang, on, dijit){

	// module:
	//		dijit/form/_TextBoxMixin

	var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin for textbox form input widgets

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
			//
			//		For `dijit/form/MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{
						formattedValue = '';
					}
					// Ensure the filtered value does not change after being formatted. See track #17955.
					//
					// This check is only applied when the formatted value is not specified by the caller in order to allow the 
					// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
					// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
					// callback to this method.
					//
					// TODO: Should developers be warned that they broke the round trip on format?
					if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
						formattedValue = null;
					}
				}
			}
			if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			//		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value == null /* or undefined */){
				value = ''
			}
			else if(typeof value != "string"){
				value = String(value)
			}

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a value to a properly formatted string.
			// value: String
			// constraints: Object
			// tags:
			//		protected extension
			return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
		},

		parse: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a formatted string to a value
			// value: String
			// constraints: Object
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit/form/TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		 onInput: function(/*Event*/ /*===== evt =====*/){
			 // summary:
			 //		Connect to this function to receive notifications of various user data-input events.
			 //		Return false to cancel the event and prevent it from being processed.
			 //		Note that although for historical reasons this method is called `onInput()`, it doesn't
			 //		correspond to the standard DOM "input" event, because it occurs before the input has been processed.
			 // event:
			 //		keydown | keypress | cut | paste | compositionend
			 // tags:
			 //		callback
		 },

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened and this.textbox.value has new value.

			this._lastInputEventValue = this.textbox.value;

			// For Combobox, this needs to be called w/the keydown/keypress event that was passed to onInput().
			// As a backup, use the "input" event itself.
			this._processInput(this._lastInputProducingEvent || evt);
			delete this._lastInputProducingEvent;

			if(this.intermediateChanges){
				this._handleOnChange(this.get('value'), false);
			}
		},

		_processInput: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		Default action handler for user input events.
			//		Called after the "input" event (i.e. after this.textbox.value has been updated),
			//		but `evt` is the keydown/keypress/etc. event that triggered the "input" event.
			// tags:
			//		protected

			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			// normalize input events to reduce spurious event processing
			//	keydown: do not forward modifier keys
			//		       set charOrCode to numeric keycode
			//	keypress: do not forward numeric charOrCode keys (already sent through onkeydown)
			//	paste, cut, compositionend: set charOrCode to 229 (IME)
			function handleEvent(e){
				var charOrCode;

				// Filter out keydown events that will be followed by keypress events.  Note that chrome/android
				// w/word suggestion has keydown/229 events on typing with no corresponding keypress events.
				if(e.type == "keydown" && e.keyCode != 229){
					charOrCode = e.keyCode;
					switch(charOrCode){ // ignore state keys
						case keys.SHIFT:
						case keys.ALT:
						case keys.CTRL:
						case keys.META:
						case keys.CAPS_LOCK:
						case keys.NUM_LOCK:
						case keys.SCROLL_LOCK:
							return;
					}
					if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
						switch(charOrCode){ // ignore location keys
							case keys.NUMPAD_0:
							case keys.NUMPAD_1:
							case keys.NUMPAD_2:
							case keys.NUMPAD_3:
							case keys.NUMPAD_4:
							case keys.NUMPAD_5:
							case keys.NUMPAD_6:
							case keys.NUMPAD_7:
							case keys.NUMPAD_8:
							case keys.NUMPAD_9:
							case keys.NUMPAD_MULTIPLY:
							case keys.NUMPAD_PLUS:
							case keys.NUMPAD_ENTER:
							case keys.NUMPAD_MINUS:
							case keys.NUMPAD_PERIOD:
							case keys.NUMPAD_DIVIDE:
								return;
						}
						if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
							return; // keypress will handle simple non-modified printable keys
						}
						var named = false;
						for(var i in keys){
							if(keys[i] === e.keyCode){
								named = true;
								break;
							}
						}
						if(!named){
							return;
						} // only allow named ones through
					}
				}

				charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
				if(!charOrCode){
					charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
				}
				if(!charOrCode){
					charOrCode = 229; // IME
				}
				if(e.type == "keypress"){
					if(typeof charOrCode != "string"){
						return;
					}
					if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
						if(e.ctrlKey || e.metaKey || e.altKey){
							return;
						} // can only be stopped reliably in keydown
					}
				}

				// create fake event to set charOrCode and to know if preventDefault() was called
				var faux = { faux: true }, attr;
				for(attr in e){
					if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
						var v = e[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							faux[attr] = v;
						}
					}
				}
				lang.mixin(faux, {
					charOrCode: charOrCode,
					_wasConsumed: false,
					preventDefault: function(){
						faux._wasConsumed = true;
						e.preventDefault();
					},
					stopPropagation: function(){
						e.stopPropagation();
					}
				});

				this._lastInputProducingEvent = faux;

				// Give web page author a chance to consume the event.  Note that onInput() may be called multiple times
				// for same keystroke: once for keypress event and once for input event.
				//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
				if(this.onInput(faux) === false){ // return false means stop
					faux.preventDefault();
					faux.stopPropagation();
				}
				if(faux._wasConsumed){
					return;
				} // if preventDefault was called

				// IE8 doesn't emit the "input" event at all, and IE9 doesn't emit it for backspace, delete, cut, etc.
				// Since the code below (and perhaps user code) depends on that event, emit it synthetically.
				// See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html.
				if(has("ie") <= 9){
					switch(e.keyCode){
					case keys.TAB:
					case keys.ESCAPE:
					case keys.DOWN_ARROW:
					case keys.UP_ARROW:
					case keys.LEFT_ARROW:
					case keys.RIGHT_ARROW:
						// These keys may alter the <input>'s value indirectly, but we don't want to emit an "input"
						// event.  For example, the up/down arrows in TimeTextBox or ComboBox will cause the next
						// dropdown item's value to be copied to the <input>.
						break;
					default:
						if(e.keyCode == keys.ENTER && this.textbox.tagName.toLowerCase() != "textarea"){
							break;
						}
						this.defer(function(){
							if(this.textbox.value !== this._lastInputEventValue){
								on.emit(this.textbox, "input", {bubbles: true});
							}
						});
					}
				}
			}
			this.own(
				on(this.textbox, "keydown, keypress, paste, cut, compositionend", lang.hitch(this, handleEvent)),
				on(this.textbox, "input", lang.hitch(this, "_onInput")),

				// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
				// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
				// trigger the Toolbar's letter key navigation.
				on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
			);
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			//
			//		- once with the display value
			//		- once the value as set/returned by set('value', ...)
			//
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){
				return this._blankValue;
			}
			if(typeof val != "string"){
				return val;
			}
			if(this.trim){
				val = lang.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0, 1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
			// or (for CurrencyTextBox) 2.50 to $2.50

			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){
				return;
			}
			this._setBlurValue();
			this.inherited(arguments);
		},

		_isTextSelected: function(){
			return this.textbox.selectionStart != this.textbox.selectionEnd;
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){
				return;
			}

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
				// the selection.
				this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					if(!this._isTextSelected()){
						_TextBoxMixin.selectInputText(this.textbox);
					}
				}));
				this.own(this._selectOnClickHandle);

				// in case the mouseup never comes
				this.defer(function(){
					if(this._selectOnClickHandle){
						this._selectOnClickHandle.remove();
						this._selectOnClickHandle = null;
					}
				}, 500); // if mouseup not received soon, then treat it as some gesture
			}
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides `dijit/_FormWidget/reset()`.
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_setDisplayedValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_onInput: function(){
				this.applyTextDir(this.focusNode);
				this.inherited(arguments);
			}
		});
	}

	_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	};

	_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		// summary:
		//		Select text in the input element argument, from start (default 0), to stop (default end).

		// TODO: use functions in _editor/selection.js?
		element = dom.byId(element);
		if(isNaN(start)){
			start = 0;
		}
		if(isNaN(stop)){
			stop = element.value ? element.value.length : 0;
		}
		try{
			element.focus();
			_TextBoxMixin._setSelectionRange(element, start, stop);
		}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
		}
	};

	return _TextBoxMixin;
});

},
'dijit/_base/window':function(){
define([
	"dojo/window", // windowUtils.get
	"../main"	// export symbol to dijit
], function(windowUtils, dijit){
	// module:
	//		dijit/_base/window

	/*=====
	return {
		// summary:
		//		Back compatibility module, new code should use windowUtils directly instead of using this module.
	};
	=====*/

	dijit.getDocumentWindow = function(doc){
		return windowUtils.get(doc);
	};
});

},
'curam/ajax':function(){
/*
 * Copyright 2009-2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 27-Feb-2014  MV  [CR00419961] Move to common AJAX request API.
 * 31-Jan-2012 MV [CR00302081] Move away from global context. 
 */

define(['curam/util/Request'
        ], function(curamRequest) {

var AJAXCall = function(dataTarget, inputProviderName) {
  this.target=dataTarget;
  this.inputProvider = inputProviderName || 'null';
};

var theAJAXCall = {
  doRequest: function (opAlias, params, isPopup, synchronous) {
    var theServlet = "../servlet/JSONServlet";

    var filler = this;

      if (isPopup) theServlet= "../" + theServlet;

      var oData = {
          caller: this.target.id,
          operation: opAlias,
          inputProvider: this.inputProvider,
          args: params
      };

      function processResult(oResult, opAlias){
        oResult = dojo.fromJson(oResult);
          if (oResult instanceof Array) {
            if (oResult.length > 1) {
              if (opAlias == "getCodeTableSubset") {
                filler.fillCTWithBlank(oResult); 
              } else { 
                filler.fillCT(oResult);
              }
            } else {
              if (opAlias == "getCodeTableSubset") {
                // have to handle code tables with one item
                filler.fillCTWithBlank(oResult);            
              } else {
                filler.fillSingle(oResult, true);
              }
            }
          } else {
            filler.fillSingle(oResult);
          }
      };

      curamRequest.post({
        url:theServlet,
        handleAs:   "text",
        load: function(data, evt){
          processResult(data, opAlias);
        },
        error: function(){
          alert("error");
        },
        content: {"content": dojo.toJson(oData)},
        preventCache: true,
        sync: synchronous
      });
  },

  fillCT: function (theResult) {
    this.target.options.length = 0;
    for (var i = 0; i < theResult.length; i++) {
      this.target.options[i] = new Option(theResult[i]["descr"], theResult[i]["code"], theResult[i]["default"]);
    }
  },

  fillCTWithBlank: function (theResult) {
    this.target.options.length = 0;
    this.target.options[0] = new Option("");
    for (var i = 0; i < theResult.length; i++) {
      this.target.options[i+1] = new Option(theResult[i]["descr"], theResult[i]["code"]);
    }
  },

  fillSingle: function (theResult, arrayed) {
    if (arrayed) {
      this.target.value = theResult[0]["value"];
    } else {
      this.target.value = theResult["value"];
    }
  }
};

dojo.mixin(AJAXCall.prototype, theAJAXCall);

// Keep the functions in the global scope for backwards compatibility.
// TODO: remove when code calling these functions is updated
dojo.global.AJAXCall = AJAXCall;

return AJAXCall;
});

},
'curam/util/Dialog':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.util.Dialog
 * @namespace Provides the ability to open arbitrary (non-UIM) content
 * in a Curam dialog.
 * 
 * It is required that the non-UIM page you are opening in a dialog resides
 * on the same Internet domain as the Curam application you are integrating
 * with.
 * <p/>
 * To open a custom page in a dialog you have to <ul>
 * <li> in the Curam application make the API call to load the custom page
 *      in a dialog </li>
 * <li> hook the custom page into the dialog API </li> </ul>
 * 
 * To hook the custom page into the dialog API, you first need to load the code,
 * preferably using <code>dojo.require("curam.util.Dialog");</code>
 * This assumes that you are using Dojo and you have access to the Curam
 * infrastructure JavaScript libraries.
 * <p/>
 * If this is not true for your pages, you will need to load the code
 * in the page header with standard <code>script</code> HTML elements.
 * The necesary script files are
 * <code>/CDEJ/jscript/curam/util/Dialog.js</code>,
 * <code>/CDEJ/jscript/curam/dialog.js</code>
 * and <code>/CDEJ/jscript/cdej.js</code>.
 * <p/>
 * The important API functions that must be called from your page are:<ul>
 * <li><code>{@link curam.util.Dialog.init}</code> in the page header.</li>
 * <li><code>{@link curam.util.Dialog.pageLoadFinished} when the page has been
 * fully loaded.</code></li></ul>
 * <p/>
 * To control the dialog size and title text you must register custom
 * functions by calling the following API in the page header:<ul>
 * <li><code>{@link curam.util.Dialog.registerGetSizeFunc}</code></li>
 * <li><code>{@link curam.util.Dialog.registerGetTitleFunc}</code></li></ul>
 * <p/>
 * Optionally you can also register custom handlers for the following events:<ul>
 * <li>AfterDisplay</li>
 * <li>BeforeClose</li></ul>
 * 
 * If linking from a dialog back into the Curam application is required,
 * this is done using the {@link curam.util.Dialog.close} function.
 */
define(["curam/util",
        "curam/define",
        "curam/dialog",
        "dojo/on",
        "curam/util/onLoad",
        "curam/debug"
        ], function(util, define, dialog, on, onLoad, debug) {

/*
 * Modification History
 * --------------------
 * 11-Oct-2019  CM  [RTC253441] Fix blank modal after IEG script on Chrome with iPad.
 * 10-Oct-2019  CM  [RTC253438] Add check for modals exiting an IEG script to use the 
 *                  onbeforeunload event, as modals exiting an IEG script weren't 
 *                  closing correctly in IE11 browsers.
 * 21-Aug-2018  BD  [RTC229425] Removed the handler to the unload event after it happen
 *                  to avoid memory leak.
 * 13-Aug-2018  SK  [RTC234604] Moved the cleanup to the unload instead
 *                  of onbeforeunload.
 * 03-Jul-2013  MV  [CR00390548] Remove IEG2 specific processing.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 03-Feb-2011  MV  [CR00253193] Add special processing in case IEG2
 *    is the client of the API - will be removed later on.
 * 03-Feb-2011  MV  [CR00250687] Notify the parent of the page unload.
 * 18-Jan-2011  MV  [CR00243263] Ensure handlers are released properly. Remove
 *    the use of alias for the window object.
 * 12-Jan-2011  PK  [CR00231655] Fixed issue with registerGetSizeFunc() not
 *                    correctly registering the specified sizing function.
 * 18-Nov-2010  MV  [CR00231655] Take dialog size into account properly.
 * 29-Sep-2010  MV  [CR00221605] Refactor to enable easy change of the context
 *      the API works on.
 */
  
/**
 * Creating Resource Bundle Object to access localized resources.
 */ 
  
 define.singleton("curam.util.Dialog",
/**
 * @lends curam.util.Dialog.prototype
 */
{  
  /**
   * Holds ID of the dialog in the current context.
   * @private
   */
  _id: null,
  
  /**
   * Holds the tokens for unsubscribing handlers on dialog close.
   * @private
   */
  _unsubscribes: [],
  
  /**
   * Boolean variable for a dialog modal with IEG script.
   * @private
   */
  _modalWithIEGScript: false,

  /**
   * Opens the specified non-UIM page in a Curam dialog.
   * 
   * @param {String} path URL path to the page to display in the dialog, without
   *              the query string.
   * @param {Object} pageParameters An object containing the required page
   *      parameters, or null if no page parameters are required.
   *      The following format is expected:
   *                        <code>{ param1Name:"value", param2Name:248 }</code>
   *      The infrastructure handles URL-encoding the values so do NOT encode
   *      them yourself.
   * @param {Object} [dialogSize] An object representing the required size
   *    of the dialog in pixels. The following form is required:
   *        <code>{ width:500, height:300 }</code> If size is not specified
   *      the default size will be used instead.
   */
  open: function(path, pageParameters, dialogSize) {
    var url = path + curam.util.makeQueryString(pageParameters);
    var anchor = { href: url };
    var windowOptions = null;
    if (dialogSize) {
      windowOptions = "width=" + dialogSize.width
          + ",height=" + dialogSize.height;
    }
    window.jsModals = true;
    curam.util.openModalDialog(anchor, windowOptions);
  },
    
  /**
   * Initializes the dialog infrastructure.
   *
   * Must be called in the header of the page loaded in the dialog.
   */
  init: function() {
    // receive the dialogId for the current context
    var topWin = curam.util.getTopmostWindow();
    var unsToken = topWin.dojo.subscribe("/curam/dialog/SetId", null,
        function(dialogId) {
          curam.util.Dialog._id = dialogId;
          
          curam.debug.log(debug.getProperty("curam.util.Dialog.id.success"), 
            curam.util.Dialog._id);

          topWin.dojo.unsubscribe(unsToken);
        });
    curam.util.Dialog._unsubscribes.push(unsToken);
    
    // publish the init event
    // this also triggers the /curam/dialog/SetId event
    // to get the ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!curam.util.Dialog._id) {
      curam.debug.log(debug.getProperty("curam.util.Dialog.id.fail"));
    }

    if (curam.util.Dialog._modalWithIEGScript) {
        dojo.addOnUnload(function() {

        // ensure any event handlers are released on page unload
        curam.util.Dialog._releaseHandlers();

        // notify interested parties of the iframe unload
        window.parent.dojo.publish(
          "/curam/dialog/iframeUnloaded", [ curam.util.Dialog._id, window ]);
        });

      } else {
        var signal = on(window, 'unload', function() {
          signal.remove();	
          // ensure any event handlers are released on page unload
          curam.util.Dialog._releaseHandlers();

          // notify interested parties of the iframe unload
          window.parent.dojo.publish(
            "/curam/dialog/iframeUnloaded", [ curam.util.Dialog._id, window ]);
        });
    }
    
  },
  
  /**
   * Initializes the dialog infrastructure for an IEG script on a dialog.
   * Must be called in the header of the page loaded in the dialog. This
   * calls the onbeforeunload, because IE 11 and Edge browsers cannot
   * handle the onunload call correctly. See RTC251740
   * 
   */
  initModalWithIEGScript: function() {

    curam.util.Dialog._modalWithIEGScript = true;

    curam.util.Dialog.init();
  },
  
  /**
   * Registers a custom function to get the dialog title text.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getTitle A function that returns the text to be displayed
   *                  in the dialog title bar.
   */
  registerGetTitleFunc: function(getTitle) {
    curam.util.onLoad.addPublisher(function(context) {
      context.title = getTitle();
    });
  },
  
  /**
   * Registers a custom function to get the dialog size.
   *
   * Can be optioanally called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getSize A function that returns an object
   *      in the following form: <code>{ width:500, height:300 }</code>
   */
  registerGetSizeFunc: function(getSize) {
    curam.util.onLoad.addPublisher(function(context) {
      context.windowOptions = getSize();
    });
  },
  
  /**
   * Registers a custom function that will be called after the dialog appears
   * on the screen.
   * 
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the AfterDisplay event.
   */
  registerAfterDisplayHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/AfterDisplay", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Registers a custom function that will be called before the dialog
   * is closed.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the BeforeClose event.
   */
  registerBeforeCloseHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId === curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Notifies the dialog infrastructure that the page has been fully loaded.
   *
   * Must be called by the page after it finishes loading in the dialog.
   * (E.g. dojo.addOnLoad(curam.Dialog.pageLoadFinished))
   */
  pageLoadFinished: function() {
    // ensure the handlers are unregistered on dialog close
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsTokenReleaseHandlers = topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            curam.util.Dialog._releaseHandlers(topWin);
          }
        });
     
    // invoke the onLoad API 
    curam.util.onLoad.execute();
  },
  
  /**
   * Releases any registered handlers.
   * @param {Object} topWindow. The top most window.
   * @private
   */
  _releaseHandlers: function(topWindow) {
	
    var topWin;
    
    if (topWindow) {
      topWin = topWindow;
    } else {
      topWin = curam.util.getTopmostWindow();
    }

    dojo.forEach(curam.util.Dialog._unsubscribes, topWin.dojo.unsubscribe);
    curam.util.Dialog._unsubscribes = [];
    
    topWin.dojo.unsubscribe(curam.util.Dialog._unsTokenReleaseHandlers);
    curam.util.Dialog._unsTokenReleaseHandlers = null;
  },
  
  /**
   * Closes the dialog, optionally refreshing or redirecting the parent window.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Boolean} [refreshParent=false] Should the parent be refreshed
   *              when this dialog closes?
   * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
   *      should be redirected to when this dialog closes. Alternatively
   *      a full URL including the page parameters can be passed.
   * @param {Object} [pageParameters] Page parameters to be used when
   *        redirecting the parent to the new page. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        The infrastructure handles URL-encoding the values so do NOT encode
   *        them yourself.
   *        If full URL is specified then the pageParameters are ignored.
   */
  close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
      /*optional*/ pageParameters) {
    
    var parentWindow = curam.dialog.getParentWindow(window);
    
    // Dialog._id may be lost on iPad - recover from frame ID
    if (typeof(curam.util.Dialog._id) === "undefined" || curam.util.Dialog._id == null) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.util.Dialog._id = modalID;
      
      debug.log("curam.util.Dialog.closeAndSubmitParent() " 
          + debug.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    if (refreshParent && !newPageIdOrFullUrl) {
      curam.dialog.forceParentRefresh();
      parentWindow.curam.util.redirectWindow(null);
      
    } else if (newPageIdOrFullUrl) {
      var newParentUrl = newPageIdOrFullUrl;
      // distinguish between pageId and full URL
      if (newPageIdOrFullUrl.indexOf("Page.do") == -1 && newPageIdOrFullUrl.indexOf("Action.do") == -1) {
        newParentUrl = newPageIdOrFullUrl + "Page.do"
            + curam.util.makeQueryString(pageParameters);
      }

      parentWindow.curam.util.redirectWindow(newParentUrl);
    }

    var topWin = curam.util.getTopmostWindow();
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  },
  
  /**
   * Closes the dialog and submit the parent page, where the form parameters
   * will be optionally passed to. This method is design for the senario where
   * the parent page has an <code>ACTION</code> phase.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Object} [formParameters] Form parameters to be used in the form of
   *        the parent page when it is being submitted. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        Those parameters should not be encoded. The parameter name should be
   *        the order of the input fields in the form, e.g. '1' means the first
   *        input field in the form.
   */
  closeAndSubmitParent: function(/*optional*/ formParameters) {
    var parentWindow = curam.dialog.getParentWindow(window);
    // Get the form of the parent page.
    var parentWindowForm = parentWindow.document.forms["mainForm"];
    var topWin = curam.util.getTopmostWindow();
    
    // Dialog._id may be lost on iPad - recover from frame ID
    if (typeof(curam.util.Dialog._id) === "undefined" || curam.util.Dialog._id == null) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.util.Dialog._id = modalID;
      
      debug.log("curam.util.Dialog.closeAndSubmitParent() " 
          + debug.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    // Check if the from in the parent window exists or not. If not, simply 
    // close the modal and return. The parent page will not be submitted.
    if (parentWindowForm == null || parentWindowForm == undefined) {
      //Close the modal
      topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
      return;
    }
        
    // Define the function used to check if the "formParameters" object is
    // empty or not.
    var isEmpty = function (object) {
      for (var property in object) {
        if (object.hasOwnProperty(property)) {
          return false;
        }
      }
      return true;
    };

    
    // Set the from parameters to the corresponding input fields 
    // in the form of the parent page that will be submitted.
    if (formParameters && !isEmpty(formParameters)) {
      // Reset and assign new form parameters to the input fields
      var inputFieldListUnfiltered = dojo.query("#" + parentWindowForm.id + " > " +
      "input[type=text]");
	 
      var inputFieldList = dojo.filter(inputFieldListUnfiltered, function(node){
        return node.readOnly == false;
      });
	  
      dojo.forEach(inputFieldList, function(node) {
          node.value = "";
      });
    
      for (var fieldName in formParameters) {
        var inputField = inputFieldList[parseInt(fieldName)];
        
        if (inputField) {
          var hiddenInputForDropDown = dojo.query(
                   "input[name=" + inputField.id + "]", parentWindowForm)[0];
            if (hiddenInputForDropDown) {
              hiddenInputForDropDown.value = formParameters[fieldName];
            } else {
              inputField.value = formParameters[fieldName];
            }
        
        }
      }
    } else {
      // Do nothing. No form paramters are passed down. Keep the existing string
      // in the from input fields.
    }
	
    //Submit the parent page.
    parentWindow.dojo.publish("/curam/page/refresh");
    parentWindowForm.submit();
    
    //Close the modal
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  },

  /**
   * Opens a modal window with confirm/cancel options for the current file
   * download.
   * <p>
   * The modal informs the user that the file they are about to download
   * contains sensitive personal information and warns them to clear their
   * browser cache afterwards if using a public computer. It then lists
   * instructions on how to clear the cache for their specific browser.
   * <p>
   * This method should be returned by the onclick function of a link when
   * that link is being rendered.
   * <p>
   * Example Java Renderer code:
   * <pre>
   * anchor.setAttribute("onclick",
   *     "return curam.util.Dialog.fileDownloadAnchorHandler('" + url
   *         + "');");
   * </pre>
   * The messages displayed to the user can be overridden using a copy of
   * the <code>GenericModalError.js.properties</code> file.
   *
   * @param {String} url The URL to be accessed when the user confirms
   *        that they want to download the file.
   */
  fileDownloadAnchorHandler: function(url) {
    // This method is just a wrapper to publicly expose
    // curam.util.fileDownloadAnchorHandler(url)
    return curam.util.fileDownloadAnchorHandler(url);
  }

  });
  
});
},
'dojo/hccss':function(){
define([
	"require",			// require, require.toUrl
	"./_base/config", // config.blankGif
	"./dom-class", // domClass.add
	"./dom-style", // domStyle.getComputedStyle
	"./has",
	"./domReady",
	"./_base/window" // win.body
], function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
			"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
		win.body().appendChild(div);

		var cs = domStyle.getComputedStyle(div),
			bkImg = cs.backgroundImage,
			hc = (cs.borderTopColor == cs.borderRightColor) ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));

		if(has("ie") <= 8){
			div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
		}else{
			win.body().removeChild(div);
		}

		return hc;
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
});

},
'dijit/_BidiMixin':function(){
define([], function(){

	// module:
	//		dijit/_BidiMixin

	// UCC - constants that will be used by bidi support.
	var bidi_const = {
		LRM : '\u200E',
		LRE : '\u202A',
		PDF : '\u202C',
		RLM : '\u200f',
		RLE : '\u202B'
	};

	return {
		// summary:
		//		When has("dojo-bidi") is true, _WidgetBase will mixin this class.   It enables support for the textdir
		//		property to control text direction independently from the GUI direction.
		// description:
		//		There's a special need for displaying BIDI text in rtl direction
		//		in ltr GUI, sometimes needed auto support.
		//		In creation of widget, if it's want to activate this class,
		//		the widget should define the "textDir".

		// textDir: String
		//		Bi-directional support,	the main variable which is responsible for the direction of the text.
		//		The text direction can be different than the GUI direction by using this parameter in creation
		//		of a widget.
		//
		//		Allowed values:
		//
		//		1. "ltr"
		//		2. "rtl"
		//		3. "auto" - contextual the direction of a text defined by first strong letter.
		//
		//		By default is as the page direction.
		textDir: "",

		getTextDir: function(/*String*/ text){
			// summary:
			//		Gets the right direction of text.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.
			return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
		},

		_checkContextual: function(text){
			// summary:
			//		Finds the first strong (directional) character, return ltr if isLatin
			//		or rtl if isBidiChar.
			// tags:
			//		private.

			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as defult.
			return fdc ? ( fdc[0] <= 'z' ? "ltr" : "rtl" ) : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
		},

		applyTextDir: function(/*DOMNode*/ element, /*String?*/ text){
			// summary:
			//		Set element.dir according to this.textDir, assuming this.textDir has a value.
			// element:
			//		The text element to be set. Should have dir property.
			// text:
			//		If specified, and this.textDir is "auto", for calculating the right transformation
			//		Otherwise text read from element.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.

			if(this.textDir){
				var textDir = this.textDir;
				if(textDir == "auto"){
					// convert "auto" to either "ltr" or "rtl"
					if(typeof text === "undefined"){
						// text not specified, get text from element
						var tagName = element.tagName.toLowerCase();
						text = (tagName == "input" || tagName == "textarea") ? element.value :
							element.innerText || element.textContent || "";
					}
					textDir = this._checkContextual(text);
				}

				if(element.dir != textDir){
					// set element's dir to match textDir, but not when textDir is null and not when it already matches
					element.dir = textDir;
				}
			}
		},

		enforceTextDirWithUcc: function(option, text){
			// summary:
			//		Wraps by UCC (Unicode control characters) option's text according to this.textDir
			// option:
			//		The element (`<option>`) we wrapping the text for.
			// text:
			//		The text to be wrapped.
			// description:
			//		There's a dir problem with some HTML elements. For some elements (e.g. `<option>`, `<select>`)
			//		defining the dir in different direction then the GUI orientation, won't display correctly.
			//		FF 3.6 will change the alignment of the text in option - this doesn't follow the bidi standards (static text
			//		should be aligned following GUI direction). IE8 and Opera11.10 completely ignore dir setting for `<option>`.
			//		Therefore the only solution is to use UCC (Unicode  control characters) to display the text in correct orientation.
			//		This function saves the original text value for later restoration if needed, for example if the textDir will change etc.
			if(this.textDir){
				if(option){
					option.originalText = text;
				}
				var dir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
				return (dir == "ltr" ? bidi_const.LRE : bidi_const.RLE ) + text + bidi_const.PDF;
			}
			return text;
		},

		restoreOriginalText: function(origObj){
			// summary:
			//		Restores the text of origObj, if needed, after enforceTextDirWithUcc, e.g. set("textDir", textDir).
			// origObj:
			//		The element (`<option>`) to restore.
			// description:
			//		Sets the text of origObj to origObj.originalText, which is the original text, without the UCCs.
			//		The function than removes the originalText from origObj!
			if(origObj.originalText){
				origObj.text = origObj.originalText;
				delete origObj.originalText;
			}
			return origObj;
		},

		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			if(!this._created || this.textDir != textDir){
				this._set("textDir", textDir);
				var node = null;
				if(this.displayNode){
					node = this.displayNode;
					this.displayNode.align = this.dir == "rtl" ? "right" : "left";
				}else{
					node = this.textDirNode || this.focusNode || this.textbox;
				}
				if(node){
					this.applyTextDir(node);
				}
			}
		}
	};
});

},
'curam/widget/_ComboBoxMenu':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2019. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/**
 * Override of the Dojo _ComboBoxMenu module to add an additional attribute to
 * blank drop down options, enabling screen readers to correctly read the entry. 
 */
define(["dojo/_base/declare",
        "dojo/dom-attr",
        "curam/util/ResourceBundle",
        "dijit/form/_ComboBoxMenu"
], function(declare, domAttr, ResourceBundle) {
  
  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  //dojo.requireLocalization("curam.application", "FilteringSelect");
  var bundle = new ResourceBundle("FilteringSelect");
  
  /*
   * Modification History
   * --------------------
   * 01-Aug-2019 RS [RTC249288] Added a regular expression to remove HTML Tags before adding 
   *                            menuitem.innerHTML to menuitem.title
   * 14-Sep-2017 SO [RTC205990] Changed the title value from &nbsp; to Blank Value to fix screen readers issue
   * 21-Mar-2017 GB [RTC185863] Adding a title to the MenuItem so we have a tooltip displayed.
   * 20-Nov-2015 AZ [CR00472692] Initial Version
   */
  /**
   * @name curam.widget._ComboBoxMenu
   * @namespace Override of the Dojo _ComboBoxMenu in order to make the _ComboBoxMenu
   *              accessible using screen reader.
   */
  var ComboBoxMenu = declare("curam.widget._ComboBoxMenu", [dijit.form._ComboBoxMenu],
  /**
   * @lends curam.widget._ComboBoxMenu.prototype
   */
  {
    _createOption: function(/*Object*/ item, labelFunc){
    
      var menuitem = this._createMenuItem();
      var labelObject = labelFunc(item);
      if(labelObject.html){
        menuitem.innerHTML = labelObject.label;
      }else{
        menuitem.appendChild(
          menuitem.ownerDocument.createTextNode(labelObject.label)
        );
      }
      
      // #3250: in blank options, assign a normal height
      if(menuitem.innerHTML == ""){
        // CURAM CUSTOMIZATION START - Adding aria-label attribute to blank option to ensure
        // that the entry can be read by screen readers.
    	//menuitem.innerHTML = "&#160;";  // &nbsp;
        domAttr.set(menuitem, "aria-label", bundle.getProperty("curam.select.option.blank"));
        domAttr.set(menuitem, "title", bundle.getProperty("curam.select.option.blank"));
        // CURAM CUSTOMIZATION END
      } else {
    	  // This regular expression strips out HTML tags from the memuitem.innerHTML so only words, 
    	  // special characters and numbers can be added in the manuitem.title
    	  var removeHTMLTags = /<[a-zA-Z\/][^>]*>/g;
    	  var innerHTML = menuitem.innerHTML;
          menuitem.title = innerHTML.replace(removeHTMLTags,'');
      }
      return menuitem;
    }
  });

  return ComboBoxMenu;
});
},
'dijit/main':function(){
define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'curam/define':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/lang"], function(lang) {

  /*
   * Modification History
   * --------------------
   * 29-Jul-2011  MV [CR00269970] Initial version.
   */

  /**
   * This package contains function for working with classes in our code.
   */
  var global = this;
  if(typeof(global.curam) == "undefined") {
    global.curam = {};
  }

  if (typeof(global.curam.define) == "undefined") {
    lang.mixin(global.curam, {define: {}});
  }

  lang.mixin(global.curam.define, {
    /**
     * Defines a singleton class ensuring any packages are created and no
     * existing packages are overwritten in the process.
     *
     * @param {String} singletonName Name of the singleton class to be defined.cdej
     * @param {Object} [content] Optional content of the singleton class.
     */
    singleton: function(singletonName, content) {
      var parts = singletonName.split(".");

      // we assume we are runnning within a browser environment so the window
      // object is available.
      var currentContext = window;

      // now check for existence and create any missing packages
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (typeof currentContext[part] == "undefined") {
          currentContext[part] = {};
        }
        currentContext = currentContext[part];
      }

      // now set the content
      if (content) {
        lang.mixin(currentContext, content);
      }
    }
  });

  return global.curam.define;
});

},
'curam/util/external':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

  /*
   * Modification History
   * --------------------
   * 25-Mar-2014 MV  [CR00423311] Initial version.  
   */
define(['curam/util'
        ], function(util) {
  
  /**
   * @name curam.util.external
   * @namespace Contains functions of general use for the external application
   *    container.
   */
  curam.define.singleton("curam.util.external",
  /**
   * @lends curam.util.external.prototype
   */
  {
    /**
     * Determines whether we are running within an external application
     * container or not.
     * 
     * @return True if we are in external app container, otherwise false.
     */
    inExternalApp: function() {
      return jsScreenContext.hasContextBits("EXTAPP");
    },
    
    /**
     * Determines the iframe to be used as parent for a UIM modal dialog.
     * 
     * @returns iframe or null.
     */
    getUimParentWindow: function() {
      if (util.getTopmostWindow() === dojo.global) {
        return null;

      } else {
        return dojo.global;
      }
    }
  });

  return curam.util.external;
});

},
'dijit/_OnDijitClickMixin':function(){
define([
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/has", // has("dom-addeventlistener")
	"./a11yclick"
], function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
});

},
'curam/layout/ScrollingTabController':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.layout.ScrollingTabController
 * @namespace Customized dijit.layout.ScrollingTabController class that adds
 *    rounded corners to tabs.
 * 
 */
define(["dojo/_base/declare",
        "dojo/dom-class",
        "dijit/layout/ScrollingTabController",
        "curam/inspection/Layer",
        "curam/debug",
        "curam/widget/_HasDropDown",
        "dojo/text!curam/layout/resources/ScrollingTabController.html"
        ], function(declare, domClass, ScrollingTabController, layer, debug, _HasDropDown, tabControllerTemplate) {

/*
 * Modification History
 * --------------------
 * 14-May-2019  JD  [RTC242058]  _ScrollingTabControllerMenuButton to use 
 * 								 curam/widget/_HasDropDown
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 10-Jan-2011  KW  [CR00240897] Curam Logo is now hard-coded. Also added new
 *                    element to application banner to accommodate new styling.
 * 18-Nov-2010  MV [CR00231387] Replaced the compressed version with the proper
 *    source.
 */

var CuramScrollingTabController = declare("curam.layout.ScrollingTabController", ScrollingTabController,
/**
 * @lends curam.layout.ScrollingTabController.prototype
 */
{
  templateString: tabControllerTemplate,
	
  onStartup: function(){
	  
    this.inherited(arguments);
    layer.register("curam/layout/ScrollingTabController", this);
  },
  
  updateTabStyle:function() {
    var kids = this.getChildren();
    curam.debug
      .log("curam.layout.ScrollingTabController.updateTabStyle kids = ", 
          this.domNode);
    
    dojo.forEach(kids , function(button,index,array) {
      domClass.remove(button.domNode, ["first-class", "last-class"] );
      
      if (index == 0) {
        domClass.add(button.domNode,"first");
      
      } else if(index == array.length - 1) {
        domClass.add(button.domNode,"last");
      }
    });
    
    //Apply new classes and elements related to the updated v6
    //banner style
    var newBanner = dojo.query(".nowrapTabStrip", this.domNode)[0];
    domClass.replace(newBanner, "nowrapSecTabStrip", "nowrapTabStrip");
    
    var bannerEnding = document.createElement("div");
    domClass.add(bannerEnding, "block-slope");
    domClass.add(bannerEnding, "dijitTab");
    bannerEnding.innerHTML="&#x200B;";
    
    newBanner.appendChild(bannerEnding);
    }
  });

  // Class used in template
  declare("curam.layout._ScrollingTabControllerMenuButton", [dijit.layout._ScrollingTabControllerMenuButton, _HasDropDown], {

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
				this._popupStateNode.removeAttribute("aria-owns");	// remove ref to node that we are about to delete
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}

  });

  return CuramScrollingTabController;  
});

},
'dijit/_BidiSupport':function(){
define(["dojo/has", "./_WidgetBase", "./_BidiMixin"], function(has, _WidgetBase, _BidiMixin){

	// module:
	//		dijit/_BidiSupport

	/*=====
	return function(){
		// summary:
		//		Deprecated module for enabling textdir support in the dijit widgets.   New code should just define
		//		has("dojo-bidi") to return true, rather than manually requiring this module.
	};
	=====*/

	_WidgetBase.extend(_BidiMixin);

	// Back-compat with version 1.8: just including _BidiSupport should trigger bidi support in all the widgets.
	// Although this statement doesn't do much because the other widgets have likely already been loaded.
	has.add("dojo-bidi", true);

	return _WidgetBase;
});

},
'dijit/form/_ListMouseMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/touch",
	"./_ListBase"
], function(declare, on, touch, _ListBase){

	// module:
	//		dijit/form/_ListMouseMixin

	return declare("dijit.form._ListMouseMixin", _ListBase, {
		// summary:
		//		A mixin to handle mouse or touch events for a focus-less menu
		//		Abstract methods that must be defined externally:
		//
		//		- onClick: item was chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		// tags:
		//		private

		postCreate: function(){
			this.inherited(arguments);

			// Add flag to use normalized click handling from dojo/touch
			this.domNode.dojoClick = true;

			this._listConnect("click", "_onClick");
			this._listConnect("mousedown", "_onMouseDown");
			this._listConnect("mouseup", "_onMouseUp");
			this._listConnect("mouseover", "_onMouseOver");
			this._listConnect("mouseout", "_onMouseOut");
		},

		_onClick: function(/*Event*/ evt, /*DomNode*/ target){
			this._setSelectedAttr(target, false);
			if(this._deferredClick){
				this._deferredClick.remove();
			}
			this._deferredClick = this.defer(function(){
				this._deferredClick = null;
				this.onClick(target);
			});
		},

		_onMouseDown: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			this._isDragging = true;
			this._setSelectedAttr(target, false);
		},

		_onMouseUp: function(/*Event*/ evt, /*DomNode*/ target){
			this._isDragging = false;
			var selectedNode = this.selected;
			var hoveredNode = this._hoveredNode;
			if(selectedNode && target == selectedNode){
				this.defer(function(){
					this._onClick(evt, selectedNode);
				});
			}else if(hoveredNode){ // drag to select
				this.defer(function(){
					this._onClick(evt, hoveredNode);
				});
			}
		},

		_onMouseOut: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			if(this._isDragging){
				this._cancelDrag = (new Date()).getTime() + 1000; // cancel in 1 second if no _onMouseOver fires
			}
		},

		_onMouseOver: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._cancelDrag){
				var time = (new Date()).getTime();
				if(time > this._cancelDrag){
					this._isDragging = false;
				}
				this._cancelDrag = null;
			}
			this._hoveredNode = target;
			this.onHover(target);
			if(this._isDragging){
				this._setSelectedAttr(target, false);
			}
		}
	});
});

},
'dojo/cookie':function(){
define(["./_base/kernel", "./regexp"], function(dojo, regexp){

// module:
//		dojo/cookie

/*=====
var __cookieProps = {
	// expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	// path: String?
	//		The path to use for the cookie.
	// domain: String?
	//		The domain to use for the cookie.
	// secure: Boolean?
	//		Whether to only send the cookie on secure connections
};
=====*/


dojo.cookie = function(/*String*/name, /*String?*/ value, /*__cookieProps?*/ props){
	// summary:
	//		Get or set a cookie.
	// description:
	//		If one argument is passed, returns the value of the cookie
	//		For two or more arguments, acts as a setter.
	// name:
	//		Name of the cookie
	// value:
	//		Value for the cookie
	// props:
	//		Properties for the cookie
	// example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		cookie("configObj", json.stringify(config, {expires: 5 }));
	//	|	});
	//
	// example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		config = json.parse(cookie("configObj"));
	//	|	});
	//
	// example:
	//		delete a cookie:
	//	|	require(["dojo/cookie"], function(cookie){
	//	|		cookie("configObj", null, {expires: -1});
	//	|	});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	// summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'idx/has':function(){
define(["dojo/_base/lang","dojo/has"], function(dLang,dHas){
	var iHas = {};
	dLang.mixin(iHas, dHas);
	iHas.normalize = function(id, toAbsMid){
		// summary:
		//	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
		//
		// toAbsMid: Function
		//	 Resolves a relative module id into an absolute module id
		var
			tokens = id.match(/[\?:]|[^:\?]*/g), i = 0,
			get = function(skip){
				var term = tokens[i++];
				if(term == ":"){
					// empty string module name, resolves to 0
					return 0;
				}else{
					// postfixed with a ? means it is a feature to branch on, the term is the name of the feature
					if(tokens[i++] == "?"){
						if (term.length>1 && term.charAt(0)=="#") term = term.substring(1);
						if(!skip && dHas(term)){
							// matched the feature, get the first value from the options
							return get();
						}else{
							// did not match, get the second value, passing over the first
							get(true);
							return get(skip);
						}
					}
					// a module
					return term || 0;
				}
			};
		id = get();
		return id && toAbsMid(id);
	};
	
	return iHas;
});

},
'dojo/cache':function(){
define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'curam/util/ui/refresh/TabRefreshController':function(){
/*
 * Copyright 2011-2018 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/declare",
        "curam/inspection/Layer",
        "curam/debug",
        "curam/util/ui/refresh/RefreshEvent"
        ], function(declare, layer, debug) {

  /*
   * Modification History
   * --------------------
   * 23-Aug-2018  BD  [RTC229425]  Included publish to alert when the page is submitted
                                   and when the context is refreshed.
   * 17-Oct-2014  MV  [CR00447421] Ignore very first context panel refresh
   *                               request. Always refresh menu and navigation
   *                               on a tab load.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 07-May-2013  MV  [CR00383012] Fix destroy function to properly
   *    re-initialize members. 
   * 07-Mar-2013  MV  [CR00373496] Fix member variable values handling.
   * 22-Oct-2012  SK  [CR00346419] Now destroys the configuration references
   *                  to avoid memory leak.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * @name curam.util.ui.refresh.TabRefreshController
   * @namespace Manages refreshing of the the tab UI components.
   *
   */
  var TabRefreshController = declare("curam.util.ui.refresh.TabRefreshController", null,
  /**
   * @lends curam.util.ui.refresh.TabRefreshController.prototype
   */
  {
    /** Event name for menu refresh. */
    EVENT_REFRESH_MENU: "/curam/refresh/menu",

    /** Event name for navigation refresh. */
    EVENT_REFRESH_NAVIGATION: "/curam/refresh/navigation",

    /** Event name for context panel refresh. */
    EVENT_REFRESH_CONTEXT: "/curam/refresh/context",

    /** Event name for the main content panel refresh. */
    EVENT_REFRESH_MAIN: "/curam/refresh/main-content",

    /** ID of the related tab widget. */
    _tabWidgetId: null,

    /** The configuration for onsubmit handling. */
    _configOnSubmit: null,

    /** The configuration for onload handling. */
    _configOnLoad: null,

    /** The handler function that performs the actual refresh based on the
     * generated events. */
    _handler: null,

    /**
     * Holds the last submit event to be processed. This is needed because page
     * submits are processed only when the next page loads. It is done for two
     * reasons: a) to make sure any server updates caused by the submit are
     * reflected when the UI is refreshed and b) to avoid double refreshes
     * when they are configured on both one page submit and the next page load.
     * If this is the case the refresh list is optimized and only done once.
     */
    _lastSubmitted: null,

    /**
     * Holds the current refresh event sent to the main content panel. This is
     * used to break potential infinite recursion when we are notified of page
     * events caused by our own refresh event.
     */
    _currentlyRefreshing: null,


    /**
      * The very first context panel refresh will be ignored, if it comes
      * from the main content panel load. This is to make sure we don't load
      * the context panel twice when tab is being opened.
      */
    _ignoreContextRefresh: true,

      /**
      * We need to always refresh menu/nav on tab open regardless
      * the configuration.
      */
    _initialMenuAndNavRefreshDone: false,

    _nullController: null,

    /**
     * Creates an instance of the refresh controller.
     *
     * @param {String} tabWidgetId Id of the tab widget this controller
     *            belongs to.
     * @param {Object} [config] The tab refresh configuration object.
     *            The expected structure is the one output
     *            by curam.util.client.render.component.TabRenderer.
     *            Configuration is optional as some tabs have no associated
     *            refresh configuration. If not provided, the controller will not
     *            be active, i.e. will not send out any refresh events ever.
     */
    constructor: function(tabWidgetId, config) {
      this._configOnSubmit = {};
      this._configOnLoad = {};

      if (!config) {
        // is null controller
        this._nullController = true;
        return;
      }

      this._tabWidgetId = tabWidgetId;

      // Expand the configuration data structure so that it is easily
      // used in the controller.
      dojo.forEach(config.config, dojo.hitch(this, function(item) {
        this._configOnSubmit[item.page] = item.onsubmit;
        this._configOnLoad[item.page] = item.onload;
      }));
      layer.register("curam/util/ui/refresh/TabRefreshController", this);

    },

    /**
     * Notifies the controller of a page submit in the specified context.
     *
     * @param pageId ID of the page that has been submitted.
     * @param context Context in which the page has been submitted. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageSubmitted: function(pageId, context) {
      // create event object - validates the parameters
      new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONSUBMIT, context);
      debug.log("curam.util.ui.refresh.TabRefreshController: " +
          debug.getProperty("curam.util.ui.refresh.TabRefreshController.submit",
                             [pageId, context]));
      dojo.publish("curam/form/submit",[pageId]);
      if (this._configOnSubmit[pageId]) {
        // if we are interested in this submit, record the event
        // it will be processed when a next page loads
        this._lastSubmitted = pageId;
        debug.log("curam.util.ui.refresh.TabRefreshController: "
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "submit.notify"));
      }
    },

    /**
     * Notifies the controller of a page load in the specified context.
     *
     * @param pageId ID of the page that has been loaded.
     * @param context Context in which the page has been loaded. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageLoaded: function(pageId, context) {
      // create event object - also validates the parameters
      var event = new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD, context);

      debug.log("curam.util.ui.refresh.TabRefreshController:"
        + debug.getProperty("curam.util.ui.refresh.TabRefreshController.load",
          [pageId, context]));

      // do not react to onload event if it was caused by our refresh event
      // this avoids possible infinite recursion
      if (this._currentlyRefreshing && this._currentlyRefreshing.equals(event)) {
        this._currentlyRefreshing = null;
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "refresh"));
        return;
      }

      // if a refresh is configured for both previous page submit and next page
      // load we merge the configurations and only refresh once
      var mergedRefreshConfig = {};

      // only support onload event for the main content panel
      if(context == event.SOURCE_CONTEXT_MAIN && this._configOnLoad[pageId]) {
        mergedRefreshConfig = this._configOnLoad[pageId];
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".load.config"));
      }
      // else ->
      // load in other contexts will be only used to dispatch
      // any previous onsubmit event
      if (this._lastSubmitted) {
        // merge the configs if we have both onsubmit and onload
        var cfg = this._configOnSubmit[this._lastSubmitted];
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".submit.config", [this._lastSubmitted]));

        mergedRefreshConfig.details = mergedRefreshConfig.details || cfg.details;
        mergedRefreshConfig.menubar = mergedRefreshConfig.menubar || cfg.menubar;
        mergedRefreshConfig.navigation =
            mergedRefreshConfig.navigation || cfg.navigation;
        mergedRefreshConfig.mainContent =
            mergedRefreshConfig.mainContent || cfg.mainContent;

        this._lastSubmitted = null;
      }

      if (!this._nullController) {
        this._fireRefreshEvents(mergedRefreshConfig, this._ignoreContextRefresh,
            !this._initialMenuAndNavRefreshDone);
      }

      // stop ignoring context refresh after the initial page load
      // in the main content panel and leave it that way
      if (this._ignoreContextRefresh && context == event.SOURCE_CONTEXT_MAIN) {
        this._ignoreContextRefresh = false;
      }

      if (!this._initialMenuAndNavRefreshDone) {
        // initial refresh done, obey the config from now on
        this._initialMenuAndNavRefreshDone = true;
      }
    },

    /**
     * Invokes the refresh handler with events based on the received
     * page load/submit events and refresh configuration.
     *
     * @private
     *
     * @param cfg The relevant configuration fragment.
     */
    _fireRefreshEvents: function(cfg, ignoreContextRefresh, doRefreshMenuNav) {
      var events = [];
      if (cfg.details) {
        if (ignoreContextRefresh) {
          curam.debug.log(
              "curam.util.ui.refresh.TabRefreshController: ignoring the first CONTEXT refresh request");
        } else {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.context"));
        events.push(this.EVENT_REFRESH_CONTEXT + "/" + this._tabWidgetId);
        }
      }else if(!ignoreContextRefresh){
    	  dojo.publish("curam/tab/contextRefresh");
      }
      if (cfg.menubar || doRefreshMenuNav) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.menu"));
        events.push(this.EVENT_REFRESH_MENU + "/" + this._tabWidgetId);
      }
      if (cfg.navigation || doRefreshMenuNav) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.nav"));
        events.push(this.EVENT_REFRESH_NAVIGATION + "/" + this._tabWidgetId);
      }
      if (cfg.mainContent) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.main"));
        // store the refresh event for later use in the infinite recursion
        // breaking code above
        this._currentlyRefreshing = new curam.util.ui.refresh.RefreshEvent(
            curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD,
            curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN,
            null);
        events.push(this.EVENT_REFRESH_MAIN + "/" + this._tabWidgetId);
      }
      if (events.length > 0) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".refresh.log", [events.length, events]));
        this._handler(events);
      }
    },

    /**
     * Specifies the refresh handler function to be invoked when some tab UI
     * parts should be refreshed.
     *
     * @param {Function} handler A function to be invoked in response to tab UI
     *    refresh events. The function will be passed one parameter
     *    which is an array of refresh event names. The format of the refresh
     *    event names is the following: event_name/tab_widget_id, where
     *    the supported event_names are defined as constants in this class
     *    and tab_widget_id is ID of the tab the events are related to. Please
     *    note that all the events in the array will always refer to the same tab.
     */
    setRefreshHandler: function(handler) {
      this._handler = handler;
    },

    /**
     * Releases any resources related to this controller instance.
     * It is the responsibility of this class' clients to call this function when
     * the tab that owns the controller instance is closed.
     */
    destroy: function() {
      for (prop in this._configOnSubmit) {
        if (this._configOnSubmit.hasOwnProperty(prop)) {
        delete this._configOnSubmit[prop];
      }
      }
      for (prop in this._configOnLoad) {
        if (this._configOnLoad.hasOwnProperty(prop)) {
        delete this._configOnLoad[prop];
      }
      }
      this._configOnSubmit = {};
      this._configOnLoad = {};
      this._handler = null;
      this._lastSubmitted = null;
      this._currentlyRefreshing = null;
    }
  });

  return TabRefreshController;
});

},
'dijit/_base/popup':function(){
define([
	"dojo/dom-class", // domClass.contains
	"dojo/_base/window",
	"../popup",
	"../BackgroundIframe"	// just loading for back-compat, in case client code is referencing it
], function(domClass, win, popup){

// module:
//		dijit/_base/popup

/*=====
return {
	// summary:
	//		Deprecated.   Old module for popups, new code should use dijit/popup directly.
};
=====*/


// Hack support for old API passing in node instead of a widget (to various methods)
var origCreateWrapper = popup._createWrapper;
popup._createWrapper = function(widget){
	if(!widget.declaredClass){
		// make fake widget to pass to new API
		widget = {
			_popupWrapper: (widget.parentNode && domClass.contains(widget.parentNode, "dijitPopup")) ?
				widget.parentNode : null,
			domNode: widget,
			destroy: function(){},
			ownerDocument: widget.ownerDocument,
			ownerDocumentBody: win.body(widget.ownerDocument)
		};
	}
	return origCreateWrapper.call(this, widget);
};

// Support old format of orient parameter
var origOpen = popup.open;
popup.open = function(/*__OpenArgs*/ args){
	// Convert old hash structure (ex: {"BL": "TL", ...}) of orient to format compatible w/new popup.open() API.
	// Don't do conversion for:
	//		- null parameter (that means to use the default positioning)
	//		- "R" or "L" strings used to indicate positioning for context menus (when there is no around node)
	//		- new format, ex: ["below", "above"]
	//		- return value from deprecated dijit.getPopupAroundAlignment() method,
	//			ex: ["below", "above"]
	if(args.orient && typeof args.orient != "string" && !("length" in args.orient)){
		var ary = [];
		for(var key in args.orient){
			ary.push({aroundCorner: key, corner: args.orient[key]});
		}
		args.orient = ary;
	}

	return origOpen.call(this, args);
};

return popup;
});

},
'dojo/promise/all':function(){
define([
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

},
'curam/widget/_TabButton':function(){
/*
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * Copyright IBM Corporation 2022.
 *
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the US
 * Copyright Office.
 */

/**
 * @name curam.widget._TabButton
 * @namespace Customized dijit.layout._TabButton class.
 *
 * This code has been taken from Dojo 1.4.0 source and small improvements
 * have been made to it. There are number of TODOs in the code, but they
 * belong to Dojo people and there's no need for us to worry about them.
 *
 */
define(["dojo/_base/declare",
        "dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/has",
        "dojo/i18n",
        "dojo/_base/lang",
        "dojo/text!curam/widget/templates/_TabButton.html",
        "dijit/registry",
        "dojo/_base/connect",
        "curam/inspection/Layer",
        "dijit/layout/StackController", // to load the base class dijit.layout._StackButton
        "dijit/Menu",
        "dijit/MenuItem",
        "curam/widget/MenuItem",
        "curam/tab"], function(declare, dom, domAttr, domClass, domStyle, has, i18n, lang, 
            template, registry, connect, layer) {       
 
/*
 * Modification History
 * --------------------
 * 07-Mar-2022  FN  [RTC254434] Removed code for enabled/disabled tab context render.
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Moved publishing of
 * /curam/tab/closing event to TabContainer.removeChild function.)
 * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 30-Jan-2014  MV  [CR00412899] Refactor tab context info handler for better
 *      performance.
 * 22-Jan-2014  MV  [CR00412812] Fix tab context info handler.
 * 30-Sep-2013  MK  [CR00390932] Upgrade to Dojo 1.9 
 * 04-Aug-2013  NLH  [CR00388987] Toggle button on context panel disappears.
 * 18-Jul-2013  SB  [CR00388308] Added tab context event handler.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 06-Feb-2013  SB  [CR00368739] Updated id of the focusNode.
 * 14-Aug-2012  MV  [CR00338135] Remove dependency on full Dojo API.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 16-Mar-2012  BOS [TEC-9823]   Localizing the tooltip for closing a tab
 * 30-Nov-2011  SB  [CR00293890] Updated span tag inner text for close tab.
 * 03-Dec-2010  MV [CR00232963] Add ability to disable and hide the button.
 */

  /**
   * Updates tab context strings of all tabs, e.g 'Tab 1 of 4'.
   * This is only ever registered once, as the module is loaded.
   */
  connect.subscribe("/curam/tab/labelUpdated", function() {
    var tabs;  
    var tabLists = dojo.query(".dijitTabContainerTop-tabs");
    
    tabLists.forEach(function(tabList){
       tabs = dojo.query('.tabLabel', tabList);
      
       tabs.forEach(function(tab, index){
         var label = tabs[index].innerHTML;
         tab.setAttribute("title", label);
         
         //Add the tab name to the close button title.
         var nextSibling = tab.nextSibling;
         while(nextSibling){
        	 if(domClass.contains(nextSibling, "dijitTabCloseButton")){
        		 var title = nextSibling.getAttribute("title");  
        		 if(title && title.indexOf(label) < 0){
        			 nextSibling.setAttribute("title", title + " - " + label);
        		 } 
        		 break;
        	 }
        	 nextSibling = nextSibling.nextSibling; 
         }
       }); 
    }); 
  });
  
  var _TabButton = declare("curam.widget._TabButton", dijit.layout._StackButton,
 
/**
 * A tab (the thing you click to select a pane).
 * Contains the title of the pane, and optionally a close-button to destroy
 * the pane. This is an internal widget and should not be instantiated
 * directly.
 *
 * @private
 *
 * @lends curam.widget._TabButton.prototype
 */
{
  //>>> Override the templateString to add the class 'dijitTab' to the
  //>>> outer div of each tab button
  templateString: template,

  // Button superclass maps name to a this.valueNode, but we don't have a this.valueNode attach point
  _setNameAttr: "focusNode",

  // Override _FormWidget.scrollOnFocus.
  // Don't scroll the whole tab container into view when the button is focused.
  scrollOnFocus: false,

  curamDisabled: false,
  curamVisible: true,

  // baseClass: String
  //    The CSS class applied to the domNode.
  baseClass: "dijitTab",

  postMixInProperties: function(){
    // Override blank iconClass from Button to do tab height adjustment on IE6,
    // to make sure that tabs with and w/out close icons are same height
    if(!this.iconClass){
      this.iconClass = "dijitTabButtonIcon";
    }
  },

  postCreate: function() {
    this.inherited(arguments);
    dom.setSelectable(this.containerNode, false);

    // If a custom icon class has not been set for the
    // tab icon, set its width to one pixel. This ensures
    // that the height styling of the tab is maintained,
    // as it is based on the height of the icon.
    // TODO: I still think we can just set dijitTabButtonIcon to 1px in CSS <Bill>
    if(this.iconNode.className == "dijitTabButtonIcon"){
      domStyle.set(this.iconNode, "width", "1px");
    }
    
    domAttr.set(this.focusNode, "id", this.id );
    layer.register("curam/widget/_TabButton", this);
  },

  startup: function(){
    dijit.layout._StackButton.prototype.startup.apply(this, arguments);
  },

  _setCloseButtonAttr: function(/*Boolean*/ disp) {
    this._set("closeButton", disp);
    domClass.toggle(this.domNode, "dijitClosable", disp);
    this.closeNode.style.display = disp ? "" : "none";
    if(disp){
      var _nlsResources = i18n.getLocalization("dijit", "common");
      if(this.closeNode){
        domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
      }
    }else{
        //>>> addition next line only
      domClass.add(this.titleNode,"hasNoCloseButton");
      if(this._closeMenu){
        this._closeMenu.destroyRecursive();
        delete this._closeMenu;
      }
    }
  },
  /**
   * Hook for attr('disabled', ...) to work.
   * Enable or disable this button.
   */
  _setCuramDisabledAttr: function(/*Boolean*/ value) {
    this.curamDisabled = value;
    this._swapState(this.domNode, this.curamDisabled, "disabled", "enabled");
  },
  
  /**
   * Hook for attr('visible', ...) to work.
   * Show or hide this button.
   */
  _setCuramVisibleAttr: function(/*Boolean*/ value) {
    this.curamVisible = value;
    this._swapState(this.domNode, this.curamVisible, "visible", "hidden");
  },
  
  /**
   * Given a DOM node, boolean state and class names for true and false
   * alternatives, the function sets the appropriate classes on the node.
   */
  _swapState: function(node, state, classTrue, classFalse) {
    if (state) {
      domClass.replace(node, classTrue, classFalse);
    } else {
      domClass.replace(node, classFalse, classTrue);
    }
  },
  
  destroy: function() {
    // removing button, need to update all other tabs
    connect.publish("/curam/tab/labelUpdated");
    if (this._closeMenu) {
      this._closeMenu.destroyRecursive();
      delete this._closeMenu;
    }
    this.inherited(arguments);
  }
  });
  
  return _TabButton;
});

},
'dojo/_base/url':function(){
define(["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'curam/widget/FilteringSelect':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2021. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * Override of the Dojo FilteringSelect in order to get it to display
 * items in the drop down when the associated value is the empty string.
 * 
 */
define(["dijit/registry",
        "dojo/_base/declare",
        "dojo/on", 
        "dojo/dom",
        "dojo/dom-construct",
        "dojo/keys",
        "dojo/sniff",
        "dijit/form/FilteringSelect",
        "curam/widget/ComboBoxMixin"
        ], function(registry, declare, on, dom, domConstruct, keys, has) {
  
  /*
   * Modification History
   * --------------------
   * 28-Jan-2021  JD  [RTC265372] Update startup() so only role=listbox is added
   *                  for IE. Edge Chromium requires it to be combobox for JAWs
   *                  to announce it correctly and for it to be interactive.
   * 16-Dec-2019  SH  [RTC252278] Add missing dojo/keys module and prevent Enter
   *            from submitting the form on option select.
   * 18-Nov-2910  SH  [RTC252278] Added overrides to _selectOption and _onKey 
   *  				  in order to place cursor at start of selected option 
   * 07-Aug-2019  RS  [RTC242763] Added `required: false`, which overrides the 
   *                  default value 'required: True'
   * 20-Nov-2015  AZ  [CR00472692] Load custom ComboBoxMixin for accessibility.
   * 10-Mar-2014  AS  [CR00415345] Modified the role of widget 
   *                    to listbox from combobox. Also handled the
   *                  enter key on open dropdown.
   * 15-Nov-2011  PK  [CR00297778] Ported to Dojo 1.7.
   * 03-Nov-2011  JY  [CR00296248] Added a blank option to the <select> element 
   *                  where there is no option
   * 31-Oct-2011  MV  [CR00289694] Fixed the superclass' method call.
   * 25-Oct-2011  JY  [CR00295925] Updated postMixInProperties() function to
   *                  ignore handling the blank option that contains a comment.
   * 19-Oct-2011  JY  [CR00295026] Overwrite _callbackSetLabel() function to set
   *                  an particular code "__o3_INVALID" for the invalid inputs.
   * 22-Oct-2010  MK  [CR00222181] Initial version.
   */
  /**
   * @name curam.widget.FilteringSelect
   * @namespace Get it to display items in the drop down when the associated
   *              value is the empty string.
   */
  var FilteringSelect = declare("curam.widget.FilteringSelect", [dijit.form.FilteringSelect, curam.widget.ComboBoxMixin],
  /**
   * @lends curam.widget.FilteringSelect.prototype
   */
  {
      // Flag which indicates if the enter key is used on open dropdown
      enterKeyOnOpenDropDown: false,
      // This flag is set to `true` in dijit.form.FilteringSelect, which makes the screen reader 
      // read `required` for all FilteringSelect widgets.
      required: false,
    
      postMixInProperties: function(){
          /*
           * Add a blank option to the <select> element where there is no option,
           * to enable users to open a empty dropdown list in this widget.
           * 
           */
          if (!this.store) {
            if (dojo.query("> option", this.srcNodeRef)[0] == undefined) {
              domConstruct.create("option", {innerHTML:"<!--__o3_BLANK-->"}, this.srcNodeRef);
            }
          }
          
          
            if(!this.get("store") && this.srcNodeRef.value == '') {
              var srcNodeRef = this.srcNodeRef,
                  nodes = dojo.query("> option[value='']", srcNodeRef);
            
      
            if (nodes.length && nodes[0].innerHTML != "<!--__o3_BLANK-->") {
              this.displayedValue = dojo.trim(nodes[0].innerHTML);
            }
          }   
    
          this.inherited(arguments);
      },
  
      postCreate : function() {
        // Attached a keyboard event listener so that we can set a flag
        // indicating enter is pressed in open state of dropdown
        on(this.focusNode, "keydown",function(e){
          var widget = registry.byNode(dom.byId("widget_" + e.target.id)); 
          if(e.keyCode == dojo.keys.ENTER && widget._opened) {
            widget.enterKeyOnOpenDropDown = true;
           }
         });
        
        this.inherited(arguments);
      },
      
      startup : function(){
        // We have to change role to listbox as Jaws do not work correctly
        // in IE when role is combobox.
        if (has('trident')) {
          this.domNode.setAttribute("role", "listbox");
        }
        this.inherited(arguments);
      },
  
      /**
       * Overwrite _callbackSetLabel() function to make the FilteringSelect widget
       * set a particular code "__o3_INVALID" for the invalid inputs, instead
       * of setting an empty string.
       * 
         */
        _callbackSetLabel: function(
          /*Array*/ result,
          /*Object*/ query,
          /*Object*/ options,
          /*Boolean?*/ priorityChange){
        //  summary:
          //              Callback from dojo.store after lookup of user entered value finishes
    
        //  setValue does a synchronous lookup,
        //  so it calls _callbackSetLabel directly,
        //  and so does not pass dataObject
        //  still need to test against _lastQuery in case it came too late
          if((query && query[this.searchAttr] !== this._lastQuery)
              || (!query && result.length && this.get("store").getIdentity(result[0]) != this._lastQuery)){
          return;
        }
        if(!result.length){
            //#3268: don't modify display value on bad input
          //    #3285: change CSS to indicate error
            
            // CURAM CUSTOMIZATION START - This is the only customization made to
            // the ootb _callbackSetLabel method in Dojo's FilteringSelect. The
            // specific change is:
            // The second parameter below has been changed from "" to "__o3_INVALID".
            this.set("value", "__o3_INVALID", priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
            // CURAM CUSTOMIZATION END
        }else{
            this.set('item', result[0], priorityChange);
        }
      },
      
      /**
       * Override _onKey to handle pressing Enter key on a dropdown.
       */
      _onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			if(evt.charCode >= 32){
				return;
			} // alphanumeric reserved for searching

			var key = evt.charCode || evt.keyCode;

			// except for cutting/pasting case - ctrl + x/v
			if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
				return; // throw out spurious events
			}

			var pw = this.dropDown;
			var highlighted = null;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//
			//	1. when drop down is not yet shown:
			//		- if user presses the down arrow key, call loadDropDown()
			//	2. when drop down is already displayed:
			//		- on ESC key, call closeDropDown()
			//		- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(evt.altKey || evt.ctrlKey || evt.metaKey){
				return;
			} // don't process keys with modifiers  - but we want shift+TAB

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					evt.stopPropagation();
					evt.preventDefault();
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}
						// prevent submit if ENTER was to choose an item
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						/* CURAM-FIX: RTC252278 - move the cursor to the start of the input area */
						// this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
						this._setCaretPos(this.focusNode, 0); // move cursor to start and cancel highlighting

						var oldvalue = this._resetValue; 
						var newvalue = this.displayedValue;
						if (oldvalue != newvalue) {
							evt.stopPropagation();
							evt.preventDefault();
						}
						/* END CURAM-FIX */
					}
				// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
						break;
					}
					if(highlighted){
						this._selectOption(highlighted);
					}
				// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;
			}
		},
		
		/**
	       * Override _selectOption to fix cursor placement.
	       */
        _selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			/* CURAM-FIX: RTC252278 - move the cursor to the start of the input area */
			// this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._setCaretPos(this.focusNode, 0);
			/* END CURAM-FIX */

			this._handleOnChange(this.value, true);
			// Remove aria-activedescendant since the drop down is no loner visible
			// after closeDropDown() but _announceOption() adds it back in
			this.focusNode.removeAttribute("aria-activedescendant");
		}
      
  });
  
  return FilteringSelect;
});

},
'dojo/text':function(){
define(["./_base/kernel", "require", "./has", "./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if( 1 ){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});


},
'dojo/uacss':function(){
define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"],
	function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		trident = has("trident"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),
			"dj_edge": has("edge"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(trident){
		classes["dj_trident"] = true;
		classes["dj_trident" + maj(trident)] = true;
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'dijit/Tooltip':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/mouse",
	"dojo/on",
	"dojo/sniff", // has("ie"), has("trident")
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"./main"		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

	// module:
	//		dijit/Tooltip


	// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
	//		- the orient() method
	//		- the connector positioning code in show()
	//		- the dijitTooltip[Dialog] class
	//
	// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
	// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).

	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			this.ownerDocumentBody.appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode|dijit/place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse enter on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip

			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}

			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}else{
				// Not *-centered, but just above/below/after/before
				this.connectorNode.style.left = "";
				this.connectorNode.style.top = "";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;

			this.onMouseEnter = onMouseEnter || noop;
			this.onMouseLeave = onMouseLeave || noop;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected

			this.connectorNode.style.top = ""; //reset to default

			var heightAvailable = spaceAvailable.h,
				widthAvailable = spaceAvailable.w;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.style.width = "auto";

			// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
			// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
			// negative number since that causes an exception on IE.
			var size = domGeometry.position(this.domNode);
			if(has("ie") || has("trident")){
				// workaround strange IE bug where setting width to offsetWidth causes words to wrap
				size.w += 2;
			}

			var width = Math.min((Math.max(widthAvailable,1)), size.w);

			domGeometry.setMarginBox(this.domNode, {w: width});

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var bb = domGeometry.position(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(bb.h > heightAvailable){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						bb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - widthAvailable);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}

			this.onMouseEnter = this.onMouseLeave = noop;
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}
	});

	if(has("dojo-bidi")){
		MasterTooltip.extend({
			_setAutoTextDir: function(/*Object*/node){
				// summary:
				//		Resolve "auto" text direction for children nodes
				// tags:
				//		private

				this.applyTextDir(node);
				array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private

				this._set("textDir", textDir);

				if (textDir == "auto"){
					this._setAutoTextDir(this.containerNode);
				}else{
					this.containerNode.dir = this.textDir;
				}
			}
		});
	}

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit/Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: place.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		// onMouseEnter: Function?
		//		Callback function for mouse over on tooltip
		// onMouseLeave: Function?
		//		Callback function for mouse leave on tooltip

		// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
		// Possibly remove this in 2.0.   Alternately, get before/after to work.
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	// Possible states for a tooltip, see Tooltip.state property for definitions
	var DORMANT = "DORMANT",
		SHOW_TIMER = "SHOW TIMER",
		SHOWING = "SHOWING",
		HIDE_TIMER = "HIDE TIMER";

	function noop(){}

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.
		//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.

		// label: String
		//		HTML to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// hideDelay: Integer
		//		Number of milliseconds to wait after unhovering the object, before
		//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
		hideDelay: 400,

		// connectId: String|String[]|DomNode|DomNode[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node(s), the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
		position: [],

		// selector: String?
		//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
		//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
		//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
		//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
		// So, change connectId to a "", remove addTarget()/removeTarget(), etc.

		_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id, this.ownerDocument); }, this);

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id, this.ownerDocument),
					selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){ return on.selector(selector, eventType); } :
						function(eventType){ return eventType; },
					self = this;
				return [
					on(node, delegatedEvent(mouse.enter), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent("focusin"), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
					on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*OomNode|String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		getContent: function(/*DomNode*/ node){
			// summary:
			//		User overridable function that return the text to display in the tooltip.
			// tags:
			//		extension
			return this.label || this.domNode.innerHTML;
		},

		// state: [private readonly] String
		//		One of:
		//
		//		- DORMANT: tooltip not SHOWING
		//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
		//		- SHOWING: tooltip displayed
		//		- HIDE TIMER: tooltip displayed, but timer set to hide it
		state: DORMANT,
		_setStateAttr: function(val){
			if(this.state == val ||
				(val == SHOW_TIMER && this.state == SHOWING) ||
				(val == HIDE_TIMER && this.state == DORMANT)){
				return;
			}

			if(this._hideTimer){
				this._hideTimer.remove();
				delete this._hideTimer;
			}
			if(this._showTimer){
				this._showTimer.remove();
				delete this._showTimer;
			}

			switch(val){
				case DORMANT:
					if(this._connectNode){
						Tooltip.hide(this._connectNode);
						delete this._connectNode;
						this.onHide();
					}
					break;
				case SHOW_TIMER:	 // set timer to show tooltip
					// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
					if(this.state != SHOWING){
						this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
					}
					break;
				case SHOWING:		// show tooltip and clear timers
					var content = this.getContent(this._connectNode);
					if(!content){
						this.set("state", DORMANT);
						return;
					}

					// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
					Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
						lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));

					this.onShow(this._connectNode, this.position);
					break;
				case HIDE_TIMER:	// set timer set to hide tooltip
					this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
					break;
			}

			this._set("state", val);
		},

		_onHover: function(/*DomNode*/ target){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private

			if(this._connectNode && target != this._connectNode){
				// Tooltip is displaying for another node
				this.set("state", DORMANT);
			}
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"

			this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
		},

		_onUnHover: function(/*DomNode*/ target){
			// summary:
			//		Handles mouseleave event on the target node, hiding the tooltip.
			// tags:
			//		private

			this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
		},

		// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
		// Should probably remove for 2.0, but leaving for now.
		open: function(/*DomNode*/ target){
			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			this.set("state", DORMANT);
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
			this.set("state", SHOWING);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			this.set("state", DORMANT);
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		destroy: function(){
			this.set("state", DORMANT);

			// Remove connections manually since they aren't registered to be removed by _WidgetBase
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	Tooltip.defaultPosition = ["after-centered", "before-centered"];

	/*=====
	lang.mixin(Tooltip, {
		 // defaultPosition: String[]
		 //		This variable controls the position of tooltips, if the position is not specified to
		 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
		 //		possible for `dijit/place.around()`.   The recommended values are:
		 //
		 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- above-centered: tooltip is centered above anchor node
		 //		- below-centered: tooltip is centered above anchor node
		 //
		 //		The list is positions is tried, in order, until a position is found where the tooltip fits
		 //		within the viewport.
		 //
		 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
		 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
		 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
		 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
		 //		is only room below (or above) the target node, but not both.
	 });
	=====*/
	return Tooltip;
});

},
'dojo/string':function(){
define([
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});

},
'curam/util/ui/refresh/RefreshEvent':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/declare"], function(declare) {
  
  /*
   * Modification History
   * --------------------
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * @name curam.util.ui.refresh.RefreshEvent
   * @namespace Represents a UI element refresh event.
   * 
   */
  var RefreshEvent = declare("curam.util.ui.refresh.RefreshEvent", null,
  /**
   * @lends curam.util.ui.refresh.RefreshEvent.prototype
   */
  {
    /** Event type constant. */
    TYPE_ONLOAD: "onload",
    
    /** Event type constant. */
    TYPE_ONSUBMIT: "onsubmit",
    
    /** Event context constant. */
    SOURCE_CONTEXT_MAIN: "main-content",
    
    /** Event context constant. */
    SOURCE_CONTEXT_DIALOG: "dialog",
    
    /** Event context constant. */
    SOURCE_CONTEXT_INLINE: "inline",

    /** Holds the type of the event. */
    _type: null,
    
    /** Holds the context of the event. */
    _context: null,
    
    /**
     * Creates an instance of the refresh event.
     * 
     * @param {String}
     *                type The event type. Only accepted values will be the ones
     *                provided as constants in this class.
     * @param {String}
     *                context The event context. Only accepted values will be the
     *                ones provided as constants in this class.
     */
    constructor: function(type, context) {
      if (!type || !context) {
        throw "Required parameters missing.";
      }
      if (!(type == this.TYPE_ONLOAD || type == this.TYPE_ONSUBMIT)) {
        throw "Unknown type: " + type;
      }
      if (!(context == this.SOURCE_CONTEXT_DIALOG
          || context == this.SOURCE_CONTEXT_INLINE
          || context == this.SOURCE_CONTEXT_MAIN)) {
        throw "Unknown context: " + context;
      }

      this._type = type;
      this._context = context;
    },
    
    /**
     * Determines if the specified event is the same as this one.
     * 
     * @param other
     *                The event to check.
     * @returns {Boolean} True if the other event is the same, otherwise false.
     */
    equals: function(other) {
      // check for undefined, null and variable types other than object
      if (typeof other != "object") {
        return false;
      }
      
      // check for Dojo class name
      if (other.declaredClass != this.declaredClass) {
        return false;
      }
      
      return this._type === other._type
          && this._context === other._context;
    }
  });
  
  return RefreshEvent;
});

},
'dijit/dijit':function(){
define([
	"./main",
	"./_base",
	"dojo/parser",
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./layout/_LayoutWidget",
	"./form/_FormWidget",
	"./form/_FormValueWidget"
], function(dijit){

	// module:
	//		dijit/dijit

	/*=====
	return {
		// summary:
		//		A roll-up for common dijit methods
		//		All the stuff in _base (these are the function that are guaranteed available without an explicit dojo.require)
		//		And some other stuff that we tend to pull in all the time anyway
	};
	=====*/

	return dijit;
});

},
'dijit/form/_FormValueMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/lang",
	"dojo/on",
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, lang, on, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormValueMixin

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			domAttr.set(this.focusNode, 'readOnly', value);
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		}
	});
});

},
'idx/form/_CssStateMixin':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define([
"dojo", 
"dijit/dijit", 
"dijit/_WidgetBase", 
"dojo/_base/array", 
"dojo/has", 
"dojo/ready", 
"dojo/on", 
"dojo/_base/window", 
"dijit/registry",
"dojo/dom", 
"dojo/dom-class"], 
function(dojo, dijit, widgetBase, array, has, ready, on, win, registry, dom, domClass){

var CssStateMixin =  dojo.declare("idx.form._CssStateMixin", [], {
	
	cssStateNodes: {},
	hovering: false,
	active: false,

	// stateNode
	//		The original dijit domNode (inner field widget)
	
	// oneuiBaseClass
	//		The original dijit baseClass (inner field widget)

	_applyAttributes: function(){
		widgetBase.prototype._applyAttributes.apply(this, arguments);

		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		dojo.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "required"], function(attr){
			this.watch(attr, dojo.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		this._trackMouseState(this.stateNode, this.oneuiBaseClass);
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.
		if(!this.disabled){
			switch(event.type){
				case "mouseover":
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;
				case "mouseout":
					this._set("hovering", false);
					this._set("active", false);
					break;
				case "mousedown":
				case "touchstart":
					this._set("active", true);
					break;
				case "mouseup":
				case "touchend":
					this._set("active", false);
					break;
			}
		}
	},
	
	_setStateClass: function(){
		// Compute new set of classes
		var newStateClasses = this._getModifiedClasses(this.oneuiBaseClass);
		this._applyStateClass(this.stateNode, newStateClasses);
		newStateClasses = this._getModifiedClasses(this.baseClass);
		this._applyStateClass(this.domNode, newStateClasses);
	},
	
	_getModifiedClasses: function(/*String*/className){
		var clazz = className.split(" ");
		function multiply(modifier){
			clazz = clazz.concat(dojo.map(clazz, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
		if(this.checked){
			multiply(checkedState);
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}
		if(this.required){
			multiply("Required");
		}
		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this.focused){
			multiply("Focused");
		}
		return clazz;
	},
	
	_applyStateClass: function(/*DomNode*/ node, /*Array*/classes){
		// Compute new set of classes
		// Remove old state classes and add new ones.
		// For performance concerns we only write into stateNode.className and domNode.className once.
		var classHash = {};	// set of all classes (state and otherwise) for node
		
		dojo.forEach(node.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in node){
			dojo.forEach(node._stateClasses, function(c){ delete classHash[c]; });
		}

		dojo.forEach(classes, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		node.className = newClasses.join(" ");
		node._stateClasses = classes;
	},
	
	_subnodeCssMouseEvent: function(node, clazz, evt){
		// summary:
		//		Handler for hover/active mouse event on widget's subnode
		if(this.disabled || this.readOnly){
			return;
		}
		var classSet = clazz.split(/\s+/);
		function hover(isHovering){
			array.forEach(classSet, function(clazz){
				domClass.toggle(node, clazz+"Hover", isHovering);
			})
		}
		function active(isActive){
			array.forEach(classSet, function(clazz){
				domClass.toggle(node, clazz+"Active", isActive);
			})
		}
		function focused(isFocused){
			array.forEach(classSet, function(clazz){
				domClass.toggle(node, clazz+"Focused", isFocused);
			})
		}
		switch(evt.type){
			case "mouseover":
				hover(true);
				break;
			case "mouseout":
				hover(false);
				active(false);
				break;
			case "mousedown":
			case "touchstart":
				active(true);
				break;
			case "mouseup":
			case "touchend":
				active(false);
				break;
			case "focus":
			case "focusin":
				focused(true);
				break;
			case "blur":
			case "focusout":
				focused(false);
				break;
		}
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//
		//		- fooActive: if the user is currently pressing down the mouse button while over the node
		//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//		- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow)

		// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
		// when node is hovered/active
		node._cssState = clazz;
	}
});
ready(function(){
	// Document level listener to catch hover etc. events on widget root nodes and subnodes.
	// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
	// have been hovered or unhovered (try test_Accordion.html)
	function handler(evt){
		// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
		// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
		// such events shouldn't be interpreted as a mouseleave on the widget.
		if(!dom.isDescendant(evt.relatedTarget, evt.target)){
			for(var node = evt.target; node && node != evt.relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.oneuiBaseNode){
							widget._cssMouseEvent(evt);
						}else{
							if(node == widget.domNode){
								// event on the widget's root node
								widget._cssMouseEvent(evt);
							}else{
								// event on widget's sub-node
								widget._subnodeCssMouseEvent(node, node._cssState, evt);
							}
						}
					}
				}
			}
		}
	}
	function ieHandler(evt){
		evt.target = evt.srcElement;
		handler(evt);
	}

	// Use addEventListener() (and attachEvent() on IE) to catch the relevant events even if other handlers
	// (on individual nodes) call evt.stopPropagation() or event.stopEvent().
	// Currently typematic.js is doing that, not sure why.
	// Don't monitor mouseover/mouseout on mobile because iOS generates "phantom" mouseover/mouseout events when
	// drag-scrolling, at the point in the viewport where the drag originated.   Test the Tree in api viewer.
	var body = win.body(),
		types = (has("touch") ? [] : ["mouseover", "mouseout"]).concat(["mousedown", "touchstart", "mouseup", "touchend"]);
	array.forEach(types, function(type){
		if(body.addEventListener){
			body.addEventListener(type, handler, true);	// W3C
		}else{
			body.attachEvent("on"+type, ieHandler);	// IE
		}
	});

	// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
	// However, don't track focus events on the widget root nodes, because focus is tracked via the
	// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
	// nodes or a subwidget's node or a popup node, etc.)
	// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
	on(body, "focusin, focusout", function(evt){
		var node = evt.target;
		if(node._cssState && !node.getAttribute("widgetId")){
			var widget = registry.getEnclosingWidget(node);
			widget._subnodeCssMouseEvent(node, node._cssState, evt);
		}
	});
});
return CssStateMixin;
});
},
'dijit/form/_FormWidgetMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/sniff", // has("webkit")
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"    // a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);

			// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
			// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
			if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
				domAttr.set(this.focusNode, 'disabled', value);
			}else{
				this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
			}

			// And also set disabled on the hidden <input> node
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/a11yclick':function(){
define([
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/mouse",
	"dojo/on",
	"dojo/touch" // touch support for click is now there
], function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
});

},
'dijit/Destroyable':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/declare"
], function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
});

},
'curam/inspection/Layer':function(){
define(['curam/define'], function(def) {
 
  curam.define.singleton("curam.inspection.Layer", {
    /* Called from every module participating in inspecting */
    register: function(moduleName, inst) {
      require(["curam/util"]);
      var tWin = curam.util.getTopmostWindow();
      return tWin.inspectionManager ? tWin.inspectionManager.observe(moduleName, inst): null;
    }
  });
  var ref = curam.inspection.Layer;
  require(["curam/util"]);
  ref.tWin = curam.util.getTopmostWindow();
  var directs = ref.tWin.inspectionManager ? ref.tWin.inspectionManager.getDirects() : [];
  if (directs.length > 0) {
    require(directs);
  }
      
  return ref;
});
},
'dijit/WidgetSet':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.global
	"./registry"	// to add functions to dijit.registry
], function(array, declare, kernel, registry){

	// module:
	//		dijit/WidgetSet

	var WidgetSet = declare("dijit.WidgetSet", null, {
		// summary:
		//		A set of widgets indexed by id.
		//		Deprecated, will be removed in 2.0.
		//
		// example:
		//		Create a small list of widgets:
		//		|	require(["dijit/WidgetSet", "dijit/registry"],
		//		|		function(WidgetSet, registry){
		//		|		var ws = new WidgetSet();
		//		|		ws.add(registry.byId("one"));
		//		|		ws.add(registry.byId("two"));
		//		|		// destroy both:
		//		|		ws.forEach(function(w){ w.destroy(); });
		//		|	});

		constructor: function(){
			this._hash = {};
			this.length = 0;
		},

		add: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(this._hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			this._hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
			//		removes the reference.
			if(this._hash[id]){
				delete this._hash[id];
				this.length--;
			}
		},

		forEach: function(/*Function*/ func, /* Object? */thisObj){
			// summary:
			//		Call specified function for each widget in this set.
			//
			// func:
			//		A callback function to run for each item. Is passed the widget, the index
			//		in the iteration, and the full hash, similar to `array.forEach`.
			//
			// thisObj:
			//		An optional scope parameter
			//
			// example:
			//		Using the default `dijit.registry` instance:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.forEach(function(widget){
			//		|			console.log(widget.declaredClass);
			//		|		});
			//		|	});
			//
			// returns:
			//		Returns self, in order to allow for further chaining.

			thisObj = thisObj || kernel.global;
			var i = 0, id;
			for(id in this._hash){
				func.call(thisObj, this._hash[id], i++, this._hash);
			}
			return this;	// dijit/WidgetSet
		},

		filter: function(/*Function*/ filter, /* Object? */thisObj){
			// summary:
			//		Filter down this WidgetSet to a smaller new WidgetSet
			//		Works the same as `array.filter` and `NodeList.filter`
			//
			// filter:
			//		Callback function to test truthiness. Is passed the widget
			//		reference and the pseudo-index in the object.
			//
			// thisObj: Object?
			//		Option scope to use for the filter function.
			//
			// example:
			//		Arbitrary: select the odd widgets in this list
			//		|	
			//		|		
			//		|	
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.filter(function(w, i){
			//		|			return i % 2 == 0;
			//		|		}).forEach(function(w){ /* odd ones */ });
			//		|	});

			thisObj = thisObj || kernel.global;
			var res = new WidgetSet(), i = 0, id;
			for(id in this._hash){
				var w = this._hash[id];
				if(filter.call(thisObj, w, i++, this._hash)){
					res.add(w);
				}
			}
			return res; // dijit/WidgetSet
		},

		byId: function(/*String*/ id){
			// summary:
			//		Find a widget in this list by it's id.
			// example:
			//		Test if an id is in a particular WidgetSet
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		var ws = new WidgetSet();
			//		|		ws.add(registry.byId("bar"));
			//		|		var t = ws.byId("bar") // returns a widget
			//		|		var x = ws.byId("foo"); // returns undefined
			//		|	});

			return this._hash[id];	// dijit/_WidgetBase
		},

		byClass: function(/*String*/ cls){
			// summary:
			//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
			//
			// cls: String
			//		The Class to scan for. Full dot-notated string.
			//
			// example:
			//		Find all `dijit.TitlePane`s in a page:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });
			//		|	});

			var res = new WidgetSet(), id, widget;
			for(id in this._hash){
				widget = this._hash[id];
				if(widget.declaredClass == cls){
					res.add(widget);
				}
			 }
			 return res; // dijit/WidgetSet
		},

		toArray: function(){
			// summary:
			//		Convert this WidgetSet into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		array.map(registry.toArray(), function(w){ return w.domNode; });
			//		|	});


			var ar = [];
			for(var id in this._hash){
				ar.push(this._hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		map: function(/* Function */func, /* Object? */thisObj){
			// summary:
			//		Create a new Array from this WidgetSet, following the same rules as `array.map`
			// example:
			//		|	require(["dijit/WidgetSet", "dijit/registry"],
			//		|		function(WidgetSet, registry){
			//		|		var nodes = registry.map(function(w){ return w.domNode; });
			//		|	});
			//
			// returns:
			//		A new array of the returned values.
			return array.map(this.toArray(), func, thisObj); // Array
		},

		every: function(func, thisObj){
			// summary:
			//		A synthetic clone of `array.every` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first false return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || kernel.global;
			var x = 0, i;
			for(i in this._hash){
				if(!func.call(thisObj, this._hash[i], x++, this._hash)){
					return false; // Boolean
				}
			}
			return true; // Boolean
		},

		some: function(func, thisObj){
			// summary:
			//		A synthetic clone of `array.some` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first true return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || kernel.global;
			var x = 0, i;
			for(i in this._hash){
				if(func.call(thisObj, this._hash[i], x++, this._hash)){
					return true; // Boolean
				}
			}
			return false; // Boolean
		}

	});

	// Add in 1.x compatibility methods to dijit/registry.
	// These functions won't show up in the API doc but since they are deprecated anyway,
	// that's probably for the best.
	array.forEach(["forEach", "filter", "byClass", "map", "every", "some"], function(func){
		registry[func] = WidgetSet.prototype[func];
	});


	return WidgetSet;
});

},
'dojo/store/util/SimpleQueryEngine':function(){
define(["../../_base/array" /*=====, "../api/Store" =====*/], function(arrayUtil /*=====, Store =====*/){

// module:
//		dojo/store/util/SimpleQueryEngine

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	//		used to match strings by more complex expressions
	//		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo/store/api/Store.QueryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						// an object can provide a test method, which makes it work with regex
						if(!required.test(object[key], object)){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		var sortSet = options && options.sort;
		if(sortSet){
			results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
				for(var sort, i=0; sort = sortSet[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					// valueOf enables proper comparison of dates
					aValue = aValue != null ? aValue.valueOf() : aValue;
					bValue = bValue != null ? bValue.valueOf() : bValue;
					if (aValue != bValue){
						return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};

});

},
'dijit/typematic':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect", // connect._keyPress
	"dojo/_base/lang", // lang.mixin, lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./main"        // setting dijit.typematic global
], function(array, connect, lang, on, has, dijit){

	// module:
	//		dijit/typematic

	var typematic = (dijit.typematic = {
		// summary:
		//		These functions are used to repetitively call a user specified callback
		//		method when a specific key or mouse click over a specific DOM node is
		//		held down for a specific amount of time.
		//		Only 1 such event is allowed to occur on the browser page at 1 time.

		_fireEventAndReload: function(){
			this._timer = null;
			this._callback(++this._count, this._node, this._evt);

			// Schedule next event, timer is at most minDelay (default 10ms) to avoid
			// browser overload (particularly avoiding starving DOH robot so it never gets to send a mouseup)
			this._currentTimeout = Math.max(
				this._currentTimeout < 0 ? this._initialDelay :
					(this._subsequentDelay > 1 ? this._subsequentDelay : Math.round(this._currentTimeout * this._subsequentDelay)),
				this._minDelay);
			this._timer = setTimeout(lang.hitch(this, "_fireEventAndReload"), this._currentTimeout);
		},

		trigger: function(/*Event*/ evt, /*Object*/ _this, /*DOMNode*/ node, /*Function*/ callback, /*Object*/ obj, /*Number?*/ subsequentDelay, /*Number?*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start a timed, repeating callback sequence.
			//		If already started, the function call is ignored.
			//		This method is not normally called by the user but can be
			//		when the normal listener code is insufficient.
			// evt:
			//		key or mouse event object to pass to the user callback
			// _this:
			//		pointer to the user's widget space.
			// node:
			//		the DOM node object to pass the the callback function
			// callback:
			//		function to call until the sequence is stopped called with 3 parameters:
			// count:
			//		integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped
			// node:
			//		the DOM node object passed in
			// evt:
			//		key or mouse event object
			// obj:
			//		user space object used to uniquely identify each typematic sequence
			// subsequentDelay:
			//		if > 1, the number of milliseconds until the 3->n events occur
			//		or else the fractional time multiplier for the next event's delay, default=0.9
			// initialDelay:
			//		the number of milliseconds until the 2nd event occurs, default=500ms
			// minDelay:
			//		the maximum delay in milliseconds for event to fire, default=10ms
			if(obj != this._obj){
				this.stop();
				this._initialDelay = initialDelay || 500;
				this._subsequentDelay = subsequentDelay || 0.90;
				this._minDelay = minDelay || 10;
				this._obj = obj;
				this._node = node;
				this._currentTimeout = -1;
				this._count = -1;
				this._callback = lang.hitch(_this, callback);
				this._evt = { faux: true };
				for(var attr in evt){
					if(attr != "layerX" && attr != "layerY"){ // prevent WebKit warnings
						var v = evt[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							this._evt[attr] = v
						}
					}
				}
				this._fireEventAndReload();
			}
		},

		stop: function(){
			// summary:
			//		Stop an ongoing timed, repeating callback sequence.
			if(this._timer){
				clearTimeout(this._timer);
				this._timer = null;
			}
			if(this._obj){
				this._callback(-1, this._node, this._evt);
				this._obj = null;
			}
		},

		addKeyListener: function(/*DOMNode*/ node, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a specific typematic key.
			//		See also the trigger method for other parameters.
			// keyObject:
			//		an object defining the key to listen for:
			//
			//		- keyCode: the keyCode (number) to listen for, used for non-printable keys
			//		- charCode: the charCode (number) to listen for, used for printable keys
			//		- charOrCode: deprecated, use keyCode or charCode
			//		- ctrlKey: desired ctrl key state to initiate the callback sequence:
			//			- pressed (true)
			//			- released (false)
			//			- either (unspecified)
			//		- altKey: same as ctrlKey but for the alt key
			//		- shiftKey: same as ctrlKey but for the shift key
			// returns:
			//		a connection handle

			// Setup keydown or keypress listener depending on whether keyCode or charCode was specified.
			// If charOrCode is specified use deprecated connect._keypress synthetic event (remove for 2.0)
			var type = "keyCode" in keyObject ? "keydown" : "charCode" in keyObject ? "keypress" : connect._keypress,
				attr = "keyCode" in keyObject ? "keyCode" : "charCode" in keyObject ? "charCode" : "charOrCode";

			var handles = [
				on(node, type, lang.hitch(this, function(evt){
					if(evt[attr] == keyObject[attr] &&
						(keyObject.ctrlKey === undefined || keyObject.ctrlKey == evt.ctrlKey) &&
						(keyObject.altKey === undefined || keyObject.altKey == evt.altKey) &&
						(keyObject.metaKey === undefined || keyObject.metaKey == (evt.metaKey || false)) && // IE doesn't even set metaKey
						(keyObject.shiftKey === undefined || keyObject.shiftKey == evt.shiftKey)){
						evt.stopPropagation();
						evt.preventDefault();
						typematic.trigger(evt, _this, node, callback, keyObject, subsequentDelay, initialDelay, minDelay);
					}else if(typematic._obj == keyObject){
						typematic.stop();
					}
				})),
				on(node, "keyup", lang.hitch(this, function(){
					if(typematic._obj == keyObject){
						typematic.stop();
					}
				}))
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		},

		addMouseListener: function(/*DOMNode*/ node, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a typematic mouse click.
			//		See the trigger method for other parameters.
			// returns:
			//		a connection handle
			var handles = [
				on(node, "mousedown", lang.hitch(this, function(evt){
					evt.preventDefault();
					typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
				})),
				on(node, "mouseup", lang.hitch(this, function(evt){
					if(this._obj){
						evt.preventDefault();
					}
					typematic.stop();
				})),
				on(node, "mouseout", lang.hitch(this, function(evt){
					if(this._obj){
						evt.preventDefault();
					}
					typematic.stop();
				})),
				on(node, "dblclick", lang.hitch(this, function(evt){
					evt.preventDefault();
					if(has("ie") < 9){
						typematic.trigger(evt, _this, node, callback, node, subsequentDelay, initialDelay, minDelay);
						setTimeout(lang.hitch(this, typematic.stop), 50);
					}
				}))
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		},

		addListener: function(/*Node*/ mouseNode, /*Node*/ keyNode, /*Object*/ keyObject, /*Object*/ _this, /*Function*/ callback, /*Number*/ subsequentDelay, /*Number*/ initialDelay, /*Number?*/ minDelay){
			// summary:
			//		Start listening for a specific typematic key and mouseclick.
			//		This is a thin wrapper to addKeyListener and addMouseListener.
			//		See the addMouseListener and addKeyListener methods for other parameters.
			// mouseNode:
			//		the DOM node object to listen on for mouse events.
			// keyNode:
			//		the DOM node object to listen on for key events.
			// returns:
			//		a connection handle
			var handles = [
				this.addKeyListener(keyNode, keyObject, _this, callback, subsequentDelay, initialDelay, minDelay),
				this.addMouseListener(mouseNode, _this, callback, subsequentDelay, initialDelay, minDelay)
			];
			return { remove: function(){
				array.forEach(handles, function(h){
					h.remove();
				});
			} };
		}
	});

	return typematic;
});

},
'dijit/MenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/sniff", // has("ie")
	"dojo/_base/lang", // lang.hitch
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, kernel, has, lang,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

	// module:
	//		dijit/MenuItem

	var MenuItem = declare("dijit.MenuItem" + (has("dojo-bidi") ? "_NoBidi" : ""),
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin], {
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text as HTML
		label: "",
		_setLabelAttr: function(val){
			this._set("label", val);
			var shortcutKey = "";
			var text;
			var ndx = val.search(/{\S}/);
			if(ndx >= 0){
				shortcutKey = val.charAt(ndx + 1);
				var prefix = val.substr(0, ndx);
				var suffix = val.substr(ndx + 3);
				text = prefix + shortcutKey + suffix;
				val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
			}else{
				text = val;
			}
			this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
			this.containerNode.innerHTML = val;
			this._set('shortcutKey', shortcutKey);
		},

		/*=====
		// shortcutKey: [readonly] String
		//		Single character (underlined when the parent Menu is focused) used to navigate directly to this widget,
		//		also known as [a mnemonic](http://en.wikipedia.org/wiki/Mnemonics_(keyboard%29).
		//		This is denoted in the label by surrounding the single character with {}.
		//		For example, if label="{F}ile", then shortcutKey="F".
		shortcutKey: "",
		=====*/

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination, a control, alt, etc. modified keystroke meant to
		//		execute the menu item regardless of where the focus is on the page.
		//
		//		Note that although Menu can display accelerator keys, there is no infrastructure to actually catch and
		//		execute those accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this._set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id + "_text";
			domAttr.set(this.containerNode, "id", label); // only needed for backward compat
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel"); // only needed for backward compat
			}
			dom.setSelectable(this.domNode, false);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},

		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			if(this.accelKeyNode){
				this.accelKeyNode.style.display = value ? "" : "none";
				this.accelKeyNode.innerHTML = value;
				//have to use colSpan to make it work in IE
				domAttr.set(this.containerNode, 'colSpan', value ? "1" : "2");
			}
			this._set("accelKey", value);
		}
	});

	if(has("dojo-bidi")){
		MenuItem = declare("dijit.MenuItem", MenuItem, {
			_setLabelAttr: function(val){
				this.inherited(arguments);
				if(this.textDir === "auto"){
					this.applyTextDir(this.textDirNode);
				}
			}
		});
	}

	return MenuItem;
});

},
'dijit/layout/TabController':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch lang.trim
	"./StackController",
	"../registry",
	"../Menu",
	"../MenuItem",
	"curam/inspection/Layer",
	"dojo/text!./templates/_TabButton.html",
	"curam/widget/_TabButton",
	"curam/widget/MenuItem",
	"dojo/i18n!../nls/common"
], function(declare, dom, domAttr, domClass, has, i18n, lang, StackController, registry, Menu, MenuItem, lm, template, CuramTabButton, CuramMenuItem){

    // module:
    // dijit/layout/TabController
        /* CURAM-FIX: Extend TabController to allow proper disabling of tab buttons. */

    /* CURAM-FIX: use our own _TabButton implementation. */
    var TabButton = CuramTabButton;
    /* END CURAM-FIX */

	if(has("dojo-bidi")){
		TabButton = declare("dijit.layout._TabButton", TabButton, {
		_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				this.applyTextDir(this.iconNode, this.iconNode.alt);
			}
		});
	}

	var TabController = declare("dijit.layout.TabController", StackController, {
		// summary:
		// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
		//		Used internally by `dijit/layout/TabContainer`.
		// description:
		//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
		//		TabController also monitors the TabContainer, and whenever a pane is
		//		added or deleted updates itself accordingly.
		// tags:
		//		private

		baseClass: "dijitTabController",

		templateString: "<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'></div>",

		// tabPosition: String
		//		Defines where tabs go relative to the content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		buttonWidget: TabButton,
		
		/* CURAM-FIX: added function */
		startup: function() {
		  this.inherited(arguments);

                  /* CURAM-FIX: When a new tab control button is added,
                   * connect a function that will remove the button when page
                   * is made invisible. */
                  this.connect(this, "onAddChild", function(page, insertIndex) {
                    var controller = this;
                    // store the page id for later use when positioning control buttons
                    page.controlButton._curamPageId = page.id;
                    // remove control button when the page is hiden,
                    // add it back when redisplayed
                    page.controlButton.connect(page.controlButton, "_setCuramVisibleAttr",
                        function() {
                          if (page.controlButton.curamVisible) {
                            // show button
                            // find the position at which to insert it
                            var actualChildIds = dojo.map(controller.getChildren(),
                                function(btn) { return btn._curamPageId; });
                            var tabWidgetId = curam.tab.getTabWidgetId(
                                curam.tab.getContainerTab(page.domNode));
                            var index = curam.util.TabNavigation.getInsertIndex(
                                tabWidgetId, actualChildIds, page.id);

                            // If the focus is currently on the tab that was last
                            // selected, set the resetFocus flag.
                            var resetFocus = false;
                            if (curam.util.getTopmostWindow().curam.util.tabButtonClicked && 
                               (document.activeElement === curam.util.getTopmostWindow().curam.util.tabButtonClicked)) {
                              resetFocus = true;
                            }

                            // and display it
                            controller.addChild(page.controlButton, index);
                            
                            // After the tab has been added to the controller,
                            // if the focus has moved away from the last selected
                            // tab and the resetFocus flag has been set, move the
                            // focus back to the tab.
                            if (resetFocus && (document.activeElement !== curam.util.getTopmostWindow().curam.util.tabButtonClicked)) {
                              curam.util.getTopmostWindow().curam.util.tabButtonClicked.focus();
                            }

                          } else {
                            // hide the button
                            var button = page.controlButton;
                            // only remove if not already removed
                            if (dojo.indexOf(controller.getChildren(), button) != -1) {
                              controller.removeChild(button);
                            }
                          }
                        });
                  });
                  /* END CURAM-FIX */
		},

		// buttonWidgetCloseClass: String
		//		Class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitTabCloseButton",

		postCreate: function(){
			this.inherited(arguments);
            /* CURAM-FIX Added inspection hookpoint */
			lm.register("dijit/layout/TabController", this);
			/* END CURAM-FIX */
			// Setup a close menu to be shared between all the closable tabs (excluding disabled tabs)
			var closeMenu = new Menu({
				id: this.id + "_Menu",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				targetNodeIds: [this.domNode],
				selector: function(node){
					return domClass.contains(node, "dijitClosable") && !domClass.contains(node, "dijitTabDisabled");
				}
			});
			this.own(closeMenu);
			
			var _nlsResources = i18n.getLocalization("dijit", "common"),
				controller = this;
			closeMenu.addChild(new MenuItem({
				label: _nlsResources.itemClose,
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				onClick: function(evt){
					var button = registry.byNode(this.getParent().currentTarget);
					controller.onCloseButtonClick(button.page);
				}
			}));
                        /* CURAM-FIX: addition */
                        //>>> addition next line had to add "dijit."
			var _nlsResourcesCuram = i18n.getLocalization("curam.application", "TabMenu"),
			closeAllMI = new CuramMenuItem({
                          onClickValue: "_onClickAll",
                          label: _nlsResourcesCuram["close.all.tabs.text"],
                          dir: this.dir,
                          lang: this.lang,
                          textDir: this.textDir,
                          onClick: function(evt){
                            this._onClickAll();
                          }
                          });
                        
                        closeMenu.addChild(closeAllMI);
                  /* END CURAM-FIX */


		},

                /* CURAM-FIX: addition */
                /**
                 * Called whenever one of my child buttons is pressed in an attempt to select a page.
                 * @private
                 */
                onButtonClick: function(/*dijit._Widget*/ page) {
                  if (!page.controlButton.get("curamDisabled")) {
                    var container = dijit.byId(this.containerId);
                    container.selectChild(page);
                  }
                }
                /* END CURAM-FIX */
	});

	TabController.TabButton = TabButton;	// for monkey patching

	return TabController;
});

},
'idx/util':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or 
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 
define(["dojo/_base/lang",
        "idx/main",
        "dojo/_base/kernel",
        "dojo/has",
		"dojo/aspect",
        "dojo/_base/xhr",
        "dojo/_base/window",
        "dojo/_base/url",
        "dojo/date/stamp",
        "dojo/json",
        "dojo/string",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/dom-geometry",
        "dojo/io-query",
        "dojo/query",
        "dojo/NodeList-dom",
		"dojo/Stateful",
        "dijit/registry",
        "dijit/form/_FormWidget",
        "dijit/_WidgetBase",
        "dojo/_base/sniff",
        "dijit/_base/manager"], // temporarily resolve dijit.byid() uncaught exception issue in aprser 
		function(dLang,				// dojo/_base/lang
				 iMain,				// idx
		         dKernel, 			// dojo/_base/kernel
		     	 dHas,				// dojo/has
				 dAspect,			// dojo/aspect
		     	 dXhr,				// dojo/_base/xhr
   		    	 dWindow,			// dojo/_base/window
   		     	 dURL,				// dojo/_base/url
   		     	 dDateStamp,		// dojo/date/stamp
	   		     dJson,				// dojo/json
	   		     dString,			// dojo/string
				 dDomClass,			// dojo/dom-class (for dDomClass.add)
				 dDomStyle,			// dojo/dom-style (for dDomStyle.getComputedStyle/set)
				 dDomAttr,			// dojo/dom-attr
				 dDomConstruct,		// dojo/dom-construct
				 dDomGeo,			// dojo/dom-geometry (for dDomGeo.getMarginBox)
				 dIOQuery,			// dojo/io-query
				 dQuery,			// dojo/query
				 dNodeList,			// dojo/NodeList-dom
				 dStateful,			// dojo/Stateful
				 dRegistry,			// dijit/registry
				 dFormWidget,		// dijit/form/_FormWidget
				 dWidget)			// dijit/_WidgetBase
{
    /**
 	 * @name idx.util
 	 * @namespace Provides Javascript utility methods in addition to those provided by Dojo.
 	 */
	var iUtil = dLang.getObject("util", true, iMain);
	
	/**
  	 * @public
  	 * @function
 	 * @name idx.util.getVersion
 	 * @description Returns the IDX toolkit version string from the "version.txt" file embedded in the toolkit.
 	 * @param {Boolean} full A boolean value indicating if the full version or partial version is desired.
 	 */
	iUtil.getVersion = function(full) {
		var params = {
			url: dKernel.moduleUrl("idx", "version.txt"),
			showProgress: false,
			handleAs: "json",
			load: function(response, ioArgs) {
				var msg = response.version;
				if(full) {
					msg += "-";
					msg += response.revision;
				}
				console.debug(msg);
			},
			error: function(response, ioArgs) {
				console.debug(response);
				return;
			}
		};
		dXhr.xhrGet(params);
	};
	
	/**
  	 * @public
  	 * @function
 	 * @name idx.util.getOffsetPosition
 	 * @description Returns the pixel offset from top-left for a given node relative to a "root" node.
 	 * @param {Node} node The node for which the offset is desired.
 	 * @param {Node} root The optional ancestor node of the first specified node.  If not specified
 	 *                    then the Window body tag is used.
 	 * @return {Object} The returned value has two fields: "l" and "t" representing "left offset" and 
 	 *                  "top offset", respectively.  Results are undefined if the "root" node is not an
 	 *                  ancestor of the first specified node.
 	 */
	iUtil.getOffsetPosition = function(node, root) {
		var body = dWindow.body();
		root = root || body;
		var n = node;
		
		var l = 0;
		var t = 0;
		
		while (n !== root) {
			// avoid infinite loop if root is not ancestor of node
			if (n === body) throw "idx.util.getOffsetPosition: specified root is not ancestor of specified node";
			
			// otherwise accumulate the offsets and move on to the parent
			l += n.offsetLeft;
			t += n.offsetTop;
			n = n.offsetParent;
		}
		return {l: l, t: t};
	};

	/**
  	 * @public
  	 * @function
 	 * @name idx.util.typeOfObject
 	 * @description Provides a type for the specified object based on the locally-scoped
 	 *              "val2type" function from "dojo/parser" module.
 	 * @param {Any} value The value for which the type is desired.
 	 * @return {String} Possible return values include: "string", "undefined", "number", "boolean", 
 	 *                  "function", "array", "date", "url" and "object".
 	 */
	iUtil.typeOfObject = function(/*Object*/ value){
		// summary:
		//		Returns name of type of given value.

		if(dLang.isString(value)){ return "string"; }
		if(typeof value == "undefined") { return "undefined"; }
		if(typeof value == "number"){ return "number"; }
		if(typeof value == "boolean"){ return "boolean"; }
		if(dLang.isFunction(value)){ return "function"; }
		if(dLang.isArray(value)){ return "array"; } // typeof [] == "object"
		if(value instanceof Date) { return "date"; } // assume timestamp
		if(value instanceof dURL){ return "url"; }
		return "object";
	};

	/**
  	 * @public
  	 * @function
 	 * @name idx.util.typeOfObject
 	 * @description Provides conversion of one object (or string) to another type based on
 	 *              the locally-scoped "str2obj" function from the "dojo/parser" module.
 	 * @param {String|Any} value The value to be converted.
 	 * @param {String} type The Type to convert the object to ("string", "number", "boolean", 
 	 *                      "function", "array", "date", or "url").  If not provided then 
 	 *                      string values are parsed as JSON and non-string value are returned as-is.
 	 * 
 	 * @return {Object} The converted value of the object according to the specified "type".
 	 */
	iUtil.parseObject = function(/*Object*/ value, /*String*/ type){
		var lastIndex = 0;
		// summary:
		//		Convert given string value to given type
		switch(type){
			case "regex": 
				value = "" + value;
				lastIndex = value.lastIndexOf('/');
				if ((value.length>2) && (value.charAt(0) == '/') && (lastIndex > 0)) {
					return new RegExp(value.substring(1,lastIndex), 
									  ((lastIndex==value.length-1)?undefined:value.substring(lastIndex+1)));
				} else {
					return new RegExp(value);
				}
				break;
			case "null":
				return null;
			case "undefined":
				return undefined;
			case "string":
				return "" + value;
			case "number":
				if (typeof value == "number") return value;
				return value.length ? Number(value) : NaN;
			case "boolean":
				// for checked/disabled value might be "" or "checked".  interpret as true.
				return (typeof value == "boolean") ? value : !(value.toLowerCase()=="false");
			case "function":
				if(dLang.isFunction(value)){
					// IE gives us a function, even when we say something like onClick="foo"
					// (in which case it gives us an invalid function "function(){ foo }"). 
					//  Therefore, convert to string
					value=value.toString();
					value=dLang.trim(value.substring(value.indexOf('{')+1, value.length-1));
				}
				try{
					if(value === "" || value.search(/[^\w\.]+/i) != -1){
						// The user has specified some text for a function like "return x+5"
						return new Function(value);
					}else{
						// The user has specified the name of a function like "myOnClick"
						// or a single word function "return"
						return dLang.getObject(value, false) || new Function(value);
					}
				}catch(e){ return new Function(); }
			case "array":
				if (dLang.isArray(value)) return value;
				return value ? value.split(/\s*,\s*/) : [];
			case "date":
				if (value instanceof Date) return value;
				switch(value){
					case "": return new Date("");	// the NaN of dates
					case "now": return new Date();	// current date
					default: {
						return dDateStamp.fromISOString(value);
					}
				}
			case "url":
				if(value instanceof dURL){ return value; }
				return dKernel.baseUrl + value;
			default:
				if (iUtil.typeOfObject(value) == "string") {
					return dJson.parse(value);
				} else {
					return value;
				}
		}
	};

	/**
  	 * @public
  	 * @function
 	 * @name idx.util.getCSSOptions
 	 * @description Creates a temporary div as a child of the optional parent (otherwise the body node),
 	 *              applies the specified CSS class to the div and extracts the query-string from the 
 	 *              background image of the created div to determine the CSS options.  The parameters in
 	 *              query string are converted to specific object types according to the optionally specified
 	 *              "guide" object which is checked for attributes with names in common with the provided 
 	 *              parameters (see idx.util.mixin).  This conversion is done in much the same way Dojo 1.6 
 	 *              parser converted string attribute values to the proper type for the created widget's attributes.
 	 * @param {String} className The CSS class name to use for getting the options.
 	 * @param {Node} parentNode The optional (but recommended) parent node parameter for the scope in which
 	 *                          to create the temporary node.
 	 * @param {Object} guide The optional guide to help in converting the CSS options to objects. 
 	 * 
 	 * @return {Object} The Object containing the CSS options with the attribute types matching the
 	 *                  specified guide where applicable.
 	 */
    iUtil.getCSSOptions = function(/*String*/  className,
                                   /*Node?*/   parentNode,
                                   /*Object?*/ guide,
                                   /*Object?*/ fallback) {
            var body = dWindow.body();
            if ((! parentNode) || (("canHaveHTML" in parentNode) && (! parentNode.canHaveHTML))) {
                parentNode = body;
            }
            
            // determine if the parent node is rooted in the body
            var rooted = false;
            var trav = parentNode;
            while (trav && (!rooted)) {
            	if (trav === body) rooted = true;
            	trav = trav.parentNode;
            }
            var root = null;
			if (!rooted) {
				trav = parentNode;
				var classes = [];
				while (trav) {
					classes.push(dDomAttr.get(trav, "class"));
					trav = trav.parentNode;
				}
				classes.reverse();
				var root = dDomConstruct.create("div",{style: "visibility: hidden; display: none;"},body,"last");
				var trav = root; 
				for (var index = 0; index < classes.length; index++) {
					var classAttr = classes[index];
					if (classAttr) classAttr = dString.trim(classAttr);
					if (classAttr && classAttr.length == 0) classAttr = null;
					var attrs = (classAttr) ? {"class": classAttr} : null;
					trav = dDomConstruct.create("div", attrs, trav, "last");
				}					
				parentNode = trav;
			}
			            
            var optionElem = dDomConstruct.create("div", null, parentNode);
        	dDomClass.add(optionElem, className);
        	var myStyle = dDomStyle.getComputedStyle(optionElem);
        	var bgImage = null;
        	if (myStyle) {
        		bgImage = "" + myStyle.backgroundImage;
        	}
        	dDomConstruct.destroy(optionElem);
            if (root) dDomConstruct.destroy(root);
            
            var noURL = ((! bgImage)
            			  || (bgImage.length < 5) 
            			  || (bgImage.toLowerCase().substring(0, 4) != "url(")
            			  || (bgImage.charAt(bgImage.length - 1) != ")"));
            var options = null;
            if (noURL && (bgImage == null || bgImage == "none") && fallback && (!dLang.isString(fallback))) {
            	options = fallback;
            } 
            
            if (! options) {
            	var cssOpts = null;
	            if (noURL && (bgImage == null || bgImage == "none") && fallback && dLang.isString(fallback)) {
            		cssOpts = fallback;
            		
            	} else if (!noURL) {
		            // remove the "url(" prefix and ")" suffix
    		        bgImage = bgImage.substring(4, bgImage.length - 1);
            
        			// check if our URL is quoted
	        	    if (bgImage.charAt(0) == "\"") {
    	        	    // if not properly quoted then we don't parse it
        	        	if (bgImage.length < 2) return null;
            	    	if (bgImage.charAt(bgImage.length - 1) != "\"") return null;
                
	                	// otherwise remove the quotes
    	            	bgImage = bgImage.substring(1, bgImage.length - 1);
            		}
            
	        		// find the query string
    	        	var queryIdx = bgImage.lastIndexOf("?");
            		var slashIdx = bgImage.lastIndexOf("/");
            		if (queryIdx < 0) return null;
            
        			// get just the query string from the URL
            		cssOpts = bgImage.substring(queryIdx + 1, bgImage.length);
            	}         
            	if (cssOpts == null) return null;
            	if (cssOpts.length == 0) return null;
            
        		// parse the query string and return the result
            	options = dIOQuery.queryToObject(cssOpts);
            }
            return (guide) ? iUtil.mixin({}, options, guide) : options;
        };
        
	/**
  	 * @public
  	 * @function
 	 * @name idx.util.mixinCSSDefaults
 	 * @description Obtains the "CSS Options" using idx.util.getCSSOptions via the specified CSS class name
 	 *              and optional parent node using the specified target object as the "guide" and mixing the
 	 *              CSS options directly into the target object via idx.util.mixin.  Any CSS options not 
 	 *              matching an attribute of the target object are ignored.
	 * 	 
 	 * @param {Object} target The target object to mix the CSS defaults into.
 	 * @param {String} className The CSS class name passed to idx.util.getCSSOptions.
 	 * @param {Node} parentNode The optional (but recommended) parent node passed to idx.util.getCSSOptions.
 	 * 
 	 * @return {Object} The Object containing the CSS options with the attribute types matching the
 	 *                  specified guide where applicable.
 	 */
    iUtil.mixinCSSDefaults = function(/*Object*/ target,
                                      /*String*/ className,
                                      /*Node?*/  parentNode) {
            if (!target) return null;
            var opts = iUtil.getCSSOptions(className, parentNode);

            if (!opts) return null;
            
            iUtil.mixin(target, opts);
            
            return opts;
        };

	/**
  	 * @public
  	 * @function
 	 * @name idx.util.mixin
 	 * @description Provides a restricted version of dojo.lang.mixin.  This function Mixes the attributes of the 
 	 *              specified "source" into the specified "target" but only if the specified target object (or
 	 *              optionally specified "guide" object) already has the attribute from the source object.  Further,
 	 *              the type of each attribute that is mixed in is interpretted to match the type of the same 
 	 *              attribute in the target (or rather the "guide" object if provided).  If no guide is specified, 
 	 *              then the target object is used as a guide.  If a guide is specified the the target object simply
 	 *              becomes the landing zone for the mixed-in attributes.
	 * 	 
 	 * @param {Object} target The target object to mix the attributes into.
 	 * @param {Object} source The source object to pull the attributes from.
 	 * @param {Object} guide The optional object whose attributes and types of those attributes will be used 
 	 *                       as a guide for converting the source attributes to the target attribute.
 	 * @return The specified target object is returned.
 	 */
     iUtil.mixin = function(/*Object*/  target,
                            /*Object*/  source,
                            /*Object?*/ guide) {
     	if (!target) return null; 	// cannot mixin to null
        if (!source) return target;	// if nothing to mixin then do nothing
        if (!guide) guide = target;	// if no guide is specified then use the target as the guide
        
        var src = { };
        // if we have the class info, then parse the fields of the options
        for (var field in source) {
	       	if (! (field in guide)) continue;
    	        var attrType = iUtil.typeOfObject(guide[field]);
                src[field] = iUtil.parseObject(source[field], attrType);
        }
            
         // mixin the options
         dLang.mixin(target, src);
         return target;
     };
        
    /**
  	 * @public
  	 * @function
 	 * @name idx.util.recursiveMixin
 	 * @description Recursively mixes in the second specified object into the first, optionally using
 	 *              the specifed options.  Recursion occurs when the attribute is contained in both
 	 *              the first and second object and is of type "object" in both cases.  Recursion can
 	 *              be made optional via the "options" parameter by specifying the name of a "controlField"
 	 *              and "controlValue".  In such cases the first object is checked for the presence of the
 	 *              "controlField" and if it exists and the value is equal to the specified "controlValue"
 	 *              then recusion occurs, otherwise it does not.  When recursion does not occur an an object
 	 *              value from the second object is copied it may optionally be cloned by setting "options.clone"
 	 *              to true.
     * @param {Object} first The object the attributes will be mixed into
     * @param {Object} second The object that holds the attributes to mixin
     * @param {Objet} options (includes "clone", "controlField" and "controlValue").  If "clone" is 
     *                        specified then attributes whose values are of type object in the second 
     *                        object are cloned before being set in the first object.  The "controlField"
     *                        and "controlValue" options are used to determine if an object in the first
     *                        object should be recursively mixed in.  If "controlField" is provided, but
     *                        not "controlValue" then "controlValue" is defaulted to true.
     */
     iUtil.recursiveMixin = function(first, second, options) {
        	var clone = null;
        	var controlField = null;
        	var controlValue = null;
        	if (options) {
        		clone = options.clone;
        		controlField = options.controlField;
        		if ("controlValue" in options) {
        			controlValue = options.controlValue;
        		} else {
        			controlValue = true;
        		}
        	}
        	
        	for (field in second) {
        		if (field in first) {
        			// get the field values
        			var firstValue = first[field];
        			var secondValue = second[field];
        			
        			// get the types for the values
        			var firstType = iUtil.typeOfObject(firstValue);
        			var secondType = iUtil.typeOfObject(secondValue);

        			// check if they are not the same type
        			if ((firstType == secondType) && (firstType == "object")
        				&& ((!controlField) || (firstValue[controlField] == controlValue))) {
        				// if both are objects then mix the second into the first
        				iUtil.recursiveMixin(firstValue, secondValue, options);
        				
        			} else {
        				// otherwise overwrite the first with the second
        				first[field] = (clone) ? dLang.clone(secondValue) : secondValue;
        			}
        		} else {
        			first[field] = (clone) ? dLang.clone(second[field]) : second[field];
        		}
        	}
        };
        
        
    /**
  	 * @public
  	 * @function
 	 * @name idx.util.nullify
 	 * @description Accepts a target object, an object that represents arguments passed
     *              to construct the target object (usually via mixin). and an
     *              and an array of property names for which the value should be null if
     *              not otherwise specified.  For each of the specified properties, if 
     *              the construction arguments does not specify a value for that property, 
     *              then the same property is set to null on the target object.  If a 
     *              property name is found not to exist in the target object then it is 
     *              ignored.
     *
     * @param {Object} target Usually the object being constructed.
     * 
     * @param {Object} ctorArgs The objects that would specify attributes on the target.
     * 
     * @param {Object} props The array of property names for properties to be set to null
     *                       if none of the objects in the argsArray specify them.
     */
    iUtil.nullify = function(target,ctorArgs,props) {
        var index = 0;
        for (index = 0; index < props.length; index++) {
            var prop = props[index];
            if (! (prop in target)) continue;
            if ((ctorArgs) && (prop in ctorArgs)) continue;
            target[prop] = null;
        }
    };
        
    /**
  	 * @private
  	 * @function
 	 * @name idx.util._getNodeStyle
     * @description Internal method to get the node's style as an object.  This method does not
     *              normalize the style fields so it will need to be extended to make it more
     *              robust for the general case.  idx.util only needs this for things like "position",
     *              "width" and "height" in order to reset values on a node after changing them.
     */
    iUtil._getNodeStyle = function(node) {
        	var nodeStyle = dDomAttr.get(node, "style");
        	if (!nodeStyle) return null;
        	var result = null;
       		if (iUtil.typeOfObject(nodeStyle) == "string") {
       			result = {};
       			var tokens = nodeStyle.split(";");
       			for (var index = 0; index < tokens.length; index++) {
       				var token = tokens[index];
       				var colonIndex = token.indexOf(":");
       				if (colonIndex < 0) continue;
       				var field = token.substring(0, colonIndex);
       				var value = "";
       				if (colonIndex < token.length - 1) {
       					value = token.substring(colonIndex+1);
       				}
       				result[field] = value;
       			}
     		} else {
     			result = nodeStyle;
     		}
       		return result;
        };

    /**
  	 * @private
  	 * @function
 	 * @name idx.util._getNodePosition
     * @description Internal method to get the node's specific position and detect when none is specifically
     *              assigned to the node.
     */
    iUtil._getNodePosition = function(node) {
        	var style = iUtil._getNodeStyle(node);
        	if (! style) return "";
        	if (! style.position) return "";
        	return style.position;
    };
        
    /**
  	 * @public
  	 * @function
 	 * @name idx.util.fitToWidth
     * @description Sizes a parent to fit the child node as if the child node's positioning was
     *              NOT absolute.  Absolutely positioned elements due not "reserve" space, so this
     *              method will temporarily position the element as "static", then determine the
     *              result size of the parent, set the parent's width explicitly, and then return the
     *              child to the default previously set positioning.  This is especially handy in that
     *              it allows the parent to define padding which will be respected.
     *
     * @param {Node} parent The parent node -- no checking is done to ensure this node is actually 
     *                      a parent of the specified child.
     * @param {Node} child The child node -- no checking is done to ensure this node is actually a
     *                     child of the specified parent.
     */
    iUtil.fitToWidth = function(/*Node*/ parent, /*Node*/ child) {
        	var pos = iUtil._getNodePosition(child);
            dDomStyle.set(parent, {width: "auto"});
            dDomStyle.set(child, {position: "static"});
            var dim = dDomGeo.getMarginBox(parent);
            dDomStyle.set(parent, {width: dim.w + "px"});
            dDomStyle.set(child, {position: pos});  
            return dim;
    };
        
    /**
  	 * @public
  	 * @function
 	 * @name idx.util.fitToHeight
 	 * @description Sizes a parent to fit the child node as if the child node's positioning was
 	 *              NOT absolute.  Absolutely positioned elements due not "reserve" space, so 
 	 *              this method will temporarily position the element as "static", then determine
 	 *              the result size of the parent, set the parent's height explicitly, and then 
 	 *              return the child to the default previously set positioning.  This is especially
 	 *              handy in that it allows the parent to define padding which will be respected.
     *
     * @param {Node} parent The parent node -- no checking is done to ensure this node is actually 
     *                      a parent of the specified child.
	 * @param {Node} child The child node -- no checking is done to ensure this node is actually a
	 *                     child of the specified parent.
 	 */
    iUtil.fitToHeight = function(/*Node*/ parent, /*Node*/ child) {
        	var pos = iUtil._getNodePosition(child);
            dDomStyle.set(parent, {height: "auto"});
            dDomStyle.set(child, {position: "static"});
            var dim = dDomGeo.getMarginBox(parent);
            dDomStyle.set(parent, {height: dim.h + "px"});
            dDomStyle.set(child, {position: pos});  
            return dim;
    };
       
    /**
  	 * @public
  	 * @function
 	 * @name idx.util.fitToSize
 	 * @description Sizes a parent to fit the child node as if the child node's positioning was 
 	 *              NOT absolute.  Absolutely positioned elements due not "reserve" space, so this
 	 *              method will temporarily position the element as "static", then determine the 
 	 *              result size of the parent, set the parent's size explicitly, and then return the
	 *              child to the default previously set positioning.  This is especially handy in 
	 *              that it allows the parent to define padding which will be respected.
	 * 
     * @param {Node} parent The parent node -- no checking is done to ensure this node is actually 
     *                      a parent of the specified child.
     *
     * @param {Node} child The child node -- no checking is done to ensure this node is actually a 
     *                     child of the specified parent.
     */
    iUtil.fitToSize = function(/*Node*/ parent, /*Node*/ child) {
        	var pos = iUtil._getNodePosition(child);
            dDomStyle.set(parent, {width: "auto", height: "auto"});
            dDomStyle.set(child, {position: "static"});
            var dim = dDomGeo.getMarginBox(parent);
            dDomStyle.set(parent, {width: dim.w + "px", height: dim.h + "px"});
            dDomStyle.set(child, {position: pos});
            return dim;
        };
     
     /**
      * @public
  	  * @function
 	  * @name idx.util.getStaticSize
 	  * @description Determines the  dimensions of the specified node if it were to use static positioning.
      *
      * @param {Node} node The node to work with.
      */  
     iUtil.getStaticSize = function(/*Node*/ node) {
        	var style = iUtil._getNodeStyle(node);
        	var pos = (style && style.position) ? style.position: "";
            var width  = (style && style.width) ? style.width : "";
            var height = (style && style.height) ? style.height : "";
            dDomStyle.set(node, {position: "static", width: "auto", height: "auto"});
            var dim = dDomGeo.getMarginBox(node);
            dDomStyle.set(node, {position: pos, width: width, height: height});
            return dim;
        };
        
     /**
      * @public
  	  * @function
 	  * @name idx.util.reposition
 	  * @description Determines the  dimensions of the specified node if it were to use static positioning.
      *
      * @param {Node} node The node to work with.
      * @param {String} position The CSS position to use.
      */  
     iUtil.reposition = function(/*Node*/ node, /*String*/ position) {
        	var oldpos = iUtil._getNodePosition(node);
            dDomStyle.set(node, {position: position});
            return oldpos;
     };

		        
     /**
      * @public
  	  * @function
 	  * @name idx.util.getParentWidget
 	  * @description Determines the widget that is the parent of the specified widget or node.  This 
 	  *              is determined by obtaining the parent node for the specified node or "widget.domNode"
 	  *              and then calling dijit.getEnclosingWidget().  This method may return null if no widget
 	  *              parent exists.
      *
      * @param {Node|Widget} child The node or dijit._WidgetBase child for which the parent is being requested.
      * @param {Type} widgetType The optional type of widget for the parent.  The method recursively looks for 
      *                          the first ancestor of this type until found or we run out of ancestors.
      *
      * @return {Widget} The parent or ancestor widget.
      */  
     iUtil.getParentWidget = function(/*Node|Widget*/ child,
     								  /*Type*/        widgetType) {
            // get the widget node
            var childNode = (child instanceof dWidget) ? child.domNode : child;
            
            // get the parent node of the DOM node
            var parentNode = childNode.parentNode;
            
            // check the parent node
            if (parentNode == null) return null;
            
            // get the widget for the node
            var parent = dRegistry.getEnclosingWidget(parentNode);
            
            // check if looking for a specific widget type
            while ((widgetType) && (parent) && (! (parent instanceof widgetType))) {
            	parentNode = parent.domNode.parentNode;
            	parent = null;
            	if (parentNode) {
            		parent = dRegistry.getEnclosingWidget(parentNode);
            	}
            } 
            
            // return the parent
            return parent;
    };

     /**
      * @public
  	  * @function
 	  * @name idx.util.getSiblingWidget
 	  * @description Determines the widget that is the first next or previous sibling of the 
 	  *              specified widget or node that is a widget (optionally of a specific type).  This
 	  *              is determined by obtaining the parent node for the specified node or "widget.domNode",
 	  *              finding the first next or previous sibling node that is the domNode for a widget, and
 	  *              if not moving on to the next.  This method may return null if no widget sibling exists.
      *
      * @param {Node|Widget} target The node or dijit._WidgetBase for which the sibling is being requested.
      * @param {Boolean} previous Optional parameter for indicating which sibling.  Specify true if the 
      *                           previous sibling is desired and false if the next sibling.  If omitted then
      *                           false is the default.
      * @param {Type} widgetType The optional type of widget for the sibling.  If specified, this method ignores
      *                          any sibling that is not of the specified type.
      *
      * @return {Widget} The sibling widget or null if no widget matching the criteria is found..
      */  
    iUtil.getSiblingWidget = function(/*Node|Widget*/ target, 
        	 						  /*Boolean*/     previous,
        							  /*Type*/        widgetType) {        	
            // get the widget node
            var widgetNode = (target instanceof dWidget) ? target.domNode : target;
            
            // get the parent node of the DOM node
            var parentNode = widgetNode.parentNode;
            
            // check the parent node
            if (parentNode == null) return null;
            
            // get the children of the parent
            var children = parentNode.childNodes;
            if (! children) return null;
            
            // find the index for the child
            var index = 0;
            for (index = 0; index < children.length; index++) {
            	if (children[index] == widgetNode) break;
            }
            
            if (index == children.length) return null;
            
            // work forward are backward from the index
            var step = (previous) ? -1: 1;
            var limit = (previous) ? -1 : children.length;
            var sibindex = 0;
            var sibling  = null;
            for (sibindex = (index + step); sibindex != limit; (sibindex += step)) {
            	var sibnode = children[sibindex];
            	
            	// get the widget for the node
                var sibwidget = dRegistry.getEnclosingWidget(sibnode);
                if (! sibwidget) continue;
                if (sibwidget.domNode == sibnode) {
                	if ((!widgetType) || (sibwidget instanceof widgetType)) {
                		sibling = sibwidget;
                		break;
                	}
                }
            }
            
            // return the sibling
            return sibling;
    };
        

     /**
      * @public
  	  * @function
 	  * @name idx.util.getChildWidget
 	  * @description Determines the widget that is the first or last child of the specified widget 
 	  *              or node that is a widget (optionally of a specified type).  This is determined
 	  *              by obtaining the widget for the specified parent, obtaining the children widgets
 	  *              and returning either the first or last that is optionally of a specified type.
      *              This method may return null if no widget child exists.
      *
      * @param {Node|Widget} parent The node or dijit._WidgetBase for which the child is being requested.
      * @param {Boolean} last Optional parameter for indicating which child.  Specify true if the 
      *                       last child is desired and false if the first child.  If omitted then
      *                       false is the default.
      * @param {Type} widgetType The optional type of widget for the child.  If specified, this method ignores
      *                          any child that is not of the specified type.
      *
      * @return {Widget} The child widget or null if no widget matching the criteria is found.
      */  
     iUtil.getChildWidget = function(/*Node|Widget*/ parent, 
        								   /*Boolean*/     last,
        								   /*Type*/        widgetType) {
            // get the widget node
        	if (! (parent instanceof dWidget)) {
            	var widget = dRegistry.getEnclosingWidget(parent);
            	if (widget) parent = widget;
            }

            var children = null;
            if (parent instanceof dWidget) {
            	children = parent.getChildren();
            } else {
                children = parent.childNodes;
            }
            
            // check the children
            if (! children) return null;
            if (children.length == 0) return null;

            // setup the looping variables
            var start = (last) ? (children.length - 1) : 0;
            var step  = (last) ? -1 : 1;
            var limit = (last) ? -1 : children.length;

            // work forward are backward from the index
            var childIndex = 0;
            var child      = null;
            for (childIndex = start; childIndex != limit; (childIndex += step)) {
            	var widget = children[childIndex];
            	if (! (widget instanceof dWidget)) {
                	// get the widget for the node
                    var node = widget;
                    widget = dRegistry.getEnclosingWidget(node);
                    if (! widget) continue;
                    if (widget.domNode != node) continue;
            	}
            	if ((!widgetType) || (widget instanceof widgetType)) {
            		child = widget;
            		break;
            	}
            }
            
            // return the child
            return child;
        };

     /**
      * @public
  	  * @function
 	  * @name idx.util.getFormWidget
 	  * @description Determines the widget (derived from dijit.form._FormWidget) that is a child of the 
 	  *              specified node or widget (usually a dijit.form.Form) that has the specified form 
 	  *              field name.  If the found form field is found to be an instance of dijit.form._FormWidget
 	  *              then it is returned, otherwise null is returned.
      *
      * @param {String} formFieldName The name of the form field widget that is being requested.
      * @param {Node|Widget} parent Optional root node or root widget under which to look for the form 
      *                             widgets. If not specified then the entire document body is searched.
      * @return The form field widget with the specified name or null if not found.
      */  
     iUtil.getFormWidget = function(/*String*/ 			formFieldName,
        							/*Node|Widget?*/	parent) {
        	// get the widget node
        	var rootNode = null;
        	if (!parent) {
        		parent = dWindow.body();
        	} else if (parent instanceof dWidget) {
        		rootNode = parent.domNode;
        	} else {
        		rootNode = form;
        	}
        			
        	var formWidget = null;
        	var nodeList = dQuery("[name='" + formFieldName + "']", rootNode);
        	for (var index = 0; (!formWidget) && (index < nodeList.length);index++) {
        		var node = nodeList[index];
        		var widget = dRegistry.getEnclosingWidget(node);
        		if (!widget) continue;
        		if (! (widget instanceof dFormWidget)) {
        			continue;
        		}
        		var name = widget.get("name");
        		if (name != formFieldName) {
        			continue;
        		}
        		formWidget = widget;
        	}
        	return formWidget;
   };
        
        
     /**
      * @public
  	  * @function
 	  * @name idx.util.isNodeOrElement
 	  * @description Attempts to determine if the specified object is a DOM node.  This is needed since IE does
 	  *              not recognize the "Node" type, and only IE-8 recognizes the "Element" type.
      *
      * @param {Object|Node|Element} obj The object to check.
      * @return The result is true if the specified object is a node or element, otherwise false.
      */  
     iUtil.isNodeOrElement = function(/*Object*/ obj) {
         return ((obj.parentNode) && (obj.childNodes) && (obj.attributes)) ? true : false;
     };

     /**
      * @public
  	  * @function
 	  * @name idx.util.debugObject
 	  * @description Generates a diagnostic string describing the specified object.
      *
      * @param {Object} obj The object to debug
      * @return The debug string for the object.
      */  
     iUtil.debugObject = function(/*Object*/ obj) {
        	return iUtil._debugObject(obj, "/", [ ]);
     };
        
     /**
      * @private
  	  * @function
 	  * @name idx.util._debugObject
 	  * @description Recursively generates a diagnostic string describing the specified object
 	  *              and tries to detect circular references.
      *
      * @param {Object} obj The object to debug
      * @param {String} path The current attribute path within the object.
      * @param {Object} seen The associative array of paths to boolean values to check if already seen in 
      *                      order to avoid circular recursion.
      * @return The debug string for the object.
      */  
     iUtil._debugObject = function(/*Object*/ obj, /*String*/ path, /*Array*/ seen) {
           if (obj === null) return "null";
           var objType = iUtil.typeOfObject(obj);
           switch (objType) {
           case 'object':
        	   for (var index = 0; index < seen.length; index++) {
        		   if (seen[index].obj == obj) {
        			   return "CIRCULAR_REFERENCE[ " + seen[index].path + " ]";
        		   }
        	   }
        	   seen.push({obj: obj, path: path});
        	   var result = "{ ";
        	   var prefix = "";
        	   for (field in obj) {
        	     result = (result + prefix + '"' + field + '": ' 
        	    		   + iUtil._debugObject(obj[field], 
        	    				   				   path + '/"' + field + '"', 
        	    				   				   seen));
        	     prefix = ", ";
        	   }
        	   result = result + " }";
        	   return result;
           case 'date':
        	   return "DATE[ " + dDateStamp.toISOString(obj) + " ]";
           default:
        	   return dJson.stringify(obj);
           }
        };
     
     /**
      * @public
  	  * @field
 	  * @name idx.util.isBrowser
 	  * 
 	  * @description Equivalent to "dojo.isBrowser" in Dojo 1.6 and dojo/ 1  in Dojo 1.7+
 	  * @deprecated Use dojo/ 1  instead.
 	  */
      iUtil.isBrowser = dHas("host-browser");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isIE
 	  * 
 	  * @description Equivalent to "dojo.isIE" in Dojo 1.6 and dojo/has("ie") in Dojo 1.7+
 	  * @deprecated Use dojo/has("ie") instead.
 	  */
      iUtil.isIE = dHas("ie");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isFF
 	  * 
 	  * @description Equivalent to "dojo.isFF" in Dojo 1.6 and dojo/has("ff") in Dojo 1.7+
 	  * @deprecated Use dojo/has("ff") instead.
 	  */
      iUtil.isFF = dHas("ff");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isSafari
 	  * 
 	  * @description Equivalent to "dojo.isSafari" in Dojo 1.6 and dojo/has("safari") in Dojo 1.7+
 	  * @deprecated Use dojo/has("safari") instead.
 	  */
      iUtil.isSafari = dHas("safari");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isChrome
 	  * 
 	  * @description Equivalent to "dojo.isChrome" in Dojo 1.6 and dojo/has("chrome") in Dojo 1.7+
 	  * @deprecated Use dojo/has("chrome") instead.
 	  */
      iUtil.isChrome = dHas("chrome");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isMozilla
 	  * 
 	  * @description Equivalent to "dojo.isMozilla" in Dojo 1.6 and dojo/has("mozilla") in Dojo 1.7+
 	  * @deprecated Use dojo/has("mozilla") instead.
 	  */
      iUtil.isMozilla = dHas("mozilla");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isOpera
 	  * 
 	  * @description Equivalent to "dojo.isOpera" in Dojo 1.6 and dojo/has("opera") in Dojo 1.7+
 	  * @deprecated Use dojo/has("opera") instead.
 	  */
      iUtil.isOpera = dHas("opera");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isKhtml
 	  * 
 	  * @description Equivalent to "dojo.isKhtml" in Dojo 1.6 and dojo/has("khtml") in Dojo 1.7+
 	  * @deprecated Use dojo/has("khtml") instead.
 	  */
      iUtil.isKhtml	= dHas("khtml");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isAIR
 	  * 
 	  * @description Equivalent to "dojo.isAIR" in Dojo 1.6 and dojo/has("air") in Dojo 1.7+
 	  * @deprecated Use dojo/has("air") instead.
 	  */
      iUtil.isAIR = dHas("air");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isQuirks
 	  * 
 	  * @description Equivalent to "dojo.isQuirks" in Dojo 1.6 and dojo/has("quirks") in Dojo 1.7+
 	  * @deprecated Use dojo/has("quirks") instead.
 	  */
      iUtil.isQuirks = dHas("quirks");
      
     /**
      * @public
  	  * @field
 	  * @name idx.util.isWebkit
 	  * 
 	  * @description Equivalent to "dojo.isWebkit" in Dojo 1.6 and dojo/has("webkit") in Dojo 1.7+
 	  * @deprecated Use dojo/has("webkit") instead.
 	  */
      iUtil.isWebKit = dHas("webkit");
        

        // idx.util.fromJson is copied from IBM Dojo Toolkit 1.7.x implementation of dojox.secure.fromJson
        // because that module lacks AMD support in Dojo 1.7 and early releases of Dojo 1.8.  The original 
        // implementation of dojox.secure.fromJson includes the following notice:
        //
        // Used with permission from Mike Samuel of Google (has CCLA), from the json-sans-eval project:
        // http://code.google.com/p/json-sans-eval/
        //	Mike Samuel <mikesamuel_at_gmail_dot_com>

     /**
      * @public
  	  * @function
 	  * @name idx.util.fromJson
 	  * @description Generates a diagnostic string describing the specified object.  Parses a string 
 	  *              of well-formed JSON text without exposing the application to cross-site request
 	  *              forgery attacks.  Use this in place of dojo.fromJson().  The code is copied from 
 	  *              IBM Dojo Toolkit 1.7.x implementation of dojox.secure.fromJson module which lacks 
 	  *              support for AMD as of Dojo 1.7 & Dojo 1.8 RC1.
      * 
      *              Parses a string of well-formed JSON text. If the input is not well-formed, then behavior
      *              is undefined, but it is deterministic and is guaranteed not to modify any object other 
      *              than its return value.
      *
	  * 			 This does not use `eval` so is less likely to have obscure security bugs than json2.js.
	  *              It is optimized for speed, so is much faster than json_parse.js.
	  *
	  *              This library should be used whenever security is a concern (when JSON may
	  *              come from an untrusted source), speed is a concern, and erroring on malformed
      *              JSON is *not* a concern.
	  *	
	  *              json2.js is very fast, but potentially insecure since it calls `eval` to
	  *              parse JSON data, so an attacker might be able to supply strange JS that
      *              looks like JSON, but that executes arbitrary javascript.
      * 
	  * @param {String} json JSON text per RFC 4627
	  * 
	  * @param {Function (this:Object, string, *)} optReviver Optional function that reworks JSON objects post-parse
	  *                                                       per Chapter 15.12 of EcmaScript3.1.  If supplied, the
	  *                                                       function is called with a string key, and a value.
	  * 													  The value is the property of 'this'.	The reviver should
	  *                                                       return the value to use in its place.	So if dates were
	  *                                                       serialized as {@code { "type": "Date", "time": 1234 }},
	  *                                                       then a reviver might look like 
	  *	  {@code 
	  *			function (key, value) {
      * 			if (value && typeof value === 'object' && 'Date' === value.type) {
	  *				return new Date(value.time);
	  *			} else {
	  * 				return value;
	  *			}
	  * 		}}.
	  * 		If the reviver returns {@code undefined} then the property named by key
	  *		will be deleted from its container.
	  *		{@code this} is bound to the object containing the specified property.
	  * 
	  * @return {Object|Array} representing the parsed object.
      */
     iUtil.fromJson = typeof JSON != "undefined" ? JSON.parse :
        	(function () {
        		var number
        			= '(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)';
        		var oneChar = '(?:[^\\0-\\x08\\x0a-\\x1f\"\\\\]'
        			+ '|\\\\(?:[\"/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';
        		var string = '(?:\"' + oneChar + '*\")';

        		// Will match a value in a well-formed JSON file.
        		// If the input is not well-formed, may match strangely, but not in an unsafe
        		// way.
        		// Since this only matches value tokens, it does not match whitespace, colons,
        		// or commas.
        		var jsonToken = new RegExp(
        				'(?:false|true|null|[\\{\\}\\[\\]]'
        				+ '|' + number
        				+ '|' + string
        				+ ')', 'g');

        		// Matches escape sequences in a string literal
        		var escapeSequence = new RegExp('\\\\(?:([^u])|u(.{4}))', 'g');

        		// Decodes escape sequences in object literals
        		var escapes = {
        				'"': '"',
        				'/': '/',
        				'\\': '\\',
        				'b': '\b',
        				'f': '\f',
        				'n': '\n',
        				'r': '\r',
        				't': '\t'
        		};
        		function unescapeOne(_, ch, hex) {
        			return ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));
        		}

        		// A non-falsy value that coerces to the empty string when used as a key.
        		var EMPTY_STRING = new String('');
        		var SLASH = '\\';

        		// Constructor to use based on an open token.
        		var firstTokenCtors = { '{': Object, '[': Array };

        		var hop = Object.hasOwnProperty;

        		return function (json, opt_reviver) {
        			// Split into tokens
        			var toks = json.match(jsonToken);
        			// Construct the object to return
        			var result;
        			var tok = toks[0];
        			var topLevelPrimitive = false;
        			if ('{' === tok) {
        				result = {};
        			} else if ('[' === tok) {
        				result = [];
        			} else {
        				// The RFC only allows arrays or objects at the top level, but the JSON.parse
        				// defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null
        				// at the top level.
        				result = [];
        				topLevelPrimitive = true;
        			}

        			// If undefined, the key in an object key/value record to use for the next
        			// value parsed.
        			var key;
        			// Loop over remaining tokens maintaining a stack of uncompleted objects and
        			// arrays.
        			var stack = [result];
        			for (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {
        				tok = toks[i];

        			var cont;
        			switch (tok.charCodeAt(0)) {
        			default:	// sign or digit
        				cont = stack[0];
        				cont[key || cont.length] = +(tok);
        				key = void 0;
        				break;
        			case 0x22:	// '"'
        				tok = tok.substring(1, tok.length - 1);
        				if (tok.indexOf(SLASH) !== -1) {
        					tok = tok.replace(escapeSequence, unescapeOne);
        				}
        				cont = stack[0];
        				if (!key) {
        					if (cont instanceof Array) {
        						key = cont.length;
        					} else {
        						key = tok || EMPTY_STRING;	// Use as key for next value seen.
        						break;
        					}
        				}
        				cont[key] = tok;
        				key = void 0;
        				break;
        			case 0x5b:	// '['
        				cont = stack[0];
        				stack.unshift(cont[key || cont.length] = []);
        				key = void 0;
        				break;
        			case 0x5d:	// ']'
        				stack.shift();
        				break;
        			case 0x66:	// 'f'
        				cont = stack[0];
        				cont[key || cont.length] = false;
        				key = void 0;
        				break;
        			case 0x6e:	// 'n'
        				cont = stack[0];
        				cont[key || cont.length] = null;
        				key = void 0;
        				break;
        			case 0x74:	// 't'
        				cont = stack[0];
        				cont[key || cont.length] = true;
        				key = void 0;
        				break;
        			case 0x7b:	// '{'
        				cont = stack[0];
        				stack.unshift(cont[key || cont.length] = {});
        				key = void 0;
        				break;
        			case 0x7d:	// '}'
        				stack.shift();
        				break;
        			}
        		}
        		// Fail if we've got an uncompleted object.
        		if (topLevelPrimitive) {
        			if (stack.length !== 1) { throw new Error(); }
        			result = result[0];
        		} else {
        			if (stack.length) { throw new Error(); }
        		}

        		if (opt_reviver) {
        			// Based on walk as implemented in http://www.json.org/json2.js
        			var walk = function (holder, key) {
        				var value = holder[key];
        				if (value && typeof value === 'object') {
        					var toDelete = null;
        					for (var k in value) {
        						if (hop.call(value, k) && value !== holder) {
        							// Recurse to properties first.	This has the effect of causing
        							// the reviver to be called on the object graph depth-first.

        							// Since 'this' is bound to the holder of the property, the
        							// reviver can access sibling properties of k including ones
        							// that have not yet been revived.

        							// The value returned by the reviver is used in place of the
        							// current value of property k.
        							// If it returns undefined then the property is deleted.
        							var v = walk(value, k);
        							if (v !== void 0) {
        								value[k] = v;
        							} else {
        								// Deleting properties inside the loop has vaguely defined
        								// semantics in ES3 and ES3.1.
        								if (!toDelete) { toDelete = []; }
        								toDelete.push(k);
        							}
        						}
        					}
        					if (toDelete) {
        						for (var i = toDelete.length; --i >= 0;) {
        							delete value[toDelete[i]];
        						}
        					}
        				}
        				return opt_reviver.call(holder, key, value);
        			};
        			result = walk({ '': result }, '');
        		}

        		return result;
        		};
        	})();
        
     /**
      * @private
  	  * @function
 	  * @name idx.util._getFontMeasurements
 	  * @description Internal function for computing the measurements of on-screen fonts.
 	  */ 
     function _getFontMeasurements(measurements,fontSize){
    		// initialize heights to the specified fontMeasurements parameter
    		var heights = measurements;
    		
    		// if it does not yet exist then create it
    		if (!heights) {
    			heights = {
    				'1em': -1, '1ex': -1, '100%': -1, '12pt': -1, '16px': -1, 'xx-small': -1,
	    			'x-small': -1, 'small': 1, 'medium': -1, 'large': -1, 'x-large': -1,
    				'xx-large': -1
    			};
    		}
    		
    		// check if a specific font size was requested in addition to defaults
    		if (fontSize && (! (fontSize in heights))) {
    			heights[fontSize] = -1;
    		}
    		
    		var p;
    		if(dHas("ie")){
    			dWindow.doc.documentElement.style.fontSize="100%";
    		}
    		var div = dDomConstruct.create("div", {style: {
    				position: "absolute",
    				left: "0",
    				top: "-100000px",
    				width: "30px",
    				height: "1000em",
    				borderWidth: "0",
    				margin: "0",
    				padding: "0",
    				outline: "none",
    				lineHeight: "1",
    				overflow: "hidden"
    			}}, dWindow.body());
    		for(p in heights){
    			// check if the given font size was already calculated and skip it
    			if (heights[p] >= 0) {
    				continue;
    			}
    			
    			// set the font size
    			dDomStyle.set(div, "fontSize", p);
    			
    			// get the measurement
    			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
    		}

    		dWindow.body().removeChild(div);
    		return heights; //object
    };
    
     /**
      * @private
      * @function
      * @name idx.util._toFontSize
      * @description Internal function to convert a node to a font size string.
      * @param fontSizeOrNode The font size as a string or a node.
      */
     function _toFontSize(fontSize) {
     		var fontSizeType = iUtil.typeOfObject(fontSize);
     		
     		if ((fontSizeType == "object")&&(iUtil.isNodeOrElement(fontSize))) {
    			var compStyle = dDomStyle.getComputedStyle(fontSize);
     			fontSize = compStyle["fontSize"];
     		} else if (fontSizeType != "string") {
     			fontSize = "" + fontSize;
     		}
     		return fontSize;
     };
     
     /**
      * @private
  	  * @function
 	  * @name idx.util._getCachedFontMeasurements
 	  * @description Internal function for computing and cacheing the measurements of on-screen fonts.
 	  */ 
	 var fontMeasurements = null;
     function _getCachedFontMeasurements(fontSize,recalculate){
     		var fontSizeType = iUtil.typeOfObject(fontSize);
     		
     		if(fontSizeType == "boolean"){ 
     			recalculate = fontSize;
     			fontSize = null;
     			
     		} else {
     			fontSize = _toFontSize(fontSize);
     		}
     		
     		// if recalculating then clear out old calculations
     		if (fontMeasurements && recalculate) {
     			if (fontSize) {
     				if (fontMeasurements[fontSize]) delete fontMeasurements[fontSize];
     			} else {
     				fontMeasurements = null;
     			}
     		}
     		
    		if(recalculate || !fontMeasurements || (fontSize && !fontMeasurements[fontSize])){
    			fontMeasurements = _getFontMeasurements(fontMeasurements, fontSize);
    		}
    		return fontMeasurements;
	};
   
   		 	
     /**
      * @public
  	  * @function
 	  * @name idx.util.normalizedLength
 	  * @description Converts non-percentage CSS widths from various units to pixels.
 	  * @param len The CSS length with optional units.
 	  * @param fontSizeOrNode The optional font size or node for which the font size is computed (defaults to "12pt").
 	  * @return The length/width in pixels.
 	  */ 
     iUtil.normalizedLength = function(len,fontSize) {
    		if(len.length === 0){ return 0; }
    		if(!fontSize) fontSize = "12pt";
    		else fontSize = _toFontSize(fontSize);
    		if(len.length > 2){
				// we don't want to use the fontSize parameter if the
				// specified length is not font-based units
				var units = len.slice(-2);
				var fontUnits = (units == "em" || units == "ex");
				if (! fontUnits) fontSize = "12pt";     		
    			var fm = _getCachedFontMeasurements(fontSize);
    			var px_in_pt = fm["12pt"] / 12;
    			var px_in_em = fm[fontSize];
    			var px_in_ex = px_in_em / 2;
    			var val = parseFloat(len);
    			switch(len.slice(-2)){
    				case "px": return val;
    				case "em": return val * px_in_em;
    				case "ex": return val * px_in_ex;
    				case "pt": return val * px_in_pt;
    				case "in": return val * 72 * px_in_pt;
    				case "pc": return val * 12 * px_in_pt;
    				case "mm": return val * g.mm_in_pt * px_in_pt;
    				case "cm": return val * g.cm_in_pt * px_in_pt;
    			}
    		}
    		return parseFloat(len);	// Number
    };
	/**
	 * @public
	 * @function
	 * @name idx.util.isPercentage
	 * @description Attempts to determine if the value is a percentage 
	 * @param value to be check 
	 * @return return true if value is a percentage
	 */
	iUtil.isPercentage = function(value){
		return  /^\d+%$/.test(value);
	};
	/**
	 * @public
	 * @function
	 * @name idx.util.includeValidCSSWidth
	 * @description Attempts to determine if the value includes a valid CSS width
	 * @param value to be check
	 * @return return ture if the value includes a valid CSS width
	 */
	iUtil.includeValidCSSWidth = function(value){
		return /width:\s*\d+(%|px|pt|in|pc|mm|cm)/.test(value)
	};
	iUtil.getValidCSSWidth = function(style){
		var styleType = iUtil.typeOfObject(style);
		if (styleType != "string") {
			if ("width" in style) {
				style = "width: " + style.width + ";";
			} else {
				style = "width: " + style + ";";
			}
		}
		return /width:\s*\d+(%|px|pt|in|pc|mm|cm|em|ex)/.test(style) ? 
			style.match(/width:\s*(\d+(%|px|pt|in|pc|mm|cm|em|ex))/)[1] : "";
	};

	/**
	 * Compares to widgets to see if they are identical or alternatively compares
	 * strings to strings or strings to widgets, treating the strings as the ID of
	 * a widget.  The widget for the specified ID need not exist yet in the registry
	 * for this function to compare since it relies on the "id" field of any specified
	 * widget to perform a string compare.
	 *
	 * @param {String|Widget} w1 The first widget or the ID for the first widget.
	 * @param {String|Widget| w2 The second widget or the ID for the second widget.
	 *
	 * @return {boolean} Returns true if equal, otherwise false.
	 */
	iUtil.widgetEquals = function(w1,w2) {
		if (w1 === w2) return true;
		if (!w1 && w2) return false;
		if (w1 && !w2) return false;
		if ((!dLang.isString(w1)) && ("id" in w1)) w1 = w1.id;
		if ((!dLang.isString(w2)) && ("id" in w2)) w2 = w2.id;
		return (w1 == w2);
	};
  
	/**
	 * Provides a way to watch an attribute on an object whether it be an instance of
	 * dojo/Stateful or dijit/_WidgetBase.  The "watch()" method does not work on 
	 * dijit/_WidgetBase instances that implement custom setters.
	 *
	 * @param {Stateful|Widget} obj The object that owns the attribute to watch.
	 * @param {String} attr The attribute name to watch.
	 *
	 * @return {Handle} Returns the handle to remove the watch or null if the attribute
	 *         cannot be watched on the specified object.
	 */
	iUtil.watch = function(obj, attr, func) {
		if (!obj) return null;
		if (!attr) return null;
		if  ((! ("watch" in obj)) || (!dLang.isFunction(obj.watch))) {
			// object is not an instance of dojo/Stateful
			return null;
		}
		attr = dString.trim(attr);
		if (attr.length == 0) return null;
		var uc = attr.charAt(0).toUpperCase();
		if (attr.length > 1) {
			uc = uc + attr.substring(1);
		}
		var funcName = "_set" + uc + "Attr";
		if (funcName in obj) {
			return dAspect.around(obj, funcName, function(origFunc) {
				return function(value) {
					var oldValue = obj.get(attr);
					origFunc.apply(obj, arguments);
					var newValue = obj.get(attr);
					if (oldValue != newValue) {
						func.call(undefined, attr, oldValue, newValue);
					}
				};
			});
		} else {
			return obj.watch(attr, func);
		}
	};
  	
    return iUtil;
});
},
'dijit/layout/_LayoutWidget':function(){
define([
	"dojo/_base/lang", // lang.mixin
	"../_Widget",
	"../_Container",
	"../_Contained",
	"../Viewport",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style" // domStyle.getComputedStyle
], function(lang, _Widget, _Container, _Contained, Viewport,
	declare, domClass, domGeometry, domStyle){

	// module:
	//		dijit/layout/_LayoutWidget


	return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title property (used to specify
		// tab labels) to be set as an attribute on this.domNode... otherwise a tooltip shows up over the
		// entire widget.
		_setTitleAttr: null,

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under <body>.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent();
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		####Change size mode:
			//
			//		When changeSize is specified, changes the marginBox of this widget
			//		and forces it to re-layout its contents accordingly.
			//		changeSize may specify height, width, or both.
			//
			//		If resultSize is specified it indicates the size the widget will
			//		become after changeSize has been applied.
			//
			//		####Notification mode:
			//
			//		When changeSize is null, indicates that the caller has already changed
			//		the size of the widget, or perhaps it changed because the browser
			//		window was resized.  Tells widget to re-layout its contents accordingly.
			//
			//		If resultSize is also specified it indicates the size the widget has
			//		become.
			//
			//		In either mode, this method also:
			//
			//		1. Sets this._borderBox and this._contentBox to the new size of
			//			the widget.  Queries the current domNode size if necessary.
			//		2. Calls layout() to resize contents (and maybe adjust child widgets).
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				domGeometry.setMarginBox(node, changeSize);
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = lang.mixin(domGeometry.getMarginBox(node), mb);	// just use domGeometry.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling domGeometry.getContentBox() since that may fail if size was recently set)
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var be = domGeometry.getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = domGeometry.getPadExtents(node, cs);
			this._contentBox = {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit/_WidgetBase*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			domClass.add(child.domNode, cls);
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			domClass.remove(child.domNode, cls);

			this.inherited(arguments);
		}
	});
});

},
'dijit/popup':function(){
define("dijit/popup", [
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class",
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("config-bgIframe")
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./place",
	"./BackgroundIframe",
	"./Viewport",
	"./main",    // dijit (defining dijit.popup to match API doc)
	"dojo/touch"		// use of dojoClick
], function(array, aspect, declare, dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, keys, lang, on,
			place, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/popup

	/*=====
	 var __OpenArgs = {
		 // popup: Widget
		 //		widget to display
		 // parent: Widget
		 //		the button etc. that is displaying this popup
		 // around: DomNode
		 //		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		 // x: Integer
		 //		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // y: Integer
		 //		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // orient: Object|String
		 //		When the around parameter is specified, orient should be a list of positions to try, ex:
		 //	|	[ "below", "above" ]
		 //		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		 //		(around-node-corner, popup-node-corner), ex:
		 //	|	{ "BL": "TL", "TL": "BL" }
		 //		where BL means "bottom left" and "TL" means "top left", etc.
		 //
		 //		dijit/popup.open() tries to position the popup according to each specified position, in order,
		 //		until the popup appears fully within the viewport.
		 //
		 //		The default value is ["below", "above"]
		 //
		 //		When an (x,y) position is specified rather than an around node, orient is either
		 //		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		 //		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		 //		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		 //		and the top-right corner.
		 // onCancel: Function
		 //		callback when user has canceled the popup by:
		 //
		 //		1. hitting ESC or
		 //		2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		 //		   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		 // onClose: Function
		 //		callback whenever this popup is closed
		 // onExecute: Function
		 //		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		 // padding: place.__Position
		 //		adding a buffer around the opening position. This is only useful when around is not set.
		 // maxHeight: Integer
		 //		The max height for the popup.  Any popup taller than this will have scrollbars.
		 //		Set to Infinity for no max height.  Default is to limit height to available space in viewport,
		 //		above or below the aroundNode or specified x/y position.
	 };
	 =====*/

	function destroyWrapper(){
		// summary:
		//		Function to destroy wrapper when popup widget is destroyed.
		//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
		if(this._popupWrapper){
			domConstruct.destroy(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	var PopupManager = declare(null, {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).

		// _stack: dijit/_WidgetBase[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_repositionAll: function(){
			// summary:
			//		If screen has been scrolled, reposition all the popups in the stack.
			//		Then set timer to check again later.

			if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
				var oldPos = this._firstAroundPosition,
					newPos = domGeometry.position(this._firstAroundNode, true),
					dx = newPos.x - oldPos.x,
					dy = newPos.y - oldPos.y;

				if(dx || dy){
					this._firstAroundPosition = newPos;
					for(var i = 0; i < this._stack.length; i++){
						var style = this._stack[i].wrapper.style;
						style.top = (parseFloat(style.top) + dy) + "px";
						if(style.right == "auto"){
							style.left = (parseFloat(style.left) + dx) + "px";
						}else{
							style.right = (parseFloat(style.right) - dx) + "px";
						}
					}
				}

				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
			}
		},

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div", {
					"class": "dijitPopup",
					style: { display: "none"},
					role: "region",
					"aria-label": widget["aria-label"] || widget.label || widget.name || widget.id
				}, widget.ownerDocumentBody);
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", destroyWrapper, true);
			    // Workaround iOS problem where clicking a Menu can focus an <input> (or click a button) behind it.
				// Need to be careful though that you can still focus <input>'s and click <button>'s in a TooltipDialog.
				// Also, be careful not to break (native) scrolling of dropdown like ComboBox's options list.
				if("ontouchend" in document) {
					on(wrapper, "touchend", function (evt){
						if(!/^(input|button|textarea)$/i.test(evt.target.tagName)) {
							evt.preventDefault();
						}
					});
				}
				// Calling evt.preventDefault() suppresses the native click event on most browsers.  However, it doesn't
				// suppress the synthetic click event emitted by dojo/touch.  In order for clicks in popups to work
				// consistently, always use dojo/touch in popups.  See #18150.
				wrapper.dojoClick = true;
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			// Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
			var ltr = domGeometry.isBodyLtr(widget.ownerDocument),
				style = {
					visibility: "hidden",
					top: "-9999px",
					display: ""
				};
			style[ltr ? "left" : "right"] = "-9999px";
			style[ltr ? "right" : "left"] = "auto";
			domStyle.set(wrapper, style);

			return wrapper;
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			//		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			/* CURAM-FIX:
			 * This is an IE11 specific accessibility fix. When a popup is hidden after selecting a menuitem,
			 * the screenreader virtual cursor is not moving to the input field of the page that's then opened.
			 * It appears to be related to the "display:none" styling applied to the menu.
			 * This fix visually hides the menu and after 200ms, sets the original dojo styling.
			 * This gives the screenreader a chance for the virtual cursor to move to the new field.
			 */
			if (dojo.hasClass(wrapper, "dijitMenuPopup") && (has('trident') || has('edge') || has('ie'))) {
				
				// Visually hide popup
				domAttr.set(wrapper, "aria-hidden", "true");
				domStyle.set(wrapper, {
					position: "absolute",
					overflow: "hidden",
					clip: "rect(0 0 0 0)",
					height: "1px",
					width: "1px",
					margin: "-1px",
					padding: "0",
					border: "0"
				});
				
				setTimeout(function(){
					// Only apply the original stylings if menu is visually hidden.
					if(domAttr.get(wrapper, "aria-hidden", "true")){
						domStyle.set(wrapper, {
						display: "none",
						height: "auto",
						overflowY: "visible",
						border: "",
						position: "",
						overflow: "",
						clip: "",
						width: "",
						margin: "",
						padding: ""
					  });
					}
					
				}, 200, wrapper);
			} else {
				// use original styling for other browsers.
				domStyle.set(wrapper, {
					display: "none",
					height: "auto",		// Open may have limited the height to fit in the viewport
					overflowY: "visible",	// and set overflowY to "auto".
					border: ""			// Open() may have moved border from popup to wrapper.
				});
			}
			/* END CURAM-FIX */

			// Open() may have moved border from popup to wrapper.  Move it back.
			var node = widget.domNode;
			if("_originalStyle" in node){
				node.style.cssText = node._originalStyle;
			}
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				node = widget.domNode,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){
				this.close(stack[stack.length - 1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
			// off screen) so we can do sizing calculations.
			var wrapper = this.moveOffScreen(widget);

			if(widget.startup && !widget._started){
				widget.startup(); // this has to be done after being added to the DOM
			}

			// Limit height to space available in viewport either above or below aroundNode (whichever side has more
			// room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
			// dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
			var maxHeight, popupSize = domGeometry.position(node);
			if("maxHeight" in args && args.maxHeight != -1){
				maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
			}else{
				var viewport = Viewport.getEffectiveBox(this.ownerDocument),
					aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
				maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
			}
			if(popupSize.h > maxHeight){
				// Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
				// and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
				var cs = domStyle.getComputedStyle(node),
					borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;

				domStyle.set(wrapper, {
					overflowY: "scroll",
					/* CURAM-FIX: Dojo bug here. Border size is excluded from the maximum height set on the popup wrapper,
	                                 * which causes the popup a bit truncated. Also in IE11, the borderLeftWidth got there is incorrect (0.5px instead of 1px).
	                                 * This is fixed using the CSS rules "border-width: 1px !important" given the fact that the border width in Curam is set
	                                 * to "1px". therefore, here we can determine to minus 2 from maxHeight to set for the wrapper's height.
	                                 */
					height: (maxHeight-2) + "px",
					/* END CURAM-FIX */
					border: borderStyle	// so scrollbar is inside border
				});
				node._originalStyle = node.style.cssText;
				node.style.border = "none";
			}

			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});
			
			/* CURAM-FIX:
			 * This is an IE11 specific accessibility fix. If the popup was visually hidden
			 * but a user chooses to open the popup again while it's still visually hidden,
			 * revert those specific stylings.
			 */
			if (dojo.hasClass(wrapper, "dijitMenuPopup") && (has('trident') || has('edge') || has('ie'))) {
				
				if(domAttr.get(wrapper, "aria-hidden") === "true"){
					
					domStyle.set(wrapper, {
					 	position: "",
					 	clip: "",
					 	width: "",
					 	margin: "",
					 	padding: "",
					 	border: ""
					 });
				}
				
				domAttr.set(wrapper, "aria-hidden", "false");
			}
			/* END CURAM-FIX */

			if(stack.length == 0 && around){
				// First element on stack. Save position of aroundNode and setup listener for changes to that position.
				this._firstAroundNode = around;
				this._firstAroundPosition = domGeometry.position(around, true);
				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
			}

			if(has("config-bgIframe") && !widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			// position the wrapper node and make it visible
			var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null,
				best = around ?
					place.around(wrapper, around, orient, ltr, layoutFunc) :
					place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
						layoutFunc);

			wrapper.style.visibility = "visible";
			node.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, "keydown", lang.hitch(this, function(evt){
				if(evt.keyCode == keys.ESCAPE && args.onCancel){
					evt.stopPropagation();
					evt.preventDefault();
					/* CURAM-FIX: add evt param here*/
					args.onCancel(evt);
					/* END CURAM-FIX*/
				}else if(evt.keyCode == keys.TAB){
					evt.stopPropagation();
					evt.preventDefault();
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						/* CURAM-FIX: add evt param here*/
						topPopup.onCancel(evt);
						/* END CURAM-FIX*/
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				wrapper: wrapper,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){
				return elem.widget == popup;
			})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if (widget.bgIframe) {
					// push the iframe back onto the stack.
					widget.bgIframe.destroy();
					delete widget.bgIframe;
				}

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).
					// Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted
					// (i.e. that the TabContainer's tab's [x] icon was clicked)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){
					h.remove();
				}

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}
			
			if(stack.length == 0 && this._aroundMoveListener){
				clearTimeout(this._aroundMoveListener);
				this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/_base/manager':function(){
define([
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"dojo/_base/lang",
	"../registry",
	"../main"	// for setting exports to dijit namespace
], function(array, config, lang, registry, dijit){

	// module:
	//		dijit/_base/manager

	var exports = {
		// summary:
		//		Deprecated.  Shim to methods on registry, plus a few other declarations.
		//		New code should access dijit/registry directly when possible.
	};

	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		exports[name] = registry[name];
	});

	 lang.mixin(exports, {
		 // defaultDuration: Integer
		 //		The default fx.animation speed (in ms) to use for all Dijit
		 //		transitional fx.animations, unless otherwise specified
		 //		on a per-instance basis. Defaults to 200, overrided by
		 //		`djConfig.defaultDuration`
		 defaultDuration: config["defaultDuration"] || 200
	 });

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/layout/StackController':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-construct",
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/topic",
	"../focus", // focus.focus()
	"../registry", // registry.byId
	"../_Widget",
	"../_TemplatedMixin",
	"../_Container",
	"../form/ToggleButton",
	"dojo/touch"	// for normalized click handling, see dojoClick property setting in postCreate()
], function(array, declare, domClass, domConstruct, keys, lang, on, topic,
			focus, registry, _Widget, _TemplatedMixin,_Container, ToggleButton){

	// module:
	//		dijit/layout/StackController

	var StackButton = declare("dijit.layout._StackButton", ToggleButton, {
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		// closeButton: Boolean
		//		When true, display close button for this tab
		closeButton: false,

		_aria_attr: "aria-selected",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			(this.focusNode || this.domNode).setAttribute("role", "tab");
		}
	});


	var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {
		// summary:
		//		Set of buttons to select a page in a `dijit/layout/StackContainer`
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

		baseClass: "dijitStackController",

		templateString: "<span role='tablist' data-dojo-attach-event='onkeydown'></span>",

		// containerId: [const] String
		//		The id of the page container that I point to
		containerId: "",

		// buttonWidget: [const] Constructor
		//		The button widget to create to correspond to each page
		buttonWidget: StackButton,

		// buttonWidgetCloseClass: String
		//		CSS class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitStackCloseButton",

		pane2button: function(/*String*/ id){
			// summary:
			//		Returns the button corresponding to the pane w/the given id.
			// tags:
			//		protected
			return registry.byId(this.id + "_" + id);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Listen to notifications from StackContainer.  This is tricky because the StackContainer may not have
			// been created yet, so abstracting it through topics.
			// Note: for TabContainer we can do this through bubbled events instead of topics; maybe that's
			// all we support for 2.0?
			this.own(
				topic.subscribe(this.containerId + "-startup", lang.hitch(this, "onStartup")),
				topic.subscribe(this.containerId + "-addChild", lang.hitch(this, "onAddChild")),
				topic.subscribe(this.containerId + "-removeChild", lang.hitch(this, "onRemoveChild")),
				topic.subscribe(this.containerId + "-selectChild", lang.hitch(this, "onSelectChild")),
				topic.subscribe(this.containerId + "-containerKeyDown", lang.hitch(this, "onContainerKeyDown"))
			);

			// Listen for click events to select or close tabs.
			// No need to worry about ENTER/SPACE key handling: tabs are selected via left/right arrow keys,
			// and closed via shift-F10 (to show the close menu).
			// Also, add flag to use normalized click handling from dojo/touch
			this.containerNode.dojoClick = true;
			this.own(on(this.containerNode, 'click', lang.hitch(this, function(evt){
				var button = registry.getEnclosingWidget(evt.target);
				if(button != this.containerNode && !button.disabled && button.page){
					for(var target = evt.target; target !== this.containerNode; target = target.parentNode){
						if(domClass.contains(target, this.buttonWidgetCloseClass)){
							this.onCloseButtonClick(button.page);
							break;
						}else if(target == button.domNode){
							this.onButtonClick(button.page);
							break;
						}
					}
				}
			})));
		},

		onStartup: function(/*Object*/ info){
			// summary:
			//		Called after StackContainer has finished initializing
			// tags:
			//		private
			this.textDir = info.textDir;
			array.forEach(info.children, this.onAddChild, this);
			if(info.selected){
				// Show button corresponding to selected pane (unless selected
				// is null because there are no panes)
				this.onSelectChild(info.selected);
			}

			// Reflect events like page title changes to tab buttons
			var containerNode = registry.byId(this.containerId).containerNode,
				pane2button = lang.hitch(this, "pane2button"),
				paneToButtonAttr = {
					"title": "label",
					"showtitle": "showLabel",
					"iconclass": "iconClass",
					"closable": "closeButton",
					"tooltip": "title",
					"disabled": "disabled",
					"textdir": "textdir"
				},
				connectFunc = function(attr, buttonAttr){
					return on(containerNode, "attrmodified-" + attr, function(evt){
						var button = pane2button(evt.detail && evt.detail.widget && evt.detail.widget.id);
						if(button){
							button.set(buttonAttr, evt.detail.newValue);
						}
					});
				};
			for(var attr in paneToButtonAttr){
				this.own(connectFunc(attr, paneToButtonAttr[attr]));
			}
		},

		destroy: function(preserveDom){
			// Since the buttons are internal to the StackController widget, destroy() should remove them.
			// When #5796 is fixed for 2.0 can get rid of this function completely.
			this.destroyDescendants(preserveDom);
			this.inherited(arguments);
		},

		onAddChild: function(/*dijit/_WidgetBase*/ page, /*Integer?*/ insertIndex){
			// summary:
			//		Called whenever a page is added to the container.
			//		Create button corresponding to the page.
			// tags:
			//		private

			// create an instance of the button widget
			// (remove typeof buttonWidget == string support in 2.0)
			var Cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
			var button = new Cls({
				id: this.id + "_" + page.id,
				name: this.id + "_" + page.id, // note: must match id used in pane2button()
				label: page.title,
				disabled: page.disabled,
				ownerDocument: this.ownerDocument,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir || this.textDir,
				showLabel: page.showTitle,
				iconClass: page.iconClass,
				closeButton: page.closable,
				title: page.tooltip,
				page: page
			});

			this.addChild(button, insertIndex);
			page.controlButton = button;	// this value might be overwritten if two tabs point to same container
			if(!this._currentChild){
				// If this is the first child then StackContainer will soon publish that it's selected,
				// but before that StackContainer calls layout(), and before layout() is called the
				// StackController needs to have the proper height... which means that the button needs
				// to be marked as selected now.   See test_TabContainer_CSS.html for test.
				this.onSelectChild(page);
			}

			// Add this StackController button to the list of things that labels that StackContainer pane.
			// Also, if there's an aria-labelledby parameter for the pane, then the aria-label parameter is unneeded.
			var labelledby = page._wrapper.getAttribute("aria-labelledby") ?
				page._wrapper.getAttribute("aria-labelledby") + " " + button.id : button.id;
			page._wrapper.removeAttribute("aria-label");
			page._wrapper.setAttribute("aria-labelledby", labelledby);
		},

		onRemoveChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever a page is removed from the container.
			//		Remove the button corresponding to the page.
			// tags:
			//		private

			if(this._currentChild === page){
				this._currentChild = null;
			}

			var button = this.pane2button(page.id);
			if(button){
				this.removeChild(button);
				button.destroy();
			}
			delete page.controlButton;
		},

		onSelectChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called when a page has been selected in the StackContainer, either by me or by another StackController
			// tags:
			//		private

			if(!page){
				return;
			}

			if(this._currentChild){
				var oldButton = this.pane2button(this._currentChild.id);
				oldButton.set('checked', false);
				oldButton.focusNode.setAttribute("tabIndex", "-1");
			}

			var newButton = this.pane2button(page.id);
			newButton.set('checked', true);
			this._currentChild = page;
			newButton.focusNode.setAttribute("tabIndex", "0");
			var container = registry.byId(this.containerId);
		},

		onButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons is pressed in an attempt to select a page
			// tags:
			//		private

			var button = this.pane2button(page.id);

			// For TabContainer where the tabs are <span>, need to set focus explicitly when left/right arrow
			focus.focus(button.focusNode);

			if(this._currentChild && this._currentChild.id === page.id){
				//In case the user clicked the checked button, keep it in the checked state because it remains to be the selected stack page.
				button.set('checked', true);
			}
			var container = registry.byId(this.containerId);
			container.selectChild(page);
		},

		onCloseButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
			// tags:
			//		private

			var container = registry.byId(this.containerId);
			container.closeChild(page);
			if(this._currentChild){
				var b = this.pane2button(this._currentChild.id);
				if(b){
					focus.focus(b.focusNode || b.domNode);
				}
			}
		},

		// TODO: this is a bit redundant with forward, back api in StackContainer
		adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Helper for onkeydown to find next/previous button
			// tags:
			//		private

			if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){
				forward = !forward;
			}
			// find currently focused button in children array
			var children = this.getChildren();
			var idx = array.indexOf(children, this.pane2button(this._currentChild.id)),
				current = children[idx];

			// Pick next/previous non-disabled button to focus on.   If we get back to the original button it means
			// that all buttons must be disabled, so return current child to avoid an infinite loop.
			var child;
			do{
				idx = (idx + (forward ? 1 : children.length - 1)) % children.length;
				child = children[idx];
			}while(child.disabled && child != current);

			return child; // dijit/_WidgetBase
		},

		onkeydown: function(/*Event*/ e, /*Boolean?*/ fromContainer){
			// summary:
			//		Handle keystrokes on the page list, for advancing to next/previous button
			//		and closing the current page if the page is closable.
			// tags:
			//		private

			if(this.disabled || e.altKey){
				return;
			}
			var forward = null;
			if(e.ctrlKey || !e._djpage){
				switch(e.keyCode){
					case keys.LEFT_ARROW:
					case keys.UP_ARROW:
						if(!e._djpage){
							forward = false;
						}
						break;
					case keys.PAGE_UP:
						if(e.ctrlKey){
							forward = false;
						}
						break;
					case keys.RIGHT_ARROW:
					case keys.DOWN_ARROW:
						if(!e._djpage){
							forward = true;
						}
						break;
					case keys.PAGE_DOWN:
						if(e.ctrlKey){
							forward = true;
						}
						break;
					case keys.HOME:
						// Navigate to first non-disabled child
						var children = this.getChildren();
						for(var idx = 0; idx < children.length; idx++){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.END:
						// Navigate to last non-disabled child
						var children = this.getChildren();
						for(var idx = children.length - 1; idx >= 0; idx--){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.DELETE:
					case "W".charCodeAt(0):    // ctrl-W
						if(this._currentChild.closable &&
							(e.keyCode == keys.DELETE || e.ctrlKey)){
							this.onCloseButtonClick(this._currentChild);

							// avoid browser tab closing
							e.stopPropagation();
							e.preventDefault();
						}
						break;
					case keys.TAB:
						if(e.ctrlKey){
							this.onButtonClick(this.adjacent(!e.shiftKey).page);
							e.stopPropagation();
							e.preventDefault();
						}
						break;
				}
				// handle next/previous page navigation (left/right arrow, etc.)
				if(forward !== null){
					this.onButtonClick(this.adjacent(forward).page);
					e.stopPropagation();
					e.preventDefault();
				}
			}
		},

		onContainerKeyDown: function(/*Object*/ info){
			// summary:
			//		Called when there was a keydown on the container
			// tags:
			//		private
			info.e._djpage = info.page;
			this.onkeydown(info.e);
		}
	});

	StackController.StackButton = StackButton;	// for monkey patching

	return StackController;
});

},
'curam/util/onLoad':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2016. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 15-Jun-2021 SK  Removing old IE related functionality to free up memory.
   * 08-Jun-2016 SO  [156831] Removing the ie-progress-indicator-helper iframe
   * 06-May-2014 AB   [Cr00430639]Adding title to Iframe-RPT project
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
   * 14-Dec-2010  MV  [CR00238518] Ensure the hidden iframe is not picked up by
   *    WordIntegration control.
   * 06-Dec-2010  MV  [CR00233442] Avoid never ending progress bar in IE.
   * 19-Nov-2010  MV  [CR00231655] Subscribe/connect to events with
   *    a function that will automatically unsubscribe/disconnect on page unload.
   * 30-Jun-2010 MV [CR00161271] Update documentation.
   * 11-Jun-2010 MV [CR00202971] Fixed function for removing subscribers.
   * 02-Jun-2010 MV [CR00202412] Initial version.
   */

define(['curam/util',
        'curam/define',
        'curam/debug',
        'dojo/dom-attr'], function(util, define, debug, attr) {

  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  //dojo.requireLocalization("curam.application", "Debug");
  //var bundle = new curam.util.ResourceBundle("Debug");
  
  define.singleton("curam.util.onLoad", {
    EVENT: "/curam/frame/load",

    // Used in the context of the iframe.
    publishers: [],

    /* Used in the context of the parent window and contains subscribers
     * for all the iframes that exist in this window context.
     */
    subscribers: [],

    defaultGetIdFunction: function(iframeNode) {
      // summary:
      // This is the default function for getting a unique ID of an iframe.
      // If the iframe has a CSS class that starts with "iframe-" then this class
      // is returned as the unique ID of the iframe.
      var classes = attr.get(iframeNode, "class").split(" ");
      return dojo.filter(classes, function(className) {
        return className.indexOf("iframe-") == 0;
      })[0];
    },

    addPublisher: function(callback) {
      // summary:
      //   Public function, is called in the context of the iframe window.
      curam.util.onLoad.publishers.push(callback);
    },

    addSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //   This is called in the context of the parent window.
      //   Multiple subscribers per iframe can be registered, provided each
      //   has a different handler function.
      // parameter: getId
      //   optional, if not specified the default getId function will be used

      curam.util.onLoad.subscribers.push({
        "getId": getId ? getId : curam.util.onLoad.defaultGetIdFunction,
        "callback": callback,
        "iframeId": iframeId
      });
    },

    removeSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //  Must be called in the context of the parent window.

      curam.util.onLoad.subscribers =
        dojo.filter(curam.util.onLoad.subscribers, function(subscriberData) {
          return !(subscriberData.iframeId == iframeId
              && subscriberData.callback == callback);
        });
    },

    execute: function() {
      // summary:
      //   Public function, is called in the context of the iframe window.

      if(window.parent == window) {
        curam.debug.log("curam.util.onLoad.execute(): " 
          + debug.getProperty("curam.util.onLoad.exit"));
        return;
      }

      var context = {};

      dojo.forEach(curam.util.onLoad.publishers, function(callback) {
        // Allow each of the publishers to add to the context object
        callback(context);
      });

      // Free up references to functions
      curam.util.onLoad.publishers = [];
      
      curam.util.getTopmostWindow().dojo.publish('/curam/progress/unload');
      window.parent.dojo.publish(curam.util.onLoad.EVENT, [window.frameElement, context]);
    }
  });

  /* Subscribe to events in the context this file is being loaded in.
   * This is meant for parent window contexts.
   */
  curam.util.subscribe(curam.util.onLoad.EVENT, function(iframeNode, context) {
    dojo.forEach(curam.util.onLoad.subscribers, function(subscriberData) {
      var currentId = subscriberData.getId(iframeNode);
      if (subscriberData.iframeId == currentId) {
        subscriberData.callback(currentId, context);
      }
    });
  });
  
  return curam.util.onLoad;
});

},
'dojo/request/default':function(){
define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'dijit/layout/TabContainer':function(){
define([
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/declare", // declare
	"./_TabContainerBase",
	"./TabController",
	"./ScrollingTabController"
], function(lang, declare, _TabContainerBase, TabController, ScrollingTabController){

	// module:
	//		dijit/layout/TabContainer


	return declare("dijit.layout.TabContainer", _TabContainerBase, {
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `TabContainer`.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: Class
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			// "string" branch for back-compat, remove for 2.0
			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = typeof this.controllerWidget == "string" ? lang.getObject(this.controllerWidget) :
						this.controllerWidget;

			return new TabController({
				id: this.id + "_tablist",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							ScrollingTabController : TabController;
			}
		}
	});
});

},
'dijit/BackgroundIframe':function(){
define([
	"require",			// require.toUrl
	"./main",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/sniff" // has("ie"), has("trident"), has("quirks")
], function(require, dijit, config, domConstruct, domStyle, lang, on, has){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// By default, it's enabled for IE6-10, excluding Windows Phone 8,
	// and it's also enabled for IE11 on Windows 7 and Windows 2008 Server.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("config-bgIframe",
		(has("ie") && !/IEMobile\/10\.0/.test(navigator.userAgent)) || // No iframe on WP8, to match 1.9 behavior
		(has("trident") && /Windows NT 6.[01]/.test(navigator.userAgent)));

	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = document.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index shenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node).
		//
		//		Makes a background iframe as a child of node, that fills
		//		area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("config-bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			//		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'curam/util/Constants':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["curam/define"
        ], function() {
  
  /*
   * Modification History
   * --------------------
   * 05-Jul-2011  KW  [CR00275353] Initial version
   */

  /**
   * Maintains a list of parameter name constants. 
   */
  curam.define.singleton("curam.util.Constants", {
    RETURN_PAGE_PARAM: "__o3rpu"
  });
  
  return curam.util.Constants;
});

},
'dijit/form/Button':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/has", //  1 
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html",
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

	// module:
	//		dijit/form/Button

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {
		// summary:
		//		Basically the same thing as a normal HTML button, but with special styling.
		// description:
		//		Buttons can display a label, an icon, or both.
		//		A label should always be specified (through innerHTML) or the label
		//		attribute.  It can be hidden via showLabel=false.
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		//
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// showLabel: Boolean
		//		Set this to true to hide the label text and display only the icon.
		//		(If showLabel=false then iconClass must be specified.)
		//		Especially useful for toolbars.
		//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
		//
		//		The exception case is for computers in high-contrast mode, where the label
		//		will still be displayed, since the icon doesn't appear.
		showLabel: true,

		// iconClass: String
		//		Class to apply to DOMNode in button to make it display an icon
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		baseClass: "dijitButton",

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setValueAttr: "valueNode",
		_setNameAttr: function(name){
			// avoid breaking existing subclasses where valueNode undefined.  Perhaps in 2.0 require it to be defined?
			if(this.valueNode){
				this.valueNode.setAttribute("name", name);
			}
		},

		_fillContent: function(/*DomNode*/ source){
			// Overrides _Templated._fillContent().
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			// TODO: remove the method in 2.0, parser will do it all for me
			if(source && (!this.params || !("label" in this.params))){
				var sourceLabel = lang.trim(source.innerHTML);
				if(sourceLabel){
					this.label = sourceLabel; // _applyAttributes will be called after buildRendering completes to update the DOM
				}
			}
		},

		_setShowLabelAttr: function(val){
			if(this.containerNode){
				domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
			}
			this._set("showLabel", val);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.  Use set('label', ...) instead.
			kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			//		If the label is hidden (showLabel=false) then and no title has
			//		been specified, then label is also set as title attribute of icon.
			this.inherited(arguments);
			if(!this.showLabel && !("title" in this.params)){
				this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		}
	});

	if(has("dojo-bidi")){
		Button = declare("dijit.form.Button", Button, {
			_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				if(this.titleNode.title){
					this.applyTextDir(this.titleNode, this.titleNode.title);
				}
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this._setLabelAttr(this.label); // call applyTextDir on both focusNode and titleNode
				}
			}
		});
	}

	return Button;
});

},
'dijit/_WidgetBase':function(){
define([
	"require", // require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/has",
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.body()
	"./Destroyable",
	"dojo/has!dojo-bidi?./_BidiMixin",
	"./registry"    // registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

/* CURAM-FIX: Extend ContentPane to allow P&S instrumentation. */
var curamPerfTrackingEnabled = typeof(dojo.global.perf) != "undefined";

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	 1 || has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,
		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

                /* CURAM-FIX: P&S */
                if(curamPerfTrackingEnabled) {
                        perf.widgetStartedLoadingCallback();
                }
                /* END CURAM-FIX */

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;

                /* CURAM-FIX: P&S */
                if(curamPerfTrackingEnabled) {
                        perf.widgetLoadedCallback(this);
                }
                /* END CURAM-FIX */
			
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
});

},
'dijit/layout/_TabContainerBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"./StackContainer",
	"./utils", // marginBox2contextBox, layoutChildren
	"../_TemplatedMixin",
	"dojo/text!./templates/TabContainer.html"
], function(declare, domClass, domGeometry, domStyle, StackContainer, layoutUtils, _TemplatedMixin, template){

	// module:
	//		dijit/layout/_TabContainerBase

	return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {
		// summary:
		//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
		//		and return the widget that displays the tab labels
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// tabPosition: String
		//		Defines where tabs go relative to tab content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		baseClass: "dijitTabContainer",

		// tabStrip: [const] Boolean
		//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
		//		around the set of tabs.   Not supported by claro theme.
		tabStrip: false,

		// nested: [const] Boolean
		//		If true, use styling for a TabContainer nested inside another TabContainer.
		//		For tundra etc., makes tabs look like links, and hides the outer
		//		border since the outer TabContainer already has a border.
		nested: false,

		templateString: template,

		postMixInProperties: function(){
			// set class name according to tab position, ex: dijitTabContainerTop
			this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

			this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");

			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
			this.tablist = this._makeController(this.tablistNode);

			if(!this.doLayout){
				domClass.add(this.domNode, "dijitTabContainerNoLayout");
			}

			if(this.nested){
				/* workaround IE's lack of support for "a > b" selectors by
				 * tagging each node in the template.
				 */
				domClass.add(this.domNode, "dijitTabContainerNested");
				domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
				domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
				domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
			}else{
				domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
			}
		},

		_setupChild: function(/*dijit/_WidgetBase*/ tab){
			// Overrides StackContainer._setupChild().
			domClass.add(tab.domNode, "dijitTabPane");
			this.inherited(arguments);
		},

		startup: function(){
			if(this._started){
				return;
			}

			// wire up the tablist and its tabs
			this.tablist.startup();

			this.inherited(arguments);
		},

		layout: function(){
			// Overrides StackContainer.layout().
			// Configure the content pane to take up all the space except for where the tabs are

			if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){
				return;
			}

			var sc = this.selectedChildWidget;

			if(this.doLayout){
				// position and size the titles and the container node
				var titleAlign = this.tabPosition.replace(/-h/, "");
				this.tablist.region = titleAlign;
				var children = [this.tablist, {
					domNode: this.tablistSpacer,
					region: titleAlign
				}, {
					domNode: this.containerNode,
					region: "center"
				}];
				layoutUtils.layoutChildren(this.domNode, this._contentBox, children);

				// Compute size to make each of my children.
				// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
				this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);

				if(sc && sc.resize){
					sc.resize(this._containerContentBox);
				}
			}else{
				// just layout the tab controller, so it can position left/right buttons etc.
				if(this.tablist.resize){
					//make the tabs zero width so that they don't interfere with width calc, then reset
					var s = this.tablist.domNode.style;
					s.width = "0";
					var width = domGeometry.getContentBox(this.domNode).w;
					s.width = "";
					this.tablist.resize({w: width});
				}

				// and call resize() on the selected pane just to tell it that it's been made visible
				if(sc && sc.resize){
					sc.resize();
				}
			}
		},

		destroy: function(preserveDom){
			if(this.tablist){
				this.tablist.destroy(preserveDom);
			}
			this.inherited(arguments);
		}
	});
});

},
'curam/widget/ComboBoxMixin':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2015. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/**
 * Override of the Dojo ComboBoxMixin module to load a custom ComboBoxMenu module.
 */
define(["dojo/_base/declare",
         "curam/widget/_ComboBoxMenu",
         "dijit/form/ComboBoxMixin"
], function(declare, _ComboBoxMenu){
  
  /*
   * Modification History
   * --------------------
   * 20-Nov-2015 AZ [CR00472692] Initial Version
   */
  /**
   * @name curam.widget.ComboBoxMixin
   * @namespace Override of the Dojo ComboBoxMixin in order to make the ComboBoxMixin
   *              accessible using screen reader.
   */
  var ComboBoxMixin = declare("curam.widget.ComboBoxMixin", dijit.form.ComboBoxMixin, 
  /**
   * @lends curam.widget.ComboBoxMixin.prototype
   */
  {
    dropDownClass: _ComboBoxMenu
  });
  
  return ComboBoxMixin;
});
},
'idx/main':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or 
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 
define(["require","dojo/_base/lang","dojo/_base/kernel","dojo/_base/window","dojo/ready","dojo/has","dojo/sniff","dojo/dom-class"], 
	   function(dRequire,dLang,dKernel,dWindow,dReady,dHas,dSniff,dDomClass) {
  /**
   * @name idx.main
   * @namespace This serves as the main module for the "idx" package when using "packages" in the "dojo config".
   *            This module's only action is to apply a CSS class to the body tag that identifies the Dojo version
   *            being utilized on the page. 
   */
	var iMain = dLang.getObject("idx", true);
	
	var majorVersion = dKernel.version.major;
	var minorVersion = dKernel.version.minor;
	
	var applyExtraClasses = function(){
		// apply dojo version class, "idx_dojo_1.x"
		var bodyNode = dWindow.body();
		var versionClass = "idx_dojo_" + dKernel.version.major + "_" + dKernel.version.minor;
		dDomClass.add(bodyNode, versionClass);	
		
		// apply bidi class for hebrew
		var locale = dKernel.locale.toLowerCase();
		if ((locale.indexOf("he") == 0) || (locale.indexOf("_il") >= 0)) {
			dDomClass.add(bodyNode, "idx_i18n_il");
		}
		
		// apply browser-specific classes
		if (dHas("ie")) {
			dDomClass.add(bodyNode, "dj_ie");
			dDomClass.add(bodyNode, "dj_ie" + dHas("ie"));
		} else if (dHas("ff")) {
			dDomClass.add(bodyNode, "dj_ff");
			dDomClass.add(bodyNode, "dj_ff" + dHas("ff"));
		} else if (dHas("safari")) {
			dDomClass.add(bodyNode, "dj_safari");
			dDomClass.add(bodyNode, "dj_safari" + dHas("safari"));		
		} else if (dHas("chrome")) {
			dDomClass.add(bodyNode, "dj_chrome");
			dDomClass.add(bodyNode, "dj_chrome" + dHas("chrome"));		
		} else if (dHas("webkit")) {
			dDomClass.add(bodyNode, "dj_webkit");		
		}
	}
	
	
	if ((majorVersion < 2) && (minorVersion < 7)) {
		// for dojo 1.6 we need to use "addOnLoad" to ensure the body exists first
		dojo.addOnLoad(applyExtraClasses);
	} else {
		dReady(applyExtraClasses);
	}
	
	return iMain;
});
},
'curam/util/Refresh':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012-2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 
  /*
   * Modification History
   * --------------------
   * 07-Feb-2023  BOS [SPM-126846] Ensuring that the corect number of tab action items are diaplyed
   * if no dynamic update.
   * 06-Jan-2023  BOS [SPM-126610] Path name change for manageInlineTabMenuStates() function.
   * 22-Nov-2022  AT [SPM-126184]  Support for autorecovery restore modal.
   * 16-Nov-2022  FN  [SPM-106691] Amending setupRefreshButton and adding accessibility
   *                               mark-up for screen reader.
   * 21-Nov-2014  MV  [CR00450009] Stop request if there is no data.
   * 17-Oct-2014  MV  [CR00447421] Logic for tab open scenario moved to refresh
   *                               controller.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
   * 27-Feb-2014  MV  [CR00419961] Move to common AJAX request API.
   * 07-Oct-2013  BOS [CR00396277] Refactoring to take account of the fact that
   *                    the selected tab may not be defined. 
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 05-Aug-2011  MV  [CR00283589] Stop the click event in refreshPage() function.
   * 29-Jul-2011  MV  [CR00269970] Make use of the new refresh controller.
   * 24-May-2011  MV  [CR00267843] Disallow auto refresh on submitted action pages.
   * 29-Apr-2011  SC  [CR00264826] Removed incorrect usage of getselectedtab.
   * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
   *                    panel on submit.
   * 22-Dec-2010  MV  [CR00239864] Only call menu/nav loaders if there is request
   *                    for menu/nav update.
   * 14-Dec-2010  DG  [CR00217921] Updated for "tabDescriptor" on a tab panel.
   *                    Added copyright.
   * 30-Nov-2010  FG  [CR00232780] Add a new function that may be used to refresh
   *                    the page content and smart panel of a page.
   * 13-Jul-2010  MV  [CR00210064] Ensure tab menu and navigation is not updated
   *                   twice on tab load.
   * 07-Jul-2010  MV  [CR00180694] Refactor to unify dynamic updates of actions
   *                  menu and tab navigation. Move JavaScript code from renderer
   *                  to here.
   * 29-Apr-2010  MV  [CR00195109] Uncomment menu bar refresh code.
   * 26-Apr-2010  JS  [CR00197709] Removed refresh navigation bar code.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 18-Nov-2009  MV  [CR00172452] Only call handlers for the corresponding tab.
   * 03-Aug-2009  MLB [CR00163869] Full refresh implementation.
   * 16-Jul-2009  MLB [CR00162701] Initial version.
*/

  define(["dijit/registry",
        "dojo/dom-class",
        "dojo/dom-attr",
        "curam/inspection/Layer",
        "curam/util/Request",
        "curam/define",
        "curam/debug",
        "curam/util/ResourceBundle",
        "curam/util",
        "curam/tab",
        "curam/util/ContextPanel",
        "curam/util/ui/refresh/TabRefreshController"
        ], function(registry, domClass, domAttr, layer, curamRequest, define, debug, resBundle) {
 

  /**
   * Contains functions for refreshing the various panels.
   */
  define.singleton("curam.util.Refresh", {
    // flag if the content panel has been submitted
    submitted : false,
    // the id of the page that was submitted
    pageSubmitted : "",
    // array of refresh configuration for all tabs
    refreshConfig : [],

    menuBarCallback: null,
    navigationCallback: null,
    
    /** Holds references to refresh controllers for individual tabs. */
    _controllers: {},
    
    /** Holds reference to the page level refresh button anchor. */
    _pageRefreshButton: undefined,

    /**
     * Called by the MenuBarRenderer to register functions to be used
     * for dynamically updating the menu items.
     * 
     * The function is called once for each opened tab that has dynamic menu
     * items. The assumption is that all such tabs are using the same callbacks
     * so only the first call to this function is used to set the callbacks.
     * Subsequent calls are ignored.
     * 
     * @param updateMenuItemStates
     * @param getRefreshParams
     */
    setMenuBarCallbacks: function(updateMenuItemStates, getRefreshParams) {
      if (!curam.util.Refresh.menuBarCallback) {
        curam.util.Refresh.menuBarCallback = {
          updateMenuItemStates: updateMenuItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    /**
     * Called by the NavigationTabRenderer to register functions to be used
     * for dynamically updating the navigation items.
     * 
     * The function is called once for each opened tab that has dynamic
     * navigation items. The assumption is that all such tabs are using the same
     * callbacks so only the first call to this function is used to set
     * the callbacks. Subsequent calls are ignored.
     * 
     * @param updateNavItemStates
     * @param getRefreshParams
     */
    setNavigationCallbacks: function(updateNavItemStates, getRefreshParams) {
      if (!curam.util.Refresh.navigationCallback) {
        curam.util.Refresh.navigationCallback = {
          updateNavItemStates: updateNavItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    refreshMenuAndNavigation: function(tabWidgetId, refreshMenuBar,
        refreshNavigation) {
      // Summary:
      //    Sends an AJAX request to get dynamic menu and navigation data
      //    and calls the functions for updating these components.
      curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
          + "tabWidgetId=%s, refreshMenuBar || refreshNavigation: %s || %s",
          tabWidgetId, refreshMenuBar, refreshNavigation);

      if (!refreshMenuBar && !refreshNavigation) {
        // do nothing
        curam.debug.log(debug.getProperty("curam.util.Refresh.no.refresh"));
        return;
      }

      var callbacks = {
        /**
         * Handles the successful return of the AJAX call.
         */
        update: function(tabWidgetId, result, ioargs) {
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.refresh"), result);
          var ncb = curam.util.Refresh.navigationCallback;
          curam.debug.log("refreshNavigation? ", refreshNavigation);
          if (refreshNavigation && result.navData && ncb) {
            ncb.updateNavItemStates(tabWidgetId, result);
          };
          var mcb = curam.util.Refresh.menuBarCallback;
          curam.debug.log("refreshMenuBar? ", refreshMenuBar);
          if (refreshMenuBar && result.menuData && mcb) {
            // TODO: Put this string in debug.js.properties -- BOS
            curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
              + "dynamic tab menu item update");
            mcb.updateMenuItemStates(tabWidgetId, result);
          } else {
            // TODO: Put this string in debug.js.properties -- BOS
            curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
              + "no dynamic data, updating initially loaded tab action items to show"
              + "only those that should be inlined");
            curam.util.TabActionsMenu.manageInlineTabMenuStates(tabWidgetId);
          }
        },

        /**
         * Handles the failure case of the AJAX call made to get data
         * for the dynamic items.
         */
        error: function(error, ioargs) {
          curam.debug.log("========= " + debug
            .getProperty("curam.util.Refresh.dynamic.failure") 
              + " ===========");
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.error"), error);
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.args"), ioargs);
          curam.debug.log("==================================================");
        }
      };

      // send the AJAX request
      var fullUrl = "servlet/JSONServlet?o3c=TAB_DYNAMIC_STATE_QUERY",
          hasAnyParams = false;
      var mcb = curam.util.Refresh.menuBarCallback;
      if (refreshMenuBar && mcb) {
        var menuParams = mcb.getRefreshParams( tabWidgetId);
        if (menuParams) {
          fullUrl += "&" + menuParams;
          hasAnyParams = true;
        }
      }
      var ncb = curam.util.Refresh.navigationCallback;
      if (refreshNavigation && ncb) {
        var navParams = ncb.getRefreshParams(tabWidgetId);
        if (navParams) {
          fullUrl += "&" + navParams;
          hasAnyParams = true;
        }
      }
      curam.debug.log(debug
          .getProperty("curam.util.Refresh.dynamic.refresh.req"));
      if (hasAnyParams) {
        curamRequest.post({
         url: fullUrl,
         handleAs: "json",
         preventCache: true,
         load: dojo.hitch(callbacks, "update", tabWidgetId),
         error: dojo.hitch(callbacks, "error")
      });

      } else {
        // manage the state on inline items
        curam.util.TabActionsMenu.manageInlineTabMenuStates(tabWidgetId);
        curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.refresh.no_dynamic_items"));
      }
    },
    
    /**
     * Called by the tab renderer this function ensures that if config is added
     * repeatedly, it overrides any existing config for the same tab.
     * 
     * This caters for closing and reopening tabs.
     * 
     * @param {Object} config The tab refresh configuration to add.
     */
    addConfig: function(config) {
      var updated = false;
      
      // if the config for the tab is already added, replace it with the new one
      dojo.forEach(curam.util.Refresh.refreshConfig, function(existingConfig) {
        if (existingConfig.tab == config.tab) {
          existingConfig.config = config.config;
          
          updated = true;
        }
      });
      
      // otherwise just add as a new config
      if (!updated) {
        curam.util.Refresh.refreshConfig.push(config);
      }
    },

    /**
     * Called by the tab renderer this function instantiates the refresh
     * controller for the specified tab.
     * 
     * @param {String} tabWidgetId Widget ID of the tab to create refresh
     *    controller for.
     */
    setupRefreshController: function(tabWidgetId) {
      curam.debug.log("curam.util.Refresh.setupRefreshController " 
         + debug.getProperty("curam.util.ExpandableLists.load.for"), 
           tabWidgetId);
      
      var selectedTab = registry.byId(tabWidgetId);
      var tabId = selectedTab.tabDescriptor.tabID;
      
      var filteredConfigs = dojo.filter(curam.util.Refresh.refreshConfig,
          function(item) { return item.tab == tabId; });

      if (filteredConfigs.length == 1) {
        var refreshConfigTab = filteredConfigs[0];
        var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, refreshConfigTab);
        curam.util.Refresh._controllers[tabWidgetId] = ctl;
        ctl.setRefreshHandler(curam.util.Refresh.handleRefreshEvent);
      
      } else {
        if (filteredConfigs.length == 0) {
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.no.dynamic.refresh"), tabWidgetId);
          var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, null);
          curam.util.Refresh._controllers[tabWidgetId] = ctl;
        
        } else {
          throw "curam.util.Refresh: multiple dynamic refresh "
              + "configurations found for tab " + tabWidgetId;

        }
      }
      
      // destroy controller reference on tab close
      curam.tab.executeOnTabClose(function() {
        curam.util.Refresh._controllers[tabWidgetId].destroy();
        curam.util.Refresh._controllers[tabWidgetId] = undefined;
      }, tabWidgetId);
    },
    
    /**
     * Returns the refresh controller for the specified tab, throwing exception
     * in case controller doesn't exist for the tab.
     * 
     * @param tabWidgetId Widget ID of the tab.
     * 
     * @returns The refresh controller.
     */
    getController: function(tabWidgetId) {
      var ctl = curam.util.Refresh._controllers[tabWidgetId];
      if (!ctl) {
        throw "Refresh controller for tab '" + tabWidgetId + "' not found!";
      }
      return ctl;
    },
    
    /**
     * This is called by nested frames to notify the refresh controller of a page
     * load.
     * 
     * @param iframeId ID of the source iframe.
     * @param context The context in which the load happened.
     */
    handleOnloadNestedInlinePage: function(iframeId, context) {
      curam.debug.log("curam.util.Refresh.handleOnloadNestedInlinePage " 
        + debug.getProperty("curam.util.Refresh.iframe", [iframeId, context]));
       var topmostWin = curam.util.getTopmostWindow();
       var tabWidgetId = undefined;

      // get the source tab of the nested page
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        tabWidgetId = curam.tab.getTabWidgetId(sourceTab);  
      }

      if (tabWidgetId) {
        curam.debug.log(debug.getProperty("curam.util.Refresh.parent"), 
                      tabWidgetId);
        topmostWin.curam.util.Refresh.getController(tabWidgetId).pageLoaded(
          context.pageID,
          curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_INLINE);
        topmostWin.dojo.publish("/curam/main-content/page/loaded",
          [context.pageID, tabWidgetId, sourceTab]);
        return true;
      }
      return false;
    },

    /**
     * Handles refresh events emitted by refresh controllers for tabs in the UI.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     */
    handleRefreshEvent: function(eventIds) {
      var contextPanelRefreshHandler = function(tabWidgetId) {
        curam.util.ContextPanel.refresh(registry.byId(tabWidgetId));
      };
      var mainContentRefreshHandler = function(tabWidgetId) {
        curam.tab.refreshMainContentPanel(registry.byId(tabWidgetId));
      };
      var menuAndNavigationRefreshHandler =
      function(tabWidgetId, refreshMenuBar, refreshNavigation) {
        curam.util.Refresh.refreshMenuAndNavigation(
            tabWidgetId, refreshMenuBar, refreshNavigation);
      };
      curam.util.Refresh._doRefresh(eventIds, contextPanelRefreshHandler,
        mainContentRefreshHandler, menuAndNavigationRefreshHandler);
    },
    
    /**
     * Performs the actual refresh using the specified handlers.
     * THis is factored out to a separate function so that it can be unit tested.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     * @param {Function} refreshContextPanel A handler to be called when context
     *            panel refresh is required.
     * @param refreshMainContent A handler to be called when main content panel
     *            refresh is required.
     * @param refreshMenuAndNavigation A handler to be called when menu
     *            and navigation refresh is required.
     */
    _doRefresh: function(eventIds, refreshContextPanel, refreshMainContent,
        refreshMenuAndNavigation) {

      var tabWidgetId = null;
      var refreshMenuBar = false;
      var refreshNavigation = false;
      var refreshContext = false;
      var refreshMain = false;
      var trc = curam.util.ui.refresh.TabRefreshController.prototype;
      dojo.forEach(eventIds, function(eventId) {
        var lastSlashIndex = eventId.lastIndexOf("/");
        var target = eventId.slice(0, lastSlashIndex);
        // all events are for the same tabWidgetId so just read the first one
        if (!tabWidgetId) {
          tabWidgetId = eventId.slice(lastSlashIndex + 1, eventId.length);
        }
        // now read the target part
        if (target == trc.EVENT_REFRESH_MENU) {
          refreshMenuBar = true;
        }
        if (target == trc.EVENT_REFRESH_NAVIGATION) {
          refreshNavigation = true;
        }
        if (target == trc.EVENT_REFRESH_CONTEXT) {
          refreshContext = true;
        }
        if (target == trc.EVENT_REFRESH_MAIN) {
          refreshMain = true;
        }
      });
      
      // perform the refreshes
      if (refreshContext) {
        // refreshes the context panel
        refreshContextPanel(tabWidgetId);
      }
      if (refreshMain) {
        refreshMainContent(tabWidgetId);
      }
      refreshMenuAndNavigation(tabWidgetId, refreshMenuBar, refreshNavigation);
    },
    
    setupRefreshButton:function(buttonClass) {
      dojo.ready(function() {
        var button = dojo.query("." + buttonClass)[0];
        if (!button) {
          throw "Refresh button not found: " + buttonClass;
        }
        curam.util.Refresh._pageRefreshButton = button;
        var href = window.location.href;
        if (curam.util.isActionPage(href)) {
          // disable the button
          var bundle = new resBundle("Refresh");
          var disabledRefreshButtonText = bundle.getProperty("refresh.button.disabled");               
          domClass.add(button, "disabled");
          domAttr.set(button, "title", disabledRefreshButtonText);
          domAttr.set(button, "aria-label", disabledRefreshButtonText);
          domAttr.set(button, "role", "link");
          domAttr.remove(button, "href");
          domAttr.set(button, "aria-disabled", "true");
          curam.util.Refresh._pageRefreshButton._curamDisable = true;
          if (button.firstChild != null) {
            domClass.add(button.firstChild, "refresh-disabled");
            domAttr.set(button.firstChild, "alt", disabledRefreshButtonText); 
          }

        } else {
          domClass.add(button, "enabled");
          curam.util.Refresh._pageRefreshButton["_curamDisable"] = undefined;
        }
        
        curam.util.getTopmostWindow().curam.util.setupPreferencesLink(href);
      });
    },
    
    /**
     * Sets the force refresh flag to true and then invokes the function
     * that refreshes the main content area of a page. An event is also fired
     * that ensures that the associated smart panel is also refreshed.
     */
    refreshPage: function(event){
      dojo.stopEvent(event);

      var href = window.location.href;
      var buttonDisabled = curam.util.Refresh._pageRefreshButton._curamDisable;
      if(buttonDisabled) {
        // do nothing
        return;
      }

      // Ensure that the force refresh flag is set to true and make a call to
      // the function that will carry out the refresh operation.
      curam.util.FORCE_REFRESH = true;
      curam.util.redirectWindow(href, true);
    }
  });
  layer.register("curam/util/Refresh", curam.util.Refresh);

  return curam.util.Refresh;
});

},
'curam/util/ContextPanel':function(){
/*
 * Copyright 2010-2015 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dijit/registry",
        "dojo/dom-attr",
        "curam/inspection/Layer",

        "curam/debug",
        "curam/util/onLoad",
        "curam/util",

        "curam/tab",
        "curam/define"], function(registry, domAttr, layer, debug, onLoad) {

/*
 * Modification History
 * --------------------
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Adding debug statement.)
 * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
 * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 21-Oct-2012  SK  [CR00346419] Correctly unsubscribes from the onload registry
 *                               when a tab is closed.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 10-Sep-2012  MV  [CR00344216] Only subscribe one listener to tab ready event.
 * 31-Jul-2012  MV  [CR00336202] Refactor to also work in IE7.
 * 17-Jul-2012  MV  [CR00329547] Load context panel only after tab is ready.
 * 15-Dec-2011  MV [CR00299726] Synchronize initial load of panel with
 *                              subsequent refreshes. 
 * 26-Aug-2011  JK [TEC-7914]   Added title to context panel.
 * 29-Jul-2011  MV [CR00269970] Added refresh() function.
 * 20-Jan-2011  MV [CR00244126] Initial version.
 */






  
/**
 * @namespace Functions specific to the context panel.
 */
  curam.define.singleton("curam.util.ContextPanel", {
    
    /** Name of the attribute on content iframe that holds the URL of the frame
     * content. */
    CONTENT_URL_ATTRIB: "data-content-url",
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     */
    setupLoadEventPublisher: function(eventName, tabWidgetId, iframeId) {
      curam.util.ContextPanel._doSetup(eventName, tabWidgetId, iframeId,
          function(tabWidgetId) { return registry.byId(tabWidgetId); });
    },
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     * @param getTab A function to get tab widget based on ID.
     */
    _doSetup: function(eventName, tabWidgetId, iframeId, getTab) {
    var unsToken = curam.util.getTopmostWindow().dojo.subscribe(
          eventName, function() {
            var tab = getTab(tabWidgetId);
            var iframe = curam.util.ContextPanel._getIframe(tab);
            
            if (iframe) {
              curam.tab.executeOnTabClose(function() {
                // make sure we release iframe content - avoid memory leaks
                var src = domAttr.get(iframe, "src");
                domAttr.set(iframe, "src", "");
                curam.debug.log("curam.util.ContextPanel: Released iframe content for " + src);
              }, tabWidgetId);

            //publish when the detailsPanel is fully loaded
              debug
                .log(debug.getProperty("curam.util.ContextPanel.loaded"));
              curam.util.getTopmostWindow().dojo.publish(
                  '/curam/frame/detailsPanelLoaded', [{ loaded: true }, tabWidgetId]);
    
              // mark the frame as loaded
              iframe._finishedLoading = true;
    
              // effect a scheduled refresh if there is one
              if (iframe._scheduledRefresh) {
                curam.util.ContextPanel.refresh(tab);
                // scheduled refresh done - reset the indicator
                iframe._scheduledRefresh = false;
              }
            }         
        });

    onLoad.addSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    
    curam.tab.unsubscribeOnTabClose(unsToken, tabWidgetId);
    curam.tab.executeOnTabClose(function() {
      onLoad.removeSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    }, tabWidgetId);
  },
  
  /**
   * Refreshes the content panel of the specified tab.
   * This function is expected to be called in the top window runtime context. 
   */
  refresh: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        curam.debug.log(debug
          .getProperty("curam.util.ContextPanel.refresh.prep"));
        if (iframe._finishedLoading) {
          curam.debug.log(debug
            .getProperty("curam.util.ContextPanel.refresh"));
          // we will be reloading so reset the flag to guard against in-flight
          // refreshes interrupting
          iframe._finishedLoading = false;
          var doc =  iframe.contentDocument // W3C
                  || iframe.contentWindow.document; //IE
          // reload the context panel, but do use cached static resources 
          doc.location.reload(false);
  
        } else {
          // frame not yet loaded, delay the refresh after it has loaded fully
          curam.debug.log(debug
            .getProperty("curam.util.ContextPanel.refresh.delay"));
          iframe._scheduledRefresh = true;
        }
      }
    },
    
    /**
     * 
     * @param tab The tab to look for context panel in.
     * @returns A context panel iframe or undefined if it was not found. 
     */
    _getIframe: function(tab) {
      if (tab) {
        var frames = dojo.query("iframe.detailsPanelFrame", tab.domNode);
        return frames[0];
      }     
  },
  
  addTitle: function(iframeId) {
    var iframe = dojo.query("." + iframeId)[0];
    var pageTitle = iframe.contentWindow.document.title;
    iframe.setAttribute("title", CONTEXT_PANEL_TITLE + " - " + pageTitle);
    },
    
    /**
     * Loads the context panel content in its iframe.
     * The function gracefully handles situations where there is no context
     * panel on the tab or it has been loaded already.
     * 
     * Initially context panel iframe has no src attribute so that we can
     * control at which point in time the content is loaded.
     * 
     * @param tab The tab object to load context panel content for.
     */
    load: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        var source = domAttr.get(iframe,
            curam.util.ContextPanel.CONTENT_URL_ATTRIB);
        if (source && source != "undefined") {
          iframe[curam.util.ContextPanel.CONTENT_URL_ATTRIB] = undefined;
          domAttr.set(iframe, "src", source);
        }
      }
    }
  });
  
  /* Only load the context panel when the tab is setup completely.
   * This is to work around the issue in IE9 that was causing the iframe to be
   * garbage collected inadvertently.
   */
  var topWin = curam.util.getTopmostWindow();
  if (typeof topWin._curamContextPanelTabReadyListenerRegistered != "boolean") {
    topWin.dojo.subscribe(
        "/curam/application/tab/ready", null, function(newTab) {
          curam.util.ContextPanel.load(newTab);
        });
    topWin._curamContextPanelTabReadyListenerRegistered = true;
  }
  layer.register("curam/util/ContextPanel", this);

  return curam.util.ContextPanel;
});

},
'curam/util':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 10-Jan-2023 BOS [SPM-126610] Moved updateInlineTabMenuState() and manageInlineTabMenuStates()
 * function to curam.util.TabActionsMenu.js
 * 09-Jan-2023 LS [SPM-1260841] Skip to Main Content Link not accessible by keyboard.
 * 03-Jan-2023 JD [SPM-125865] Updated span to h1 in dojo query in _findAppropriateDynamicTitle.
 * 19-Dec-2022 BOS [SPM-126480] Added updateInlineTabMenuState() function for inline tab actions.
 * 14-Dec-2022 CMC[SPM-105222] Updated file download logic in clickHandlerForListActionMenu(). 
 * 13-Oct-2022 FN [SPM125042] Added _addContextToWidgetForScreenReader to pick up cluster context in java widget render ListBodyRendererConcernMember.
 * 09-Jun-2022 CM [RTC277941] Remove code around the session storage localRefresh key.
 * 06-May-2022 LS  [RTC277951] Date picker for received date is displayed open blocking content when new evidence is opened.
 * 21-Apr-2022 GB  [RTC277797] Added a new parameter to insertAriaLiveLabelRecordSearchItem related to the heading id to be used. 
 * 06-Apr-2022 LS [RTC277567] Check Boxes - selecting checkbox on various screen  is causing the screen to align the focus to the top of the screen.
 * 30-Mar-2022 JD  [RTC270575] Updated URLs for search widget so params are ignored by secure URLs solution.
 * 29-Mar-2022 CM  [RTC277374] Updated setupPreferencesLink() and setupLocaleLink() to remove outdated css class 
 * and _curamDisable attribute.
 * 25-Mar-2022 CM  [RTC277060] Updated _doRedirectWindow() to allow application to be refreshed from an ActionPage,
 * when the LOCALE_REFRESH parameter is set to true.
 * 23-Mar-2022 CM  [RTC277294] Updated openLocaleNew() to allow dialog to open correctly.
 * 21-Mar-2022 CM  [RTC277294] Added openLocaleNew() function to open the new Language modal.
 * 09-Mar-2022 CM  [RTC276771] Updated _doRedirectWindow() function to add check for LOCALE_REFRESH, and 
 * refresh the entire application if parameter is found. 
 * 14-Oct-2021 LS  [RTC274183] Focus doesn't start in right place on the page
 * 07-Oct-2021 FN  [RTC255412] Added _addAccessibilityMarkupInAddressClustersWhenContextIsMissing function.
 * 06-Oct-2021 BOS [RTC273988] Updated the addCarbonModalButton() function to put the dataTestID into
 * object rather than separate argument.
 * 06-Oct-2021 GB  [RTC273983] Adding the new parameter to returnFocusToPopupActionAnchorElement function.
 * 29-Sep-2021  GB [RTC273619] Added data-testid to the carbon modal buttons.
 * 09-Sep-2021  FN  [RTC268445] Refactor toClipboard() since IE11 drop to make it work on supported modern browsers.
 * 16-Aug-2021  LS  [RTC272772] Move focus to tab warning or error modal when opened
 * 11-Aug-2021  SK [RTC272800] Progress spinner invocation has changed to the decoupled version.
 * 15-Jun-2021  SK [RTC272800] Memory leak prevention.
 * 03-Jun-2021  BD [RTC271240] Added returnFocusToPopupActionAnchorElement and addPlaceholderFocusClassToEventOrAnchorTag 
 * functions.
 * 18-May-2021  FN [RTC265093] Updated loadInformationalMsgs and setFocusOnField to set element attributes and focus
 * on container-messages-ul.
 * 13-May-2021  BD [RTC266250] Updated loadInformationalMsgs, setFocus and doSetFocus to return container-messages-ul or
 * error-messages element.
 * 04-May-2021  LS [RTC270554] Remove css-vars-ponyfill package to improve performance.
 * 26-Apr-2021  ZV [RTC270145] Update word dialog to Carbon.
 * 31-Mar-2021  FN [RTC265093] Updated loadInformationalMsgs() to explicitly focus on the correct page where the error message
 * details should be announced by the screen-reader. Also updated setFocusOnField() to fix Shift+Tab issue on error messages
 * in IE11 with screen reader.
 * 15-Mar-2021 BOS [RTC269160] Handling buttons configured as JSON object rather than HTML string.
 * 11-Mar-2021  FN [RTC265093] Updated loadInformationalMsgs() to explicitly focus on the correct page where the error message
 * details should be announced by the screen-reader.
 * 09-Mar-2021  JD [RTC268623] Updated loadInformationalMsgs() to keep focus on navigation tab instead of info
 * message if the navigation tab was the last element selected.
 * 18-Feb-2021  BD [RTC268079] Update method setFocus to set the tabindex and focus on the current iframe. Fix 
 * condition to check for Edge Chromium browser.
 * 05-Feb-2021  JD [RTC265373] Updated insertAriaLiveLabelRecordSearchItem so text is announced by screen reader
 * when search results are returned.
 * 28-Jan-2021  BD [RTC265376] Changed from label to span the element that contains the css class fileuploadButton.
 * 02-Dec-2020 BOS [RTC266982] Added functions to handle the addition of button to CuramDialog.
 * 11-Nov-2020  DM [RTC266277] Load css-vars-ponyfill to implement custom css properties in IE11.
 * 08-May-2020  JD [RTC259879] Adjusted timeouts when setting focus in IE11, added setFocusOnField() and _createHiddenInputField().
 * 01-Apr-2020  FN [RTC250370] Updated updateListControlReadings in order to get links in lists read out by a screen-reader.
 * 31-Mar-2020  FN [RTC257127] Updated _setBrowserTabTitle() to fix issue on embedded pages with in-page navigation
 *                             tabs throwing error message(s).
 * 05-Feb-2020  FN [RTC254720] Added logic in _findAppropriateDynamicTitle() to fix issue on pages with 
 *                             error messages where browser tab title was not updating correctly to reflect the 
 *                             presence of an error message.
 * 29-Jan-2020  JD [RTC257000] Fixed issue in IE11 where main content area is printed twice when context panel
 *                             is collapsed.
 * 17-Jan-2020  SH [RTC255274] Don't return the tabButton if in a modal in doSetFocus.
 * 08-Jan-2020  SH [RTC255274] More updates to setFocus() for focusing on CKEditor fields.
 * 04-Dec-2019  AA [RTC255177] Updated setBrowserTabTitle to handle the scenario where title is undefined and 
 *                             curam.util._browserTabTitleData does not contain staticTabTitle, separator 
 *                             and appNameFirst.
 * 03-Dec-2019  SH [RTC255274] Prevent focus being moved in setFocus if the user has already 
 *                             focused on a form element manually.
 * 18-Nov-2019  CMC[RTC239509] Updated printPage() function.
 * 07-Nov-2019  GG [RTC251143] Added lastOpenedTabButton variable to store the last opened tab to manage the focus 
 * on just opened tabs and updated doSetFocus to exclude hidden fields and use lastOpenedTabButton to set focus.
 * 17-Oct-2019  FN [RTC251289] Added aria-hidden attribute to input elements with the attribute 'hidden-button'.
 * 14-Oct-2019  FN [RTC250878] Minor change in the curam.debug.log when returning the application section title.
 * 10-Oct-2019  CM [RTC253438] Added getter and setter methods for new variable exitingIEGScript variable.
 * 04-Oct-2019  FN [RTC250878] Fixing the default application section title to be reflected
 *                             in the browser tab. This default changes upon the user used for logging.
 * 03-Oct-2019  AA [RTC251481] Added tabButtonClicked variable to store the tab button clicked in the navigation
 *                             tab. Added set and get functions. Changed the doSetFocus function to return
 *                             the tab button when the user is navigating through tabs.
 * 20-Sep-2019  AA [RTC250096] Added function to remove a property from the session storage. Updated setFocus to 
 *                             set the focus on the search button when the property curamDefaultActionId 
 *                             is defined.
 * 29-Aug-2019	FN [RTC249991] Additional updates to _findAppropriateDynamicTitle() to update the browser 
 * 							   title to a widget title when a session timeout closes.
 * 08-Aug-2019  CM [RTC248363] Updated updateListControlReadings function to check for controls 
 *                             on lists when sorting is triggered, as some links were missing 
 *                             aria-labels due to not having any controls from the initial loading.
 * 29-Jul-2019	FN [RTC249991] Updated _findAppropriateDynamicTitle() to update the browser title to
 * 							   a modal title when a pop-up window closes.
 * 22-Jul-2019  JD [RTC250498] Updated doSetFocus function to cater for multi-select fields and
 * 							   action pop-up links.
 * 01-Jul-2019  GG [RTC245742] Added extendXHR to update session timeout time into sessionStorage.
 * 18-Jun-2019  CMC[RTC248518] Removing 'Select' from aria labels on links within sortable lists.
 * 05-Jun-2019  SK [RTC248394] Updates accessibility readings gradually for IE only.
 * 28-May-2019  CM [RTC242923] Added fileUploadOpenFileBrowser() function.
 * 27-May-2019  SH [RTC240305] Decode url params before comparing them in isSameUrl().
 * 26-Apr-2019  SK [RTC241554] Added methods for list control readings set up and
 *                             updating.
 * 11-Feb-2019  CM [RTC240091] Fixing accessibility issue on date time widget field. 
 *                             Function addLayoutStylingOnDateTimeWidgetOnZoom() adds
 *                             css styling.
 * 17-Jan-2019  CM [RTC241236] Fixing accessibility issue where page title was set to 
 *                             undefined on a UIM page with in-page navigation. Function
 *                             getPageTitleOnContentPanel() updates the page title for this
 *                             edge case.
 * 30-NOV-2018  BD [RTC238774] Added method to check if the window contains 
 * 							   when the user clicks to print the page. The method 
 * 							   _prepareContentPrint() creates the wrapper to include
 * 							   the content of iframe and disable the iframe on the page. 
 * 							   After prints the page, the method _deletePrintVersion()
 *                             removes the wrapper and enables the iframe again,
 *                             returning to the original.
 * 24-Oct-2018	CMC[RTC225885] Fixing accessibility issue where initial focus was not  
 * 							   being placed correctly on the first editable page element.
 * 23-Oct-2018   SK [RTC237984] Modified the focus setter to correctly handle the
 *                             select Dijit widget and to return field for focusing
 *                             rather than doing the focus inside.
 * 25-Sep-2018  SK [RTC235825] Corrected the key handling to take into account the 
 *                             potentially different registry entry for the
 *                             Select based dropdown. 
* 25-Sep-2018  SK [RTC235825] Corrected the key handling to take into account the 
 *                             potentially different registry entry for the
 *                             Select based dropdown.
 * 23-Aug-2018  BD [RTC229425]  Included publish to alert when the page will be redirected 
 *                               to the logout page. 
 * 21-Aug-2018  SK [RTC230487]   Optimization of the table striping code.
 * 09-May-2018  BD [RTC225963]   Fixed accessibility issues related with alerts the search results.
 * 11-Apr-2018  BD [RTC210785]  Removed scrolltop for ios devices.
 * 27-Mar-2018  JD [RTC224593]  Fixed issue where the CSS of each row in a list
 * 								was set to 'even' after sorting the list.
 * 11-OCT-2017  JD [RTC206743]  Added GENERIC_ERROR_MODAL_MAP so parameters can be
 * 								passed to generic-modal-error.jspx without using
 * 								appending them to the url.
 * 12-07-2017   SK [RTC201190]  Moved clipboard related JS from the old JS file and
 *                              the custom tag.
 * 31-Mar-2017  GB [RTC182027]  Encoding URL for openGenericErrorModalDialog and 
 * 								removing the parameters from the request.
 * 27-Mar-2017  FG [191880]     Removed references to portlets.
 * 23-Feb-2017  BD [188234]     Added method setParentFocusByChild
 * 25-Oct-2016  BD [180045]     Update the method showModalDialogWithRef to accept the 
 *                        windows options as parameter.     
 * 04-Aug-2016  CD [143055]     Logic fixed on iframeTitleFallBack.
 * 25-Jan-2016  AZ [CR00475431] Check-box does not receive focus, if it is the 
 *                              first item on a page.
 * 05-Nov-2015  AB [CR00472177] Toggle buttons are not visible in Windows
 *                              high-contrast mode.
 * 07-Sep-2015  AZ [CR00466289] clickButton() function could not locate submit
 *                              buttons.
 * 27-Aug-2015  AB [CR00465809] Dynamic browser tab titles.
 * 20-Aug-2015  AZ [CR00465719] Added an index to submit button ID for unique IDs
 * 08-Apr-2015  SK [CR00460103] Added internal modal dialog showing function with
 *                              dialog reference.
 * 27-Feb-2015  AB [CR00458854] TEC-17714 Added code related to opening an Ok/Cancel
 *                              modal dialog with a browser-specific message when
 *                              attempting to download a file
 * 24-Feb-2015  AZ [CR00458302] Refactor isShiftTab() and focusHelpIconOnTab()
 *                              into curam/ModalDialog
 * 17-Feb-2015  AZ [CR00458206] Update the doSetFocus() function to cater for
 *                              scenario where there is a from with no editable
 *                              fields. (Port CR00450079 from TI_60)
 * 10-Feb-2015  AZ [CR00457893] Avoid opening a modal dialog when tab has
 *                              not yet loaded (Port CR00455284 from TI_60)
 * 30-Sep-2014  MV [CR00436657] Fixed informational display problem after
 *              closing modal.
 * 22-Sep-2014  SK [CR00445339] Added inspection layer integration.
 * 12-Sep-2014  MV [CR00444603] Replace dojox/storage with HTML5 local storage.
 * 06-Jun-2014  AS [CR00428142] TEC-17091. Skiplink should become visible when focused
 * 03-Nov-2014  JY [CR00448474] Make the context panel print configurable.
 * 06-Oct-2014  MV [CR00446285] Use cache when reloading page.
 * 06-Jun-2014  AS [CR00428142] TEC-17091. Skiplink should become visible when focused
 * 03-Jun-2014 BOS [CR00434187] Added the getCookie() function and updated
 *                    replaceSubmitButton() to support timeout warning dialog.
 * 15-Apr-2014  JY [CR00425261] Refactored the print function to allow printing
 *                              the context panel.
 * 20-Feb-2014  AS [CR00414442] Skipped arrow and validation div of filtering
 *                              select in doSetFocus and added a new method to
 *                              focus the help icon on tab navigation after end
 *                              of modal dialog.
 * 28-Sep-2013  BOS [CR00396277] Added tests for undefined selected tab.
 * 07-Jun-2013 NLH  [CR00385557] Added highContrastModeType() funtion.
 * 11-Mar-2013  SB  [CR00372052] Added iframeTitleFallBack() function.
 * 21-Feb-2013  SB  [CR00369658] Updated setupGenericKeyHandler() to
                                        handle year field in Date Selector correctly.
 * 20-Feb-2013  MV  [CR00367727] Prevent opening multiple dialogs at once
 *      by clicking on link in quick succession.
 * 14-Dec-2012  SB  [CR00352283] Added removeRoleRegion() function to remove
 *                                      aria role from multiselect.
 * 14-Dec-2012  JY  [CR00360602] Remove the hardcoded height for the actions
 *                               panel.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 08-Nov-2012  SB  [CR00350381] Added focus setting code for error and
 *                  informational messages.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 03-Oct-2012  SB  [CR00344085] Updated openGenericErrorModalDialog() function
 *      to include boolean check for error or warning modal.
 * 01-Oct-2012  MV  [CR00345339] Improve a way to determine topmost window.
 * 24-Sep-2012  MV  [CR00345119] Handle mailto: links properly across browsers.
 * 17-Sep-2012  MK  [CR00344397] Updated incorrect calls to method called
 *              hasClass to reference correct method called contains instead.
 * 17-Sep-2012  SB  [CR00341890] Added title attribute for page level action
 *                                  menu of the type submit.
 * 11-Sep-2012  MV  [CR00339639] Use local storage API from topmost window to
 *      avoid loading storage for every page. Move a function to this module.
 * 06-Sep-2012  AF  [CR00330559] Added skip link focus method.
 * 31-Aug-2012  MK  [CR00339638] Reverted connect and disconnect functions back
 *              to previous versions. Added in searchButtonStatus that was
 *              missed in the merge from TI_60.
 * 23-Aug-2012  BOS [CR00338361] Added the openGenericErrorModalDialog fucntion.
 * 23-Jul-2012  MV  [CR00336202] Handle gracefully when no tab is open on dialog
 *              submit. Migrate to take on Dojo 1.7.3
 * 26-Jun-2012  SB  [CR00332545] Added searchButtonStatus() function.
 * 28-May-2012  MV  [CR00326704] Fix click event handling for row action menus.
 * 30-Apr-2012  MK  [CR00319243] Updated condition in isSameUrl function to
 *      check if the base string is the same.
 * 24-Apr-2012  AF  [CR00317721] Updated online help URL in openHelpPage method.
 * 14-Mar-2012  SB  [CR00312247] Added openAbout() function
 * 07-Feb-2012  MV  [CR00301458] Code cleanup - added comments,
 *      removed unused code.
 * 13-Dec-2011  BOS [CR00299497] Updating the getTopmostWindow() function
 *                    to check that the Screen Context is defined.
 * 02-Dec-2011  BOS [CR00298234] Updating the getTopmostWindow() function
 *                 in order to support portlets.
 * 05-Oct-2011  PK  [CR00289859] Dojo 1.6.1 upgrade and IE9+ support.
 * 06-Sep-2011  MV  [CR00286500] Don't fail when Preferences anchor not found.
 * 05-Aug-2011  MV  [CR00283589] Remove incorrect code from connect().
 * 02-Aug-2011  MV  [CR00283023] Some refactoring to allow unit testing.
 * 01-Aug-2011  MV  [CR00283020] Refactored redirectWindow() to allow unit
 *      testing.
 * 29-Jul-2011  MV  [CR00269970] Define curam.util using dojo.mixin to avoid
 *      overwriting other class definitions in the same package. Add support
 *      for new UI refresh handling implementation.
 * 28-Jul-2011  MV  [] Handle the FORCE_REFRESH case fully
 *      in redirectWindow()
 * 05-Jul-2011  KW  [CR00275353] Added setRpu() function and refactored
 *                                openLocaleSelector().
 * 18-Jul-2011  KW  [CR00277581] Connect() now strips '#' from end of event URL
 * 13-Jun-2011  MV  [CR00269902] Avoid 404 error coming from bad RPU.
 * 25-May-2011  MV  [CR00267843] Add function for setting up the Preferences
 *    link.
 * 29-Apr-2011  SC  [CR00264826] Modified page load event to include context.
 * 27-Apr-2011  MV [CR00265188] Added support for opening pages in new tab from
 *    dialog opened in the INLINE_PAGE context.
 * 11-Apr-2011  AF [CR00262956] Modified setupGenericKeyHandler method to
 *                              support device independence.
 * 01-Apr-2011  KW [CR00262936] Altered 'alterScrollableListBottomBorder' to
 *                              run after page has loaded
 * 25-Mar-2011  SK [TEC-6335] Removed jsModals indicator as modals are always
 *     on for v6
 * 25-Feb-2011  MV [CR00254937] Honour the RPU set by LinkTag when redirecting
 *     content panel.
 * 25-Feb-2011  MV [CR00254380] Prepare for fix: Honour the RPU set by LinkTag
 *    when redirecting content panel.
 * 18-Feb-2011  MV [CR00247527] Do not block submit when text field has focus.
 * 16-Feb-2011  MV [CR00252701] Fix the isSameUrl() function to work for action
 *    pages that take no parameters.
 * 07-Feb-2011  SJ [CR00247527]  Fixed dropdown submit issue.
 * 07-Jan-2011  MV  [CR00251284] Add support for button load mask.
 * 31-Jan-2011  MK [CR00250297]  Update the clickButton function to handle both
 *    an object and an id as an argument.
 * 28-Jan-2011  MV [CR00245381]  Remove obsolete help settings for dialogs.
 * 26-Jan-2011  MV  [CR00244801] Added another type of refresh behaviour. Strip
 *    o3rpu from RPU value.
 * 25-Jan-2011  MV  [CR00244623] Refactored the function for firing onsubmit
 *    events to work with the latest tab infrastructure changes.
 * 25-Jan-2011  PK  [CR00244773] Filtered all CDEJ parameters from comparison
 *                    in isSameURL. Previously only __o3rpu was filtered.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 21-Jan-2011  MV  [CR00243263] Add 1px to page height when in list row.
 *    Implement "force refresh" behaviour.
 * 20-Jan-2010  AF  [CR00243728] Added page toolbar button mouse effects.
 * 20-Jan-2010  MK  [CR00243648] Update getPageHeight function to take into
 *                    account the wizard progress bar.
 * 18-Jan-2010  AF  [CR00243204] Modified replaceSubmitButton function for the
 *                               agenda player.
 * 17-Jan-2010 MV [CR00242255] Remove the use of dijit.focus()
 * 16-Jan-2010  PK  [CR00242698] Changed file down load method for list row
 *                    menus so errors will be correctly reported.
 * 14-Jan-2011  MK  [CR00240138] Updated showModalDialog function to remove
 *                    contexts that were not needed in a modal.
 * 06-Jan-2011 KW [CR00240549] Added function to prevent overlapping of Action
 *                             set buttons of modals
 * 04-Jan-2011 MV [CR00240081] Fixes to the getPageHeight() function.
 * 15-Dec-2010 KW [CR00238785] Stopped the refresh event when submit button
 *                             clicked
 * 10-Dec-2010  AF  [CR00233054] Added button mouse event functions that will
 *                               add specific CSS class names when modal and
 *                               cluster buttons are clicked or rolled over.
 * 07-Dec-2010  MV  [CR00233442] Adjustments to the getPageHeight() function
 *    to bring the expandable list detail row more in line with
 *    the specification.
 * 08-Dec-2010  SJ  [CR00229344] Added the print functionality.
 * 03-Dec-2010  MV  [CR00232963] Optimize swapState() function.
 * 30-Nov-2010  MV  [CR00232623] Remove extra height when in-page navigation
 *    is present.
 * 24-Nov-2010  PK  [TEC-XXXX] Added NESTED_UIM context.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 18-Nov-2010  SJ [CR00228391]Fixed the issue with OPEN_NEW attribute on
 *                   List Row Actions Menu links.
 * 01-Nov-2010  SD  [CR00225331] An extra parameter has been added to both
 *                     openModalDialog and showModalDialog functions for
 *                     UIMDialog API.
 * 27-Oct-2010  SK   [CR00224193] Changed the redirection of the window so that
       the absence of the content panel not caused failure.
 * 14-Oct-2010  MV [CR00223441] Move functions to different namespaces.
 *    Add getSuffixFromClass function.
 * 29-Sep-2010  MV  [CR00221605] Enable submitting by pressing Enter. Check
 *    for existence of dijit before accesing it.
 * 18-Sep-2010  PK  [CR00204622] Ensure when a page loads for the first time
 *                    in an expandable list, only the "expandedList.toggle"
 *                    event is processed.
 * 17-Sep-2010  MV  [CR00220607] Set page focus only when the whole page
 *                    is loaded. Use dijit.focus() instead of plain element
 *                    focus().
 * 14-Sep-2010  MV  [CR00220152] Add the getLastPathSegmentWithQueryString
 *                    function and also use it where appropriate in this file.
 * 10-Sep-2010  MV  [CR00219824] The focus setting function now indicates
 *                    the result via its return value.
 * 14-Sep-2010  PK  [CR00219843] Fixed expandable list sizing.
 * 08-Sep-2010  MV  [CR00219540] Add support for loading pages in the same
 *                    dialog from the list actions menu.
 * 27-Aug-2010  MV  [CR00217499] Added the makeQueryString() function. Replaced
 *                  the use of escape() with the correct function.
 * 05-Jul-2010 BD [CR00204119]  Introduced use of UIMController in place of
 *                              iframe for expandable lists to cater for
 *                              In Page Navigation tabs.
 * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
 *                    tab-app-controller.js.
 * 27-Jul-2010  MK  [CR00211743] Optional display the help icon on a modal
 *                    dialog.
 * 22-Jul-2010  MV  [CR00211225] Fix page height calculation for inline row
 *                    pages.
 * 22-Jul-2010  JY  [CR00210937] add 10px spacing at the top of the actions
 *                    panel.
 * 20-Jul-2010  MV  [CR00211031] doSetFocus(): handle pages with no HTML form.
 * 15-Jul-2010  MV  [CR00210541] Moved focus handling for modals to
 *                    ModalDialog.js
 * 12-Jul-2010  MV  [CR00210064] Added swapState() function.
 * 10-Jul-2010  OK  [CR00209714] Added setupRemovePageMask function.
 * 06-Jul-2010  MV  [CR00180694] Added toCommaSeparatedList() function.
 * 05-Jul-2010  SOS [CR00209386] Added try/catch to getPageHeight() for when
 *                    it's called in a hidden iframe.
 * 02-Jul-2010  PK  [CR00203531] Extra null check added to listRowFrameLoaded
 *                    method.
 * 26-Jun-2010  MV  [CR00204069] Added getPageHeight() function. Used Curam
 *                    debug logger throughout the file.
 * 18-Jun-2010  MV  [CR00203864] Remove the code for automatically resizing the
 *                    details panel.
 * 17-Jun-2010  MV  [CR00202490] Create the iframe for expandable lists on
 *                    demand only.
 * 15-Jun-2010  FG  [CR00202535] Added in some further functions required by the
 *                    application search functionality.
 * 01-Jun-2010  FG  [CR00200968] Added in some functions required by the
 *                    application search functionality.
 * 11-May-2010  SJ  [CR00198617] Implemented caching on expandable list row
 *                    level actions. As a fix CACHE_BUSTER,
 *                    CACHE_BUSTER_PARAM_NAME parameters are added and the same
 *                    are appended to the iframe source.
 * 11-May-2010  MV  [CR00196066] Added stripeTable() function.
 * 22-Apr-2010  AF  [CR00194043] Added 3 pixels to autoSizeDetailsPane's frame
 *                    height which removes an unwanted vertical scroll bar from
 *                    appearing on the details panel.
 * 23-Apr-2010  MV  [CR00194352] Avoid adding extra ampersand in
 *                    addUrlParameter() if there are no more parameters to add.
 * 07-Apr-2010  BD  [CR00191597] Renamed resizeDetailsPanel() function to
 *                    autoSizeDetailsPanel() to better reflect its function.
 *                    Refactored to handle new html structure.
 * 18-Mar-2010  PK  [CR00191211] Added toggleListDetailsRow.
 * 24-Feb-2010  MV  [CR00189738] Re-enable focus on the first editable field in
 *                    modals.
 * 23-Feb-2010  AF  [CR00189289] Added iframe title as a parameter in the iframe
 *                    upload publish event.
 * 16-Feb-2010  BD  [CR00183006] Add try/catch block to addContentWidthListener
 *                    function. Swallows an exception that does not effect the
 *                    application.
 * 08-Jan-2010  MV  [CR00182272] Added a localizable error message for the
 *                    language selector.
 * 11-Dec-2009  MV  [CR00173949] Remove the SrPopUp target from the modal
 *                    handler form.
 * 25-Nov-2009  MV  [CR00175955] Set focus to the first control when the
 *                    curam.modalDisplayed event happens.
 * 24-Nov-2009  MV  [CR00175837] Add new fireTabOpenedEvent function and a
 *                    missing require for curam.tab.
 * 20-Nov-2009  MV  [CR00175615] Fix the firePageSubmittedEvent function.
 * 20-Nov-2009  MV  [CR00175581] Fix the curam.tab.redirectContentPanel call.
 */

define(["dojo/dom",
        "dijit/registry",
        "dojo/dom-construct",
        "dojo/ready",
        "dojo/_base/window",
        "dojo/dom-style",
        "dojo/_base/array",
        "dojo/dom-class",
        "dojo/topic",
        "dojo/_base/event",
        "dojo/query",
        "dojo/Deferred",
        "dojo/has",
        "dojo/_base/unload",
        "dojo/dom-geometry",
        "dojo/_base/json",
        "dojo/dom-attr",
        "dojo/_base/lang",
        "dojo/on",
        "dijit/_BidiSupport",
        "curam/define",
        /* "dojox/storage", */
        "curam/debug",
        "curam/util/RuntimeContext",
        "curam/util/Constants",
        "dojo/_base/sniff",
        "cm/_base/_dom",
        "curam/util/ResourceBundle",
        "dojo/NodeList-traverse"

        ], function(dom, registry, domConstruct, ready, windowBase, style,
            array, domClass, topic, dojoEvent, query, Deferred, has, unload,
            geom, json, attr, lang, on, bidi, define, debug, runtimeCtx,
            Constants, sniff, _dom, resBundle) {

/**
 * @name      curam.util
 * @namespace Functions for generic utiltities across CDEJ.
 */
curam.define.singleton("curam.util",
/**
 * @lends curam.util.prototype
 */
{
  PREVENT_CACHE_FLAG: "o3pc",
  INFORMATIONAL_MSGS_STORAGE_ID: "__informationals__",
  ERROR_MESSAGES_CONTAINER: "error-messages-container",
  ERROR_MESSAGES_LIST: "error-messages",
  CACHE_BUSTER: 0,
  CACHE_BUSTER_PARAM_NAME: "o3nocache",
  PAGE_ID_PREFIX: "Curam_",
  msgLocaleSelectorActionPage: "$not-locaized$ Usage of the Language Selector is not permitted from an editable page that has previously been submitted.",
  GENERIC_ERROR_MODAL_MAP: {},
  wrappersMap : [],
  lastOpenedTabButton: false,
  tabButtonClicked: false,
  secureURLsExemptParamName: "suep",
  secureURLsExemptParamsPrefix: "spm",
  secureURLsHashTokenParam : "suhtp",
  
  /**
   * This function is used to record that the user is navigating 
   * through tabs so as to avoid the focus to move to the first editable field.
   * The tabButtonClicked stores the tabButton that will be used inside the
   * doSetFocus function to keep the focus on the tabButton.
   */
  setTabButtonClicked: function(tabButton){
          curam.util.getTopmostWindow().curam.util.tabButtonClicked = tabButton;
  },
  
  
  /**
   * Gets the tabButtonClicked and sets the variable to the default value.
   * 
   */
  getTabButtonClicked: function(){
          var tabButton = curam.util.getTopmostWindow().curam.util.tabButtonClicked;
          curam.util.getTopmostWindow().curam.util.tabButtonClicked = false;
          return tabButton;
  },

  /**
   * The lastOpenedTabButton stores the tabButton that will be used inside the
   * doSetFocus function to keep the focus on the tabButton if there are no editable 
   * fields.
   */
  setLastOpenedTabButton: function(tabButton){
    curam.util.getTopmostWindow().curam.util.lastOpenedTabButton = tabButton;
  },

  /**
   * Gets the lastOpenedTabButton and resets the variable to the default value.
   * 
   */
  getLastOpenedTabButton: function(){
        var tabButton = curam.util.getTopmostWindow().curam.util.lastOpenedTabButton;
        curam.util.getTopmostWindow().curam.util.lastOpenedTabButton = false;
        return tabButton;
  },
  
  insertCssText: function(cssString, styleNodeId) {
    var id = styleNodeId ? styleNodeId : "_runtime_stylesheet_";
      var styleSheetNode = dom.byId(id);
    var rmNode;

    if(styleSheetNode) {
      if(styleSheetNode.styleSheet) {
        cssString = styleSheetNode.styleSheet.cssText + cssString;
        rmNode = styleSheetNode;
        rmNode.setAttribute("id", "_nodeToRm");
      } else {
        styleSheetNode.appendChild(document.createTextNode(cssString));
        return;
      }
    }

    var pa = document.getElementsByTagName('head')[0];
      styleSheetNode = domConstruct.create("style", {
      type: "text/css",
      id: id
    });

    if(styleSheetNode.styleSheet) {
      styleSheetNode.styleSheet.cssText = cssString;
    }
    else{
      styleSheetNode.appendChild(document.createTextNode(cssString));
    }
    pa.appendChild(styleSheetNode);
    if(rmNode) {
      rmNode.parentNode.removeChild(rmNode);
    }
  },

  fireRefreshTreeEvent: function() {
      if (dojo.global.parent && dojo.global.parent.amIFrame) {
        var wpl = dojo.global.parent.loader;
    }
    if(wpl && wpl.dojo) {
      wpl.dojo.publish("refreshTree");
    }
  },

  /**
   * Invoked when a form is submitted on a page in any context.
   *
   * This event tracks submitting of pages anywhere in the application
   * to enable proper UI refresh handling.
   *
   * @param {String} context Specifies the context in which the submit
   *     happenned. The expected values are [main-content|dialog].
   */
  firePageSubmittedEvent: function(context) {
    require(["curam/tab"], function() {
      /*
       * This function is executed at onsubmit event and the call to
       * curam.tab.getContainerTab() below was failing in this scenario.
       * Using curam.tab.getSelectedTab() instead works fine.
       * Note that before refactoring to remove the use of getSelectedTab()
       * further changes will have to be made to make it work.
       */
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        var tabWidgetId = curam.tab.getTabWidgetId(sourceTab);

        var topWin = curam.util.getTopmostWindow();
        var ctx = (context == "dialog")
            ? curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_DIALOG
            : curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN;
        topWin.curam.util.Refresh.getController(tabWidgetId).pageSubmitted(
                dojo.global.jsPageID, ctx);
        topWin.dojo.publish("/curam/main-content/page/submitted",
                [dojo.global.jsPageID, tabWidgetId]);

      } else {
        curam.debug.log("/curam/main-content/page/submitted: " // don't localize
            + debug.getProperty("curam.util.no.open")); // FIXME: localize
      }
    });
  },

  fireTabOpenedEvent: function(tabWidgetId) {
    // Publish the tab opened event
    curam.util.getTopmostWindow().dojo.publish("curam.tabOpened",
          [dojo.global.jsPageID, tabWidgetId]);
  },

  /**
   * Setup the submit event publisher for the main content panel.
   */
  setupSubmitEventPublisher: function() {
      ready(function() {
        var form = dom.byId('mainForm');
      if (form) {
        curam.util.connect(form, 'onsubmit', function() {
          
          // Display Progress spinner
            curam.util.getTopmostWindow().dojo.publish('/curam/progress/display',
          		  [curam.util.PAGE_ID_PREFIX + dojo.global.jsPageID]);
          curam.util.firePageSubmittedEvent("main-content");
        });
      }
    });
  },

  getScrollbar: function(){
    //  summary
    //  returns the width of a scrollbar.

    //  set up the test nodes.
      var scroll = domConstruct.create("div", {}, windowBase.body());

      style.set(scroll, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-300px",
      left: "0px"
    });

      var test = domConstruct.create("div", {}, scroll);

      style.set(test, {
      width: "400px",
      height: "400px"
    });

    var width = scroll.offsetWidth - scroll.clientWidth;
      domConstruct.destroy(scroll);

    //  we return an object because we may add additional info in the future.
    return { width: width };  //  object
  },

  // Returns true if the page is in a modal dialog, false otherwise.
  isModalWindow: function() {
    // the window.curamModal flag is set in curam.dialog.initModal()
      return (dojo.global.curamModal === undefined) ? false : true;
  },

  // Returns true if the page is in a modal dialog and running or existing 
  // an IEG script, otherwise returns false.
  isExitingIEGScriptInModalWindow: function(exitingIEGScript) {
    // the exitingIEGScript variable is set in ieg-modal.initDialog()
      return (curam.util.getTopmostWindow().exitingIEGScript === undefined) ? false : true;
  },
  
  // Set a global variable to true for a modal dialog and running or existing 
  // an IEG script.
  setExitingIEGScriptInModalWindowVariable: function() {
	  curam.util.getTopmostWindow().exitingIEGScript = true;
  },

  /**
   * Gets the top most window. The topmost window window is returned 
   * starting with the current window object.
   */
  getTopmostWindow: function() {

    // check topmost window cache and cache it if it is not yet cached
    if (typeof (dojo.global._curamTopmostWindow) == "undefined") {
      var parentWin = dojo.global;
      if (parentWin.__extAppTopWin) {
        dojo.global._curamTopmostWindow = parentWin;
      } else {
        while (parentWin.parent != parentWin) {
          parentWin = parentWin.parent;
          if (parentWin.__extAppTopWin) {
            // found the top window of a public facing app
            break;
          }
        }
        dojo.global._curamTopmostWindow = parentWin;
      }
    }

    // report cases of incorrect topmost window
    if (dojo.global._curamTopmostWindow.location.href.indexOf(
        "AppController.do") < 0
        && typeof(dojo.global._curamTopmostWindow.__extAppTopWin)
           == "undefined") {
      curam.debug.log(debug.getProperty("curam.util.wrong.window")
         + dojo.global._curamTopmostWindow.location.href);
    }

    return dojo.global._curamTopmostWindow;
  },

  getUrlParamValue: function(url, paramName) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return null;}
    var paramStr = url.substring(qPos + 1, url.length);

    function getVal(delim) {
      var params = paramStr.split(delim);

      paramName += "=";
      for(var i = 0; i < params.length; i++) {
        if(params[i].indexOf(paramName) == 0){
          return params[i].split("=")[1];
        }
      }
    }

    return getVal("&") || getVal("");
  },

  addUrlParam: function(href, paramName, paramValue, prepend) {
    var hasQ = href.indexOf("?") > -1;
    var doPrepend = prepend ? prepend : 'undefined';

    if (!hasQ || (doPrepend == false)) {
      return href + (hasQ ? "&" : "?") + paramName + "=" + paramValue;

    } else {
      var parts = href.split("?");
      href = parts[0] + "?" + paramName + "=" + paramValue + (parts[1] != "" ? ("&" + parts[1]) : "");
      return href;
    }
  },

  replaceUrlParam: function(href, paramName, newValue) {
    href = curam.util.removeUrlParam(href, paramName);
    return curam.util.addUrlParam(href, paramName, newValue);
  },

  removeUrlParam: function(url, paramName, /*optional*/paramValue) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return url;}
    if(url.indexOf(paramName + "=") < 0){return url;}//shortcut

    var paramStr = url.substring(qPos + 1, url.length);
    var params = paramStr.split("&");
    var value;
    var paramParts, doRemove;

    for(var i = 0; i < params.length; i++) {
      if (params[i].indexOf(paramName+"=") == 0) {
        doRemove = false;
        if(paramValue) {
          paramParts = params[i].split("=");
          if (paramParts.length > 1) {
            if (paramParts[1] == paramValue){
              doRemove = true;
            }

          } else if ( paramValue == "") {
            doRemove = true;
          }

        } else {
          doRemove = true;
        }

        if(doRemove) {
          //remove the parameter from the array
          params.splice(i, 1);
          //in case the param is in the url more than once, keep checking
          i--;
        }
      }
    }
    return url.substring(0, qPos + 1) + params.join("&");
  },

  //Remove the hash symbol, and everything that follows it, from a url.
  stripHash: function(url) {
    var idx = url.indexOf("#");
    if(idx < 0){return url;}
    return url.substring(0, url);
  },

  /**
   * Compares the specified URLs.
   *
   * This ignores the order of parameters - identical parameters in different
   * orders will still return true.
   *
   * If the second href is omitted, it defaults to the location
   * of the specified runtime context.
   *
   * @param href1 First HREF.
   * @param href2 Second HREF.
   * @param rtc current runtime context.
   *
   * @return True if the two urls are the same, false otherwise.
   */
  isSameUrl: function(href1, href2, rtc) {
    if (!href2) {
      href2 = rtc.getHref();
    }
    if (href1.indexOf("#") == 0) {
      return true;
    }

    // Remove the # symbols from the comparison.
    var hashIdx = href1.indexOf('#');
    if (hashIdx > -1) {
      //If the first URL starts with a #, then it is automatically equal to the
      //second URL
      if (hashIdx == 0) {
        return true;
      }

      var urlParts1 = href1.split("#");
      var hashIdx2 = href2.indexOf("#");

      //If the second URL has a hash symbol, remove it and everything after it,
      //then do the comparison
      if (hashIdx2 > -1) {
        if (hashIdx2 == 0) {
          return true;
        }
        href2 = href2.split("#")[0];
      }
      return urlParts1[0] == href2;
    }

    var stripPageOrActionFromUrl = function(url) {
      var idx = url.lastIndexOf("Page.do");
      var len = 7;
      if (idx < 0) {
        idx = url.lastIndexOf("Action.do");
        len = 9;
      }
      if (idx < 0) {
        idx = url.lastIndexOf("Frame.do");
        len = 8;
      }
      if (idx > -1 && idx == url.length - len) {
        return url.substring(0, idx);
      }
      return url;
    };

    var rp = curam.util.removeUrlParam;

    var here = curam.util.stripHash(rp(href2,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var there = curam.util.stripHash(rp(href1,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var partsThere = there.split("?");
    var partsHere = here.split("?");

    //Remove the Action.do or Page.do from the url
    partsHere[0] = stripPageOrActionFromUrl(partsHere[0]);
    partsThere[0] = stripPageOrActionFromUrl(partsThere[0]);

      // This check to see if the page names are the same assumes that the
      // functions above to strip parameters and page or actions from the url
      // have been run first. So the end of each string is only the name of
      // the page.
    var baseEqual = (partsHere[0] == partsThere[0]
          || partsHere[0].match(partsThere[0]+"$")==partsThere[0]);

    if (!baseEqual) {
      return false;
    }

    if (partsHere.length == 1 && partsThere.length == 1 && baseEqual) {
      //If the base URL is equal, and the parameter string is exactly equal,
      //then don't bother checking the unordered parameters. Just return true,
      //because they're equal
      return true;

    } else {
      //Check the values of all of the parameters, ignoring order of url
      //parameters
      var paramsHere;
      var paramsThere;
      if (typeof partsHere[1] != "undefined" && partsHere[1] != "") {
        paramsHere = partsHere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsHere = new Array();
      }

      if (typeof partsThere[1] != "undefined" && partsThere[1] != "") {
        paramsThere = partsThere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsThere = new Array();
      }

      // don't include CDEJ parameters in the comparison
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.before")
          + paramsHere.length);
        paramsHere = array.filter(paramsHere, curam.util.isNotCDEJParam);
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.after")
          + paramsHere.length);

      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.before")
          + paramsThere.length);
        paramsThere = array.filter(paramsThere, curam.util.isNotCDEJParam);
        curam.debug.log(
            "curam.util.isSameUrl: paramsHere "
            + debug.getProperty("curam.util.after")
          + paramsThere.length);

      if (paramsHere.length != paramsThere.length) {
        return false;
      }

      var paramMap = {};
      var param;
      for (var i = 0; i < paramsHere.length; i++) {
        param = paramsHere[i].split("=");
        // Decode the key and value before adding to the map.
        // This ensures a correct comparison in the following loop.
        param[0] = decodeURIComponent(param[0]);
        param[1] = decodeURIComponent(param[1]);
        paramMap[param[0]] = param[1];
      }
      for (var i = 0; i < paramsThere.length; i++) {
        param = paramsThere[i].split("=");
        // Decode the key and value before adding to the map.
        // This ensures a correct comparison in the next step.
        param[0] = decodeURIComponent(param[0]);
        param[1] = decodeURIComponent(param[1]);
        if (paramMap[param[0]] != param[1]) {
          curam.debug.log(debug.getProperty("curam.util.no.match",
              [param[0], param[1], paramMap[param[0]]]));
          return false;
        }
      }
    }

    //If the base url is the same, and all the parameters match, then
    //the urls are equal
    return true;
  },

  /**
   * Tests if the specified parameter name isn't a CDEJ parameter. It is used by
     * the array.filter used in the isSameUrl method.
   *
   * TODO: There is a similar method in PageRequest.js. Attempted to re-factor
   * but led to JavaScript errors in PageRequest.js when it was executed. Need
   * more time to work out dependency problem, for now duplicating the method.
   *
   * @return true if the specified parameter name is a CDEJ parameter, false
   *         otherwise.
   */
  isNotCDEJParam: function(paramName) {
    return !((paramName.charAt(0) == 'o' && paramName.charAt(1) == '3')
           || (paramName.charAt(0) == '_' && paramName.charAt(1) == '_'
               && paramName.charAt(2) == 'o' && paramName.charAt(3) == '3'));
  },

  //Sets one or more attributes on a DOM node. The map looks like:
  //{ type:'text', value:'This is text', style:'width:100px'}
  setAttributes: function(node, map) {
    for(var x in map) {
      node.setAttribute(x, map[x]);
    }
  },

  //This should be called if a pop up page has submitted a form, stating that
  //if this page is redirected to itself, rather than ignoring it, it should
  //refresh the browser.
  invalidatePage: function() {
    curam.PAGE_INVALIDATED = true;

      var parentWin = dojo.global.dialogArguments
          ? dojo.global.dialogArguments[0]:opener;

    if(parentWin && parentWin != dojo.global) {
      try {
        parentWin.curam.util.invalidatePage();

      } catch(e) {
        curam.debug.log(debug.getProperty("curam.util.error"), e);
      }
    }
  },

  /**
   * Sends the window to a new URL. This needs to be done differently depending
   * on whether or not the window is modal (IE only).
   * @param force
   *    If set to true, it does not matter if the href is the same as
   *    the current href or not, it will be refreshed.
   * @param ignoreFrame
   *    If true, then any other frames on the page are not refreshed.
   */
  redirectWindow: function(href, force, ignoreFrames) {
    var rtc = new curam.util.RuntimeContext(dojo.global);
    var redirectContentPanelInDifferentFrameRootContext =
      function(context, rootObject, href, forceLoad, justRefresh) {
        curam.util.getFrameRoot(context, rootObject)
            .curam.util.redirectContentPanel(href, forceLoad, justRefresh);
      };
      curam.util._doRedirectWindow(href, force, ignoreFrames,
          dojo.global.jsScreenContext, rtc, curam.util.publishRefreshEvent,
        redirectContentPanelInDifferentFrameRootContext);
  },

  _doRedirectWindow: function(href, force, ignoreFrames, screenContext, rtc,
      publishRefreshEvent, redirectContentPanelInDifferentFrameRootContext) {
    if (href && curam.util.isActionPage(href) && !curam.util.LOCALE_REFRESH) {
      // Avoid 404 error coming from bad RPU. This is temporary,
      // will be properly fixed by TEC-7123.
      curam.debug.log(debug.getProperty("curam.util.stopping"), href);
      return;
    }

    var rpl = curam.util.replaceUrlParam;
    //check if we are in the frameset context
    var inFrame = screenContext.hasContextBits('TREE')
                 || screenContext.hasContextBits('AGENDA')
                   || screenContext.hasContextBits('ORG_TREE');

    if (curam.util.LOCALE_REFRESH) {
     
      curam.util.publishRefreshEvent();
      // reload the entire application  
	  curam.util.getTopmostWindow().location.reload(); 
    
      return;
      
    } else if(curam.util.FORCE_REFRESH) {
      //If the FORCE_REFRESH parameter is set, in dialog.js, then ignore the
      //href parameter and just reload the page. This is done for the user
      //preferences dialog, so that it doesn't lose the __o3rpu parameter,
      //but can be used in other places too.
      href = rpl(rtc.getHref(), curam.util.PREVENT_CACHE_FLAG,
                 (new Date()).getTime());
      if(curam.util.isModalWindow() || inFrame) {
        publishRefreshEvent();
          dojo.global.location.href = href;

      } else {
        if (screenContext.hasContextBits('LIST_ROW_INLINE_PAGE')
            || screenContext.hasContextBits('NESTED_UIM')) {

          curam.util._handleInlinePageRefresh(href);

        } else {
          publishRefreshEvent();
          if (dojo.global.location !== curam.util.getTopmostWindow().location) {
            require(["curam/tab"], function() {
              redirectContentPanelInDifferentFrameRootContext(dojo.global,
                  curam.tab.getTabController().ROOT_OBJ, href, true, true);
            });
          }
        }
      }
      return;
    }

    var u = curam.util;
    //if the URL is identical, it's not a real redirect, so do nothing.
    //This solves the case of a Cancel button being clicked in a modal window.
    var rtc = new curam.util.RuntimeContext(dojo.global);
    if(!inFrame && !force && !curam.PAGE_INVALIDATED
        && u.isSameUrl(href, null, rtc)) {
      return;
    }

    //If in a modal dialog, then submit a form via a 'POST', as doing a normal
    //redirect
    if(curam.util.isModalWindow() || inFrame) {

      //make sure that the modal parameter is set, and that a timestamp is added
      //to prevent the resulting page from being cached.
      href = rpl(rpl(href, "o3frame", "modal"),
        curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
        var form = domConstruct.create("form", {
        action:href,
        method:"POST"
      });

      //modals launched from Agenda Player in modal do not need artificial post
      if (!inFrame) {

          if(!dom.byId("o3ctx")) {
          // The o3ctx may exist on the url passed into this method already.
          // So, remove it and reset the form action.
          // This is a last-minute fix for an issue found during JDE 009
          // testing.
          form.action =
            curam.util.removeUrlParam(form.action, "o3ctx");
            var input1 = domConstruct.create("input", {
            type: "hidden", id: "o3ctx", name:"o3ctx",
            value: screenContext.getValue()
          }, form);
        }
          windowBase.body().appendChild(form);
        publishRefreshEvent();
        form.submit();
      }
      if(!ignoreFrames) {
        if (inFrame) {
          curam.util.redirectFrame(href);
        }
      }

    } else {
      //The base context case; no frameset, these are not supported in the tab
      //content panel. Just change the href
      //BEGIN,RTC 194820,267326 COF
   	  var launchWordEditOp=sessionStorage.getItem("launchWordEdit");
      //END,RTC 194820,267326 COF
      if (!launchWordEditOp && (screenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || screenContext.hasContextBits("NESTED_UIM"))) {

        curam.util._handleInlinePageRefresh(href);

      } else {
    	//BEGIN,RTC 194820,267326 COF
	    if(launchWordEditOp){
           sessionStorage.removeItem("launchWordEdit");
   		}
         
      //END, RTC 194820,267326 COF
      publishRefreshEvent();
      if (dojo.global.location !== curam.util.getTopmostWindow().location) {
        if (screenContext.hasContextBits("EXTAPP")) {
          var topWindow = window.top;
          topWindow.dijit.byId("curam-app").updateMainContentIframe(href);
        } else {
          require(["curam/tab"], function() {
            curam.util.getFrameRoot(dojo.global,
              curam.tab.getTabController().ROOT_OBJ)
                .curam.util.redirectContentPanel(href, force);
          });
        }
      }
    }
  }
},

  /**
   * Closing modal dialog opened from expanded list row or nested UIM.
   * Either Redirect expanded row iframe or open the url in a new tab,
   * depending on whether the target page is mapped to some tab or not.
   */
  _handleInlinePageRefresh: function(href) {
    curam.debug.log(debug.getProperty("curam.util.closing.modal"), href);

    /*
     * The following code is based on assumption that inline pages are not
     * mapped to any tabs. If this is the case then the inline frame will
     * be refreshed. If the page is mapped to a tab then it will open in that
     * tab rather than in the inline frame.
     */
    var pageRequest = new curam.ui.PageRequest(href);
    require(["curam/tab"], function() {
      curam.tab.getTabController().checkPage(pageRequest, function(request) {
        // refresh the inline frame
        curam.util.publishRefreshEvent();
        // specifically pass false so that browser uses cached resources
        // where possible
        window.location.reload(false);
      });
    });
  },

  /**
   * @param url
   *    The URL to redirect to.
   * @param forceLoad
   *    Load the page even if the existing URL is the same.
   * @param justRefresh
   *    Do not change to a different URL, only refresh the existing page.
   */
  redirectContentPanel: function(url, forceLoad, justRefresh) {
    require(["curam/tab"], function() {
      // add the return page parameter
      var iframe = curam.tab.getContentPanelIframe();
      var newUrl = url;
      if (iframe != null) {
        var rpu = curam.util.Constants.RETURN_PAGE_PARAM;
        var o3rpuValue = null;
        if (url.indexOf(rpu + "=") >= 0) { // if the url has RPU param
          curam.debug.log("curam.util.redirectContentPanel: "
            + debug.getProperty("curam.util.rpu"));
          o3rpuValue = decodeURIComponent(curam.util.getUrlParamValue(url, rpu));
        }
        // or the specified URL has no __o3rpu parameter - just pass through

        if (o3rpuValue) {
          // strip the __o3rpu parameter form the RPU value
          o3rpuValue = curam.util.removeUrlParam(o3rpuValue, rpu);

          newUrl = curam.util.replaceUrlParam(url, rpu,
              encodeURIComponent(o3rpuValue));
        }
      }
      var uimPageRequest = new curam.ui.PageRequest(newUrl);
      if (forceLoad) {
        uimPageRequest.forceLoad = true;
      }
      if (justRefresh) {
        uimPageRequest.justRefresh = true;
      }
      curam.tab.getTabController().handlePageRequest(uimPageRequest);
    });
  },

  //Redirects a page in a frame, and refreshes all other frames.
  //If 'href' is not set, then the current window is not refreshed,
  //just the other frames.
  redirectFrame: function(href) {
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      var target = curam.util.getFrameRoot(dojo.global, "wizard").targetframe;
      target.curam.util.publishRefreshEvent();
      target.location.href = href;

      } else if (dojo.global.jsScreenContext.hasContextBits('ORG_TREE')) {//lazy tree
      var target = curam.util.getFrameRoot(dojo.global, "orgTreeRoot");
        /* FIXME: this code expects that curam.util and dojo are loaded
         * and avaialble in the target context. Instead it should call require()
         * to load the required module.
         */
      target.curam.util.publishRefreshEvent();
      target.dojo.publish("orgTree.refreshContent", [ href ]);

    } else { //tree frameset
      var treeRef = curam.util.getFrameRoot(dojo.global, "iegtree");
      var navigator = treeRef.navframe || treeRef.frames[0];
      var contents = treeRef.contentframe || treeRef.frames['contentframe'];
      contents.curam.util.publishRefreshEvent();
      if (curam.PAGE_INVALIDATED || navigator.curam.PAGE_INVALIDATED) {
        var newHref = curam.util.modifyUrlContext(href, 'ACTION');
        contents.location.href = newHref;

      } else {
        contents.location.href = href;
      }
    }

    //Return true, indicating that a redirect did take place.
    return true;
  },

  publishRefreshEvent: function() {
      topic.publish("/curam/page/refresh");
  },

  /**
   * Opens a basic error modal dialog using the href
   * <code>generic-modal-error.jspx</code>. The parameters are passed to a
   * Javascript object which can be retrieved in the JSP.
   *
   * @param windowOptions        The windows options to specifiy the width and
   *                             height of the dialog.
   * @param titleProp            The property key to be used when localizing
   *                             the text of the title on the dialog.
   * @param messageProp          The property key to be used when localizing
   *                             the message on the dialog.
   * @param messagePlaceholder1  The first placeholder to be within the message
   *                             on the dialog. THis will not be set if it is
   *                             undefined.
   * @param isErrorModal         The boolean value to indicate whether it is an
   *                             error modal or a warning modal.
   */
  openGenericErrorModalDialog: function(windowOptions, titleProp,
	      messageProp, messagePlaceholder1, isErrorModal) {
	  
	var topmostWin = curam.util.getTopmostWindow();
	
	// Add the GENERIC_ERROR_MODAL_MAP to the top most window so it can be
	// retrieved in the JSP.
	topmostWin.curam.util.GENERIC_ERROR_MODAL_MAP = {"windowsOptions": windowOptions,
          "titleInfo" : titleProp,
          "msg" : messageProp,
          "msgPlaceholder" : messagePlaceholder1,
          "errorModal" : isErrorModal,
          "hasCancelButton" : false};
	  
    var url ="generic-modal-error.jspx";
    // TODO: May also want to take into account whether window options are set
    // or not -- BOS
	curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton = true;
    curam.util.openModalDialog({href:encodeURI(url)}, windowOptions);

  },

  /**
   * Opens an Ok/Cancel modal dialog using the href
   * <code>generic-modal-error.jspx</code>. The parameters are passed to a
   * Javascript object which can be retrieved in the JSP. The Ok/Cancel buttons
   * pass 'confirm' or 'cancel' respectively to the "/curam/dialog/close"
   * event.
   *
   * @param windowOptions  The windows options to specifiy the width and
   *                       height of the dialog.
   * @param titleProp      The property key to be used when localizing
   *                       the text of the title on the dialog.
   * @param messageProp    The property key to be used when localizing
   *                       the message on the dialog.
   */
  openGenericErrorModalDialogYesNo: function(windowOptions, titleProp,
      messageProp) {
	
	// Parameters that are added to the URL for the JSP. 
	var sc = dojo.global.jsScreenContext;
    var topmostWin = curam.util.getTopmostWindow();    
    
    sc.addContextBits('MODAL');
        
	// Add the GENERIC_ERROR_MODAL_MAP to the top most window so it can be
	// retrieved in the JSP.
    topmostWin.curam.util.GENERIC_ERROR_MODAL_MAP = {"windowsOptions": windowOptions,
      "titleInfo" : titleProp,
      "msg" : messageProp,
      "msgPlaceholder" : "",
      "errorModal" : false,
      "hasCancelButton" : true};
            
    var url ="generic-modal-error.jspx?" + sc.toRequestString();

    // TODO: May also want to take into account whether window options are set
    // or not -- BOS
	      
	 curam.util.openModalDialog({href:encodeURI(url)}, windowOptions);
	 
  },

  /**
  * Appends placeholder-for-focus class to the element tag
  * and add the window to  to the PLACEHOLDER_WINDOW_LIST.
  * @param eventOrAnchorTag  The element to be added the placeholder-for-focus class.
  * @param window            The property window key to be used when returning the 
  *                          focus when the modal is closed.
  */
  addPlaceholderFocusClassToEventOrAnchorTag: function (eventOrAnchorTag, window){
	var topMostWindow = curam.util.getTopmostWindow();
	topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST = 
	  !topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST ? [] : topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST; 
	domClass.add(eventOrAnchorTag,"placeholder-for-focus");
	topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST.push(window);
  },

  /**
   * 
   * Returns the focus to a anchor element when the pop-up dialog is closed and
   * removes placeholder-for-focus appended to the anchor element class in the iframe content.
   */
   returnFocusToPopupActionAnchorElement: function(parentWindowRef) {
	 var focusList = parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST;
	 if (focusList && focusList.length > 0 ){
	   var parentWindow = focusList.pop();
       var iFrameContent = parentWindow && parentWindow.document.activeElement;
	
       var anchorElementToFocusOn = iFrameContent && dojo.query(".placeholder-for-focus", iFrameContent); 
       if(anchorElementToFocusOn && anchorElementToFocusOn.length == 1){
         anchorElementToFocusOn[0].focus();
         domClass.remove(anchorElementToFocusOn[0],"placeholder-for-focus");
       }
       parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST.splice(0, parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST.length);
       parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST = null;
     }
   },

  // Opens a modal dialog.
  // This is the public API function.
  // The function can take an anchor tag or an event as its first parameter
  // The uimToken parameter is only used in conjunction with the UIMDialog API.
  openModalDialog: function(
    eventOrAnchorTag, windowOptions, left, top, uimToken) {
	
	eventOrAnchorTag.event && 
	  curam.util.addPlaceholderFocusClassToEventOrAnchorTag(eventOrAnchorTag.event, eventOrAnchorTag.event.ownerDocument.defaultView.window);

    var href;
    if(!eventOrAnchorTag || !eventOrAnchorTag.href) {
      // it is an event
        eventOrAnchorTag = dojoEvent.fix(eventOrAnchorTag);

      var target = eventOrAnchorTag.target;
        while(target.tagName != "A" && target != windowBase.body()){
        target = target.parentNode;
      }

      href = target.href;

      //Mark the anchor tag as a modal dialog opener, so that other listeners on
      //it, e.g. the List Context Menus in /jscript/curam/listMenu.js, ignore
      //clicks on it.
      target._isModal = true;

        dojoEvent.stop(eventOrAnchorTag);

    } else {
      // it is an anchorTag
      href = eventOrAnchorTag.href;
      eventOrAnchorTag._isModal = true;
    }

        require(["curam/dialog"]);
    var opts = curam.dialog.parseWindowOptions(windowOptions);
    curam.util.showModalDialog(href, eventOrAnchorTag,
          opts['width'], opts['height'], left, top,  false, null, null, uimToken);
    return true;

  },

  // Shows a modal dialog.
  // Internal function, used from the public openModalDialog() function above
  // and also from pop-up-related code (omega3-util.js).

  // The uimToken parameter is only used in conjunction with the UIMDialog API.

  // @param realParent
  //            The parent window the request to open modal originated from.
  showModalDialog: function(url, eventOrAnchorTag,
      width, height, left, top, resizable, status, realParent, uimToken) {

    // handling nested modals ->
    // if called from within modal, redirect call to the parent window.
    var topmostWindow = curam.util.getTopmostWindow();
    if (dojo.global != topmostWindow) {
      curam.debug.log(
          "curam.util.showModalDialog: "
            + debug.getProperty("curam.util.redirecting.modal"));
      topmostWindow.curam.util.showModalDialog(url, eventOrAnchorTag,
          width, height, left, top, resizable, status, dojo.global, uimToken);
      return;
    }

    var rup = curam.util.replaceUrlParam;
    url = rup(url, "o3frame","modal");
    url = curam.util.modifyUrlContext(url, 'MODAL', 'TAB|LIST_ROW_INLINE_PAGE|LIST_EVEN_ROW|NESTED_UIM');
    url = rup(url, curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
    curam.debug.log(debug.getProperty("curam.util.modal.url"), url);

    if (width) {
      width = typeof(width) == 'number' ? width : parseInt(width);
    }
    if (height) {
      height = typeof(height) == 'number' ? height : parseInt(height);
    }

    // Prevent multiple further requests for modal until this one is processed
    if (!curam.util._isModalCurrentlyOpening()) {
      // handle scenarios where user clicks on a modal link before main content
      // has finished loading
      if (url.indexOf('__o3rpu=about%3Ablank') >= 0 ) {
        alert(curam_util_showModalDialog_pageStillLoading);
        return;
      }

      curam.util._setModalCurrentlyOpening(true);

      if (jsScreenContext.hasContextBits("EXTAPP")) {
        require(["curam/ModalDialog"]);
        new curam.ModalDialog({href: url,
                               width: width,
                               height: height,
                               openNode: (eventOrAnchorTag && eventOrAnchorTag.target) ? eventOrAnchorTag.target : null,
                               parentWindow: realParent,
                               uimToken: uimToken});
      } else {
      	// Modal implemented in Carbon
        require(["curam/modal/CuramCarbonModal"]);
        new curam.modal.CuramCarbonModal({href: url,
                               width: width,
                               height: height,
                               openNode: (eventOrAnchorTag && eventOrAnchorTag.target) ? eventOrAnchorTag.target : null,
                               parentWindow: realParent,
                               uimToken: uimToken});
      }
      return true;
    }
  },
  // Shows a modal dialog and returns its reference.
  // Internal function, currently just used by the file edit widget.
  // @param realParent
  //            The parent window the request to open modal originated from.
  // @param windowsOptions
  //            The windows options to open a modal dialod.
  
  showModalDialogWithRef: function(modUrl, realParent, windowsOptions) {
    var topmostWindow = curam.util.getTopmostWindow();
    if (dojo.global != topmostWindow) {
      return topmostWindow.curam.util.showModalDialogWithRef(modUrl, dojo.global);
    }
    var rup = curam.util.replaceUrlParam;
    modUrl = curam.util.modifyUrlContext(modUrl, 'MODAL', 'TAB|LIST_ROW_INLINE_PAGE|LIST_EVEN_ROW|NESTED_UIM');
    modUrl = rup(modUrl, curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
    if (!curam.util._isModalCurrentlyOpening()) {
      curam.util._setModalCurrentlyOpening(true);
      var dl;
      if (jsScreenContext.hasContextBits("EXTAPP")) {
        require(["curam/ModalDialog"]);
        if(windowsOptions){
            dl = new curam.ModalDialog({href: modUrl, width: windowsOptions.width, height: windowsOptions.height,  parentWindow: realParent});

        }else{
            dl = new curam.ModalDialog({href: modUrl,  parentWindow: realParent});
        }
      }else{
        require(["curam/modal/CuramCarbonModal"]);
        if(windowsOptions){
          dl = new curam.modal.CuramCarbonModal({href: modUrl, width: windowsOptions.width, height: windowsOptions.height,  parentWindow: realParent});
        }else{
          dl = new curam.modal.CuramCarbonModal({href: modUrl,  parentWindow: realParent});
        }
      }
      return dl;
    }
  },

  /**
   * Determine if a modal is being opened at this time.
   *
   * @returns True if modal open operation is in progress, otherwise false.
   */
  _isModalCurrentlyOpening: function() {
    return curam.util.getTopmostWindow().curam.util._modalOpenInProgress;
  },

  /**
   * Set the flag indicating if a modal is being opened at this time.
   *
   * @param isOpening {Boolean} Value for the flag, either true or false.
   */
  _setModalCurrentlyOpening: function(isOpening) {
    curam.util.getTopmostWindow().curam.util._modalOpenInProgress = isOpening;
  },

 setupPreferencesLink: function(href) {
      ready(function() {
        var prefsAnchor = query(".user-preferences")[0];
      if (prefsAnchor) {
        if (typeof(prefsAnchor._disconnectToken) == "undefined") {
          prefsAnchor._disconnectToken = curam.util.connect(prefsAnchor,
              "onclick", curam.util.openPreferences);
        }

        if (!href) {
            href = dojo.global.location.href;
        }

      } else {
        curam.debug.log(debug.getProperty("curam.util.no.setup"));
      }
    });
  },
  
  /**
   * Set up the link for the Language menu-item.
   *
   * @param href hyperlink
   *          
   */
  setupLocaleLink: function(href) {
      ready(function() {
        var localeAnchor = query(".user-locale")[0];
      if (localeAnchor) {
        if (typeof(localeAnchor._disconnectToken) == "undefined") {
        	localeAnchor._disconnectToken = curam.util.connect(localeAnchor,
              "onclick", curam.util.openLocaleNew);
        }
        if (!href) {
            href = dojo.global.location.href;
        }

      } else {
        curam.debug.log(debug.getProperty("curam.util.no.setup"));
      }
    });
  },
  
  openPreferences: function(event) {
      dojoEvent.stop(event);

    if (event.target._curamDisable) {
      // link disabled, do nothing
      return;
    }

    require(["curam/tab"], function() {
      curam.tab.getTabController().handleLinkClick(
          "user-prefs-editor.jspx", {dialogOptions:"width=605"});
    });
  },
  
  logout: function(event) {
          var topWin = curam.util.getTopmostWindow();
          topWin.dojo.publish("curam/redirect/logout");
          window.location.href = jsBaseURL + "/logout.jsp";
  },

  openAbout: function(event) {
      dojoEvent.stop(event);
      require(["curam/tab"], function() {
        curam.tab.getTabController().handleLinkClick(
            "about.jsp", {dialogOptions:"width=583,height=399"});
      });
  },

  addMinWidthCalendarCluster: function(id){

      var contentNode = dom.byId(id);
    var i = 0;

    function addWidth(evt){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "width", "97%");
          if(node.clientWidth < 700){
              style.set(node, "width", "700px");
          }
        }
      });
    }//end function addWidth

      if(has("ie") > 6){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "minWidth", "700px");
        }
      });
    } else {
        on(dojo.global, 'resize', addWidth);
        ready(addWidth);
    }
  },

  addPopupFieldListener: function(id){
      if(!has("ie") || has("ie") > 6){
      return;
    }
    if(!curam.util._popupFields) {
      function doResize(evt){
        var actionWidth=0;
        var j = 0;
        var x = 0;
        var arr = curam.util._popupFields;
          array.forEach(curam.util._popupFields, function(id){
            var fieldNode = dom.byId(id);
            query("> .popup-actions", fieldNode).forEach(function(node){
            actionWidth = node.clientWidth + 30;
          });

            query("> .desc", fieldNode).forEach(function(node){
              style.set(node, "width",
              Math.max(0, fieldNode.clientWidth - actionWidth) + "px");
          });
        });
      }// end doResize function
      curam.util._popupFields = [id];
        on(dojo.global, 'resize', doResize);
        ready(doResize);
    } else {
     curam.util._popupFields.push(id);
    }
  },

  /**
   * Sets the width and height (on IE6) of the main content area and sidebar
   * when the window is resized. The sidebar is not always included on a page.
   */
  addContentWidthListener: function(id) {
      if (has("ie") > 6) {
      // don't do if IE is 7 and higher
      return;
    }
      var setStyle = style.set;
      var hasClass = domClass.contains;

    function doResize(evt) {
      var i = 0;
        var contentNode = dom.byId("content");
      if (contentNode) {
        var width = contentNode.clientWidth;

        // Only set the height of the content if the footer is present,
        // and if the browser is Internet Explorer 6
          if (has("ie") == 6 && dom.byId("footer")) {
            var contentHeight = windowBase.body().clientHeight - 100;
          setStyle(contentNode, "height", contentHeight + "px");
            var sideNode = dom.byId("sidebar");
          if (sideNode) {
            setStyle(sideNode, "height", contentHeight + "px");
          }
        }

        try{
            query("> .page-title-bar", contentNode).forEach(function(node){
              var marginW = geom.getMarginSize(node).w
                  - geom.getContentBox(node).w;
              if (!has("ie")) {
              marginW +=1;
            }
            width =  contentNode.clientWidth - marginW;
              style.set(node, "width", width + "px");
          });
        }catch(e){
        // Do nothing. If the page-title-bar does not exist it won't need to be resized.
        }

          query("> .page-description", contentNode).style("width", width + "px");
          query("> .in-page-navigation", contentNode).style("width", width + "px");
      }
    }

    curam.util.subscribe("/clusterToggle", doResize);
    curam.util.connect(dojo.global, 'onresize', doResize);
      ready(doResize);
  },

  //depending on the final row and height of the visible scrollable area
  //we will have to add/remove the bottom border on the final row
  alterScrollableListBottomBorder: function(id, maxHeight){

    var visibleAreaHeight = maxHeight;
    var queryText = "#" + id + " table"; //to find the table contained in the div

    function alterBorder() {
        var scrollTable = query(queryText)[0];
      if (scrollTable.offsetHeight >= visibleAreaHeight) { //scrollbar visible & active
        //dont want a border on final row, if an odd row
          var lastRow = query(".odd-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "no-bottom-border");
        }
      }
      else if (scrollTable.offsetHeight < visibleAreaHeight) { //scrollbar visible & inactive
        //we want a border on final row, if an even row
          var lastRow = query(".even-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "add-bottom-border");
        }
      }
      else {
        curam.debug.log("curam.util.alterScrollableListBottomBorder: "
          + debug.getProperty("curam.util.code"));
      }
    }
    //added onLoad event to stop IE7 reading table heght before it is fully loaded
      ready(alterBorder);

  },

  //Set the width (on IE6) of the file upload button and its associated textfield,
  // and it will be auto resized when the window is resized.
  addFileUploadResizeListener:function(code){

    function fileUploadResize(evt){

        if(query(".widget")){

                query(".widget").forEach(function(widgetNode){
                var width = widgetNode.clientWidth;
                    if(query(".fileUpload", widgetNode)){

                        query(".fileUpload", widgetNode).forEach(function(fileUploadNode){
                        fileUploadWidth = width/30;
                        if(fileUploadWidth < 4){
                          fileUploadNode.size= 1;
                        }
                        else{
                          fileUploadNode.size= fileUploadWidth;
                        }
                      });
                  }
              });
          }
    }
      on(dojo.global, 'resize', fileUploadResize);
      ready(fileUploadResize);
  },


  //Opens a pop up dialog, non-modal, in the centre of the screen.
  openCenteredNonModalWindow: function(url, width, height, name) {
    // Fudge factors for window decoration space.
    width = Number(width);
    height = Number(height);
    var offsetLeft = (screen.width - width) / 2;
    var offsetTop = (screen.height - height) / 2;

    height = offsetTop < 0 ? screen.height : height;
    offsetTop = Math.max(0, offsetTop);

    width = offsetLeft < 0 ? screen.width : width;
    offsetLeft = Math.max(0, offsetLeft);

    var left = "left", top = "top";
      if(has("ff")) {
       left = "screenX", top = "screenY";
    }
    var defaultOptions = "location=no, menubar=no, status=no, toolbar=no, "
                         + "scrollbars=yes, resizable=no";

      var newWin = dojo.global.open(url, name || "name",
      'width=' + width + ', height=' + height + ', ' +
      left + '=' + offsetLeft + ',' + top + '=' + offsetTop + ',' +
            defaultOptions );
    // Enforce the size of the window.
    newWin.resizeTo(width, height);

    // Enforce the position of the window
    newWin.moveTo(offsetLeft, offsetTop);
    newWin.focus();
  },

  adjustTargetContext: function(win, href) {
      if (win && win.dojo.global.jsScreenContext) {
        var oldContext = win.dojo.global.jsScreenContext;
        oldContext.updateStates(dojo.global.jsScreenContext);
      return curam.util.replaceUrlParam(href, "o3ctx", oldContext.getValue());
    }
    return href;
    // TO DO: what context is needed to return here if the conditional
    // returns false?
    // Will be looked at in TEC-7946
  },

  modifyUrlContext: function(url, addBits, clearBits) {
    var newUrl = url;
    var ctx = new curam.util.ScreenContext();
    var valueInUrl = curam.util.getUrlParamValue(url, "o3ctx");
    if (valueInUrl) {
      ctx.setContext(valueInUrl);
    } else {
      ctx.clear();
    }
    if (addBits) {
      ctx.addContextBits(addBits);
    }
    if (clearBits) {
      ctx.clear(clearBits);
    }
    newUrl = curam.util.replaceUrlParam(url, "o3ctx", ctx.getValue());
    return newUrl;
  },

  updateCtx: function(initialValue) {
  var valueInUrl = curam.util.getUrlParamValue(initialValue, "o3ctx");
  if (!valueInUrl) {
    return initialValue;
  }
    return curam.util.modifyUrlContext(initialValue, null, 'MODAL');
  },

  getFrameRoot: function(thisWindow, rootObjectName) {
    var found = false;
    var topRef = thisWindow;
    if (topRef) {
      while (topRef != top && !topRef.rootObject) {
        topRef = topRef.parent;
      }
      if (topRef.rootObject) {
        found = (topRef.rootObject == rootObjectName);
      }
    }

    return found ? topRef : null;
  },

  //Saves HTML for informational messages locally on the clients machine.
  //This is used by modal windows to store informational messages before they
  //shut down. The parent page then loads these messages using
  //curam.util.loadInformationalMsgs, and clears the local
  //stored versions, so they are only loaded once.
  saveInformationalMsgs: function(callback) {
      try {
        localStorage[curam.util.INFORMATIONAL_MSGS_STORAGE_ID] =
              json.toJson({
              //Store the page ID, so these messages are only loaded back onto
              //the same page as the one on which they were saved.
                pageID: windowBase.body().id,

              //Store the entire set of messages, including the header, the
              //<ul> element and it's contents. This will be used in most cases.
                total: dom.byId(curam.util.ERROR_MESSAGES_CONTAINER).innerHTML,

              //Save just the <li> elements. If the parent page already has
              //informational messages, these are appended to the existing list.
              //This should not happen really, but is possible. I think...
              //Either way, this doesn't hurt.
                listItems: dom.byId(curam.util.ERROR_MESSAGES_LIST).innerHTML
        });

      callback();

      } catch (e) {
        curam.debug.log(debug.getProperty("curam.util.exception"), e);
      }
    },

  //Disables the loading of informational messages on the current page.
  //This prevents the messages being cleared for a modal dialog's parent page
  //if the loadInformationalMsgs function runs on the page after the messages
  //are saved using the saveInformationalMsgs function.
  disableInformationalLoad: function() {
    curam.util._informationalsDisabled = true;
  },

  redirectDirectUrl: function() {
      ready(function(){
        if (dojo.global.parent == dojo.global) {
        var url = document.location.href;
        var idx=url.lastIndexOf("/");
        if (idx > -1) {
          if (idx <= url.length) {
           url = url.substring(idx + 1);
         }
        }

        dojo.global.location = jsBaseURL + "/AppController.do?o3gtu=" + encodeURIComponent(url);
      }
    });
  },

  //Loads any informational messages from local storage, and puts them
  //on the page. If they exist, they are wiped out, so that they only show once.
  loadInformationalMsgs: function() {
    ready(function() {
      // no informational messages are to be displayed within the context panel
        if(dojo.global.jsScreenContext.hasContextBits('CONTEXT_PANEL')) {
          return;
        }

      if(curam.util._informationalsDisabled) {
        return;
      }

      var msgs = localStorage[curam.util.INFORMATIONAL_MSGS_STORAGE_ID];

        // If informational messages are stored locally, insert them into the
        // page
        if(msgs && msgs != "") {
          //Deserialize the messages from text to a JSON object
            msgs = json.fromJson(msgs);

          //Wipe out the messages so they are only loaded once
          //We could use the dojox.storage.remove method here, but it is not
          //supported by all storage implementations, so just make it an empty
          //string.
          localStorage.removeItem(curam.util.INFORMATIONAL_MSGS_STORAGE_ID);
            var div = dom.byId(curam.util.ERROR_MESSAGES_CONTAINER);
            var list = dom.byId(curam.util.ERROR_MESSAGES_LIST);

          //Only load the messages on the same page as they were saved.
          //The body of each page has it's ID set, which is the name of the
          //UIM file, more or less, and is therefore unique.
            if(msgs.pageID != windowBase.body().id) {
            return;
          }

          // If there are somehow messages already on the page, do not override
          // them, just append to them.
          if(list) {
            //Don't append duplicate informational messages.
              var tempUL = domConstruct.create("ul", {
              innerHTML: msgs.listItems
            });

            //Create an array of the LI elements already in the list.
            var currentLIs = [];
            for(var i = 0; i < list.childNodes.length; i++) {
              if(list.childNodes[i].tagName == "LI"){
                currentLIs.push(list.childNodes[i]);
              }
            }

            //Go through the existing messages to check for duplicates
            //If no duplicate informational message exists, then append the
            //message to the existing list of messages.
            var skip = false;
            var nodes = tempUL.childNodes;
            for(var i = 0; i < nodes.length; i++) {
              skip = false;
              for(var j = 0; j < currentLIs.length; j++) {
                if(nodes[i].innerHTML == currentLIs[j].innerHTML) {
                  skip = true;
                  break;
                }
              }
              if(!skip) {
                list.appendChild(nodes[i]);
                i--;
              }
            }
          } else if(div){
            div.innerHTML = msgs.total;
          }
        }
        
        var informationalMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') : dom.byId('error-messages');
        if (informationalMessage && !dojo.global.jsScreenContext.hasContextBits("MODAL")) {
        
        // Keep focus on the tab if it was the last element selected, otherwise focus
        // on the informational message.
        if (curam.util.getTopmostWindow().curam.util.tabButtonClicked) {
          curam.util.getTopmostWindow().curam.util.getTabButtonClicked().focus();
          setTimeout(function() {
            // For accessibility purposes, the info message should still be announced
            // even when not focussed on. This triggers the screen reader to announce
            // the content
            informationalMessage.innerHTML = informationalMessage.innerHTML + " ";
          }, 500);
        } else {
            informationalMessage.focus();
          }
        }

        // A wrapper div element for an error message only exists for modals as defined in gen-jsp.
        // The explicit focus on this div is necessary for IE11 to fix an issue on an edge case
        // where both a non-modal page and a modal page have respectively error messages. This forces the
        // screen reader to announce the correct error message to the user.
        var informationalMessageOnModal = dom.byId('error-messages-container-wrapper');
        if (informationalMessageOnModal) {
          var modalErrorMessagesElement = query("#container-messages-ul", informationalMessageOnModal)[0];
          if (modalErrorMessagesElement){
            modalErrorMessagesElement.focus();
          }
        }
      });
  },
  /**
   * Sets the attribute tabindex for the currrent iframe and set the
   * focus. Created timeout to remove the attribute tabindex
   * after 10 miliseconds. Method called to allow JAWS sets forms mode 
   * on Edge Chromium browser.
   */
  _setFocusCurrentIframe: function(){
	var isEdge = /Edg/.test(navigator.userAgent);
	if(isEdge){
	  var currentIframe = window.frameElement;
      if(currentIframe){
	    currentIframe.setAttribute("tabindex", "0");
	    currentIframe.focus();
	    setTimeout(function(){
          currentIframe.removeAttribute("tabindex");
        },10);
      }

	}
  },

  /** 
   * sets focus to the input field with the biggest value
   * of tabindex property.
   */
	setFocus: function() {
		
    var setFocusTimeout;		   		
    if(window.document.getElementsByClassName("skeleton").length>0){			   
              setFocusTimeout=setTimeout(function (){curam.util.setFocus();},300);            
    }else{
	if(setFocusTimeout){
	  clearTimeout(setFocusTimeout);
     }
		   		
    var isFocusSetOn =curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton;
	if (isFocusSetOn) {
	 return;
	}
	curam.util._setFocusCurrentIframe();
    var isModal = 
        curam.util.getUrlParamValue(dojo.global.location.href, "o3frame") == "modal" || 
        (curam.util.getUrlParamValue(dojo.global.location.href, "o3modalprev") !== null && 
        curam.util.getUrlParamValue(dojo.global.location.href, "o3modalprev") !== undefined); //IE11
    if (!isModal) {
      // for pages in main content call setFocus here, modals will
      // do it differently in ModalDialog.js
        ready(function(){
          var errorMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') : dom.byId('error-messages');
          var curamDefaultActionId = sessionStorage.getItem('curamDefaultActionId');
          var focusField = null;
          if (!errorMessage && curamDefaultActionId) {
            sessionStorage.removeItem('curamDefaultActionId');
            focusField =  dojo.query(".curam-default-action")[0].previousSibling;
          } else {
            focusField = curam.util.doSetFocus();
          }
          if (focusField) {
            // Call util.setFocusOnField() function where browser specific focus handling occurs.
            // For example, if IE11/Edge is the current browser, there will be a delay before
            // the focus is set. If Chrome is the current browser, the field receives focus immediately.
            curam.util.setFocusOnField(focusField, false);
          } else {
            window.focus();
          }
        });
   	 }
   }
  },
  
  /**
   * Browser specific focus handling occurs here. For example, if IE11/Edge is the current browser,
   * there will be a delay before the focus is set. If Chrome is the current browser, the field
   * receives focus immediately.
   * 
   *  @param focusField The field to focus on.
   *  @param isModal Flag indicating whether the page is a modal or not.
   *  @param localizedModalFrameTitle Localized modal frame title text that's
   *  used when the current page is open in a modal.
   */
  setFocusOnField: function(focusField, isModal, localizedModalFrameTitle) {
    
    // If the browser is not IE11 or Edge, focus on the field immediately.
	  if (has('IE') || has('trident')) {
      
      // Constants for setting focus timeout threshold.
      // Textareas require a longer delay as JAWs forms mode is not triggered consistently with anything less.
      // Text input fields/combo boxes require a different timeout depending on whether the field is
      // present in a modal or tabbed page in order to help trigger forms mode in JAWs.
      var textAreaFocusDelayThreshold = 1000;
      var inputFocusDelayThreshold = isModal ? 200 : 500;
      
      // Creating a visually hidden input and focussing on that initially before focussing on the
      // actual focusField helps the screenreader switch to forms mode for the appropriate fields in IE11.
      curam.util._createHiddenInputField(focusField);

      // Function to execute after timeout threshold has been reached.
      var fnFocus = function(ff){
        return function() {

          var currentNode = ff.ownerDocument.activeElement;
          // do nothing if already focused on a form element
          if (currentNode.tagName === 'INPUT' && !currentNode.classList.contains('hidden-focus-input') 
              || currentNode.tagName === 'TEXTAREA'
              || (currentNode.tagName === 'SPAN' && currentNode.className == 'fileUploadButton')
              || (currentNode.tagName === 'A' && currentNode.className == 'popup-action')
              || (currentNode.tagName === 'IFRAME' && currentNode.classList.contains('cke_wysiwyg_frame'))) {
            return;
          } else {
            ff.focus();
          }
        
        } 
      };
      
      if(isModal) {
	  
        // Only update the aria-label when setting focus within a modal.
        var ownAria = attr.get(focusField, 'aria-label');
        var localizedTitle = "";
        // Cases for combo boxes where a subcomponent value is dependent on its main component's (component) selected value.
        // Both components have ojbid attributes respectively set as "component" and "subComponent".
        // Added case for stand-alone combo box.
        var componentObjId = attr.get(focusField,"objid");
        if (componentObjId && componentObjId.indexOf("component") == 0
            || domClass.contains(focusField,"dijitReset dijitInputInner")){
          localizedTitle = focusField.title;
        } else {
          localizedTitle = localizedModalFrameTitle
                             || 'Modal Dialog';
        }

        // Prevent aria-label with localizedTitle from being added to error-messages as it prevents the screen reader from
        // announcing the contents of the error messages list.
        if (focusField && focusField.id !== "container-messages-ul") {
          attr.set(focusField, 'aria-label', localizedTitle);
        }
        
        var restorer = function(oldAria) {
          return function(e) {
            query('input|select[aria-label=' + localizedTitle + ']')
              .forEach(function(entry) {
              oldAria && attr.set(entry, 'aria-label', oldAria);
              !oldAria && attr.remove(entry, 'aria-label');
              });
          }
        }
        on(focusField, 'blur', restorer(ownAria));
      }
      
      // Only fields that require user interaction need a delay in setting focus.
      // Textareas require a longer delay as forms mode is not triggered consistently with anything less.
      // Text input fields, comboboxes and select elements require a shorter delay to help trigger forms mode.
      // Any other element that receives focus and does not require forms mode in order for the user to interact
      // with it, will receive focus without any delay.
      if (focusField.tagName === 'TEXTAREA') {
        setTimeout(fnFocus(focusField), textAreaFocusDelayThreshold);
      } else if (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && attr.get(focusField, "type") === "text")) {
        setTimeout(fnFocus(focusField), inputFocusDelayThreshold);
      } else {
        focusField.focus();
      }
    } else {
      focusField.focus();
    }
  },
  
  /**
   * Creating a visually hidden input and focussing on that initially before focussing on the
   * actual focusField helps the screenreader switch to forms mode for the appropriate fields in IE11.
   * This is destroyed as soon as focus leaves the field.
   * 
   * @param focusField The field to focus on.
   */
  _createHiddenInputField: function(focusField) {
    
    var mainForm = focusField.ownerDocument.forms['mainForm'];
    // Only create the hidden input for fields that require forms mode to be automatically switched on.
    if (mainForm && (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && attr.get(focusField, "type") === "text"))) {
      // Visually hide the input field.
      var hiddenInput = domConstruct.create("input", 
                        {"class": "hidden-focus-input", 
                         "style": "position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap;", 
                         "type": "text", 
                         "aria-hidden": "true", 
                         "tabindex": "-1"});
      domConstruct.place(hiddenInput, mainForm, "before");
      hiddenInput.focus();
      on(hiddenInput, 'blur', function(){domConstruct.destroy(hiddenInput)});
    }
  },

  /**
   * Set focus on the first editable field in the page. If there are no editable
   * fields, the function does not do anything. In case the first editable field
   * is a FilteringSelect widget than it skips the arrow and validation container
   * and sets the focus on the input container of FilteringSelect widget.
   *
   * @returns {Object} the field to focus on, or boolean false if no such
   * field was found. 
   */
  doSetFocus: function() {
	try {
    //return the tab button if the user is navigating through tabs
	  var tabButton = curam.util.getTopmostWindow().curam.util.getTabButtonClicked();
	  if(tabButton != false && !curam.util.isModalWindow()){
	    return tabButton;
	  }

	  var errorMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') :  dom.byId('error-messages');
	  if (errorMessage) {
	    return errorMessage;
      }
        
	  var form = document.forms[0];
	  if (!form) {
	    return false; //no editable fields - nothing to do
	  }
      
	  
	  var fields = form.querySelectorAll(
	  'button, output, input:not([type="image"]), select, object, textarea, fieldset, a.popup-action, span.fileUploadButton');
	  var focusField = false;
	  var l = fields.length, el;
	  for (var i = 0; i < l; i++) {
	    el = fields[i];
	    // exception: draw focus on the dijit select if that happens to
	    // be first editable field (and not overridden).
	    if (!focusField && /selectHook/.test(el.className)){
	      focusField = query(el).closest('table')[0];
	    }
        if (!focusField && !(el.style.visibility=="hidden") && (
	      /select-one|select-multiple|checkbox|radio|text/.test(el.type)
	        || el.tagName == "TEXTAREA" || /popup-action|fileUploadButton/.test(el.className))
	        && !/dijitArrowButtonInner|dijitValidationInner/.test(el.className)) {
	       focusField = el;
	    }
	    if (el.tabIndex == '1') {
	      // reset the tab index to prevent it having an effect on
	      // screen tabbing.
	      el.tabIndex = 0;
	      focusField = el;
	      break; // once we've found an override, no need to keep looping.
	    }
      }
      //if the is no form field to put the focus on, the focus should go on the last opened tab.
      lastOpenedTabButton = curam.util.getTopmostWindow().curam.util.getLastOpenedTabButton();
      if(!focusField && lastOpenedTabButton) {            
          return lastOpenedTabButton;       
      }
      var dataPickerInputFirst = focusField.classList.contains("bx--date-picker__input");

      if(dataPickerInputFirst){
			
			var modalBody = document.querySelector(".bx--uim-modal");
			
			if(modalBody){
			   focusField = modalBody;
            }      
       }
	  return focusField;
	} catch(e) {
	  debug.log(debug.getProperty("curam.util.error.focus"), e.message);
	  return false;
	}
	return false;
  },

  openLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
    var target = event.target;
    while(target && target.tagName != "A") {
      target = target.parentNode;
    }
    var loc = target.href;
    var rpu = curam.util.getUrlParamValue(loc, "__o3rpu");
    // strip the __o3rpu parameter form the RPU value
    rpu = curam.util.removeUrlParam(rpu, "__o3rpu");
    var href="user-locale-selector.jspx" + "?__o3rpu=" + rpu;

      if (!curam.util.isActionPage(dojo.global.location.href)) {
      openModalDialog({href:href},"width=500,height=300",200,150);

    } else {
      alert(curam.util.msgLocaleSelectorActionPage);
    }

    return false;
  },
  
  /**
   * Opens the new Language selector modal.
   *
   * @param event 
   *          the click event on the Language menu-item. 
   */
  openLocaleNew: function(event) {
    dojoEvent.stop(event);

    if (event.target._curamDisable) {
      // link disabled, do nothing
      return;
    }

    require(["curam/tab"], function() {
      curam.tab.getTabController().handleLinkClick(
          "user-locale-selector.jspx", {dialogOptions:"width=300"});
    });
  },

  isActionPage: function(url) {
    var pageAndQuery = curam.util.getLastPathSegmentWithQueryString(url);
    var pageName = pageAndQuery.split("?")[0];
    return pageName.indexOf("Action.do") > -1;
  },

  closeLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
      dojoEvent.stop(event);

      dojo.global.close();
    return false;
  },

  /**
   * Retrieves the remaining part of a class name which has the specified prefix.
   * E.g. for <theNode class="class1 class2 thePrefix-remaining-part-of-name" />
   * the call to curam.util.getSuffixFromClass(theNode, "thePrefix-")
   * will return "remaining-part-of-name".
   *
   * @param node
   *          The note to get the class from.
   * @param prefix
   *          The prefix to find the class by.
   * @returns
   *    If the class with the prefix is found it returns the remaining
   *    part of the class name. If the class is not found, returns null.
   *    If more than one class is found, it returns the first occurrence.
   */
  getSuffixFromClass: function(node, prefix) {
      var classes = attr.get(node, "class").split(" ");
      var namesFound = array.filter(classes, function(className) {
      return className.indexOf(prefix) == 0;
    });
    if (namesFound.length > 0) {
      return namesFound[0].split(prefix)[1];

    } else {
      return null;
    }
  },

  getCacheBusterParameter : function() {
    return this.CACHE_BUSTER_PARAM_NAME + "=" + new Date().getTime() + "_"
        + this.CACHE_BUSTER++;
  },

  /**
   * Add classes to table rows to allow striping in appearance.
   * Handles expandable and paginated lists in a specific way.
   */
  stripeTable: function(table, isExpandableList, lastVisibleRowIndex) {
    var tbody = table.tBodies[0];
    var mainRowStep = (isExpandableList ? 2 : 1);

    // for a list with one row do nothing
    if (tbody.rows.length < mainRowStep) {
      return;
    }

    var rows = tbody.rows;
    var oddRows = [], evenRows = [], isLast = false, lastRows = [], lastClass='';
    for (var i = 0, l = rows.length; i < l; i += mainRowStep) {
      //curam.debug.log("curam.util.stripeTable(%s, %s): i = %s", table, isExpandableList, i);
      var isEven = (i % (2 * mainRowStep) == 0), targetArray =  isEven ? evenRows : oddRows;
      domClass.remove(rows[i], ['odd-last-row','even-last-row']);
      targetArray.push(rows[i]);
      if (i == lastVisibleRowIndex) {
        lastRows.push(rows[i]);
        lastClass = isEven ? 'odd':'even';
        isLast = true;
      }
      if (isExpandableList && rows[i + 1]) {
        domClass.remove(rows[i+1], ['odd-last-row','even-last-row']);
    	targetArray.push(rows[i+1]);
    	isLast && lastRows.push(rows[i+1]);
      }
      isLast = false;
     }
     evenRows.forEach(function(evenRow){
       domClass.replace(evenRow, 'odd', 'even'); 
     });
     oddRows.forEach(function(oddRow){
       domClass.replace(oddRow, 'even', 'odd'); 
     });
     lastRows.forEach(function(lastRow){
       domClass.add(lastRow, lastClass+'-last-row');
     });
  },

  fillString: function(fillChar, count) {
    // summary:
    //  Creates a string of 'x' repeating characters
    var string = "";
    while (count > 0) {
      string += fillChar;
      count-=1;
    }
    return string;
 },

  updateHeader: function(qId, newHeader, answer, source) {
      var header = dom.byId('header_' + qId);
    header.firstChild.nextSibling.innerHTML = newHeader;
      answerCell = dom.byId('chosenAnswer_' + qId);
    answerCell.innerHTML = answer;
      sourceCell = dom.byId('chosenSource_' + qId);
    sourceCell.innerHTML = source;
  },

  search: function(textWidgetID, typeWidgetID){
     // summary:
     //              Invokes the required search page for an application search as
     //              specified by the associated configuration data. How this
     //              is done is described below:
     //
     // description:
     //              <ol>
     //                <li>
     //                  Retrieving the value of the business object select drop
     //                  down. This value includes a business object code and
     //                  also a page identifier.
     //                </li>
     //                <li>
     //                  Retrieving the value of the input text control which
     //                  specifies the search text to be used.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has been
     //                  specified in the associated configuration data, the
     //                  page identifier specified by the selected option will
     //                  be used to construct a URL using the
     //                  <code>searchText</code> and <code>searchType</code>
     //                  page parameters and that page is invoked.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has not been
     //                  specified in the associated configuration data, the
     //                  default search page specified will be used to construct
     //                  a URL using the <code>searchText</code> page parameter
     //                  only and then that page is invoked.
     //                </li>
     //              </ol>
     //              <P>
     //              The data used here is generated by a renderer so therefore
     //              no validations are performed and it is assumed that the
     //              data is in the correct format for parsing.
     // textWidgetID:
     //              The identifier of the text input control for the application
     //              search which is used to retrieve the text to be used in the
     //              application search. The value taken from this field is
     //              associated with the <code>searchText</code> page parameter
     //              of the search page being invoked.
     // typeWidgetID:
     //              The identifier of the drop down control for the application
     //              search which is used to retrieve the business object type
     //              to be used in the application search. The value taken from
     //              this field is associated with the <code>searchType</code>
     //              page parameter of the search page being invoked. Note that
     //              this is optional as the list of business objects to search
     //              for is an optional element of an application search.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

        // Retrieve the search text from the input control.
      var searchText = registry.byId(textWidgetID).get("value");
    // The search type, if specified, from the drop down list of business
    // objects. This is a combination of the type and the page identifier
    // so split these out here.
      var searchTypeWidget = registry.byId(typeWidgetID);
          if (searchTypeWidget == null) {
                  searchTypeWidget = dom.byId(typeWidgetID);
          }
          var currentlySelectedItem = null;
          if(searchTypeWidget != null) {
                  if (searchTypeWidget.tagName == null) {
                        currentlySelectedItem
                  = searchTypeWidget ? searchTypeWidget.get("value"): null;
                  } else {
                        if (searchTypeWidget.tagName == 'SELECT') {
                          var options = query('.multiple-search-banner select option');
                          array.forEach(options, function(elem){
                                  if (elem.selected) {
                                          currentlySelectedItem = elem.value;
                                  }
                          });
                        }
                  }
          }
    var searchType = "";
    var pageIDFromSearchOptions;
    var tokens;

    if(currentlySelectedItem){
      // The currently selected item consists of the search type and the page
      // identifier to use in the search.
      tokens = currentlySelectedItem.split("|");
      searchType = tokens[0];
      pageIDFromSearchOptions = tokens[1];
    }

    var defaultSearchPageID = curam.util.defaultSearchPageID;

    // If the select box has not been specified, then the page identifier is
    // the default page identifier. Construct the page to be invoked.
    var searchPageURL = "";
    
    // Should the secure URLs exempt param be appended?
	if (sessionStorage.getItem('appendSUEP') === "true") {
	
	    if (searchType==="") {
	      searchPageURL = defaultSearchPageID + "Page.do?searchText="
	                                              + encodeURIComponent(searchText) 
	                                              + "&" + curam.util.secureURLsExemptParamName 
	                                              + "=" + encodeURIComponent(curam.util.secureURLsExemptParamsPrefix + "_ST1");
	    } else {
	      searchPageURL = pageIDFromSearchOptions + "Page.do?searchText="
	                          + encodeURIComponent(searchText) + "&searchType="
	                            + encodeURIComponent(searchType) + "&" 
	                            + curam.util.secureURLsExemptParamName 
	                            + "=" + encodeURIComponent(curam.util.secureURLsExemptParamsPrefix 
	                            + "_ST1,"+ curam.util.secureURLsExemptParamsPrefix +"_ST2");
	    }
    } else {
	
	    if (searchType==="") {
	      searchPageURL = defaultSearchPageID + "Page.do?searchText="
	                                              + encodeURIComponent(searchText);
	    } else {
	      searchPageURL = pageIDFromSearchOptions + "Page.do?searchText="
	                          + encodeURIComponent(searchText) + "&searchType="
	                            + encodeURIComponent(searchType);
	    }
    }
    // Call the function that will load the search page.
    var searchPageRequest = new curam.ui.PageRequest(searchPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(searchPageRequest);
    });
  },

  updateDefaultSearchText: function(typeWidgetID, textWidgetID){
    // summary:
    //              Updates the search text input control in the application
    //              search widget with some initial text from the item selected
    //              in the associated list of search business objects.
    //
    // description:
    //              Retrieves the initial text from the item selected in the list
    //              of business objects drop down and sets the place holder
    //              attribute of the application search text input control with
    //              this initial text. This is called from the
    //              <code>onChange()</code> event of the application search drop
    //              down list.
    // typeWidgetID:
    //              The identifier of the drop down control for the application
    //              search which is used to retrieve the initial text that is
    //              set in the place holder attribute of the associated text
    //              input control each time the value of the drop down list
    //              is changed. This initial text acts as an aid to the user
    //              when performing the search as it offers them a hint as to
    //              what should be entered into the text area for the type of
    //              search being performed.
    // textWidgetID:
    //              The identifier of the text input control whose place
    //              holder attribute will be set with initial text to aid the
    //              user perform the search.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

      var searchTypeWidget = registry.byId(typeWidgetID);
      var textWidget = registry.byId(textWidgetID);
      var currentlySelectedItem = searchTypeWidget ? 
    		  searchTypeWidget.get("value"): null;
      // The initial text is the third token in the string.
      var str = currentlySelectedItem.split("|")[2];

      textWidget.set("placeHolder", str);
      topic.publish('curam/application-search/combobox-changed', 
    		  currentlySelectedItem);
  },

  updateSearchBtnState: function(textWidgetID, btnID){
    // summary:
    //              Enables or disables the search anchor for an application
    //              search depending on whether this is text specified for the
    //              search.
    //
    // description:
    //              The search anchor specified for an application search is
    //              disabled if no text has been specified in the text input
    //              control. This function is called on the
    //              <code>onKeyPress</code> of the text input control so that when
    //              a user enters some text, the search anchor is enabled to allow
    //              that user perform the search.
    // textWidgetID:
    //              The identifier of the text input control for the application
    //              search which is used to determine if that text box contains
    //              any text. If it does, then the search anchor is enabled,
    //              otherwise it is disabled.
    // btnID:
    //              The identifier of the search anchor for the application search
    //              and this is used to retrieve the control to enable or disable
    //              depending on whether there is text in the associated search
    //              text input control.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
      var widget = registry.byId(textWidgetID);
      var btn = dom.byId(btnID);
      var value = widget.get("value");

      if(!value || lang.trim(value).length < 1){
        domClass.add(btn, "dijitDisabled");
      } else {
        domClass.remove(btn, "dijitDisabled");
    }
  },

  furtherOptionsSearch: function() {

    // summary:
    //              Invokes the page specified for the further options link
    //              in an application search.
    //
    // description:
    //               The further options search page is invoked by retrieving
    //               the page identifier specified in the configuration
    //               data, constructing a page request for that URL and
    //               calling the function to handle that request.
    //               <P>
    //               Validations performed elsewhere should ensure that the
    //               data is specified in the correct fashion and hence there
    //               are no validations invoked here.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

    // Retrieve the page identifier for the further options link.
    var furtherOptionsPageURL = curam.util.furtherOptionsPageID + "Page.do";

    // Call the function that will load the search page.
    var furtherSearchOptionsPageRequest
        = new curam.ui.PageRequest(furtherOptionsPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(
          furtherSearchOptionsPageRequest);
    });
  },

  searchButtonStatus: function(btnID){
    // summary:
        //              Returns true if the button is not disabled
        //
        // description:
        //              The search anchor specified for an application search is
        //              disabled if no text has been specified in the text input
        //              control. This function is called on the
        //              <code>onKeyPress</code> of the text input control if this function returns true.
        // btnID:
        //              The identifier of the search anchor for the application search
        //              and this is used to retrieve the control to enable or disabled
        var btn = dom.byId(btnID);
        if(!domClass.contains(btn,"dijitDisabled")){
          return true;
        }
  },

  /**
  * Return the height of the page contents for the current width.
  * Note that if the width changes, the contents height might change as well.
  *
  * Note: this algorithm is dependent on the structure of the
  * DOM. Changes to the page layout will probably break this.
  *
  * @return page height.
  */
  getPageHeight: function() {
    var defaultHeight = 400;
    var resultingHeight = 0;

      if (query("frameset").length > 0) {
      /* Detect framesets and use default height for them.
      * Normally frameset windows should have fixed height specified
      * by the developer, but this is for the cases in which the developer
      * forgets to specify the height.
      */
      curam.debug.log(
        "curam.util.getPageHeight() "
          + debug.getProperty("curam.util.default.height"),
      defaultHeight);
      resultingHeight = defaultHeight;

    } else {
      // create function for determinning bottom coordinate of an element
      var bottom = function(node) {
        if (!node) {
          curam.debug.log(debug.getProperty("curam.util.node"));
          return 0;
        }

        // Use getMarginBoxSimple if it's available
          var mb = geom.getMarginSize(node);
          var pos = geom.position(node);

        return pos.y + mb.h;
      };

        if (dojo.global.jsScreenContext.hasContextBits('LIST_ROW_INLINE_PAGE')) {

        // if we are in list details row, just use the content div
        var contentDiv = query("div#content")[0];
        var contentBottom = bottom(contentDiv);
        curam.debug.log(debug.getProperty("curam.util.page.height"), contentBottom);
        resultingHeight = contentBottom;

      } else {
          var contentObj = dom.byId("content") || dom.byId("wizard-content");

        // find the bottom-most node
          var nodes = query("> *", contentObj).filter(function(n) {
          // leave out script and hidden nodes
          return n.tagName.indexOf("SCRIPT") < 0
            && style.get(n, "visibility") != "hidden"
            && style.get(n, "display") != "none";
        });
        var bottomNode = nodes[0];
        for (var i = 1; i < nodes.length; i++) {
          if(bottom(nodes[i]) >= bottom(bottomNode)) {
            bottomNode = nodes[i];
          }
        }
        // first count in the main contents height
        resultingHeight = bottom(bottomNode);
        curam.debug.log("curam.util.getPageHeight() "
            + debug.getProperty("curam.util.base.height"), resultingHeight);

        // count in modal dialog action set, if present
        var doesActionSetExist = query(".actions-panel", windowBase.body());

        if (doesActionSetExist.length > 0) {
          // Only one actions panel exists in one modal, we can get the height
          // of this panel dynamically.
          var actionsPanelHeight = geom.getMarginBox(doesActionSetExist[0]).h;

          curam.debug.log("curam.util.getPageHeight() "
              + debug.getProperty("curam.util.panel.height"));

          // Add the actions panel height to the total page height, here we
          // presume the actions panel is always positioned at the bottom of
          // the page.
          resultingHeight += actionsPanelHeight;

          // Then add additional 10px spacing at the top of the actions panel.
          resultingHeight += 10;
        }

        // in case we are in the details panel, count in the title bar height
          var detailsPanel = query("body.details");
        if (detailsPanel.length > 0) {
          curam.debug.log("curam.util.getPageHeight() "
              + debug.getProperty("curam.util.bar.height"));
            resultingHeight += 20;
        }
      }
    }

      curam.debug.log("curam.util.getPageHeight() "
          + debug.getProperty("curam.util.returning"), resultingHeight);
    return resultingHeight;
  },

  /**
  * Takes an array and from its elements it creates a comma separated
  * string of values, which is then returned.
  */
  toCommaSeparatedList: function(inputArray) {
    var result = "";
    for (var i = 0; i < inputArray.length; i++) {
      result += inputArray[i];
      if (i < inputArray.length -1) {
        result += ",";
      }
    }
    return result;
  },


  

  /**
  * Registers a handler for submitting a form when Enter key is pressed.
  *
  * Called from the PageTag - will be called on every page in any context,
  * main content, dialog, etc.
  */
  setupGenericKeyHandler: function() {
      ready(function() {
      // The handler is never explicitly deregistered - disappears when
      // the runtime context is destroyed (new page loaded)
      var f = function(event) {

        // On ESC key handling: When ESC key is pressed and in a modal,
        // the modal will close automatically.
        if (dojo.global.jsScreenContext.hasContextBits('MODAL')
            && event.keyCode == 27) {
          var ev = dojoEvent.fix(event);
          var dropdown = registry.byId(ev.target.id);
          var isDropdown =
            typeof dropdown != "undefined" && dropdown.baseClass == "dijitTextBox dijitComboBox";
          if (!isDropdown) {
            curam.dialog.closeModalDialog();
          }
        }

        // On ENTER key handle the event
        if (event.keyCode == 13) {
            var ev = dojoEvent.fix(event);

        // only submit form when certain input fields have focus. This allows
        // for normal keyboard selection (example: pressing enter on date
        // selector icon) to happen without the form submitting.

    var isText = ev.target.type == "text";
    var isRadio = ev.target.type == "radio";
    var isCheckbox = ev.target.type == "checkbox";
    var isMultiSelect = ev.target.type == "select-multiple";
    var isPassword = ev.target.type == "password";

    var combo = registry.byId(ev.target.id);
    // Added a check so that form is not submitted when "Enter" key
    // is pressend in open state of dropdown.
    if (typeof combo != "undefined") {
      var comboWidget = registry.byId(ev.target.id);
      if (!comboWidget) {
        comboWidget = registry.byNode(dom.byId("widget_" + ev.target.id));
      }
      if(comboWidget && comboWidget.enterKeyOnOpenDropDown) {
        comboWidget.enterKeyOnOpenDropDown = false;
        return false;
      }
    }
    
    var carbonAttachPoint = ev.target.getAttribute("data-carbon-attach-point");
    if (carbonAttachPoint && carbonAttachPoint === 'carbon-menu') {
    	return false;
    }

    var isCombo =
    typeof combo != "undefined" && combo.baseClass == "dijitComboBox";
    if ((!isText && !isRadio && !isCheckbox && !isMultiSelect
    && !isPassword) || isCombo ) {
      return true;
    }
    var defaultSubmitButton = null;
      var explicitDefaultBtnArray = query(".curam-default-action");
    // take the default button if set
    if (explicitDefaultBtnArray.length > 0) {
      defaultSubmitButton = explicitDefaultBtnArray[0];

    } else {
      // otherwise take the first found submit button
        var submitButtonsArr = query("input[type='submit']");
      if (submitButtonsArr.length > 0) {
        defaultSubmitButton = submitButtonsArr[0];
      }
    }
    // now click the button found
    if (defaultSubmitButton != null) {
        dojoEvent.stop(dojoEvent.fix(event));
      curam.util.clickButton(defaultSubmitButton);
      return false;
    }
      //Focus remains in the date selector on ENTER
      require(["curam/dateSelectorUtil"], function(selectorUtil) {
        var isInputyear = dom.byId("year");
        if (isInputyear) {
          dojo.stopEvent(dojo.fixEvent(event));

          //Enter key updates the calendar
          selectorUtil.updateCalendar();
        }
     });

     }

     // otherwise let the event continue
       return true;
     };

     // event must be onKeyUp, as the ESC key event is not fired during an
     // onKeyPress event.
     curam.util.connect(windowBase.body(), "onkeyup", f);
  });
  },

  /**
  * Returns true is key press event is triggered by the enter key.
  * Used by context panel toggle icon and list/cluster toggle icons.
  */
  enterKeyPress: function(event) {
    if(event.keyCode == 13) {
      return true;
    }
  },

  /**
  * Given a DOM node, boolean state and class names for true and false
  * alternatives, the function sets the appropriate classes on the node.
  */
  swapState: function(node, state, classTrue, classFalse) {
    if (state) {
        domClass.replace(node, classTrue, classFalse);

    } else {
        domClass.replace(node, classFalse, classTrue);
    }
  },

  /**
  * Creates a URL query string including the leading question mark
  * from the specified page parameters.
  * The function handles URL-encoding of the values so do NOT encode them.
  *
  * @param params Object in the following format:
  *                { param1Name:"value", param2Name:248 }
  */
  makeQueryString: function(params) {
    if (!params || params.length == 0) {
      return "";
    }

    var result = [];
    for (var paramName in params) {
      result.push(paramName + "=" + encodeURIComponent(params[paramName]));
    }

    return "?" + result.join("&");
  },

  /**
   * Handles the onClick event for file download anchor tags.
   *
   * Subscribes to the window close event, opens a yes/no dialog, then when publish happens
   * it checks the chosen option and if 'confirm' it calls the clickHandlerForListActionMenu
   * function. The url parameter is passed to clickHandlerForListActionMenu function.
   *
   * @param url
   *          The URL of the file download servet.
   */
  fileDownloadAnchorHandler: function(url) {
    // Subscribe downloadOnConfirm function to the window closing event
    var topmostWin = curam.util.getTopmostWindow();
    var unsToken = topmostWin.dojo.subscribe("/curam/dialog/close", function(id, option) {
      if(option === 'confirm') {
        curam.util.clickHandlerForListActionMenu(url, false, false);
      }
      topmostWin.dojo.unsubscribe(unsToken);
    });

    // Get the dialog window width and height from properties file
    var bundle = new resBundle("GenericModalError");
    var width = bundle.getProperty("file.download.warning.dialog.width");
    var height = bundle.getProperty("file.download.warning.dialog.height");
    if(!width) {
      width = 500; // Default value
    }
    if(!height) {
      height = 225; // Default value
    }

    // Show an ok/cancel dialog with browser-specific security steps
    var browserName = curam.util._getBrowserName();
    curam.util.openGenericErrorModalDialogYesNo(
        "width="+width+",height="+height,
        "file.download.warning.title",
        "file.download.warning."+browserName);

    return false; // Return false so that initial onclick event does not download the file
  },

  /**
   * Handles the onClick event for file download list action menu items.
   *
   * Subscribes to the window close event, opens a yes/no dialog, then when publish happens
   * it checks the chosen option and if 'confirm' it calls the clickHandlerForListActionMenu
   * function. The method parameters are all passed to clickHandlerForListActionMenu function.
   *
   * @param url
   *          The URL of the file download servet.
   */
  fileDownloadListActionHandler: function(url, sameDialog, newWindow, event) {
    // Subscribe downloadOnConfirm function to the window closing event
    var topmostWin = curam.util.getTopmostWindow();
    var unsToken = topmostWin.dojo.subscribe("/curam/dialog/close", function(id, option) {
      if(option === 'confirm') {
        curam.util.clickHandlerForListActionMenu(url, sameDialog, newWindow, event);
      }
      topmostWin.dojo.unsubscribe(unsToken);
    });

    // Get the dialog window width and height from properties file
    var bundle = new resBundle("GenericModalError");
    var width = bundle.getProperty("file.download.warning.dialog.width");
    var height = bundle.getProperty("file.download.warning.dialog.height");
    if(!width) {
      width = 500; // Default value
    }
    if(!height) {
      height = 225; // Default value
    }

    // Show an ok/cancel dialog with browser-specific security steps
    var browserName = curam.util._getBrowserName();
    curam.util.openGenericErrorModalDialogYesNo(
        "width="+width+",height="+height,
        "file.download.warning.title",
        "file.download.warning."+browserName);
  },

  /**
   * Gets the browser name. Returns a string, e.g. "ie8", "ie11", "firefox", etc.
   */
  _getBrowserName: function() {
    var tridentVersion = has("trident");
    var ffBrowserVersion = dojo.isFF;
    var chromeBrowserVersion = dojo.isChrome;
    var safariBrowserVersion = dojo.isSafari;
    var topmostWin = curam.util.getTopmostWindow();
    var isExternalApp = curam.util.ExpandableLists._isExternalApp(topmostWin);

    if (tridentVersion != undefined) {
      /*
       * We are assuming here that Microsoft will keep to the pattern of Trident
       * being 4 versions behind IE, i.e. IE8 = Trident 4, IE9 = Trident 5, etc.
       * If they change this pattern then we will need to modify the conditional
       * statements below.
       */
      var ieVersion = tridentVersion + 4;
      if(ieVersion < 8) {
        return "unknown.browser"; // IE7 and below are not supported
      } else {
        return "ie" + ieVersion;
      }
    } else if (ffBrowserVersion != undefined && isExternalApp) {
      return "firefox";
    } else if (chromeBrowserVersion != undefined) {
      return "chrome";
    } else if (safariBrowserVersion != undefined && isExternalApp) {
      return "safari";
    }
    return "unknown.browser"; // Unknown or unsupported browser
  },

 /**
  * Handles the onClick event for the list action menu items.
  *
  * @param url
  *          The URL of the required page.
  * @param sameDialog
  *          True if we re in a dialog and the page flow should stay
  *          in the same dialog.
  */
    clickHandlerForListActionMenu: function(url, sameDialog, newWindow, event) {
    // TODO: This handler was intended only for the list row actions menu but
    // is now being used for page level actions menus also, so re-name
    // appropriately. Also, *some* of the code in this method is duplicated
    // in the "clickHandler" method of UIMPageAdaptor.js. AS LONG AS THESE
    // METHODS ARE SEPARATE, ANY UPDATES TO THE LOGIC BELOW MUST BE ANALYZED
    // TO SEE IF THEY NEED TO BE APPLIED IN THE "UIMPageAdaptor" CLASS.
    if (sameDialog) {
      var href = curam.util.replaceUrlParam(url, "o3frame", "modal");
        var ctx = dojo.global.jsScreenContext;
      ctx.addContextBits('MODAL');
      href = curam.util.replaceUrlParam(href, "o3ctx", ctx.getValue());
      curam.util.redirectWindow(href);
      return;
    }

    // create a dummy anchor object
    var anchor = { href: url };

    require(["curam/ui/UIMPageAdaptor"]);
    if (curam.ui.UIMPageAdaptor.allowLinkToContinue(anchor)) {
      // In the case of a list action menu the click event is no longer coming
      // from an anchor element, instead it's a Diji MenuItem. Explicitly
      // setting window.location fakes the same behaviour as clicking the anchor
      // element. This will handle the sceanrios tested by allowLinkToContinue,
      // which are file downloads and the mailto link.
      // TODO: Can this method just return and let the event continue without
      // setting window.location....??? Seems to be other event handers
      // supressing this, so going with this approach for now.
      if (anchor.href.indexOf("/servlet/FileDownload")) {
        // When downloading a file, setting dojo.global.location will trigger the
        // addOnUnload event for each iframe with a addOnUnload attached. In this  
        // file downloading scenario we do not want these addOnUnload events to clear 
        // the contents of these iframes.
        sessionStorage.setItem("addOnUnloadTriggeredByFileDownload", "true");
        dojo.global.location = url;
        sessionStorage.removeItem("addOnUnloadTriggeredByFileDownload");
      } else {
        dojo.global.location = url; 
      }
      return;
    }

    // if we have an anchor, stop the click event and perform standard tab
    // processing (i.e. should it open in a new tab etc.)
    if (anchor != null) {
        if (event) {
          dojoEvent.fix(event);
          dojoEvent.stop(event);
      }

      if (!anchor.href || anchor.href.length == 0) {
        // the event has been stopped, just return if it has no href.
        // any onclick handlers attached to the link will have executed by now.
        return;
      }
      if (newWindow && !curam.util.isInternal(url)) {
          dojo.global.open(url);

      } else if (curam.ui.UIMPageAdaptor.isLinkValidForTabProcessing(anchor)) {
        var uimPageRequest = new curam.ui.PageRequest(anchor.href);
        if (dojo.global.jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || dojo.global.jsScreenContext.hasContextBits("NESTED_UIM")) {
          uimPageRequest.pageHolder = dojo.global;
        }
        require(["curam/tab"], function() {
          var tabController = curam.tab.getTabController();
          if(tabController) {
            tabController.handlePageRequest(uimPageRequest);
          }
        });
      }
    }
    // Otherwise we let the event continue uninterrupted.
  },

  /**
     * Gets browser to action a mailto: link in a separate iframe.
     * This is to avoid issues with page unloading when mailto link is clicked
     * on some browsers.
     *
     * @param event The onclick DOM event.
     * @param url The URL of the link, including the mailto: protocol.
     */
    clickHandlerForMailtoLinks: function(event, url) {
      // stop anchor click from propagating and changing page
      dojo.stopEvent(event);

      // is there existing iframe to reuse?
      var iframe = dojo.query("#mailto_frame")[0];
      if (!iframe) {
        // no frame to reuse - create a new one
        iframe = dojo.io.iframe.create("mailto_frame", "");
      }

      // get browser to action the mailto: link in separate frame
      iframe.src = url;

      // return false as per convention for DOM click handlers
      return false;
    },

    /**
  * Decides whether or not the URL is internal.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns true if the URL is internal false it it is external.
  */
  isInternal: function(url) {
    var path = url.split("?")[0];
    // Occurrence of Page.do determines whether or not it is internal URL.
    // It is assumed that, the external URL's would not have Page.do as it
    // fixed internal action call for curam.
    // TODO : Determining the URL is internal based on Page.do is a
    // brittle solution.Implement the improved solution.
    var occurrence = path.match("Page.do");
    if (occurrence!= null) {
      return true;
    }
    return false;
  },

  /**
  * Takes a URL and extracts its last path segment with the query string.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns The last path segment of the URL with the query string,
  *      if it is part of the URL.
  */
  getLastPathSegmentWithQueryString: function(url) {
    var pathAndParams = url.split("?");
    var pathComponents = pathAndParams[0].split("/");
    return pathComponents[pathComponents.length - 1]
    + (pathAndParams[1] ? "?" + pathAndParams[1] : "");
  },

  /**
  * Replaces standard submit buttons with anchor tags when no images are used.
  * @param {String} buttonText
  *            The text to be displayed on submit button.
  */
  replaceSubmitButton: function(name, buttonText, isCustomSecondaryButton, newbuttonid, hasOnClickFunction) {
    if(curam.replacedButtons[name] == "true") {
      return;
    }

    /*
    * In the agenda player search for input elements where the name attribute
    * ends with SUM. This is required because an extra string of SUM is
    * appended onto the end of the name attribute value in the agenda player.
    * For all other submit buttons in the application we'll search for the
    * input fields the normal way to ensure we're not breaking any older
    * functionality.
    */
    var buttonId = '__o3btn.' + name;
    var inputList;
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
        inputList = query("input[id='" + buttonId + "']");

    } else {
        inputList = query("input[name='" + buttonId + "']");
    }

    /*
    * You can supply 3 parameters to the forEach method of the dojo node list.
    * The current node, the index, and the node list itself.
    */
    inputList.forEach(function(replacedButton, index, theButtons) {
      // if there is a paramter passed in for button text then set the 'value'
      // of the second button (the button dipalyed to user) node to the button
      // text specified.
      // Note: This will replace any value set in the value attribute already!
      if (buttonText) {
        var buttonDisplayed = theButtons[1];
        buttonDisplayed.setAttribute("value",buttonText);
      }
      replacedButton.tabIndex = -1;
      var parentSpan = replacedButton.parentNode;
      var newLink;
      
      var isInternalModalFooter = curam.util.isInternalModal() && curam.util.isModalFooter(replacedButton);

      var buttonId = "btn-id-" + index;
      
      var cssClass = 'ac initially-hidden-widget ' + buttonId;
      if(domClass.contains(replacedButton, "first-action-control")) {
        cssClass += ' first-action-control';
      }
      
      if (isInternalModalFooter) {
    	 // for internal modal render the button using carbon
      	var submitButton = (isCustomSecondaryButton && !hasOnClickFunction) ?  undefined : theButtons[0];

    	// From a handcrafted JSP set the href to blank which will just close the dialog!
    	var buttonJson = isCustomSecondaryButton ?  {"href":"", "buttonid": newbuttonid} : {"buttonid": newbuttonid};
    	var rawDataTestID = replacedButton.getAttribute('data-rawtestid');
    	if (rawDataTestID) {
    	  buttonJson.dataTestId = rawDataTestID;
    	}
    	var isDefaulSubmitButton = domClass.contains(replacedButton, "curam-default-action") ? true : false;
      	curam.util.addCarbonModalButton(buttonJson, replacedButton.value, submitButton, isDefaulSubmitButton);
      } else {
		curam.util.setupWidgetLoadMask("a." + buttonId);
		var cssClass = 'ac initially-hidden-widget ' + buttonId;
	    if(domClass.contains(replacedButton, "first-action-control")) {
	      cssClass += ' first-action-control';
	    }
	
       var newLink = domConstruct.create("a", {
         "class": cssClass,
         href: "#"
       }, replacedButton, "before");

       var pageLevelMenu = dojo.query(".page-level-menu")[0];
       if(pageLevelMenu) {
         attr.set(newLink,"title",replacedButton.value);
       }

       /*
        * Adding filler span to create spacing between buttons. This is needed
        * because if spacing is added to anchor element using CSS, the spacing is
        * still clickable in IE.
        */
        domConstruct.create("span", {
          "class": "filler"
        }, newLink, "before");

        // Adding span elements inside anchor tag to display rounded corners.
        var left = domConstruct.create("span", {
          "class": "left-corner"
        }, newLink);

        var right = domConstruct.create("span", {
          "class": "right-corner"
        }, left);

        // Changed from using inner HTML.
        var middle = domConstruct.create("span", {
        "class": "middle"}, right );

        middle.appendChild(document.createTextNode(replacedButton.value));

        curam.util.addActionControlClass(newLink);
      }
	     

      if (newLink) {
	    on(newLink, "click", function(event) {
	      curam.util.clickButton(this._submitButton);
          dojoEvent.stop(event);
        });
	 
	    /*
        * Record the submit button on the link. This is for modal dialogs, so it
        * can distinguish a submit anchor tag from a normal anchor tag.
        *
        * NB: We have a temporary situation where we have 3 page-level-action
        * sets. 2 actions sets are the existing top and bottom ones, but they are
        * currently hidden. The third is the new button bar at the bottom of the
        * page. This is outside of the HTML form which means the "_submitButton"
        * variable was being set to a button that didn't have an associated form.
        * This caused errors in our modal dialog code. The temporary solution is
            * to set all _submitButtons to the first button found (theButtons[0])
            * which is guaranteed to be inside the form. The real solution
            * is to re-do the new button bar work so it is within the form.
        */
        newLink._submitButton = theButtons[0];
      }
	         

      domClass.add(replacedButton, 'hidden-button');
      attr.set(replacedButton, "aria-hidden", "true");
    
      /* 
       * TODO: ID of the button will be duplicated on the page, as the same 
       * ACTION_CONTROL can appear multiple times on the page. This ID is
       * connected to the ACTION_IDENTIFIER attribute, and causes knock-on
       * effects on buttons in various contexts.
       */
       attr.set(replacedButton, "id", replacedButton.id + "_" + index);
	         
	});

	curam.replacedButtons[name] = "true";
  },
	  
  /**
   * Indicates that the modal is in the internal application.
   */
  isInternalModal: function() {
    return !dojo.global.jsScreenContext.hasContextBits('EXTAPP') && dojo.global.jsScreenContext.hasContextBits('MODAL');
  },
  
  /**
   * Indicates that the modal is in the internal application and that the node is at the higest level in the modal
   * i.e not a hidden input on a form or wtihin a cluster on a modal.
   */
  isModalFooter: function(targetNode) {
	  if (targetNode) {
		var grandParentNode = targetNode.parentNode.parentNode;
		return grandParentNode && grandParentNode.id == "actions-panel";
	  }	
  },
  
  /**
   * Adds a button to modal footer.
   */
  addCarbonModalButton: function(buttonJson, buttonText, submitButton, isDefaultSubmitButton) {
    curam.util.getTopmostWindow().dojo.publish("/curam/CuramCarbonModal/addModalButton", [buttonJson, buttonText, submitButton, isDefaultSubmitButton, window]);
  },
	  

  /**
  * Adds a listener that will display the widget specified by query.
  *
  *  @param query
  *      Query of the widget to setup load mask for.
  */
  setupWidgetLoadMask: function(queryString) {
    curam.util.subscribe('/curam/page/loaded', function() {
        var widget = query(queryString)[0];
      if (widget) {
          style.set(widget, 'visibility', 'visible');

      } else {
        curam.debug.log("setupButtonLoadMask: "
          + debug.getProperty("curam.util.not.found") + "'" + queryString
         + "'" + debug.getProperty("curam.util.ignore.mask"));
      }
    });
  },

  /**
  * Optionaly replaces standard submit buttons within agenda player.
  */
  optReplaceSubmitButton: function(name) {
    if (curam.util.getFrameRoot(dojo.global,"wizard") == null) {
      curam.util.replaceSubmitButton(name);
      return;
    }
    var navigator = curam.util.getFrameRoot(dojo.global,"wizard").navframe.wizardNavigator;
    if (navigator.delegatesSubmit[jsPageID] != 'assumed') {
      curam.util.replaceSubmitButton(name);
    }
  },

  /**
  * Clicks a HTML button.
  *
  * @param buttonObj the button object or the id of the button object.
  */
  clickButton: function(buttonObj) {
      var theForm = dom.byId("mainForm");
    var hiddenButton;

    // if we have no argument, then return
    if (!buttonObj) {
      curam.debug.log("curam.util.clickButton: "
        + debug.getProperty("curam.util..no.arg"));
      return;
    }

    // if the argument is a string, then we assume it is the id of the
    // input element and search for it.
    if (typeof(buttonObj) == "string") {
      var buttonObjID = buttonObj;
      curam.debug.log("curam.util.clickButton: "
        + debug.getProperty("curam.util.searching")
        + debug.getProperty("curam.util.id.of") + "'" + buttonObjID + "'.");
        buttonObj = query("input[id='"  + buttonObjID + "']")[0];
        
        if (!buttonObj) {
          buttonObj = query("input[name='"  + buttonObjID + "']")[0];
        }
        

      // if we still have not found the input element, the return
      if (!buttonObj.form && !buttonObj.id) {
        curam.debug.log("curam.util.clickButton: "
            + debug.getProperty("curam.util.searched")
            + debug.getProperty("curam.util.id.of") + "'" + buttonObjID
            + debug.getProperty("curam.util.exiting"));
        return;
      }
    }

    // In the agenda player search for input elements where the name attribute
    // ends with SUM. This is required because an extra string of SUM is
    // appended onto the end of the name attribute value in the agenda player.
    // For all other submit buttons in the application we'll search for the
    // hidden buttons the normal way to ensure we're not breaking any older
    // functionality.
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      hiddenButton = buttonObj;

      } else {
        hiddenButton = query("input[id='" + buttonObj.id + "']", theForm)[0];
        if (!hiddenButton) {
          hiddenButton = query("input[name='" + buttonObj.name + "']", theForm)[0];
        }
    }
    try {
      // if the page is being submitted to self, publish event to enable
      // code to be run before refresh - used for example for saving list state
      // data to be restored on the page reload
        if (attr.get(theForm, "action").indexOf(jsPageID) == 0) {
        curam.util.publishRefreshEvent();
      }
      hiddenButton.click();

    } catch(e) {
      curam.debug.log(debug.getProperty("curam.util.exception.clicking"));
    }
  },

  /**
   * Handles click event on the page level print button.
   * Invokes the windows print function to print the context panel
   * and main content area.
   *
   * @param event the click event object.
   *
   */
  printPage:function(printContextPanelEnabled, event) {
    dojoEvent.stop(event);
	    
    var mainAreaWindow = dojo.window.get(event.currentTarget.ownerDocument);

    // Only printing the main content area when context
    // panel printing is disabled.
    if (printContextPanelEnabled === false) {
      curam.util._printMainAreaWindow(mainAreaWindow);    
      return false;
    }
    
    var mainAreaIframeNode = mainAreaWindow.frameElement;
    var searchNode = mainAreaIframeNode;

    // find the tab conent holder div which holds each tab.
    while(searchNode && !domClass.contains(searchNode, "tab-content-holder")) {
      searchNode = searchNode.parentNode;
    }

    var tabContentHolderNode = searchNode;

    var contextPanel = dojo.query(".detailsPanelFrame", tabContentHolderNode)[0];
    var hasContextPanel = contextPanel != undefined && contextPanel != null;

    if (hasContextPanel) {
      
      var isIE = has('trident') || has('ie');
      var isEdge = has('edge');
      
      // If a context panel is collapsed in IE11, it will not print due to display: none styling.
      // Instead, the main content area is printed twice. The below code addresses that issue.
      var contextPanelCollapsed = domClass.contains(contextPanel.parentNode, "collapsed");
      
      if (isIE && contextPanelCollapsed) {
        style.set(contextPanel.parentNode, "display", "block");
      }
      contextPanel.contentWindow.focus();
      contextPanel.contentWindow.print();
      
      if (isIE && contextPanelCollapsed) {
        style.set(contextPanel.parentNode, "display", "");
      }
      
      if (isIE || isEdge) {  
        // Give the print dialog time to display
	    setTimeout(function() {
	      if (isEdge) {
	        function printMainAreaWindow() {
	          curam.util._printMainAreaWindow(mainAreaWindow);
	          curam.util.getTopmostWindow().document.body.removeEventListener("mouseover", printMainAreaWindow, true);
	          return false;
	        }
	        // Edge will not trigger the onmouseover event on the browsers top most window until the
	        // context panel print dialog is closed.
	    	curam.util.getTopmostWindow().document.body.addEventListener("mouseover", printMainAreaWindow, true);
	      } else if (isIE) {
	        // Internet Explorer will pause timeout countdown when context panel print dialog is displayed, 
	        // once this dialog is closed the timer will continue and we can print the main content area.  
	        curam.util._printMainAreaWindow(mainAreaWindow);
	        return false;
	      }
	    }, 2000);
      } else {
    	  
        curam.util._printMainAreaWindow(mainAreaWindow);    
        return false;
      }
    } else {
      curam.util._printMainAreaWindow(mainAreaWindow);
      return false;
    }
  },
   
  /**
   * Prints the main Area window.
   */
  _printMainAreaWindow: function(mainAreaWindow){
    var hasDetailsRowExpanded = query(".list-details-row-toggle.expanded");
    if(hasDetailsRowExpanded.length > 0){
 	  curam.util._prepareContentPrint(mainAreaWindow);
 	  mainAreaWindow.focus();
      mainAreaWindow.print();
 	  curam.util._deletePrintVersion();
 	}else{
 	  mainAreaWindow.focus();
      mainAreaWindow.print();
    } 
  },
   
  /**
   * Prepare content to copy the body of iframe inside a wrapper and
   * disable the iframe when the user is printing the page.
   * This method reduce the problem of prints iframes nesting commom 
   * in scenario that involves the expandable list. 
   * In this version,the expandable list that contains context panel is excluded
   */
  _prepareContentPrint: function (baseElement){
    var iframes = Array.prototype.slice.call(baseElement.document.querySelectorAll('body iframe'));
    iframes.forEach(function(iframe) {
	  curam.util._prepareContentPrint(iframe.contentWindow);
	  var list = iframe.contentWindow.document.querySelectorAll('.title-exists');
	  var contextPanels = iframe.contentWindow.document.querySelectorAll('.title-exists div.context-panel-wrapper');		  
      if(list.length > 0 && contextPanels.length === 0){		  
	    var wrapper = document.createElement("div");
	    wrapper.setAttribute("class", "tempContentPanelFrameWrapper");
	    wrapper.innerHTML = list[0].innerHTML;
	    var parentOfIframe = iframe.parentNode;
	    parentOfIframe.parentNode.appendChild(wrapper);
	    parentOfIframe.style.display = 'none';			  
	    
	    curam.util.wrappersMap.push({tempDivWithIframeContent : wrapper, iframeParentElement: parentOfIframe}); 		    
	  } 		  
    });	  
  },
	  
  /**
   * Return the page to the original state. Removes the wrappers
   * and enables the iframes again after the user prints the page.
   */
  _deletePrintVersion: function() {
    if(curam.util.wrappersMap){
 	  curam.util.wrappersMap.forEach(function(wrappers){
 	    wrappers.tempDivWithIframeContent.parentNode.removeChild(wrappers.tempDivWithIframeContent);
 	    wrappers.iframeParentElement.style.display = 'block';
 	  });
 	
 	  curam.util.wrappersMap = [];
    }	
  },
   
  /**
  * Handles onmousedown event on the page toolbar buttons.
  * Adds a class name of selected to allow for CSS selected effect.
  *
  * @param event the click event object.
  *
  */
  addSelectedClass:function(event) {
      domClass.add(event.target,"selected");
  },

  /**
  * Handles onmouseup event on the page toolbar buttons.
  * Removes class name of selected..
  *
  * @param event the click event object.
  *
  */
  removeSelectedClass:function(event) {
      domClass.remove(event.target,"selected");
  },

  /**
  * Opens up the page level help page in new window.
  *
  * @param event the mouse click event.
  * @param event the help tag.
  *
  */
  openHelpPage: function(event, helpUrl){
      dojoEvent.stop(event);
    //opens up the constructed URL in new window.
      dojo.global.open(helpUrl);
  },

  /**
  * Connects the handler to the specified event on the specified object
  * and ensures it is disconnected when the page is unloaded.
  *
  * @param object
  *    The object to connect to.
  * @param eventName
  *    Name of the event to connect to.
  * @param handler
  *    The handler for the event.
  *
  * @return The disconnect token to be used with curam.util.disconnect()
  *    function.
  */
  connect: function(object, eventName, handler) {
    // wrap in another function to allow fixing event before passsing
    // to the handler
    var h = function(event) {
        handler(dojoEvent.fix(event));
    };

      if (has("ie") && has("ie") < 9) {
      object.attachEvent(eventName, h);

        unload.addOnWindowUnload(function() {
        object.detachEvent(eventName, h);
      });

      return { object: object, eventName: eventName, handler: h };

    } else {
        // The dojo/on API takes event names without the "on" prefix.
        var eventNameWithoutOn = eventName;
        if (eventName.indexOf("on") == 0) {
          eventNameWithoutOn = eventName.slice(2);
        }
        var dt = on(object, eventNameWithoutOn, h);

        unload.addOnWindowUnload(function() {
          dt.remove();
      });

      return dt;
    }
  },

  disconnect: function(token) {
      if (has("ie") && has("ie") < 9) {
      token.object.detachEvent(token.eventName, token.handler);
      } else {
        token.remove();
    }
  },

  /**
  * Subscribes the handler to the specified topic in the current runtime
  * context and ensures it is unsubscribed when the page is unloaded.
  *
  * @param topicName
  *    Name of the topic to subscribe to.
  * @param handler
  *    The handler for the topic.
  */
  subscribe: function(topicName, handler) {
      var st = topic.subscribe(topicName, handler);
      unload.addOnWindowUnload(function() {
        st.remove();
    });

    return st;
  },

  unsubscribe: function(token) {
      token.remove();
  },

  /**
  * Retrieves all action controls in action set.
  *
  * @param panelId
  *   ID of action set element.
  */
  addActionControlClickListener:function(panelId){
      var actionsPanel = dom.byId(panelId);
      var actionControlList = query(".ac", actionsPanel);
    if (actionControlList.length > 0) {
      for(var i = 0; i < actionControlList.length; i++) {
        var acNode = actionControlList[i];
        curam.util.addActionControlClass(acNode);
      }
    }
    this._addAccessibilityMarkupInAddressClustersWhenContextIsMissing();
  },

  /**
  * Check on each address cluster on a page for the presence of some context given whether
  * by a title or by the presence of a summary attribute in the uim page for the cluster.
  * If no given context exists on the HTML, one will be added automatically from the properties file.
  */
  _addAccessibilityMarkupInAddressClustersWhenContextIsMissing: function() {
    var clusterContentnDivWrapper = query(".bx--accordion__content");

    clusterContentnDivWrapper.forEach(function(cluster) {
      var addressCluster = query(".bx--address", cluster)[0];
      if (typeof(addressCluster) != 'undefined') {
        var bundle = new resBundle("util");
        var divAddressWrapper = addressCluster.parentElement.parentElement.parentElement;
        var divAddressMainWrapper = divAddressWrapper.parentElement.parentElement;

        // To keep it consistent with the behavior in other clusters, context should also be added automatically when
        // there is only a description present <p> on the cluster.
        var hasAddressHeader = query('h4, h3',divAddressWrapper).length == 1 ? true: false;

        var hasAlreadyAriaLabelValuePickedUpfromUIM = attr.get(divAddressMainWrapper, 'aria-label') !== null ? true: false;
        if (!hasAddressHeader && !hasAlreadyAriaLabelValuePickedUpfromUIM) {
          attr.set(divAddressMainWrapper, 'role', "group");
          attr.set(divAddressMainWrapper, 'aria-label', bundle.getProperty("curam.address.header"));
        }
      }
    });
  },

  /**
  * Adds a CSS class names to modal buttons that have been clicked.
  * This allows specific styling to be applied when buttons in a selected
  * state.
  *
  * @param acNode
  *    Modal action button node
  */
  addActionControlClass:function(acNode){
    curam.util.connect(acNode, "onmousedown",function(){
        domClass.add(acNode, "selected-button");
      curam.util.connect(acNode, "onmouseout",function(){
          domClass.remove(acNode, "selected-button");
      });
    });
  },

  /**
  * Gets all cluster level action sets contained in the content panel.
  *
  */
  getClusterActionSet:function(){
      var contentNode = dom.byId("content");
      var clusterActionSets = query(".blue-action-set", contentNode);
    if (clusterActionSets.length > 0){
      for (var i=0; i<clusterActionSets.length; i++) {
        curam.util.addActionControlClickListener(clusterActionSets[i]);
      }
    }
  },

  /**
  * Adjust Button spacing, if needed, to prevent them overlapping
  */
  adjustActionButtonWidth:function() {
      if (has("ie") == 8) {
        ready(function() {
          if (dojo.global.jsScreenContext.hasContextBits('MODAL')) {
            query(".action-set > a").forEach(function(node) {
            if(node.childNodes[0].offsetWidth > node.offsetWidth) {
                style.set(node, "width", node.childNodes[0].offsetWidth + "px");
                style.set(node, "display", "block");
                style.set(node, "display", "inline-block");
            }
          });
        }
      });
    }
  },

  /**
  * Sets the '__o3rpu' parameter for the URL. This parameter is an enocoded
  * value and holds the requesting URL and its parameters. This function may add
  * additonal parameters to the requesting URL prior to encoding it.
  *
  * @param {String} url
  *     The requested URL
  * @param {curam.util.RuntimeContext} rtc
  *     RunTimeContext Object - provides access to Window object.
  * @param {Array} [extraParaArray]
  *     An optional array of extra parametes to be added to the requesting URL.
  *     The expected array structure is
  *     [{key:"x1",value:"y1"},{key:"x2",value:"y2"},...]
  * @return The requested URL with the '__o3rpu' parameter appended.
  */
  setRpu:function(url, rtc, /*optional*/ extraParaArray){
    //Throw exception if null/blank values passed in
    if(!url||!rtc||!rtc.getHref()){
      throw {
        name:"Unexpected values",
        message:"This value not allowed for url or rtc"
      };
    }

    var o3rpuValue = curam.util.getLastPathSegmentWithQueryString(rtc.getHref());

    // strip the __o3rpu parameter from the RPU value
    o3rpuValue = curam.util.removeUrlParam(o3rpuValue, curam.util.Constants.RETURN_PAGE_PARAM);

    //Check for extra parameters passed in as {key:"",value:""} format
    if(extraParaArray){
      var i;
      for(i = 0; i < extraParaArray.length; i++) {
        if(!extraParaArray[i].key||!extraParaArray[i].value){
          throw {
            name:"undefined value error",
            message:"The object did not contain a valid key/value pair"
          };
        }
        o3rpuValue = curam.util.replaceUrlParam(o3rpuValue,
        extraParaArray[i].key, extraParaArray[i].value);
      }
    }
    var returnUrl = curam.util.replaceUrlParam(url, curam.util.Constants.RETURN_PAGE_PARAM, encodeURIComponent(o3rpuValue));
    curam.debug.log("curam.util.setRpu "
      + debug.getProperty("curam.util.added.rpu") + returnUrl);
    return returnUrl;
    },

    /**
     * Retrieves the base URL from the location.href property associated with
     * the current DOM Window object.
     * <p>
     * The base URL is the contents of the URL up as far, and including, the
     * application name.
     * <p>
     * For example, if the value of location.href was
     * "http://philippa:9080/TabTest/AppController.do" then the value returned
     * would be "http://philippa:9080/TabTest"
     *
     * @return the base URL or null if the URL cannot be retrieved.
     *
     */
    retrieveBaseURL: function() {
      //The regular expression will match a path of the form
      //[protocol]://[domain]/[name]. Where [protocol] can be any character
      //e.g. http. Where [domain] can be any character except for
      //the forward slash character e.g. www.curamsoftware.com. Where [name] can
      //be any character except for the forward slash character e.g. Curam.
      return dojo.global.location.href.match(".*://[^/]*/[^/]*");
    },

    removeRoleRegion:function(){
      var body = dojo.query("body")[0];
      attr.remove(body, "role");
    },

    /*
     * Function for iframe title fall back.
     * If PAGE_TITLE isn't specified in the UIM, this function takes care
     * of falling back to the navigation tab title or the application tab.
     */
    iframeTitleFallBack: function(){
      var currentiframe = curam.tab.getContainerTab(curam.tab.getContentPanelIframe());

      var iframe = dom.byId(curam.tab.getContentPanelIframe());
      var pageTitle = iframe.contentWindow.document.title;

      var currentAppTab = dojo.query("div.nowrapTabStrip.dijitTabContainerTop-tabs > div.dijitTabChecked.dijitChecked")[0];
      var currentAppTabName = dojo.query("span.tabLabel", currentAppTab)[0];

      var currentNavTab = dojo.query("div.nowrapTabStrip.dijitTabNoLayout > div.dijitTabChecked.dijitChecked", currentiframe.domNode)[0];
      var currentNavTabName = dojo.query("span.tabLabel", currentNavTab)[0];

      if(pageTitle=="undefined"){
          return this.getPageTitleOnContentPanel();
      } else if(pageTitle && pageTitle!=''){
        return pageTitle;
      } else if (currentNavTab){
          return currentNavTabName.innerHTML;
      } else {
          return currentAppTabName.innerHTML;
      }
    },
    
    /**
     * Function to return the page title from the content panel. 
     * This is for the edge case, where there is in-page-navigation
     * on a UIM page, and the current page title needs to be updated
     * after the content has been put into DOM.
     *
     * @return page title on content panel.
     */
    getPageTitleOnContentPanel: function() {
        
        // Page title on content panel
        var contentPanelPageTitle;
        var iframe = dojo.query("div.dijitVisible div.dijitVisible iframe.contentPanelFrame");
        var iframeDoc;
        if(iframe && iframe.length == 1) {
          iframeDoc = iframe[0].contentWindow.document;
          windowBase.withDoc(iframeDoc, function() {
            var header = dojo.query("div.title h2 span:not(.hidden)");
            if(header && header.length == 1 && header[0].textContent) {
                contentPanelPageTitle = lang.trim(header[0].textContent);
            } 
          }, this);
        } 
        
        if(contentPanelPageTitle) {
         return contentPanelPageTitle;
        }else {
          return undefined;
        }
    },

    /**
     * Function to add a specific class to the last visible node (cluster, list
     * or action set) in the page content area. It only works specifically in
     * the external application.
     *
     * @return There's no return value of this function.
     */
    addClassToLastNodeInContentArea: function() {
      var divNodes = query("> div", "content");
      var divNodesCount = divNodes.length;

      if (divNodesCount == 0) {
        return "No need to add";
      }

      var lastNode = divNodes[--divNodesCount];

      while (domClass.contains(lastNode, "hidden-action-set") && lastNode) {
        lastNode = divNodes[--divNodesCount];
      }

      domClass.add(lastNode, "last-node");

    },

    /*
     * Function to check Highcontrast mode
     * If High contrast mode is turned on the method checks the class name
     * high-contrast on body element.
     */
    highContrastModeType: function(){
      var highContrastMode = dojo.query("body.high-contrast")[0];
      return highContrastMode;
    },

    /**
     * Function to check RTL (right-to-left) mode.
     * Checks for class name 'rtl' on body element to see if RTL mode is turned
     * on.
     */
    isRtlMode: function() {
      var rtlMode = dojo.query("body.rtl")[0];
      return rtlMode;
    },

    processBidiContextual: function (target){
      target.dir = bidi.prototype._checkContextual(target.value);
    },

    getCookie: function(name) {
      var dc=document.cookie;
      var prefix=name+"=";
      var begin=dc.indexOf("; "+prefix);
      if(begin==-1) {
        begin=dc.indexOf(prefix);
        if(begin!=0)
          return null;
        } else {
          begin+=2;
        }
        var end=document.cookie.indexOf(";",begin);
        if(end==-1) {
          end=dc.length;
        }
      return unescape(dc.substring(begin+prefix.length,end));
    },

    getHeadingTitleForScreenReader: function(landmarkTitle) {
      var topWin = curam.util.getTopmostWindow();
      var tabTitle = topWin.dojo.global._tabTitle;

      if (tabTitle) {
        curam.util.getHeadingTitle(tabTitle, landmarkTitle);
      } else {
        var tabTitleSubscription = topWin.dojo.subscribe("/curam/_tabTitle", function(tabTitleFromPublish) {
                  if(tabTitleFromPublish) {
            curam.util.getHeadingTitle(tabTitleFromPublish, landmarkTitle);
                  }
          topWin.dojo.unsubscribe(tabTitleSubscription);
        });
      }
    },

    getHeadingTitle: function(tabTitle, landmarkTitle) {
      var headingTitle = undefined;

      if (tabTitle && tabTitle.length > 0) {
        headingTitle = tabTitle;
      } else {
        headingTitle = landmarkTitle;
      }

      var pageTitleBar = dojo.query(".page-title-bar");
      var mainContentPageHeading = dojo.query("div h2", pageTitleBar[0]);

      // h2 heading
      if (mainContentPageHeading) {
        var childrenSpan = dojo.query("span",mainContentPageHeading[0]);
        var span = undefined;
        if (childrenSpan) {
          span = childrenSpan[0];
        }
        if (!span || (span && (span.innerHTML.length == 0))) {
          if (span) {
            attr.set(span, "class", "hidden");
            attr.set(span, "title", headingTitle);
            span.innerHTML= headingTitle;
          } else {
            span = domConstruct.create("span", {"class" : "hidden", "title": headingTitle}, mainContentPageHeading[0]);
            span.innerHTML = headingTitle;
          }
        }
      }
    },

    /**
     * Sets up the browser tab title data for later use by the
     * curam.util.setBrowserTabTitle method.
     * 
     * @param {String} tabTitle
     *     the static tab title taken from CDEJResource.properties
     *     'browser.tab.title' property
     * @param {String} separator
     *     the separator to use between the application title and context
     *     strings
     * @param {Boolean} appNameFirst
     *     <code>true</code> if the application name should come before the
     *     context, <code>false</code> otherwise
     */
    _setupBrowserTabTitle: function(staticTabTitle, separator, appNameFirst) {
      // Convert newlines to spaces as newlines are allowed in banner title but
      // not in browser tab title
      staticTabTitle = staticTabTitle.replace("\\n", " ");

      curam.util._browserTabTitleData.staticTabTitle = staticTabTitle;
      curam.util._browserTabTitleData.separator = separator;
      curam.util._browserTabTitleData.appNameFirst = appNameFirst;
    },

    /**
     * Stores the browser tab title data.
     */
    _browserTabTitleData: {},

    /**
     * Sets the browser tab title to the given value plus the static title, or,
     * if no value is given, attempt to find an appropriate title from the page
     * layout.
     * <p>
     * Example: "Register Person - IBM Curam Social Program Management"
     * <p>
     * The value is found using the following logic:
     * <ol>
     * <li>Page Title on Content Panel
     * <li>If no page title on CPanel, then get title from page navigation group
     * <li>If no page navigation group title then use title from navigation tab bar
     * <li>If no page title on context panel then use title on application tab bar
     * <li>If no title on application tab then use title on Section
     * </ol>
     *
     * @param {String} [title]
     *         Optional title to use for the page. If a title value is not
     *         given, the function attempts to select an appropriate title from
     *         the information on the page.
     *
     * @return No return value.
     */
    setBrowserTabTitle: function(/*optional*/title) {
      curam.debug.log("curam.util.setBrowserTabTitle(title = " + title + ") called");
      // If no title given then try to find an appropriate title on the page
      if(!title) {
        title = curam.util._findAppropriateDynamicTitle();
      }

      var staticTitle = curam.util._browserTabTitleData.staticTabTitle;
      var separator = curam.util._browserTabTitleData.separator;
      var appNameFirst = curam.util._browserTabTitleData.appNameFirst;

      if (!staticTitle && !separator && !appNameFirst && !title) {
        /**
         * When setBrowserTabTitle is called from a nested page, the curam.util._browserTabTitleData 
         * may not contain staticTabTitle, separator and appNameFirst. In this particolar scenario, 
         * set document.title as the page title.
         */
        
        var headTitle = document.querySelectorAll("head title")[0];
        if (headTitle) {
          document.title = headTitle.text;
        }
    }else if (!title) {
      // If no title given or found, then just use the static title on its own
      document.title = staticTitle; 
      } else {
        if(staticTitle) {
          if(appNameFirst) {
            // Display "Title - Context"
            document.title = staticTitle + separator + title;
          } else {
            // Display "Context - Title"
            document.title = title + separator + staticTitle;
          }
        }
      }
    },
    
    /**
     * Function that handles the toggle event for the Checkboxed Multi Select Renderer
     * 
     * @param e - The checkbox element. 
     * @param div - The Select div (row).
     */
    toggleCheckboxedSelectStyle: function(e, div){ 
      if(e.checked){
	    div.classList.remove('unchecked');
		div.classList.add('checked');
      }else{
	    div.classList.remove('checked'); 
		div.classList.add('unchecked');
      }
    },

    /**
     * Searches the DOM for an approriate string to use as the browser tab
     * title. The value is selected using the following logic:
     * <ol>
     * <li>When a popup window closes, get title from the modal
     * from which it was opened
     * <li>Page Title on Content Panel
     * <li>If no page title on CPanel, then get title from page navigation group
     * <li>If no page navigation group title then use title from navigation tab bar
     * <li>If no page title on context panel then use title on application tab bar
     * <li>If no title on application tab then use title on Section
     * </ol>
     *
     * @return a string to use for the browser tab title chosen by the above
     *         logic, or <code>undefined</code> if nothing could be found.
     */
    _findAppropriateDynamicTitle: function() {
      var i; // Index used for various loops
      
      // 1. When closing a modal or popup widget, relay modal and popup widget titles to browser tab
      var one;
      var numberOfActiveModals = dojo.query("iframe.curam-active-modal").length;
      if (numberOfActiveModals > 1) {
    	// If numberOfActiveModals > 1 we are closing a modal dialog or popup widget and falling back to
    	// to a modal dialog or popup widget.
        var iFrameContainingTheTitleWeWant = dojo.query("iframe.curam-active-modal")[0];
        if (iFrameContainingTheTitleWeWant) {
	      var iFrameContainingTheTitleWeWantDoc = iFrameContainingTheTitleWeWant.contentDocument;
	      if (iFrameContainingTheTitleWeWantDoc) {
	        var iFrameContainingTheTitleWeWantDocHeadTitle = 
	          iFrameContainingTheTitleWeWantDoc.head.getElementsByTagName("title")[0];
	        if (iFrameContainingTheTitleWeWantDocHeadTitle) {
	          if (iFrameContainingTheTitleWeWantDocHeadTitle.innerHTML != '') {
	            one = iFrameContainingTheTitleWeWant.contentDocument.head.getElementsByTagName("title")[0].innerHTML;
	  		  }  
	        }  
	      }
        }
      }
      
      if(one) {
        return one;
      }

      // 2. Page title on content panel
      var two;
      var iframe = dojo.query("div.dijitVisible div.dijitVisible iframe.contentPanelFrame");
      var iframeDoc;
      if(iframe && iframe.length == 1) {
        iframeDoc = iframe[0].contentWindow.document;
        windowBase.withDoc(iframeDoc, function() {
          var header = dojo.query("div.title h2 span:not(.hidden)");
          var errorMessages = dom.byId("error-messages", iframeDoc);
          if(errorMessages) {
            two = iframeDoc.head.getElementsByTagName('title')[0].textContent;
          } else if(header && header.length == 1 && header[0].textContent) {
            two = lang.trim(header[0].textContent);
            curam.debug.log("(2) Page title for Content Panel = " + two);
          } else if(header && header.length > 1) { // Special case for sub-titles
            two = this._checkForSubTitles(header);
          } else {
            curam.debug.log("(2) Could not find page title for content panel: header = " + header);
          }
        }, this);
      } else {
        curam.debug.log("(2) Could not find iframeDoc for content panel: iframe = " + iframe);
      }

      if(two) {
        return two;
      }

      // 3. Selected navigation item title
      var three;
      var navItem = dojo.query("div.dijitVisible div.dijitVisible div.dijitVisible div.child-nav-items li.selected > div.link");
      if(navItem && navItem.length == 1 && navItem[0].textContent) {
        three = lang.trim(navItem[0].textContent);
        curam.debug.log("(3) Selected navigation item = " + three);
      } else {
        curam.debug.log("(3) Could not find selected navigation item: navItem = " + navItem);
      }

      if(three) {
        return three;
      }

      // 4. Navigation bar tab title
      var four;
      var allNavTabs = dojo.query("div.dijitVisible div.dijitVisible div.navigation-bar-tabs span.tabLabel");
      var selectedNavTab;
      for(i = 0; i < allNavTabs.length; i++) {
        if(allNavTabs[i].getAttribute("aria-selected") === "true") {
          selectedNavTab = allNavTabs[i];
        }
      }
      if(selectedNavTab && selectedNavTab.textContent) {
    	four = lang.trim(selectedNavTab.textContent);
        curam.debug.log("(4) Selected navigation bar tab = " + four);
      } else {
        curam.debug.log("(4) Could not find selected navigation bar tab: selectedNavTab = " + selectedNavTab);
      }

      if(four) {
        return four;
      }

      // 5. Application tab title bar
      var five;
      var appTabTitleBar = dojo.query("div.dijitVisible div.dijitVisible h1.detailsTitleText");
      if(appTabTitleBar && appTabTitleBar.length == 1 && appTabTitleBar[0].textContent) {
    	five = lang.trim(appTabTitleBar[0].textContent);
        curam.debug.log("(5) Selected application tab title bar = " + five);
      } else {
        curam.debug.log("(5) Could not find selected application tab title bar: appTabTitleBar = " + appTabTitleBar);
      }

      if(five) {
        return five;
      }

      // 6. Section title
      var six;
      var sections = dojo.query("div.dijitTabInnerDiv div.dijitTabContent div span.tabLabel");
      var selectedSection;
      for(i = 0; i < sections.length; i++) {
        if(sections[i].getAttribute("aria-selected") === "true") {
          selectedSection = sections[i];
          break;
        }
      }
      if(selectedSection && selectedSection.textContent) {
    	six = lang.trim(selectedSection.textContent);
        curam.debug.log("(6) Selected section title = " + six);
      } else {
        curam.debug.log("(6) Could not find selected section title: sections = " + sections);
      }

      if(six) {
        return six;
      }

      // 7. UIM pages in external application (for when curam.ModalDialog._modalClosedHandler gets called in that context.)
      var seven;
      iframe = dom.byId('curamUAIframe');
      if(iframe && iframe.contentWindow && iframe.contentWindow.document) {
        iframeDoc = iframe.contentWindow.document;
        windowBase.withDoc(iframeDoc, function() {
          var uimPageTitle = dojo.query('div.page-header > div.page-title-bar > div.title > h2 > span');
          if(uimPageTitle && uimPageTitle.length == 1 && uimPageTitle[0].textContent) {
        	seven = lang.trim(uimPageTitle[0].textContent);
            curam.debug.log("(7) UIM page title for external application page = " + seven);
          } else {
            curam.debug.log("(7) Could not find UIM page title for external application page: uimPageTitle = " + uimPageTitle);
          }
        }, this);
      }

      if(seven) {
        return seven;
      }

      return undefined;
    },

    /**
     * Checks the given array of elements consists of a valid header and
     * sub-titles. This is for when the PAGE_TITLE element contains multiple
     * CONNECT elements.
     * 
     * The first header only needs to have a textContent child. The second and
     * subsequent headers need a textContent child and to have the class
     * 'sub-title'.
     * 
     * @param {Array} header The array of HTML elements returned by dojo.query.
     * @return a string to use for the browser tab title created from the given
     *         header and sub-titles, or <code>undefined</code> if the array
     *         did not meet the criteria described above.
     */
    _checkForSubTitles: function(header) {
      var i; // Index used for various loops

      // Check first item has a textContet attribute 
      if(!header[0].textContent) {
        return undefined;
      }
      // Check all attributes except the first one have a "sub-title" class and .textContent attribute
      for(i = 1; i < header.length; i++) {
        var clazz = header[i].getAttribute('class'); 
        if(clazz.indexOf('sub-title') === -1 || !header[i].textContent) {
          curam.debug.log("(1) Failed to construct title from content panel page title. Not all header element spans had 'sub-title' class.");
          for(i = 0; i < header.length; i++) {
            curam.debug.log(header[i]);
          }
          return undefined;
        }
      }
      // All elements are valid sub-titles, so concatenate textContent values
      var ret = header[0].textContent;
      for(i = 1; i < header.length; i++) {
        ret += header[i].textContent;
      }
      return ret;
    },

    /**
     * This function adds the necessary context to a widget for accessibility concerns.
     *
     * The closest cluster above the current widget holding a title of type <h3> is used to give context to
     * the widget. If the cluster just above the widget does not have a title it looks for
     * the a cluster above and so on until a title is found.
     * If not tile is found, no accessibility feature is applied.
     *
     * @param {String} widgetId The id of the widget to add context to.
     */
    _addContextToWidgetForScreenReader: function(widgetId) {
      var found = false;
      var index = 0;
      var trainingDetailsListClusterWrapper = dojo.query(".training-details-list");

      if (trainingDetailsListClusterWrapper.length == 1) {
        var trainingDetailsListClusterWrapperParentElement = trainingDetailsListClusterWrapper[0].parentElement;
        var clusterChildrenList = dojo.query("div.bx--cluster", trainingDetailsListClusterWrapperParentElement);
        var currentIndexOfTheClusterInTheListForTheWidget = Array.prototype.indexOf.call(clusterChildrenList, trainingDetailsListClusterWrapper[0]);

        if (currentIndexOfTheClusterInTheListForTheWidget >= 0) {
          //We want to find the closest cluster with a title - hence starting from the index of the widget cluster and checking on the clusters above.
          for (var i = currentIndexOfTheClusterInTheListForTheWidget; i >= 0; i--) {
            if (dojo.query("h3", clusterChildrenList[i]).length == 1) {
              found = true;
              index = i;
              break;
            }
          }
        }

        if (found) {
          var closestClusterWithATitle = dojo.query("h3.bx--accordion__title", clusterChildrenList[index]);
          if (closestClusterWithATitle.length == 1) {
            //Define an id for the closest cluster element containing the title to be used as context for the widget.
            var idForTheClosestClusterWithATitle = closestClusterWithATitle[0].className + "_id";
            attr.set(closestClusterWithATitle[0], "id", idForTheClosestClusterWithATitle);
            //Set the widget itself with the appropriate accessibility features.
            var widgetDivWrapper = dojo.byId(widgetId).parentElement;
            attr.set(widgetDivWrapper, "aria-labelledby", idForTheClosestClusterWithATitle);
            attr.set(widgetDivWrapper, "role", "region");
          }
        }
      }
    },

    /**
     * Set the focus on the parent active iframe.
     * @param {window} [child] If specified, the dialog hierarchy will be used
     * to look up the parent window.
     */
    setParentFocusByChild : function(childID){
      var win = curam.util.UimDialog._getDialogFrameWindow(childID);

      if(win){
         var parentWindow = curam.dialog.getParentWindow(win); 
         if(parentWindow){
            parentWindow.focus();
         }
      }   
    },
    /**
     * Copies the value to system clipboard if the access
     * is configured; passes the value through the Word Integration channel if called
     * as part of Appeals Clause functionality. 
     */
    toClipboard: function(valueToCopy){
      try {
        navigator.clipboard.writeText(valueToCopy);
      } catch (err) {
        console.warn("Failed to copy into the clipboard.");
      }
      if (dojo.getObject('curam.dialog', false) != null) {
        var pw = curam.dialog.getParentWindow(window);
        pw && pw.dojo.publish('/curam/clip/selected', [valueToCopy]);
      }
      return false;
    },
    /**
     * Set to zero the scrollTop in ios devices.
     */
    removeTopScrollForIos: function(){
    	if(has("ios")){
    		window.document.body.scrollTop=0;
    	}
    },
    
    /**
     * Insert aria-live attribute in the span that contains the record of items. 
     * The span content is updated with text containing the amount of records 
     * returned so screen reader reads it when the screen is loaded.
     */
	insertAriaLiveLabelRecordSearchItem: function (numSearchResultsText){
        var span = dojo.query("[data-search-page]")[0];
        if(span) {
          span.setAttribute("aria-live", has('ios') ? "polite" : "assertive");
          // When DOM has loaded, update text after a short delay to trigger
          // screen reader to announce new text.
          setTimeout(function() {
            var currentSearchResultText = span.firstChild.nodeValue;
            var numSearchResultsTextOutput = currentSearchResultText + numSearchResultsText;
            span.innerHTML = numSearchResultsTextOutput;
          }, 10);
        }
    },
    
    /**
     * Remove a session property from the session storage.
     */
    removeSessionStorageProperty: function (propertyName){
        sessionStorage.removeItem(propertyName);
    },
    
    /**
     * This method is invoked from method render() from DateTimeEditRenderer.java
     * when a date time widget field is rendered onto a page. A css class style of 
     * "date-time-exists" is added to the <tr> element containing this widget.
     */
    addLayoutStylingOnDateTimeWidgetOnZoom: function (){
      
      var dateTimeTables = dojo.query("table.input-cluster td.field table.date-time");
      console.log("datetimetable from util.js: "+dateTimeTables);
      var dateTimeTableCount = dateTimeTables.length;
      
      if(dateTimeTables.length >0){
        for (var i=0;i<dateTimeTables.length;i++) {
          
          var dateTimeTable = dateTimeTables[i];
          var tableRow = dateTimeTable.parentNode.parentNode;
          tableRow.setAttribute("class", "date-time-exists");
        }
      }
    },
    
    /**
     * This method is used in FileUploadTag.java to cause the file
     * browser to open and allow the uploading of files to C?ram.
     * We only want to open the file browser on a 'space' or 'enter'
     * key press.
     */
    fileUploadOpenFileBrowser: function(e, elementId) {
    	if (e.keyCode == 32 || e.keyCode == 13) {
    		dom.byId(elementId).click();
    	}
    },
    
    /**
     * Invoked upon each page load to optionally set up lists
     * on a page so that the list selection controls are
     * initialized and updated with the correct text for
     * the screen readers.
     * Relies on the presence of the JavaScript objects
     * output for lists by the tag infrastructure and
     * JSP generator.
     */
    setupControlledLists: function() {
      var crtlPath = 'curam.listControls',
         togglerPath = 'curam.listTogglers';
      var crtlsStorage = getFrom(crtlPath),
            togglers = getFrom(togglerPath),
              lists = [];
      var batchQuery = crtlsStorage && query('*[data-control]'),
          togglerQuery = togglers && query('a[data-toggler]');
      if (crtlsStorage || togglers) { //no lists = no update 
        for (var listId in crtlsStorage) {
          batchQuery.filter(function(item) {
            return attr.get(item, 'data-control') == listId;
          }).forEach(function(listCrtl, ix) {
            var c = dom.byId(listCrtl),
              tr = query(listCrtl).closest('tr')[0];
              !tr.controls && (tr.controls = new Array());
              tr.controls.push(c);
              // do not add the same row twice
              if (!tr.visited) {
                tr.visited = true;
            	crtlsStorage[listId].push(tr);
              }
          });
          var cBuildUp = getFrom(crtlPath + '.' + listId);
          if (cBuildUp && cBuildUp.length && cBuildUp.length > 0) {
            lists.push(listId);
          } else {
            putTo(crtlPath + '.' + listId, false);//blanking out
          }
    	}
        if (togglerQuery && togglerQuery.length > 0) {
          for (var listId in togglers) {
            togglerQuery.filter(function(item) {
              return attr.get(item, 'data-toggler') == listId;
            }).forEach(function(listToggler) {
              var tr = query(listToggler).closest('tr')[0];
              tr.hasToggler = listToggler;
              tr.visited = true;
              togglers[listId].push(tr);
            });
            var tBuildUp = getFrom(togglerPath + '.' + listId);
            if (tBuildUp && tBuildUp.length && tBuildUp.length > 0) {
              (lists.indexOf(listId) == -1) && lists.push(listId);
            } else {
               putTo(togglerPath + '.' + listId, false); //blanking out
            }
          }
    	}
        lists.forEach(function(listId){
          var updateArray = getFrom(crtlPath + '.' + listId)
                             || getFrom(togglerPath + '.' + listId);
          cu.updateListControlReadings(listId, updateArray);      	
        });
      }
      dojo.subscribe("curam/sort/earlyAware", function(listId) {
        cu.suppressPaginationUpdate = listId;
      });
      dojo.subscribe('curam/update/readings/sort', function(listId, rows) {
    	if (!has('trident')) {
    	  cu.updateListActionReadings(listId);
          cu.updateListControlReadings(listId, rows);
          cu.suppressPaginationUpdate = false;
        } else {
      	  var pageBreak = cu.getPageBreak(listId),
	          limit = Math.ceil(rows.length/pageBreak);
	      cu.listRangeUpdate(0, limit, listId, rows, pageBreak);
        }
      });
      dojo.subscribe('curam/update/readings/pagination', function(listId, newPageSize) {
        putTo('curam.pageBreak.' + listId, newPageSize); // set for the subsequent sorts
      });
      dojo.subscribe('curam/update/pagination/rows', function(newRows, listId) {
        // this will cancel the gradual update process in IE only
    	cu.updateDeferred && !cu.updateDeferred.isResolved()
    	                     && cu.updateDeferred.cancel('Superseeded');
    	if (cu.suppressPaginationUpdate && cu.suppressPaginationUpdate == listId) {
          return; //do not attempt multiple updates
        }
        var hasTogglers = isHere('curam.listTogglers.' + listId),
                hasControls = isHere('curam.listControls.' + listId),
                  lms = getFrom('curam.listMenus.' + listId),
                    hasMenus = lms && (lms.length > 0);
        var needsStaticUpdate = hasControls || hasTogglers;
        if (!needsStaticUpdate && !hasMenus) return;
        if (needsStaticUpdate) {
          var nvRows = newRows.filter(function(aRow) {
            return (!aRow.visited || !aRow.done)
               && attr.has(aRow, 'data-lix');
          });
          hasTogglers && nvRows.forEach(function(aRow){
            var tgl = query('a[data-toggler]', aRow)[0];
            aRow.hasToggler = tgl;
            aRow.visited = true;
            curam.listTogglers[listId].push(aRow);
          });
          hasControls && nvRows.forEach(function(aRow){
            var crtlRefs = query('*[data-control]', aRow),
                  storage = new Array();
            crtlRefs.forEach(function(cRef){
              storage.push(dom.byId(cRef));
            });
            aRow.controls = storage;
            curam.listControls[listId].push(aRow);
            aRow.visited = true;
          });
          var updateArray = hasControls
        	            ? curam.listControls[listId]
                        : curam.listTogglers[listId];
          cu.updateListControlReadings(listId, updateArray);
        }
        hasMenus && cu.updateListActionReadings(listId);
      });
    },
    /**
     * Updates big list accessibility readings in parts equal to the
     * current page size, asynchronously and with delay to unlock
     * a page with list for interaction as quickly as possible.
     * Applies to IE11 only since this ancient browser is not capable
     * of reasonable updating otherwise.
     *
     * @param rangeNum the number of list range to be updated in this batch. 
     * @param limit the rage number limit to stop the updater.
     * @param listId the identifier of the list updatye applies to.
     * @param rows the full array containing row objects to be updated.
     * @param psz the current size of the paginated list.
     */
    listRangeUpdate: function(rangeNum, limit, listId, rows, psz) {
      if (rangeNum == limit) {
        cu.suppressPaginationUpdate = false;
        cu.updateDeferred = null;
        return;
      }
      var def = cu.updateDeferred = new Deferred(function(reason) {
        cu.suppressPaginationUpdate = false;
        cu.updateDeferred = null;
      });
      def.then(function(pNum) { cu.listRangeUpdate(pNum, limit, listId, rows, psz) },
    		  function(err) {/* swallow silently,it is cancellation*/});
      // additional delay for the invisible updates.
      var delay = (rangeNum === 0) ? 0 : 200;
      setTimeout(function() {
        var newNum = rangeNum+1, range = [rangeNum*psz, (newNum*psz)];
        cu.updateListActionReadings(listId, range);        
        cu.updateListControlReadings(listId, rows, range);       
        def.resolve(newNum);
      }, delay);
    },

    /**
     * Updates the screen reader texts for the list selection controls (links,
     * radio buttons, row toggle controls) depending on the current row number.
     * Relies on the additional markup output for the rows and lists.
     * 
     * @param listId optional list identifier to apply the update method to.
     * @param rowArray the array of list row objects to traverse.
     * @param suppressFocus indicates that no focus manipulation is needed
     *                      upon update completion.
     * @param range an optional array of two numbers specifying the part of
     * the rowArray to be updated
     *                      
     *                      
     */
    updateListControlReadings: function(listId, rowArray, range) {
      var c0, psz = cu.getPageBreak(listId),
        startAt = cu.getStartShift(listId, rowArray[0] || false),
        portion = rowArray;
      range && (portion = rowArray.slice(range[0], range[1]));
      for (var rix in portion) {
        var aRow = portion[rix],
            lixAttr = parseInt(attr.get(aRow, ROW_IDX)),
              lx = (lixAttr % psz) + startAt,
                crtls = aRow.controls;
        if(!crtls){ //check for controls
        	var crtlRefs = query('*[data-control]', aRow),
            storage = new Array();
      		crtlRefs.forEach(function(cRef){
        		storage.push(dom.byId(cRef));
      		});
      		aRow.controls = storage;
      		crtls = aRow.controls;
        }
        
        if (crtls) { /* a row can contain multiple controls in an array */
      	  for (var cix in crtls) {
      	    var crtl = crtls[cix],
      	      /* links have textContent, single selects do not */
      	      ttl = crtl.textContent || false,
      	        linkPrefixed = ttl ? ttl + ',' : '';  
      	    if (crtl.nodeName == 'A') {
              var imageElement = query("img",crtl)[0];
              if (imageElement && domClass.contains(crtl,"ac first-action-control external-link")) {
                var linkName = attr.get(imageElement,"alt");
                attr.set(crtl, READOUT,
                  linkName + "," + [listcontrol.reading.anchors, lx].join(' '));
              } else {
                attr.set(crtl, READOUT,
                  linkPrefixed + [listcontrol.reading.anchors, lx].join(' '));
              }
        	} else {
        	  attr.set(crtl, READOUT,
        	    linkPrefixed + [listcontrol.reading.selectors, lx].join(' '));
            }
      	  }
        }
        cu.updateToggler(aRow, lx);
        aRow.done = true;
      }
    },
    /**
     * Initializes the list action menus which are subject to the accessibility
     * readings update. Each such menu upon startup registers itself
     * in the dedicated array for quick access when updating when sorting or
     * paginating a list.
     * 
     * @param listId the identifier of the list being updated.
     */
    initListActionReadings: function(listId) {
      var actionsPath = 'curam.listMenus.' + listId; 
      putTo(actionsPath,[]);
      dojo.subscribe('curam/listmenu/started', function(widget, listId){
    	   var tr = query(widget.containerNode).closest('tr')[0],
    	     lix = parseInt(attr.get(tr, ROW_IDX)),
    	       lx = (lix % cu.getPageBreak(listId)) + cu.getStartShift(listId, tr);
    	widget.set({'belongsTo' : tr,
    		        'aria-labelledBy':'',
    		        'aria-label' : [listcontrol.reading.menus, lx].join(' ')});
    	getFrom(actionsPath).push(widget);
    	cu.updateToggler(tr, lx);
      });
    },
    /**
     * Updates toggle control in an expandable list row.
     * This can be initiated either dynamically when a list action menu
     * lazily initializes, or upon regular update where no dynamic controls
     * are present in a list.
     * 
     * @scanRow the row to be checked for toggle control.
     * @relLix the number to use for the toggling control accessibility reading.
     */
    updateToggler: function(scanRow, relLix) {
      scanRow.hasToggler
        && attr.set(scanRow.hasToggler, READOUT,
              [listcontrol.reading.togglers, relLix].join(' '));
    },
    /**
     * Called to update the list actions menu accessibility readings.
     * Used the initialized menu widget array where each of the them
     * stores the associated row reference.
     * 
     * @param listId the identifier of the list being updated.
     * @param range optional array specifying the range of list menus
     * to be updated; if absent the full range is subject to update.
     */
    updateListActionReadings: function(listId, range) {
      var menus = getFrom('curam.listMenus.' + listId),
        psz = cu.getPageBreak(listId), startAt = false,
          portion = menus;
      range && (portion = menus.slice(range[0], range[1]));
      for (var ix in portion) {
        var widget = portion[ix], tr = widget.belongsTo,
            lix = parseInt(attr.get(tr, ROW_IDX)),
              startAt = startAt || cu.getStartShift(listId, tr),
                 finalLix = (lix % psz) + startAt;
        widget.set(READOUT,
         	   [listcontrol.reading.menus, finalLix].join(' '));
        cu.updateToggler(tr, finalLix);
        tr.done = true;
      }
    },
    /**
     * Returns the current page size of a paginated list.
     * 1000 is returned for not paginated lists to exceed
     * any potential list page size.
     * This is used for the accessibility readings update.
     * 
     * @param listId the identifier of the list which page size is requested.
     */
    getPageBreak: function(listId) {
      if (!isHere('curam.list.isPaginated.'+ listId)) return 1000;
      /* NOTE: while the default size is what's used for pagination,
      threshold is what turns on pagination. Hence you can just apply
      the calculation where the threshold is actually reached. */
      if (getFrom('curam.shortlist.'+ listId)) return 1000;
      var psz = 
        getFrom('curam.pageBreak.'+ listId)
        || getFrom('curam.pagination.defaultPageSize') || 1000;
      return psz;
    },
    /**
     * Returns the starting row number to be read by the screen reader
     * for the tables with headers (2) and tables without headers (1).
     * 
     * @param listId the identifier of the list queried.
     * @param refRow a row used in header presence determination.
     */
    getStartShift: function(listId, refRow) {
      if (!refRow) return 2; // best guess default
      var hPath = 'curam.listHeaderStep.' + listId,
            hStep = getFrom(hPath);
      if (hStep) return hStep;
      putTo(hPath, 2);
	  // get header info. Readings correction for the present header is 2,
	  //but just 1 where no header is set on the list
	  var tableRef = query(refRow).closest('table');
	  if (tableRef.length == 0) return 2; //hidden row - no parent.
	  var headerRef = tableRef.children('thead')[0];
	  !headerRef && putTo(hPath, 1);
      return curam.listHeaderStep[listId];
    },
     /**
     * This method is invoked to intercept XMLHttpRequests to 
     * allow the update of sessionExpiry on sessionStorage for each ajax call.
     */
    extendXHR : function(){
        var protoTypeOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function() {
        
          this.addEventListener('load', function() {
            if (typeof(Storage) !== "undefined") {
                var sessionExp = this.getResponseHeader('sessionExpiry');
                sessionStorage.setItem("sessionExpiry", sessionExp);
            }
          });
          protoTypeOpen.apply(this, arguments);
        };
      },
    suppressPaginationUpdate: false,
    updateDeferred: null
  });
  // module level shortcuts. Used by the list control accessibility code above. 
  var cu = curam.util,
      getFrom = dojo.getObject,
      putTo = dojo.setObject,
      isHere = dojo.exists,
      READOUT = 'aria-label',
      ROW_IDX = 'data-lix';

  return curam.util;
});

},
'dojo/store/Memory':function(){
define(["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine" /*=====, "./api/Store" =====*/],
function(declare, QueryResults, SimpleQueryEngine /*=====, Store =====*/){

// module:
//		dojo/store/Memory

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

return declare("dojo.store.Memory", base, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo/store/api/Store.
	constructor: function(options){
		// summary:
		//		Creates a memory object store.
		// options: dojo/store/Memory
		//		This provides any configuration information that will be mixed into the store.
		//		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		// summary:
		//		Retrieves an object by its identity
		// id: Number
		//		The identity to use to lookup the object
		// returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// summary:
		//		Stores an object
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// summary:
		//		Creates an object, throws an error if the object already exists
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// summary:
		//		Deletes an object by its identity
		// id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		//		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// summary:
		//		Queries the store for objects.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: dojo/store/api/Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// example:
		//		Given the following store:
		//
		// 	|	var store = new Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// summary:
		//		Sets the given data as the source for this store, and indexes it
		// data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier || this.idProperty;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

},
'dijit/_base/sniff':function(){
define([ "dojo/uacss" ], function(){

	// module:
	//		dijit/_base/sniff

	/*=====
	return {
		// summary:
		//		Deprecated, back compatibility module, new code should require dojo/uacss directly instead of this module.
	};
	=====*/
});

},
'dijit/layout/StackContainer':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.some
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct",
	"dojo/has", //  1 
	"dojo/_base/lang", // lang.extend
	"dojo/on",
	"dojo/ready",
	"dojo/topic", // publish
	"dojo/when",
	"../registry", // registry.byId
	"../_WidgetBase",
	"./_LayoutWidget"
], function(array, cookie, declare, domClass, domConstruct, has, lang, on, ready, topic, when, registry, _WidgetBase, _LayoutWidget){

	// module:
	//		dijit/layout/StackContainer

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/layout/StackController"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var StackContainer = declare("dijit.layout.StackContainer", _LayoutWidget, {
		// summary:
		//		A container that has multiple children, but shows only
		//		one child at a time
		//
		// description:
		//		A container for widgets (ContentPanes, for example) That displays
		//		only one Widget at a time.
		//
		//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
		//
		//		Can be base class for container, Wizard, Show, etc.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `StackContainer`.

		// doLayout: Boolean
		//		If true, change the size of my currently displayed child to match my size
		doLayout: true,

		// persist: Boolean
		//		Remembers the selected child across sessions
		persist: false,

		baseClass: "dijitStackContainer",

		/*=====
		// selectedChildWidget: [readonly] dijit._Widget
		//		References the currently selected child widget, if any.
		//		Adjust selected child with selectChild() method.
		selectedChildWidget: null,
		=====*/

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitLayoutContainer");
		},

		postCreate: function(){
			this.inherited(arguments);
			this.own(
				on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown"))
			);
		},

		startup: function(){
			if(this._started){
				return;
			}

			var children = this.getChildren();

			// Setup each page panel to be initially hidden
			array.forEach(children, this._setupChild, this);

			// Figure out which child to initially display, defaulting to first one
			if(this.persist){
				this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
			}else{
				array.some(children, function(child){
					if(child.selected){
						this.selectedChildWidget = child;
					}
					return child.selected;
				}, this);
			}
			var selected = this.selectedChildWidget;
			if(!selected && children[0]){
				selected = this.selectedChildWidget = children[0];
				selected.selected = true;
			}

			// Publish information about myself so any StackControllers can initialize.
			// This needs to happen before this.inherited(arguments) so that for
			// TabContainer, this._contentBox doesn't include the space for the tab labels.
			topic.publish(this.id + "-startup", {children: children, selected: selected, textDir: this.textDir});

			// Startup each child widget, and do initial layout like setting this._contentBox,
			// then calls this.resize() which does the initial sizing on the selected child.
			this.inherited(arguments);
		},

		resize: function(){
			// Overrides _LayoutWidget.resize()
			// Resize is called when we are first made visible (it's called from startup()
			// if we are initially visible). If this is the first time we've been made
			// visible then show our first child.
			if(!this._hasBeenShown){
				this._hasBeenShown = true;
				var selected = this.selectedChildWidget;
				if(selected){
					this._showChild(selected);
				}
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _LayoutWidget._setupChild()
			
			var childNode = child.domNode,
				wrapper = domConstruct.place(
					"<div role='tabpanel' class='" + this.baseClass + "ChildWrapper dijitHidden'>",
					child.domNode,
					"replace"),
				label = child["aria-label"] || child.title || child.label;			 

                        /* CURAM-FIX rtc231858 fix for rtc -203938 */
                        var tabPanelWrapper = wrapper.parentElement;
                        if(tabPanelWrapper && tabPanelWrapper.parentElement)
                        {
                            var tablistId = tabPanelWrapper.parentElement.id + "_tablist";
                            var tablist = dojo.byId(tablistId);
                            if (tablist && tablist.style.height.trim() == "0px"){
                                wrapper.removeAttribute("role");
                            }
                        } 
                        /* CURAM-FIX rtc231858 fix for rtc -203938 */
			if(label){
				// setAttribute() escapes special chars, and if() statement avoids setting aria-label="undefined"
				wrapper.setAttribute("aria-label", label);
			}
			domConstruct.place(childNode, wrapper);
			child._wrapper = wrapper;	// to set the aria-labelledby in StackController

			this.inherited(arguments);

			// child may have style="display: none" (at least our test cases do), so remove that
			if(childNode.style.display == "none"){
				childNode.style.display = "block";
			}

			// remove the title attribute so it doesn't show up when i hover over a node
			child.domNode.removeAttribute("title");
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to do layout and publish events

			this.inherited(arguments);

			if(this._started){
				topic.publish(this.id + "-addChild", child, insertIndex);	// publish

				// in case the tab titles have overflowed from one line to two lines
				// (or, if this if first child, from zero lines to one line)
				// TODO: w/ScrollingTabController this is no longer necessary, although
				// ScrollTabController.resize() does need to get called to show/hide
				// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild().
				// If this is updated to not layout [except for initial child added / last child removed], update
				// "childless startup" test in StackContainer.html to check for no resize event after second addChild()
				this.layout();

				// if this is the first child, then select it
				if(!this.selectedChildWidget){
					this.selectChild(child);
				}
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ page){
			// Overrides _Container.removeChild() to do layout and publish events

			var idx = array.indexOf(this.getChildren(), page);

			this.inherited(arguments);

			// Remove the child widget wrapper we use to set aria roles.  This won't affect the page itself since it's
			// already been detached from page._wrapper via the this.inherited(arguments) call above.
			domConstruct.destroy(page._wrapper);
			delete page._wrapper;

			if(this._started){
				// This will notify any tablists to remove a button; do this first because it may affect sizing.
				topic.publish(this.id + "-removeChild", page);
			}

			// If all our children are being destroyed than don't run the code below (to select another page),
			// because we are deleting every page one by one
			if(this._descendantsBeingDestroyed){
				return;
			}

			// Select new page to display, also updating TabController to show the respective tab.
			// Do this before layout call because it can affect the height of the TabController.
			if(this.selectedChildWidget === page){
				this.selectedChildWidget = undefined;
				if(this._started){
					var children = this.getChildren();
					if(children.length){
						this.selectChild(children[Math.max(idx - 1, 0)]);
					}
				}
			}

			if(this._started){
				// In case the tab titles now take up one line instead of two lines
				// (note though that ScrollingTabController never overflows to multiple lines),
				// or the height has changed slightly because of addition/removal of tab which close icon
				this.layout();
			}
		},

		selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
			// summary:
			//		Show the given widget (which must be one of my children)
			// page:
			//		Reference to child widget or id of child widget

			var d;

			page = registry.byId(page);

			if(this.selectedChildWidget != page){
				// Deselect old page and select new one
				d = this._transition(page, this.selectedChildWidget, animate);
				this._set("selectedChildWidget", page);
				topic.publish(this.id + "-selectChild", page, this._focused);	// publish

				if(this.persist){
					cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
				}
			 }else if(this._focused  && true == page.closable){
			    //Publish topic to update tab browser title. Condition is used when the last in page navigation is closed 
				//and it is closable.
				topic.publish(this.id + "-selectChild", page, this._focused);	// publish
			}

			// d may be null, or a scalar like true.  Return a promise in all cases
			return when(d || true);		// Promise
		},

		_transition: function(newWidget, oldWidget /*===== ,  animate =====*/){
			// summary:
			//		Hide the old widget and display the new widget.
			//		Subclasses should override this.
			// newWidget: dijit/_WidgetBase
			//		The newly selected widget.
			// oldWidget: dijit/_WidgetBase
			//		The previously selected widget.
			// animate: Boolean
			//		Used by AccordionContainer to turn on/off slide effect.
			// tags:
			//		protected extension
			if(oldWidget){
				this._hideChild(oldWidget);
			}
			var d = this._showChild(newWidget);

			// Size the new widget, in case this is the first time it's being shown,
			// or I have been resized since the last time it was shown.
			// Note that page must be visible for resizing to work.
			if(newWidget.resize){
				if(this.doLayout){
					newWidget.resize(this._containerContentBox || this._contentBox);
				}else{
					// the child should pick it's own size but we still need to call resize()
					// (with no arguments) to let the widget lay itself out
					newWidget.resize();
				}
			}

			return d;	// If child has an href, promise that fires when the child's href finishes loading
		},

		_adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Gets the next/previous child widget in this container from the current selection.

			// TODO: remove for 2.0 if this isn't being used.   Otherwise, fix to skip disabled tabs.

			var children = this.getChildren();
			var index = array.indexOf(children, this.selectedChildWidget);
			index += forward ? 1 : children.length - 1;
			return children[ index % children.length ]; // dijit/_WidgetBase
		},

		forward: function(){
			// summary:
			//		Advance to next page.
			return this.selectChild(this._adjacent(true), true);
		},

		back: function(){
			// summary:
			//		Go back to previous page.
			return this.selectChild(this._adjacent(false), true);
		},

		_onKeyDown: function(e){
			topic.publish(this.id + "-containerKeyDown", { e: e, page: this});	// publish
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			var child = this.selectedChildWidget;
			if(child && child.resize){
				if(this.doLayout){
					child.resize(this._containerContentBox || this._contentBox);
				}else{
					child.resize();
				}
			}
		},

		_showChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
			//		it can do any updates it needs regarding loading href's etc.
			// returns:
			//		Promise that fires when page has finished showing, or true if there's no href
			var children = this.getChildren();
			page.isFirstChild = (page == children[0]);
			page.isLastChild = (page == children[children.length - 1]);
			page._set("selected", true);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitVisible", "dijitHidden");
			}

			return (page._onShow && page._onShow()) || true;
		},

		_hideChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Hide the specified child by changing it's CSS, and call _onHide() so
			//		it's notified.
			page._set("selected", false);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitHidden", "dijitVisible");
			}

			page.onHide && page.onHide();
		},

		closeChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Callback when user clicks the [X] to remove a page.
			//		If onClose() returns true then remove and destroy the child.
			// tags:
			//		private
			var remove = page.onClose && page.onClose(this, page);
			if(remove){
				this.removeChild(page);
				// makes sure we can clean up executeScripts in ContentPane onUnLoad
				page.destroyRecursive();
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			this._descendantsBeingDestroyed = true;
			this.selectedChildWidget = undefined;
			array.forEach(this.getChildren(), function(child){
				if(!preserveDom){
					this.removeChild(child);
				}
				child.destroyRecursive(preserveDom);
			}, this);
			this._descendantsBeingDestroyed = false;
		}
	});

	StackContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a StackContainer.

		// selected: Boolean
		//		Specifies that this widget should be the initially displayed pane.
		//		Note: to change the selected child use `dijit/layout/StackContainer.selectChild`
		selected: false,

		// disabled: Boolean
		//		Specifies that the button to select this pane should be disabled.
		//		Doesn't affect programmatic selection of the pane, nor does it deselect the pane if it is currently selected.
		disabled: false,

		// closable: Boolean
		//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
		closable: false,

		// iconClass: String
		//		CSS Class specifying icon to use in label associated with this pane.
		iconClass: "dijitNoIcon",

		// showTitle: Boolean
		//		When true, display title of this widget as tab label etc., rather than just using
		//		icon specified in iconClass
		showTitle: true
	};

	// Since any widget can be specified as a StackContainer child, mix them
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ StackContainer.ChildWidgetProperties);

	return StackContainer;
});

},
'dojo/regexp':function(){
define(["./_base/kernel", "./_base/lang"], function(dojo, lang){

// module:
//		dojo/regexp

var regexp = {
	// summary:
	//		Regular expressions and Builder resources
};
lang.setObject("dojo.regexp", regexp);

regexp.escapeString = function(/*String*/str, /*String?*/except){
	// summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	// summary:
	//		Builds a regular expression that groups subexpressions
	// description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return regexp.group(b.join("|"), nonCapture); // String
};

regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return regexp;
});

},
'curam/debug':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["curam/define",
        "curam/util/LocalConfig",
        "dojo/ready",
        "dojo/_base/lang",
        "curam/util/ResourceBundle"], function(define, localConfig, ready, lang, resBundle) {
  
  var debugBundle = new resBundle("curam.application.Debug");
  
  /*
   * Modification History
   * --------------------
   * 05-Mar-2014 MV [CR00421036] Move to using LocalConfig. 
   * 27-Feb-2014 MV [CR00419961] Add support for JavaScript debug configuration.
   * 12-Sep-2011  MV  [CR00286500] Fix stack overflow when logging window
   *    objects in IE.
   * 11-May-2011  MV  [CR00265902] Fixed log function invocation.
   * 26-Jan-2011  MV  [CR00244801] Fixed check for DEBUG flag.
   * 21-Jan-2011  DG  [CR00243540] Added note on new way to set DEBUG variable.
   *                    Added copyright. Tidied up formatting.
   * 26-Jun-2010  MV  [CR00204069] Improve to enable passing many number
   *                    of parameters. Enable easier usage by removing class
   *                    declaration and shortening the name.
   * 06-Nov-2009  SC  [CR00172239] Initial Version
   */
  /**
   * Provides a simple logging facility for debug tracing to the JavaScript
   * console.
   */
  define.singleton("curam.debug", {
    /**
     * A logging facility that can be turned on or off using the
     * "curam.trace.javascript" application property. Debug tracing is disabled
     * by default; use your application admin screens to enable it.
     * Any number of parameters can be passed. These are forwarded
     * to the <code>console.log.apply</code> function.
     */
    log: function() {
      //debugger;
      if (curam.debug.enabled()) {
        try {
          var a = arguments;
          if (!dojo.isIE) {
            console.log.apply(console, a);
          
          // the above generic call doesn't work in IE  so the following ugly
          // specific handling must be provided
          } else {
            var numArgs = a.length;
            var sa = curam.debug._serializeArgument;
            switch(numArgs) {
              case 1: console.log(arguments[0]);
              break;
              
              case 2: console.log(a[0], sa(a[1]));
              break;
              
              case 3: console.log(a[0], sa(a[1]), sa(a[2]));
              break;
              
              case 4: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]));
              break;
              
              case 5: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]));
              break;
              
              case 6: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]),
                  sa(a[5]));
              break;
              
              default: console.log("[Incomplete message - " + (numArgs - 5)
                  + " message a truncated] " + a[0],
                  sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]), sa(a[5]));
            }
          }

        } catch (e) {
          console.log(e);
          // Some problem with the console. Do nothing.
        }
      }
    },
    
    getProperty : function(key, substValues) {
      return debugBundle.getProperty(key, substValues);
    },
    
    /**
     * Make a human readable version of the object to be logged.
     *
     * @param arg The object to be serialized.
     * @returns The human readable version of the object.
     */
    _serializeArgument: function(arg) {
      if (typeof arg != "undefined"
          && typeof arg.nodeType != "undefined"
          && typeof arg.cloneNode != "undefined") { // isNode 
        // DOM nodes can't be serialized using dojo.toJson(), so just return
        // default toString version
        return "" + arg;

      } else if (curam.debug._isWindow(arg)) {
        // window object causes stack overflow for dojo.toJson() so handling 
        // specifically here
        return arg.location.href;

      } else if (curam.debug._isArray(arg)
            && curam.debug._isWindow(arg[0])) { // is array of window objects
        // array of window objects causes stack overflow for dojo.toJson()
        // so handling specifically here
        return "[array of window objects, length " + arg.length + "]";

      } else {
        return dojo.toJson(arg);
      }
    },
    
    /**
     * Recognizes array objects.
     * 
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is array, otherwise false.
     */
    _isArray: function(arg) {
      return typeof arg != "undefined"
          && (dojo.isArray(arg) || typeof arg.length != "undefined");
    },

    /**
     * Recognizes window object.
     *
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is a window object,
     *    otherwise false.
     */
    _isWindow: function(arg) {
      // some of the significant properties might be undefined fo closed window
      // so handle this case separately
      var isClosed = typeof arg != "undefined"
        && typeof arg.closed != "undefined" && arg.closed;
      if (isClosed) {
        // it is a closed window
        return true;
      
      } else {
        return typeof arg != "undefined"
            && typeof arg.location != "undefined"
            && typeof arg.navigator != "undefined"
            && typeof arg.document != "undefined"
            && typeof arg.closed != "undefined";
      }
    },
    
    enabled: function() {
      return localConfig.readOption('jsTraceLog', 'false') == 'true';
    },
    
    /**
     * Performs setup of the debug/tracing infrastructure.
     * This is called from the application main page to setup debug.
     *
     * @param {Object} config Configuration data.
     */
    _setup: function(config) {
      localConfig.seedOption('jsTraceLog', config.trace, 'false');
      localConfig.seedOption('ajaxDebugMode', config.ajaxDebug, 'false');
      localConfig.seedOption('asyncProgressMonitor',
          config.asyncProgressMonitor, 'false');
    }
  });
  
  return curam.debug;
});

},
'dijit/DropDownMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_MenuBase"
], function(declare, keys, template, _MenuBase){

	// module:
	//		dijit/DropDownMenu

	return declare("dijit.DropDownMenu", _MenuBase, {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		// Arrow key navigation
		_onUpArrow: function(){
			this.focusPrev();
		},
		_onDownArrow: function(){
			this.focusNext();
		},
		_onRightArrow: function(/*Event*/ evt){
			this._moveToPopup(evt);
			evt.stopPropagation();
			evt.preventDefault();
		},
		_onLeftArrow: function(/*Event*/ evt){
			if(this.parentMenu){
				if(this.parentMenu._isMenuBar){
					this.parentMenu.focusPrev();
				}else{
					this.onCancel(false);
				}
			}else{
				evt.stopPropagation();
				evt.preventDefault();
			}
		}
	});
});

},
'dijit/_AttachMixin':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect",	// remove for 2.0
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"dojo/mouse",
	"dojo/on",
	"dojo/touch",
	"./_WidgetBase"
], function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent; ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
});

},
'dijit/Menu':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/keys", // keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready){

	// module:
	//		dijit/Menu

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Menu", DropDownMenu, {
		// summary:
		//		A context menu you can assign to multiple elements

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- replace srcNodeRef with my generated DOM tree

			this._bindings = [];
		},

		// targetNodeIds: [const] String[]
		//		Array of dom node ids of nodes to attach to.
		//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
		targetNodeIds: [],

		// selector: String?
		//		CSS expression to apply this Menu to descendants of targetNodeIds, rather than to
		//		the nodes specified by targetNodeIds themselves.  Useful for applying a Menu to
		//		a range of rows in a table, tree, etc.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple targetNodeIds.   selector gives the same effect.
		// So, change targetNodeIds to a targetNodeId: "", remove bindDomNode()/unBindDomNode(), etc.

		/*=====
		// currentTarget: [readonly] DOMNode
		//		For context menus, set to the current node that the Menu is being displayed for.
		//		Useful so that the menu actions can be tailored according to the node
		currentTarget: null,
		=====*/

		// contextMenuForWindow: [const] Boolean
		//		If true, right clicking anywhere on the window will cause this context menu to open.
		//		If false, must specify targetNodeIds.
		contextMenuForWindow: false,

		// leftClickToOpen: [const] Boolean
		//		If true, menu will open on left click instead of right click, similar to a file menu.
		leftClickToOpen: false,
		// TODO: remove in 2.0, we have better ways of opening a menu with a left click, by extending _HasDropDown.

		// refocus: Boolean
		//		When this menu closes, re-focus the element which had focus before it was opened.
		refocus: true,

		postCreate: function(){
			if(this.contextMenuForWindow){
				this.bindDomNode(this.ownerDocumentBody);
			}else{
				array.forEach(this.targetNodeIds, this.bindDomNode, this);
			}
			this.inherited(arguments);
		},

		// thanks burstlib!
		_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns the window reference of the passed iframe
			// tags:
			//		private
			return winUtils.get(this._iframeContentDocument(iframe_el)) ||
				// Moz. TODO: is this available when defaultView isn't?
				this._iframeContentDocument(iframe_el)['__parent__'] ||
				(iframe_el.name && document.frames[iframe_el.name]) || null;	//	Window
		},

		_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns a reference to the document object inside iframe_el
			// tags:
			//		protected
			return iframe_el.contentDocument // W3
				|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
				|| (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document)
				|| null;	//	HTMLDocument
		},

		bindDomNode: function(/*String|DomNode*/ node){
			// summary:
			//		Attach menu to given node
			node = dom.byId(node, this.ownerDocument);

			var cn;	// Connect node

			// Support context menus on iframes.  Rather than binding to the iframe itself we need
			// to bind to the <body> node inside the iframe.
			if(node.tagName.toLowerCase() == "iframe"){
				var iframe = node,
					window = this._iframeContentWindow(iframe);
				cn = win.body(window.document);
			}else{
				// To capture these events at the top level, attach to <html>, not <body>.
				// Otherwise right-click context menu just doesn't work.
				cn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);
			}


			// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
			var binding = {
				node: node,
				iframe: iframe
			};

			// Save info about binding in _bindings[], and make node itself record index(+1) into
			// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
			// start with a number, which fails on FF/safari.
			domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

			// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
			// loading yet, in which case we need to wait for the onload event first, and then connect
			// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
			// we need to monitor keyboard events in addition to the oncontextmenu event.
			var doConnects = lang.hitch(this, function(cn){
				var selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){
							return on.selector(selector, eventType);
						} :
						function(eventType){
							return eventType;
						},
					self = this;
				return [
					on(cn, delegatedEvent(this.leftClickToOpen ? "click" : "contextmenu"), function(evt){
						evt.stopPropagation();
						evt.preventDefault();

						if((new Date()).getTime() < self._lastKeyDown + 500){
							// Ignore contextmenu/click events that were already processed in keydown handler below.
							// But still call preventDefault() (above) so system context menu doesn't appear.
							return;
						}

						// Schedule context menu to be opened.
						// Note that this won't work will if the click was generated by the keyboard, while
						// focused on a <button> etc.   In that case evt.pageX and evt.pageY are either (0,0) or
						// wherever the mouse cursor is.  See keydown handler below.
						self._scheduleOpen(this, iframe, {x: evt.pageX, y: evt.pageY}, evt.target);
					}),
					on(cn, delegatedEvent("keydown"), function(evt){
						if(evt.keyCode == 93 ||									// context menu key
							(evt.shiftKey && evt.keyCode == keys.F10) ||		// shift-F10
							(self.leftClickToOpen && evt.keyCode == keys.SPACE)	// space key
						){
							evt.stopPropagation();
							evt.preventDefault();

							// Open the menu around evt.target.  Note that "this" and evt.target
							// are likely different, especially for global context menu, where "this" is <body>.
							self._scheduleOpen(this, iframe, null, evt.target);	// no coords - open near evt.target

							self._lastKeyDown = (new Date()).getTime();
						}
					})
				];
			});
			binding.connects = cn ? doConnects(cn) : [];

			if(iframe){
				// Setup handler to [re]bind to the iframe when the contents are initially loaded,
				// and every time the contents change.
				// Need to do this b/c we are actually binding to the iframe's <body> node.
				// Note: can't use connect.connect(), see #9609.

				binding.onloadHandler = lang.hitch(this, function(){
					// want to remove old connections, but IE throws exceptions when trying to
					// access the <body> node because it's already gone, or at least in a state of limbo

					var window = this._iframeContentWindow(iframe),
						cn = win.body(window.document);
					binding.connects = doConnects(cn);
				});
				if(iframe.addEventListener){
					iframe.addEventListener("load", binding.onloadHandler, false);
				}else{
					iframe.attachEvent("onload", binding.onloadHandler);
				}
			}
		},

		unBindDomNode: function(/*String|DomNode*/ nodeName){
			// summary:
			//		Detach menu from given node

			var node;
			try{
				node = dom.byId(nodeName, this.ownerDocument);
			}catch(e){
				// On IE the dom.byId() call will get an exception if the attach point was
				// the <body> node of an <iframe> that has since been reloaded (and thus the
				// <body> node is in a limbo state of destruction.
				return;
			}

			// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
			var attrName = "_dijitMenu" + this.id;
			if(node && domAttr.has(node, attrName)){
				var bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;
				while((h = b.connects.pop())){
					h.remove();
				}

				// Remove listener for iframe onload events
				var iframe = b.iframe;
				if(iframe){
					if(iframe.removeEventListener){
						iframe.removeEventListener("load", b.onloadHandler, false);
					}else{
						iframe.detachEvent("onload", b.onloadHandler);
					}
				}

				domAttr.remove(node, attrName);
				delete this._bindings[bid];
			}
		},

		_scheduleOpen: function(delegatedTarget, iframe, coords, target){
			// summary:
			//		Set timer to display myself.  Using a timer rather than displaying immediately solves
			//		IE problem: without the delay, focus work in "open" causes the system
			//		context menu to appear in spite of evt.preventDefault().
			// delegatedTarget: Element
			//		The node specified in targetNodeIds or matching selector that the menu is being opened for.
			// iframe: HTMLIframeElement?
			//		Set if target is inside the specified iframe.
			// coords: Object
			//		x/y position to center the menu around.  Undefined if menu was opened via keyboard.
			// target: Element
			//		The actual clicked node, either delegatedTarget or a descendant.

			if(!this._openTimer){
				this._openTimer = this.defer(function(){
					delete this._openTimer;
					this._openMyself({
						target: target,
						delegatedTarget: delegatedTarget,
						iframe: iframe,
						coords: coords
					});
				}, 1);
			}
		},

		_openMyself: function(args){
			// summary:
			//		Internal function for opening myself when the user does a right-click or something similar.
			// args:
			//		This is an Object containing:
			//
			//		- target: The node that is being clicked.
			//		- delegatedTarget: The node from this.targetNodeIds or matching this.selector,
			//		  either the same as target or an ancestor of target.
			//		- iframe: If an `<iframe>` is being clicked, iframe points to that iframe
			//		- coords: Mouse cursor x/y coordinates.  Null when opened via keyboard.
			//		  Put menu at specified position in iframe (if iframe specified) or otherwise in viewport.
			//
			//		_openMyself() formerly took the event object, and since various code references
			//		evt.target (after connecting to _openMyself()), using an Object for parameters
			//		(so that old code still works).

			var target = args.target,
				iframe = args.iframe,
				coords = args.coords,
				byKeyboard = !coords;

			// To be used by MenuItem event handlers to tell which node the menu was opened on
			this.currentTarget = args.delegatedTarget;

			// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
			// then near the node the menu is assigned to.
			if(coords){
				if(iframe){
					// Specified coordinates are on <body> node of an <iframe>, convert to match main document
					var ifc = domGeometry.position(iframe, true),
						window = this._iframeContentWindow(iframe),
						scroll = domGeometry.docScroll(window.document);

					var cs = domStyle.getComputedStyle(iframe),
						tp = domStyle.toPixelValue,
						left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
						top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

					coords.x += ifc.x + left - scroll.x;
					coords.y += ifc.y + top - scroll.y;
				}
			}else{
				coords = domGeometry.position(target, true);
				coords.x += 10;
				coords.y += 10;
			}

			var self = this;
			var prevFocusNode = this._focusManager.get("prevNode");
			var curFocusNode = this._focusManager.get("curNode");
			var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

			function closeAndRestoreFocus(){
				// user has clicked on a menu or popup
				if(self.refocus && savedFocusNode){
					savedFocusNode.focus();
				}
				pm.close(self);
			}

			pm.open({
				popup: this,
				x: coords.x,
				y: coords.y,
				onExecute: closeAndRestoreFocus,
				onCancel: closeAndRestoreFocus,
				orient: this.isLeftToRight() ? 'L' : 'R'
			});

			// Focus the menu even when opened by mouse, so that a click on blank area of screen will close it
			this.focus();
			if(!byKeyboard){
				// But then (when opened by mouse), mark Menu as passive, so that the first item isn't highlighted.
				// On IE9+ this needs to be on a delay because the focus is asynchronous.
				this.defer(function(){
					this._cleanUp(true);
				});
			}

			this._onBlur = function(){
				this.inherited('_onBlur', arguments);
				// Usually the parent closes the child widget but if this is a context
				// menu then there is no parent
				pm.close(this);
				// don't try to restore focus; user has clicked another part of the screen
				// and set focus there
			};
		},

		destroy: function(){
			array.forEach(this._bindings, function(b){
				if(b){
					this.unBindDomNode(b.node);
				}
			}, this);
			this.inherited(arguments);
		}
	});
});

},
'idx/widget/HoverHelpTooltip':function(){
/*
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define(["dojo/_base/declare", "dojo/_base/fx", // fx.fadeIn fx.fadeOut
 "dojo/keys", // keys
 "dojo/_base/array", // array.forEach array.indexOf array.map
 "dojo/dom", // dom.byId
 "dojo/on",
 "dojo/aspect",
 "dojo/when", 
 "dojo/Deferred",
 "dojo/dom-attr", // domAttr.set
 "dojo/_base/lang", // lang.hitch lang.isArrayLike
 "dojo/_base/sniff", // has("ie")
 "dijit/popup",
 "dijit/focus", "dojo/_base/event", // event.stop
 "dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
 "dojo/dom-construct",
 "dojo/dom-class",
 "dijit/registry",
 "dijit/place", "dijit/a11y", // _getTabNavigable
 "dojo/dom-style", // domStyle.set, domStyle.get
 "dojo/_base/window", // win.body
 "dijit/_base/manager", // manager.defaultDuration
 "dijit/_Widget", "dijit/_TemplatedMixin", "dijit/Tooltip", 
 "dojo/has!dojo-bidi?../bidi/widget/HoverHelpTooltip",
 "dojo/text!./templates/HoverHelpTooltip.html", "dijit/dijit", 
 "dojo/i18n!./nls/Dialog", "dojo/i18n!./nls/HoverHelpTooltip"
], function(declare, fx, keys, array, dom, on, aspect, when, Deferred, domAttr, lang, has, popup, dijitfocus, event, domGeometry, domConstruct, domClass, registry, place, 
 a11y, domStyle, win, manager, _Widget, _TemplatedMixin, Tooltip, bidiExtension, template, dijit, dialogNls, hoverHelpTooltipNls){
	var oneuiRoot = lang.getObject("idx.oneui", true); // for backward compatibility with IDX 1.2
	
    /**
     * @name idx.widget.HoverHelpTooltip
     * @class HoverHelpTooltip provides pop-up information that displays when users hover the mouse pointer over an help indicator.
     * HoverHelpTooltip is implemented following the standard and specified IBM One UI(tm)
     * <b><a href="http://dleadp.torolab.ibm.com/uxd/uxd_oneui.jsp?site=ibmoneui&top=x1&left=y20&vsub=*&hsub=*&openpanes=1111111111">Hover Help</a></b>
     * @augments dijit.Tooltip
     * @example
     &lt;span data-dojo-type="idx.widget.HoverHelpTooltip" data-dojo-props='
     connectId:["anchor"],
     forceFocus: true,
     showLearnMore:true,
     learnMoreLinkValue:"http://www.ibm.com"'
     style="width: 300px"&gt;
     Passwords must be between 5 and 20 characters. There must be a combination of alphanumeric characters, starting with a letter and at least one number.&lt;br /&gt;&lt;br /&gt;
     &lt;/span&gt;
     * @see dijit.Tooltip
     **/
    var HoverHelpTooltip = declare("idx.widget.HoverHelpTooltip", Tooltip, {
        /** @lends idx.widget.HoverHelpTooltip.prototype */
        showDelay: 500,
        hideDelay: 800,
        /**
         * Whether to show Learn more link
         * @type Boolean
         */
        showLearnMore: false,
        /**
         * Learn more link value
         * @type String
         */
        learnMoreLinkValue: "#updateme",
        
        showCloseIcon: true,
        /**
         * Focus HoverHelpTooltip once it shown.
         * @type Boolean
         */
        forceFocus: false,
		
		textDir: "auto",

        _onHover: function(/*Event*/e){
            // summary:
            //		Despite the name of this method, it actually handles both hover and focus
            //		events on the target node, setting a timer to show the HoverHelpTooltip.
            // tags:
            //		private
            if (!HoverHelpTooltip._showTimer) {
                var target = e.target;
                HoverHelpTooltip._showTimer = setTimeout(lang.hitch(this, function(){
                    this.open(target)
                }), this.showDelay);
            }
            if (HoverHelpTooltip._hideTimer) {
                clearTimeout(HoverHelpTooltip._hideTimer);
                delete HoverHelpTooltip._hideTimer;
            }
        },
        
        _onUnHover: function(/*Event*/ /*===== e =====*/){
            // summary:
            //		Despite the name of this method, it actually handles both mouseleave and blur
            //		events on the target node, hiding the HoverHelpTooltip.
            // tags:
            //		private
            
            // keep a HoverHelpTooltip open if the associated element still has focus (even though the
            // mouse moved away)
            if (HoverHelpTooltip._showTimer) {
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
            if (!HoverHelpTooltip._hideTimer) {
                HoverHelpTooltip._hideTimer = setTimeout(lang.hitch(this, function(){
                    this.close()
                }), this.hideDelay);
            }
        },
        
        /**
         * Display the HoverHelpTooltip
         * @private
         */
        open: function(/*DomNode*/target){
            // summary:
            //		
            // tags:
            //		private
            if (HoverHelpTooltip._showTimer) {
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
			// Fix for Defect 12350: 
			if(!dom.byId(target)){return;}
			
			var ariaLabel = domAttr.get(this.domNode, "aria-label");
            HoverHelpTooltip.show(
				this.content || this.label || this.domNode.innerHTML, 
				target, this.position, !this.isLeftToRight(), 
				this.textDir, this.showLearnMore, this.learnMoreLinkValue, 
				this.showCloseIcon, this.forceFocus, ariaLabel);
            this._connectNode = target;
            this.onShow(target, this.position);
        },
		
        close: function(force){
            // summary:
            //		Hide the tooltip or cancel timer for show of tooltip
            // tags:
            //		private
            if (this._connectNode) {
                // if tooltip is currently shown
            	
            	// CHANGE FROM BARRY -- CREATED A DEFERRED OBJECT THAT GETS RESOLVED WHEN THE
            	// ANIMATION FOR HIDING COMPLETES AND RETURN IT FORM THIS METHOD SO THE CALLER
            	// CAN OPT TO WAIT FOR ANIMATION TO COMPLETE BEFORE TAKING A NEXT STEP
            	// -- I NEEDED THIS AT ONE POINT, BUT AFTER FIXING AN ISSUE WITH INTERFERENCE OF
            	// MULTIPLE TOOLTIPS IN RACE CONDITIONS IT WAS NO LONGER NEEDED.  I LEFT IT HERE
            	// SINCE IT CANNOT HURT TO GIVE THE CALLER THIS OPTION OF USING dojo/promise API
                var anim = HoverHelpTooltip.hide(this._connectNode, force);
                delete this._connectNode;
                this.onHide();
                if (anim) {
                   // create the deferred object
              	   var d = new Deferred();
              	   var handles = [];
              	   
              	   // define the function to resolve the deferred
              	   var resolve = function() {
              		   // mark the deferred as resolved (fulfill the promise)
              		   if (d) d.resolve();
              		   
              		   // for each aspect handle, remove it
              		   array.forEach(handles, function(handle) {
              			   if (handle) handle.remove();
              		   });
              	   };
              	   
              	   // use aspect.after to attach to the "onEnd" and "onStop" methods and
              	   // fire the "resolve" callback when one of these fires
              	   handles.push(aspect.after(anim, "onEnd", resolve));
              	   handles.push(aspect.after(anim, "onStop", resolve));
              	   
              	   // double-check if the animation already stopped and our deferred missed the event
              	   if ((anim.status() == "stopped") && (!d.isResolved())) {
              		   resolve();
              	   }
              	   
              	   // return the dojo/Deferred "promise"
              	   return d;
                 } else {
                   // if no animation then return null for dojo/when API
              	   return null;
                 }             	
            }
            if (HoverHelpTooltip._showTimer) {
                // if tooltip is scheduled to be shown (after a brief delay)
                clearTimeout(HoverHelpTooltip._showTimer);
                delete HoverHelpTooltip._showTimer;
            }
        },
        _setConnectIdAttr: function(/*String|String[]*/newId){
            // summary:
            //		Connect to specified node(s)
            
            // Remove connections to old nodes (if there are any)
            array.forEach(this._connections || [], function(nested){
                array.forEach(nested, lang.hitch(this, "disconnect"));
            }, this);
            
            // Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
            this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []), function(id){
                return dom.byId(id);
            });
            
            // Make connections
            this._connections = array.map(this._connectIds, function(id){
                var node = dom.byId(id);
                return [
                    // TODO - NOTE FROM BARRY: consider "onclick" triggering focus but "onmouseenter" NOT triggering focus
					this.connect(node, "onmouseenter", "_onHover"),
					this.connect(node, "onmouseleave", "_onUnHover"), 
					this.connect(node, "onclick", "_onHover"),
					this.connect(node, "onkeypress", "_onConnectIdKey")
				];
            }, this);
            
            this._set("connectId", newId);
        },
        _onConnectIdKey: function(/*Event*/evt){
            // summary:
            //		Handler for keyboard events
            // description:
            // tags:
            //		private
            var node = evt.target;
            
            if (evt.charOrCode == keys.ENTER || evt.charOrCode == keys.SPACE || evt.charOrCode == " " || evt.charOrCode == keys.F1) {
                // Use setTimeout to avoid crash on IE, see #10396.
                HoverHelpTooltip._showTimer = setTimeout(lang.hitch(this, function(){
                    this.open(node)
                }), this.showDelay);
                
                event.stop(evt);
            }
        }
        
    });
    
    var baseClassName = has("dojo-bidi")? "idx.widget._MasterHoverHelpTooltip_" : "idx.widget._MasterHoverHelpTooltip";
    var MasterHoverHelpTooltipBase = declare(baseClassName, [_Widget, _TemplatedMixin], {
		/**
		 * Milliseconds to fade in/fade out
		 * @type Integer
		 */
        duration: manager.defaultDuration,
        
        templateString: template,
		
        learnMoreLabel: "",
        
        /**
         * draggable: Boolean
         *		Toggles the moveable aspect of the HoverHelpTooltip. If true, HoverHelpTooltip
         *		can be dragged by it's grippy bar. If false it will remain positioned
         *		relative to the attached node
         *		@type boolean
         **/
        draggable: true,
        
        _firstFocusItem: null,
		
        _lastFocusItem: null,
        
        postMixInProperties: function(){
            this.learnMoreLabel = hoverHelpTooltipNls.learnMoreLabel;
			this.buttonClose = dialogNls.closeButtonLabel;
        },
        postCreate: function(){
            win.body().appendChild(this.domNode);
            
            //this.bgIframe = new BackgroundIframe(this.domNode);
            
            // Setup fade-in and fade-out functions.
            this.fadeIn = fx.fadeIn({
                node: this.domNode,
                duration: this.duration,
                onEnd: lang.hitch(this, "_onShow")
            });
            this.fadeOut = fx.fadeOut({
                node: this.domNode,
                duration: this.duration,
                onEnd: lang.hitch(this, "_onHide")
            });
            this.connect(this.domNode, "onkeypress", "_onKey");
            this.connect(this.domNode, "onmouseenter", lang.hitch(this, function(e){
				if(HoverHelpTooltip._hideTimer) {
	                clearTimeout(HoverHelpTooltip._hideTimer);
	                delete HoverHelpTooltip._hideTimer;
	            }

				// check if another tooltip is already deck
				if (!this._onDeck) {
					// CHANGE FROM BARRY - ONLY RESTORE A DYING TOOLTIP IF ANOTHER IS NOT ON DECK
					// no tooltip on deck so refocus this one and keep showing it
					
					if (this.forceFocus && this.showLearnMore) this.focus(); // NOTE FROM BARRY: consider removing this unless clicked
					this._keepShowing = true;
					
					// restore the previous state that was cleared out in forceHide
					if (this._prevState) {
						lang.mixin(this, this._prevState);
						this._prevState = null;
					}
					this.fadeOut.stop();
					this.fadeIn.play();
				} else {
					// CHANGE FROM BARRY -- IGNORE THE MOUSE LEAVE EVENT AS THE TOOLTIP CLOSES SINCE ANOTHER IS ON DECK
					// another tooltip is already deck so signal that the mouse leave event on the
					// current tooltip should not trigger a close
					this._ignoreMouseLeave = true;
				}
            }));
			this.connect(this.domNode, "onmouseleave", lang.hitch(this, function(e){
				this._keepShowing = false;
				if (this._ignoreMouseLeave) {
					// mouseenter occurred on previous tooltip and mouseleave is now firing
					// ignore this mouseleave event since the mouseenter was not for this tooltip
					// and we don't want to close the current tooltip
					delete this._ignoreMouseLeave;
					return;
				}
				HoverHelpTooltip._hideTimer = setTimeout(lang.hitch(this, function(){this.hide(this.aroundNode)}), this.hideDelay);
			}));
        },
        show: function(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, 
			learnMoreLinkValue, showCloseIcon, forceFocus, ariaLabel){
			this._lastFocusNode = aroundNode;
            if (showLearnMore) {
                this.learnMoreNode.style.display = "inline";
                this.learnMoreNode.href = learnMoreLinkValue;
            }
            else {
                this.learnMoreNode.style.display = "none";
            }
            if (showCloseIcon || showCloseIcon == null) 
                this.closeButtonNode.style.display = "inline";
            else {
                this.closeButtonNode.style.display = "none";
            }
            //in case connectorNode was hidden on a previous call to hide
            this.connectorNode.hidden = false;
            
            if (this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML) {
                return;
            }
            
            // reset width; it may have been set by orient() on a previous HoverHelpTooltip show()
            this.domNode.width = "auto";
            
            if (this.fadeOut.status() == "playing") {
                // previous HoverHelpTooltip is being hidden; wait until the hide completes then show new one
                this._onDeck = arguments;
                return;
            }
			
			
			//this._attachPopParent();
			//domStyle.set(this._popupWrapper, "display", "");
            
            this.containerNode.innerHTML = innerHTML;
			if(ariaLabel)domAttr.set(this.domNode, "aria-label", ariaLabel);
            
            this.set("textDir", textDir);
            this.containerNode.align = rtl ? "right" : "left"; //fix the text alignment
            var pos = place.around(this.domNode, aroundNode, position && position.length ? position : HoverHelpTooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));
            
            // Position the HoverHelpTooltip connector for middle alignment.
            // This could not have been done in orient() since the HoverHelpTooltip wasn't positioned at that time.
            var aroundNodeCoords = pos.aroundNodePos;
            if (pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M') {
                this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
                this.connectorNode.style.left = "";
            }
            else if (pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M') {
                this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
            }
			
			////Set order in popup stack
			//this._addToPopupStack(); 
			
            // show it
            domStyle.set(this.domNode, "opacity", 0);
			domClass.add(this.domNode, "dijitPopup");
			//this._popupWrapper.appendChild(this.domNode);
            this.fadeIn.play();
            this.isShowingNow = true;
			this.aroundNode = aroundNode;
			// Add WAI-ARIA attribute to the hover tooltip container
			var sourceId = domAttr.get(aroundNode, "id")
			if(typeof sourceId == "string"){
				dijit.setWaiState(this.containerNode, "labelledby", sourceId);
			}
			if (forceFocus) {
                this.focus();
            }
			return;
        },
		
		/*_addToPopupStack: function(){
			var stack = popup._stack;
			domStyle.set(this.domNode, "zIndex", popup._beginZIndex + stack.length);
			popup._stack.push({
				widget: this,
				handlers: []
			});
		},
        _attachPopParent: function(){
			//This is for focusManager to find popup parent of HHT
			if(!this._popupWrapper){
				this._popupWrapper = domConstruct.create("div", {
					style: {"display": "none"}
				}, this.ownerDocumentBody);
			}
			if(this.aroundNode && this.aroundNode.id){
				domAttr.set(this._popupWrapper, "dijitPopupParent", this.aroundNode.id);
			}else{
				this._popupWrapper.dijitPopupParent = this.aroundNode;
			}
		},
        _removeFromPopupStack: function(){
			popup._stack.pop();
		},*/
        orient: function(/*DomNode*/node, /*String*/ aroundCorner, /*String*/ HoverHelpTooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
            // summary:
            //		Private function to set CSS for HoverHelpTooltip node based on which position it's in.
            //		This is called by the dijit popup code.   It will also reduce the HoverHelpTooltip's
            //		width to whatever width is available
            // tags:
            //		protected
            this.connectorNode.style.top = ""; //reset to default
            //Adjust the spaceAvailable width, without changing the spaceAvailable object
            var HoverHelpTooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;
            
            node.className = "idxOneuiHoverHelpTooltip " +
            {
                "MR-ML": "idxOneuiHoverHelpTooltipRight",
                "ML-MR": "idxOneuiHoverHelpTooltipLeft",
                "TM-BM": "idxOneuiHoverHelpTooltipAbove",
                "BM-TM": "idxOneuiHoverHelpTooltipBelow",
                "BL-TL": "idxOneuiHoverHelpTooltipBelow idxOneuiHoverHelpTooltipABLeft",
                "TL-BL": "idxOneuiHoverHelpTooltipAbove idxOneuiHoverHelpTooltipABLeft",
                "BR-TR": "idxOneuiHoverHelpTooltipBelow idxOneuiHoverHelpTooltipABRight",
                "TR-BR": "idxOneuiHoverHelpTooltipAbove idxOneuiHoverHelpTooltipABRight",
                "BR-BL": "idxOneuiHoverHelpTooltipRight",
                "BL-BR": "idxOneuiHoverHelpTooltipLeft",
                "TR-TL": "idxOneuiHoverHelpTooltipRight"
            }[aroundCorner + "-" + HoverHelpTooltipCorner];
            
            // reduce HoverHelpTooltip's width to the amount of width available, so that it doesn't overflow screen
            this.domNode.style.width = "auto";
            var size = domGeometry.position(this.domNode);
            
            var width = Math.min((Math.max(HoverHelpTooltipSpaceAvaliableWidth, 1)), size.w);
            var widthWasReduced = width < size.w;
            
            this.domNode.style.width = width + "px";
            
            //Adjust width for HoverHelpTooltips that have a really long word or a nowrap setting
            if (widthWasReduced) {
                this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our HoverHelpTooltip needs to be wider to support the content
                var scrollWidth = this.containerNode.scrollWidth;
                this.containerNode.style.overflow = "visible"; //change it back
                if (scrollWidth > width) {
                    scrollWidth = scrollWidth + domStyle.get(this.domNode, "paddingLeft") + domStyle.get(this.domNode, "paddingRight");
                    this.domNode.style.width = scrollWidth + "px";
                }
            }
            
            // Reposition the HoverHelpTooltip connector.
            if (HoverHelpTooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B') {
                var mb = domGeometry.getMarginBox(node);
                var HoverHelpTooltipConnectorHeight = this.connectorNode.offsetHeight;
                if (mb.h > spaceAvailable.h) {
                    // The HoverHelpTooltip starts at the top of the page and will extend past the aroundNode
                    var aroundNodePlacement = spaceAvailable.h - ((aroundNodeCoords.h + HoverHelpTooltipConnectorHeight) >> 1);
                    this.connectorNode.style.top = aroundNodePlacement + "px";
                    this.connectorNode.style.bottom = "";
                }
                else {
                    // Align center of connector with center of aroundNode, except don't let bottom
                    // of connector extend below bottom of HoverHelpTooltip content, or top of connector
                    // extend past top of HoverHelpTooltip content
                    this.connectorNode.style.bottom = Math.min(Math.max(aroundNodeCoords.h / 2 - HoverHelpTooltipConnectorHeight / 2, 0), mb.h - HoverHelpTooltipConnectorHeight) +
                    "px";
                    this.connectorNode.style.top = "";
                }
            }
            else {
                // reset the HoverHelpTooltip back to the defaults
                this.connectorNode.style.top = "";
                this.connectorNode.style.bottom = "";
            }
            
            return Math.max(0, size.w - HoverHelpTooltipSpaceAvaliableWidth);
        },
        
        focus: function(){
			if(this._focus){return;}
            this._getFocusItems(this.outerContainerNode);
            this._focus = true;
            dijitfocus.focus(this._firstFocusItem);
        },
        
        _onShow: function(){
            // summary:
            //		Called at end of fade-in operation
            // tags:
            //		protected
            if (has("ie")) {
                // the arrow won't show up on a node w/an opacity filter
                this.domNode.style.filter = "";
            }
            domAttr.set(this.containerNode, "tabindex", "0");
            domAttr.set(this.learnMoreNode, "tabindex", "0");
            domAttr.set(this.closeButtonNode, "tabindex", "0");
        },
        
        hide: function(aroundNode, force){
            // summary:
            //		Hide the HoverHelpTooltip
            if(this._keepShowing){
            	this._keepShowing = false; 
            	if (!force) return;
            }
            if (this._onDeck && this._onDeck[1] == aroundNode) {
                // this hide request is for a show() that hasn't even started yet;
                // just cancel the pending show()
                this._onDeck = null;
            }
            else if(this.aroundNode === aroundNode){
                    // this hide request is for the currently displayed HoverHelpTooltip
                return this._forceHide();
            }
        },
        hideOnClickClose: function(){
            // summary:
            //		Hide the HoverHelpTooltip
            // this hide request is for the currently displayed HoverHelpTooltip    
            this._forceHide(true);
        },
        
        // CHANGE FROM BARRY: added "refocus" parameter so that refocus only happens on hiding the tooltip
        // if the user initiated the hide via "hideOnClickClose" or "ESC" key.  this prevents toltips that
        // are disappearing because their associated field blurred focus from refocusing the field that was
        // just blurred.  programmatic hiding/showing of the tooltip makes this problem evident
        _forceHide: function(refocus){
        	// CHANGE FROM BARRY
        	// only refocus if flag is set and the node is defined
            if (refocus && this._lastFocusNode) {
            	// check if the defined node has an enclosing widget with a "refocus" method
            	var currentWrapWidget = registry.getEnclosingWidget(this._lastFocusNode);
            	
            	// if the widget is found and has a refocus method then call it, else focus the node
            	if (currentWrapWidget && lang.isFunction(currentWrapWidget.refocus)) currentWrapWidget.refocus();
            	else dijitfocus.focus(this._lastFocusNode);
            }
            
            // CHANGE FROM BARRY
            // We save the state of this instance in case the "_forceHide" is cancelled by a "mouseenter"
            // event.  We need to restore the state after cancellingt he fadeOut and fading the tooltip 
            // back in.
            if ((this.aroundNode)||(this._lastFocusNode)) {
            	this._prevState = {
            			_lastFocusNode: this._lastFocusNode,
            			_firstFocusItem: this._firstFocusItem,
            			_lastFocusItem: this._lastFocusItem,
            			_focus: this._focus,
            			isShowingNow: this.isShowingNow,
            			aroundNode: this.aroundNode
            	};
            }
			this._lastFocusNode = null;
			this._firstFocusItem = null;
			this._lastFocusItem = null;
            this._focus = false;
            this.fadeIn.stop();
            this.isShowingNow = false;
			this.aroundNode = null; // moved this to here, similar to dijit.Tooltip
			//this._removeFromPopupStack();
            return this.fadeOut.play();
        },
        _getFocusItems: function(){
            // summary:
            //		Finds focusable items in tooltip,
            //		and sets this._firstFocusItem and this._lastFocusItem
            // tags:
            //		protected
			
			if(this._firstFocusItem){
				this._firstFocusItem = this.closeButtonNode;
				return;
			}
			var elems = a11y._getTabNavigable(this.containerNode),
				endFocusableNode = domStyle.get(this.learnMoreNode, "display") == "none" ? this.closeButtonNode : this.learnMoreNode;
			this._firstFocusItem = elems.lowest || elems.first || endFocusableNode;
			this._lastFocusItem = elems.last || elems.highest || endFocusableNode;
        },
        _onKey: function(/*Event*/evt){
            // summary:
            //		Handler for keyboard events
            // description:
            // tags:
            //		private
            
            var node = evt.target;
            if (evt.charOrCode === keys.TAB) {
                this._getFocusItems(this.outerContainerNode);
            }
            var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
            if (evt.charOrCode == keys.ESCAPE) {
                // Use setTimeout to avoid crash on IE, see #10396.
                setTimeout(lang.hitch(this, "hideOnClickClose"), 0);
                event.stop(evt);
            }
            else 
                if (node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB) {
                    if (!singleFocusItem) {
                        dijitfocus.focus(this._lastFocusItem); // send focus to last item in dialog
                    }
                    event.stop(evt);
                }
                else 
                    if (node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey) {
                        if (!singleFocusItem) {
                            dijitfocus.focus(this._firstFocusItem); // send focus to first item in dialog
                        }
                        event.stop(evt);
                    }
                    else 
                        if (evt.charOrCode === keys.TAB) {
                            // we want the browser's default tab handling to move focus
                            // but we don't want the tab to propagate upwards
                            evt.stopPropagation();
                        }
        },
        _onHide: function(){
            // summary:
            //		Called at end of fade-out operation
            // tags:
            //		protected
            this._prevState = null;
            this.domNode.style.cssText = ""; // to position offscreen again
            this.containerNode.innerHTML = "";
			//domStyle.set(this._popupWrapper, "display", "none");
            domAttr.remove(this.containerNode, "tabindex");
            domAttr.remove(this.learnMoreNode, "tabindex");
            domAttr.remove(this.closeButtonNode, "tabindex");      
			domAttr.remove(this.domNode, "aria-label");      
            if (this._onDeck) {
            	var args = this._onDeck;
            	this._onDeck = null;
                // a show request has been queued up; do it now
                this.show.apply(this, args);
            }
        },
        onBlur: function(){
            this._forceHide();
        }
    }); //end declare
    //    var MasterHoverHelpTooltip = Tooltip._MasterTooltip;
    HoverHelpTooltip._MasterHoverHelpTooltip = MasterHoverHelpTooltip = has("dojo-bidi")? declare("idx.widget._MasterHoverHelpTooltip",[MasterHoverHelpTooltipBase,bidiExtension]) : MasterHoverHelpTooltipBase; // for monkey patching
    // summary:
    //		Static method to display HoverHelpTooltip w/specified contents in specified position.
    //		See description of idx.widget.HoverHelpTooltip.defaultPosition for details on position parameter.
    //		If position is not specified then idx.widget.HoverHelpTooltip.defaultPosition is used.
    // innerHTML: String
    //		Contents of the HoverHelpTooltip
    // aroundNode: dijit.__Rectangle
    //		Specifies that HoverHelpTooltip should be next to this node / area
    // position: String[]?
    //		List of positions to try to position HoverHelpTooltip (ex: ["right", "above"])
    // rtl: Boolean?
    //		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
    //		means "rtl"; specifies GUI direction, not text direction.
    // textDir: String?
    //		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.	
    HoverHelpTooltip.show = idx.widget.showHoverHelpTooltip = function(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, learnMoreLinkValue, showCloseIcon, forceFocus, ariaLabel){
    
        if (!HoverHelpTooltip._masterTT) {
            idx.widget._masterTT = HoverHelpTooltip._masterTT = new MasterHoverHelpTooltip();
        }
        return HoverHelpTooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, showLearnMore, learnMoreLinkValue, showCloseIcon, forceFocus, ariaLabel);
    };
    
    // summary:
    //		Static method to hide the HoverHelpTooltip displayed via showHoverHelpTooltip()
    HoverHelpTooltip.hide = idx.widget.hideHoverHelpTooltip = function(aroundNode){
    
        return HoverHelpTooltip._masterTT && HoverHelpTooltip._masterTT.hide(aroundNode);
    };
    
    HoverHelpTooltip.defaultPosition = ["after-centered", "before-centered", "below", "above"];
    
    // for IDX 1.2 compatibility
	oneuiRoot.HoverHelpTooltip = HoverHelpTooltip;

    return HoverHelpTooltip;
    
});

},
'curam/util/RuntimeContext':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare'
        ], function(declare) {

/*
 * Modification History
 * --------------------
 * 02-Aug-2011  MV  [CR00283023] Added the contextObject() function.
 * 21-Jun-2011  KW  [CR00275353] Initial version.
 */

/**
 * @name curam.util.RuntimeContext
 * @namespace Provides access to the browser Window object.
 * 
   */
  var RuntimeContext = declare("curam.util.RuntimeContext", null, {

  /**
   * @private
   */
  _window: null,

  /**
   * comments to follow
   *
   * @constructor
   * @private
   */
  constructor: function(window) {
    this._window = window;
  },
  
  /**
   * Comments to follow
   * 
   */
  getHref: function(){
    return this._window.location.href;
  },
  
  /**
   * Returns the path name of the url from the window's location object.
   * @Returns {String} Url path name.
   */
  getPathName: function() {
    return this._window.location.pathName;
  },

  /**
   * Returns the underlying context object of this runtime context.
   * @returns The underlying context object of this runtime context.
   */
  contextObject: function() {
    return this._window;
  }
  });
  
  return RuntimeContext;
});

},
'dijit/_KeyNavContainer':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/lang", // lang.hitch
	"./registry",
	"./_Container",
	"./_FocusMixin",
	"./_KeyNavMixin"
], function(array, declare, domAttr, kernel, keys, lang, registry, _Container, _FocusMixin, _KeyNavMixin){


	// module:
	//		dijit/_KeyNavContainer

	return declare("dijit._KeyNavContainer", [_FocusMixin, _KeyNavMixin, _Container], {
		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		Provides normalized keyboard and focusing code for Container widgets.
		//		To use this mixin, call connectKeyNavHandlers() in postCreate().
		//		Also, child widgets must implement a focus() method.

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Deprecated.  You can call this in postCreate() to attach the keyboard handlers to the container,
			//		but the preferred method is to override _onLeftArrow() and _onRightArrow(), or
			//		_onUpArrow() and _onDownArrow(), to call focusPrev() and focusNext().
			// prevKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: remove for 2.0, and make subclasses override _onLeftArrow, _onRightArrow etc. instead.

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){
				keyCodes[code] = prev;
			});
			array.forEach(nextKeyCodes, function(code){
				keyCodes[code] = next;
			});
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		_startupChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Setup for each child widget.
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			//
			//		Note: if you add children by a different method than addChild(), then need to call this manually
			//		or at least make sure the child's tabIndex is -1.
			//
			//		Note: see also _LayoutWidget.setupChild(), which is also called for each child widget.
			// tags:
			//		private

			widget.set("tabIndex", "-1");
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[children.length - 1] : null;
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this;
		}
	});
});

},
'dijit/layout/utils':function(){
define([
    "dojo/_base/array", // array.filter array.forEach
    "dojo/dom-class", // domClass.add domClass.remove
    "dojo/dom-geometry", // domGeometry.marginBox
    "dojo/dom-style", // domStyle.getComputedStyle
    "dojo/_base/lang" // lang.mixin, lang.setObject
], function(array, domClass, domGeometry, domStyle, lang){

    // module:
    //    dijit/layout/utils

    function capitalize(word){
      return word.substring(0,1).toUpperCase() + word.substring(1);
    }

    function size(widget, dim){
      // size the child
      var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

    /* CURAM-FIX: addition */
    if (widget.fakeWidget) {
      return;
    }
    /* END CURAM-FIX */


    // record child's size
    if(newSize){
      // if the child returned it's new size then use that
      lang.mixin(widget, newSize);
    }else{
      // otherwise, call getMarginBox(), but favor our own numbers when we have them.
      // the browser lies sometimes
      /* CURAM-FIX: replace following line */
      //  lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
      lang.mixin(widget, domGeometry.getMarginBoxSimple(widget.domNode));
      /* END CURAM-FIX */
    }
  }

    var utils = {
      // summary:
      //    Utility functions for doing layout

      marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
        // summary:
        //    Given the margin-box size of a node, return its content box size.
        //    Functions like domGeometry.contentBox() but is more reliable since it doesn't have
        //    to wait for the browser to compute sizes.
        var cs = domStyle.getComputedStyle(node);
        var me = domGeometry.getMarginExtents(node, cs);
        var pb = domGeometry.getPadBorderExtents(node, cs);
        return {
          l: domStyle.toPixelValue(node, cs.paddingLeft),
          t: domStyle.toPixelValue(node, cs.paddingTop),
          w: mb.w - (me.w + pb.w),
          h: mb.h - (me.h + pb.h)
        };
      },

      layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
                        /*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
        // summary:
        //    Layout a bunch of child dom nodes within a parent dom node
        //    container:
        //      parent node
        //    dim:
        //      {l, t, w, h} object specifying dimensions of container into which to place children
        //    children:
        //      An array of Widgets or at least objects containing:
        //
        // - domNode: pointer to DOM node to position
        // - region or layoutAlign: position to place DOM node
        // - resize(): (optional) method to set size of node
        // - id: (optional) Id of widgets, referenced from resize object, below.
        //
        //    The widgets in this array should be ordered according to how they should be laid out
        //    (each element will be processed in order, and take up as much remaining space as needed),
        //    with the center widget last.
        //    changedRegionId:
        //      If specified, the slider for the region with the specified id has been dragged, and thus
        //      the region's height or width should be adjusted according to changedRegionSize
        //    changedRegionSize:
        //      See changedRegionId.

        // copy dim because we are going to modify it
        dim = lang.mixin({}, dim);
        domClass.add(container, "dijitLayoutContainer");

        // Move "client" elements to the end of the array for layout.  a11y dictates that the author
        // needs to be able to put them in the document in tab-order, but this algorithm requires that
        // client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
        children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
                     .concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

        /* CURAM-FIX: added next line */
        var retDim = {};

        // set positions/sizes
        array.forEach(children,
          function(child){
            var elm =
              child.domNode,
                pos = (child.region || child.layoutAlign);
            if(!pos){
              throw new Error("No region setting for " + child.id)
            }

            // set elem to upper left corner of unused space; may move it later
            var elmStyle = elm.style;
            elmStyle.left = dim.l+"px";
            elmStyle.top = dim.t+"px";
            elmStyle.position = "absolute";

            domClass.add(elm, "dijitAlign" + capitalize(pos));

            // Size adjustments to make to this child widget
            var sizeSetting = {};

            // Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
            // panes and width adjustment for left/right align panes.
            if(changedRegionId && changedRegionId == child.id){
              sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
            }

            if(pos == "leading"){
              pos = child.isLeftToRight() ? "left" : "right";
            }
            if(pos == "trailing"){
              pos = child.isLeftToRight() ? "right" : "left";
            }

            // set size && adjust record of remaining space.
            // note that setting the width of a <div> may affect its height.
            if(pos == "top" || pos == "bottom"){
              sizeSetting.w = dim.w;
              size(child, sizeSetting);
              dim.h -= child.h;
              if(pos == "top"){
                dim.t += child.h;
              }else{
                elmStyle.top = dim.t + dim.h + "px";
              }
            }else if(pos == "left" || pos == "right"){
              sizeSetting.h = dim.h;
              size(child, sizeSetting);	
              /* CURAM-FIX: addition */		 
			  if(child.isSplitter)
			  {
				//Reset the left attribute to not include the width
				elmStyle.left = dim.l - child.w +"px";
				dim.w += child.w; 
			  } else {
				dim.w -= child.w;  
			  }
              /* END CURAM-FIX */
              if(pos == "left"){
              /* CURAM-FIX: addition */
				if(!child.isSplitter)
				{
					dim.l += child.w;
				}
              /* END CURAM-FIX */
              }else{
              /* CURAM-FIX: addition */
				if(child.isSplitter)
				{
					elmStyle.left = dim.l + dim.w - child.w + "px";
					dim.l += child.w;
				} else {
					elmStyle.left = dim.l + dim.w + "px";
				}
              /* END CURAM-FIX */
              }
            }else if(pos == "client" || pos == "center"){
              size(child, dim);
            }
            /* CURAM-FIX: addition */
            retDim[pos] = {
              w: dim.w,
              h: dim.h
            };
            /* END CURAM-FIX */
        });		
        /* CURAM-FIX: addition next line */
        return retDim;
      }
    };

    lang.setObject("dijit.layout.utils", utils); // remove for 2.0

    return utils;
});

},
'dijit/_Contained':function(){
define([
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		// example:
		//	|	// make a basic custom widget that knows about its parents
		//	|	declare("my.customClass",[dijit._WidgetBase, dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//		Returns next or previous sibling
			// which:
			//		Either "next" or "previous"
			// tags:
			//		private
			var p = this.getParent();
			return (p && p._getSiblingOfChild && p._getSiblingOfChild(this, which == "previous" ? -1 : 1)) || null;	// dijit/_WidgetBase
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit/_WidgetBase
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit/_WidgetBase
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit/_Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'dijit/form/DataList':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/lang", // lang.trim
	"dojo/query", // query
	"dojo/store/Memory",
	"../registry"	// registry.add registry.remove
], function(declare, dom, lang, query, MemoryStore, registry){

	// module:
	//		dijit/form/DataList

	function toItem(/*DOMNode*/ option){
		// summary:
		//		Convert `<option>` node to hash
		return {
			id: option.value,
			value: option.value,
			name: lang.trim(option.innerText || option.textContent || '')
		};
	}

	return declare("dijit.form.DataList", MemoryStore, {
		// summary:
		//		Inefficient but small data store specialized for inlined data via OPTION tags
		//
		// description:
		//		Provides a store for inlined data like:
		//
		//	|	<datalist>
		//	|		<option value="AL">Alabama</option>
		//	|		...

		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String
			//		Attach widget to this DOM node.

			// store pointer to original DOM tree
			this.domNode = dom.byId(srcNodeRef);

			lang.mixin(this, params);
			if(this.id){
				registry.add(this); // add to registry so it can be easily found by id
			}
			this.domNode.style.display = "none";

			this.inherited(arguments, [{
				data: query("option", this.domNode).map(toItem)
			}]);
		},

		destroy: function(){
			registry.remove(this.id);
		},

		fetchSelectedItem: function(){
			// summary:
			//		Get the option marked as selected, like `<option selected>`.
			//		Not part of dojo.data API.
			var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
			return option && toItem(option);
		}
	});
});

},
'dijit/_Container':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"dojo/_base/kernel" // kernel.deprecated
], function(array, declare, domConstruct, kernel){

	// module:
	//		dijit/_Container

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain HTML and/or a set of widget children.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// All widgets with descendants must set containerNode.
				// NB: this code doesn't quite work right because for TabContainer it runs before
				// _TemplatedMixin::buildRendering(), and thus
				// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.
				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting
			// is thrown off by text nodes and comment nodes that show up when constructed by markup.
			// In the future consider stripping those nodes on construction, either in the parser or this widget code.
			var refNode = this.containerNode;
			if(insertIndex > 0){
				// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query
				// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.
				refNode = refNode.firstChild;
				while(insertIndex > 0){
					if(refNode.nodeType == 1){ insertIndex--; }
					refNode = refNode.nextSibling;
				}
				if(refNode){
					insertIndex = "before";
				}else{
					// to support addChild(child, n-1) where there are n children (should add child at end)
					refNode = this.containerNode;
					insertIndex = "last";
				}
			}

			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove (ie, removeChild(5) removes the sixth widget).

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//		private
			var children = this.getChildren(),
				idx = array.indexOf(children, child);	// int
			return children[idx + dir];
		},

		getIndexOfChild: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'dijit/form/ValidationTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang",
	"dojo/i18n", // i18n.getLocalization
	"./TextBox",
	"../Tooltip",
	"dojo/text!./templates/ValidationTextBox.html",
	"dojo/i18n!./nls/validate"
], function(declare, kernel, lang, i18n, TextBox, Tooltip, template){

	// module:
	//		dijit/form/ValidationTextBox


	var ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.

		templateString: template,

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		//		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		//		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: ValidationTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input as well as
		//		formatting options.  See `dijit/form/ValidationTextBox.__Constraints` for details.
		constraints:{},

		// pattern: [extension protected] String|Function(constraints) returning a string.
		//		This defines the regular expression used to validate the input.
		//		Do not add leading ^ or $ characters since the widget adds these.
		//		A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
		//		set('pattern', String|Function).
		pattern: ".*",

		// regExp: Deprecated [extension protected] String.  Use "pattern" instead.
		regExp: "",

		regExpGen: function(/*__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Deprecated.  Use set('pattern', Function) instead.
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_deprecateRegExp: function(attr, value){
			if(value != ValidationTextBox.prototype[attr]){
				kernel.deprecated("ValidationTextBox id="+this.id+", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
				this.set('pattern', value);
			}
		},
		_setRegExpGenAttr: function(/*Function*/ newFcn){
			this._deprecateRegExp("regExpGen", newFcn);
			this._set("regExpGen", this._computeRegexp); // backward compat with this.regExpGen(this.constraints)
		},
		_setRegExpAttr: function(/*String*/ value){
			this._deprecateRegExp("regExp", value);
		},

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this._refreshState();
		},

		validator: function(/*anything*/ value, /*__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.get('constraints'));
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage :
				!this.invalidMessage ? this.promptMessage : this.invalidMessage;
			var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage :
				!this.missingMessage ? invalid : this.missingMessage;
			return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", this.state == "Error" ? "true" : "false");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			if(this._created){ // should instead be this._started but that would require all programmatic ValidationTextBox instantiations to call startup()
				this.validate(this.focused);
			}
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this.constraints = lang.clone(this.constraints);
			this.baseClass += ' dijitValidationTextBox';
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setConstraintsAttr: function(/*__Constraints*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._refreshState();
		},

		_setPatternAttr: function(/*String|Function*/ pattern){
			this._set("pattern", pattern); // don't set on INPUT to avoid native HTML5 validation
			this._refreshState();
		},

		_computeRegexp: function(/*__Constraints*/ constraints){
			// summary:
			//		Hook to get the current regExp and to compute the partial validation RE.

			var p = this.pattern;
			if(typeof p == "function"){
				p = p.call(this, constraints);
			}
			if(p != this._lastRegExp){
				var partialre = "";
				this._lastRegExp = p;
				// parse the regexp and produce a new regexp that matches valid subsets
				// if the regexp is .* then there's no use in matching subsets since everything is valid
				if(p != ".*"){
					p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
					function(re){
						switch(re.charAt(0)){
							case '{':
							case '+':
							case '?':
							case '*':
							case '^':
							case '$':
							case '|':
							case '(':
								partialre += re;
								break;
							case ")":
								partialre += "|$)";
								break;
							 default:
								partialre += "(?:"+re+"|$)";
								break;
						}
					});
				}
				try{ // this is needed for now since the above regexp parsing needs more test verification
					"".search(partialre);
				}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
					partialre = this.pattern;
					console.warn('RegExp error in ' + this.declaredClass + ': ' + this.pattern);
				} // should never be here unless the original RE is bad or the parsing is bad
				this._partialre = "^(?:" + partialre + ")$";
			}
			return p;
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit/form/TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		},

		destroy: function(){
			Tooltip.hide(this.domNode);	// in case tooltip show when ValidationTextBox (or enclosing Dialog) destroyed
			this.inherited(arguments);
		}
	});

	/*=====
	 ValidationTextBox.__Constraints = {
		 // locale: String
		 //		locale used for validation, picks up value from this widget's lang attribute
		 // _flags_: anything
		 //		various flags passed to pattern function
	 };
	 =====*/

	return ValidationTextBox;
});

},
'dijit/selection':function(){
define([
	"dojo/_base/array",
	"dojo/dom", // dom.byId
	"dojo/_base/lang",
	"dojo/sniff", // has("ie") has("opera")
	"dojo/_base/window",
	"dijit/focus"
], function(array, dom, lang, has, baseWindow, focus){

	// module:
	//		dijit/selection

	// Note that this class is using feature detection, but doesn't use has() because sometimes on IE the outer window
	// may be running in standards mode (ie, IE9 mode) but an iframe may be in compatibility mode.   So the code path
	// used will vary based on the window.

	var SelectionManager = function(win){
		// summary:
		//		Class for monitoring / changing the selection (typically highlighted text) in a given window
		// win: Window
		//		The window to monitor/adjust the selection on.

		var doc = win.document;

		this.getType = function(){
			// summary:
			//		Get the selection type (like doc.select.type in IE).
			if(doc.getSelection){
				// W3C path
				var stype = "text";

				// Check if the actual selection is a CONTROL (IMG, TABLE, HR, etc...).
				var oSel;
				try{
					oSel = win.getSelection();
				}catch(e){ /*squelch*/ }

				if(oSel && oSel.rangeCount == 1){
					var oRange = oSel.getRangeAt(0);
					if(	(oRange.startContainer == oRange.endContainer) &&
						((oRange.endOffset - oRange.startOffset) == 1) &&
						(oRange.startContainer.nodeType != 3 /* text node*/)
						){
						stype = "control";
					}
				}
				return stype; //String
			}else{
				// IE6-8
				return doc.selection.type.toLowerCase();
			}
		};

		this.getSelectedText = function(){
			// summary:
			//		Return the text (no html tags) included in the current selection or null if no text is selected
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				return selection ? selection.toString() : ""; //String
			}else{
				// IE6-8
				if(this.getType() == 'control'){
					return null;
				}
				return doc.selection.createRange().text;
			}
		};

		this.getSelectedHtml = function(){
			// summary:
			//		Return the html text of the current selection or null if unavailable
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				if(selection && selection.rangeCount){
					var i;
					var html = "";
					for(i = 0; i < selection.rangeCount; i++){
						//Handle selections spanning ranges, such as Opera
						var frag = selection.getRangeAt(i).cloneContents();
						var div = doc.createElement("div");
						div.appendChild(frag);
						html += div.innerHTML;
					}
					return html; //String
				}
				return null;
			}else{
				// IE6-8
				if(this.getType() == 'control'){
					return null;
				}
				return doc.selection.createRange().htmlText;
			}
		};

		this.getSelectedElement = function(){
			// summary:
			//		Retrieves the selected element (if any), just in the case that
			//		a single element (object like and image or a table) is
			//		selected.
			if(this.getType() == "control"){
				if(doc.getSelection){
					// W3C path
					var selection = win.getSelection();
					return selection.anchorNode.childNodes[ selection.anchorOffset ];
				}else{
					// IE6-8
					var range = doc.selection.createRange();
					if(range && range.item){
						return doc.selection.createRange().item(0);
					}
				}
			}
			return null;
		};

		this.getParentElement = function(){
			// summary:
			//		Get the parent element of the current selection
			if(this.getType() == "control"){
				var p = this.getSelectedElement();
				if(p){ return p.parentNode; }
			}else{
				if(doc.getSelection){
					var selection = doc.getSelection();
					if(selection){
						var node = selection.anchorNode;
						while(node && (node.nodeType != 1)){ // not an element
							node = node.parentNode;
						}
						return node;
					}
				}else{
					var r = doc.selection.createRange();
					r.collapse(true);
					return r.parentElement();
				}
			}
			return null;
		};

		this.hasAncestorElement = function(/*String*/ tagName /* ... */){
			// summary:
			//		Check whether current selection has a  parent element which is
			//		of type tagName (or one of the other specified tagName)
			// tagName: String
			//		The tag name to determine if it has an ancestor of.
			return this.getAncestorElement.apply(this, arguments) != null; //Boolean
		};

		this.getAncestorElement = function(/*String*/ tagName /* ... */){
			// summary:
			//		Return the parent element of the current selection which is of
			//		type tagName (or one of the other specified tagName)
			// tagName: String
			//		The tag name to determine if it has an ancestor of.
			var node = this.getSelectedElement() || this.getParentElement();
			return this.getParentOfType(node, arguments); //DOMNode
		};

		this.isTag = function(/*DomNode*/ node, /*String[]*/ tags){
			// summary:
			//		Function to determine if a node is one of an array of tags.
			// node:
			//		The node to inspect.
			// tags:
			//		An array of tag name strings to check to see if the node matches.
			if(node && node.tagName){
				var _nlc = node.tagName.toLowerCase();
				for(var i=0; i<tags.length; i++){
					var _tlc = String(tags[i]).toLowerCase();
					if(_nlc == _tlc){
						return _tlc; // String
					}
				}
			}
			return "";
		};

		this.getParentOfType = function(/*DomNode*/ node, /*String[]*/ tags){
			// summary:
			//		Function to locate a parent node that matches one of a set of tags
			// node:
			//		The node to inspect.
			// tags:
			//		An array of tag name strings to check to see if the node matches.
			while(node){
				if(this.isTag(node, tags).length){
					return node; // DOMNode
				}
				node = node.parentNode;
			}
			return null;
		};

		this.collapse = function(/*Boolean*/ beginning){
			// summary:
			//		Function to collapse (clear), the current selection
			// beginning: Boolean
			//		Indicates whether to collapse the cursor to the beginning of the selection or end.
			if(doc.getSelection){
				// W3C path
				var selection = win.getSelection();
				if(selection.removeAllRanges){ // Mozilla
					if(beginning){
						selection.collapseToStart();
					}else{
						selection.collapseToEnd();
					}
				}else{ // Safari
					// pulled from WebCore/ecma/kjs_window.cpp, line 2536
					selection.collapse(beginning);
				}
			}else{
				// IE6-8
				var range = doc.selection.createRange();
				range.collapse(beginning);
				range.select();
			}
		};

		this.remove = function(){
			// summary:
			//		Function to delete the currently selected content from the document.
			var sel = doc.selection;
			if(doc.getSelection){
				// W3C path
				sel = win.getSelection();
				sel.deleteFromDocument();
				return sel; //Selection
			}else{
				// IE6-8
				if(sel.type.toLowerCase() != "none"){
					sel.clear();
				}
				return sel; //Selection
			}
		};

		this.selectElementChildren = function(/*DomNode*/ element, /*Boolean?*/ nochangefocus){
			// summary:
			//		clear previous selection and select the content of the node
			//		(excluding the node itself)
			// element: DOMNode
			//		The element you wish to select the children content of.
			// nochangefocus: Boolean
			//		Indicates if the focus should change or not.

			var range;
			element = dom.byId(element);
			if(doc.getSelection){
				// W3C
				var selection = win.getSelection();
				if(has("opera")){
					//Opera's selectAllChildren doesn't seem to work right
					//against <body> nodes and possibly others ... so
					//we use the W3C range API
					if(selection.rangeCount){
						range = selection.getRangeAt(0);
					}else{
						range = doc.createRange();
					}
					range.setStart(element, 0);
					range.setEnd(element,(element.nodeType == 3) ? element.length : element.childNodes.length);
					selection.addRange(range);
				}else{
					selection.selectAllChildren(element);
				}
			}else{
				// IE6-8
				range = element.ownerDocument.body.createTextRange();
				range.moveToElementText(element);
				if(!nochangefocus){
					try{
						range.select(); // IE throws an exception here if the widget is hidden.  See #5439
					}catch(e){ /* squelch */}
				}
			}
		};

		this.selectElement = function(/*DomNode*/ element, /*Boolean?*/ nochangefocus){
			// summary:
			//		clear previous selection and select element (including all its children)
			// element: DOMNode
			//		The element to select.
			// nochangefocus: Boolean
			//		Boolean indicating if the focus should be changed.  IE only.
			var range;
			element = dom.byId(element);	// TODO: remove for 2.0 or sooner, spec listed above doesn't allow for string
			if(doc.getSelection){
				// W3C path
				var selection = doc.getSelection();
				range = doc.createRange();
				if(selection.removeAllRanges){ // Mozilla
					// FIXME: does this work on Safari?
					if(has("opera")){
						//Opera works if you use the current range on
						//the selection if present.
						if(selection.getRangeAt(0)){
							range = selection.getRangeAt(0);
						}
					}
					range.selectNode(element);
					selection.removeAllRanges();
					selection.addRange(range);
				}
			}else{
				// IE6-8
				try{
					var tg = element.tagName ? element.tagName.toLowerCase() : "";
					if(tg === "img" || tg === "table"){
						range = baseWindow.body(doc).createControlRange();
					}else{
						range = baseWindow.body(doc).createRange();
					}
					range.addElement(element);
					if(!nochangefocus){
						range.select();
					}
				}catch(e){
					this.selectElementChildren(element, nochangefocus);
				}
			}
		};

		this.inSelection = function(node){
			// summary:
			//		This function determines if 'node' is
			//		in the current selection.
			// tags:
			//		public
			if(node){
				var newRange;
				var range;

				if(doc.getSelection){
					// WC3
					var sel = win.getSelection();
					if(sel && sel.rangeCount > 0){
						range = sel.getRangeAt(0);
					}
					if(range && range.compareBoundaryPoints && doc.createRange){
						try{
							newRange = doc.createRange();
							newRange.setStart(node, 0);
							if(range.compareBoundaryPoints(range.START_TO_END, newRange) === 1){
								return true;
							}
						}catch(e){ /* squelch */}
					}
				}else{
					// IE6-8, so we can't use the range object as the pseudo
					// range doesn't implement the boundary checking, we have to
					// use IE specific crud.
					range = doc.selection.createRange();
					try{
						newRange = node.ownerDocument.body.createTextRange();
						newRange.moveToElementText(node);
					}catch(e2){/* squelch */}
					if(range && newRange){
						// We can finally compare similar to W3C
						if(range.compareEndPoints("EndToStart", newRange) === 1){
							return true;
						}
					}
				}
			}
			return false; // Boolean
		};

		this.getBookmark = function(){
			// summary:
			//		Retrieves a bookmark that can be used with moveToBookmark to reselect the currently selected range.

			// TODO: merge additional code from Editor._getBookmark into this method

			var bm, rg, tg, sel = doc.selection, cf = focus.curNode;

			if(doc.getSelection){
				// W3C Range API for selections.
				sel = win.getSelection();
				if(sel){
					if(sel.isCollapsed){
						tg = cf? cf.tagName : "";
						if(tg){
							// Create a fake rangelike item to restore selections.
							tg = tg.toLowerCase();
							if(tg == "textarea" ||
								(tg == "input" && (!cf.type || cf.type.toLowerCase() == "text"))){
								sel = {
									start: cf.selectionStart,
									end: cf.selectionEnd,
									node: cf,
									pRange: true
								};
								return {isCollapsed: (sel.end <= sel.start), mark: sel}; //Object.
							}
						}
						bm = {isCollapsed:true};
						if(sel.rangeCount){
							bm.mark = sel.getRangeAt(0).cloneRange();
						}
					}else{
						rg = sel.getRangeAt(0);
						bm = {isCollapsed: false, mark: rg.cloneRange()};
					}
				}
			}else if(sel){
				// If the current focus was a input of some sort and no selection, don't bother saving
				// a native bookmark.  This is because it causes issues with dialog/page selection restore.
				// So, we need to create pseudo bookmarks to work with.
				tg = cf ? cf.tagName : "";
				tg = tg.toLowerCase();
				if(cf && tg && (tg == "button" || tg == "textarea" || tg == "input")){
					if(sel.type && sel.type.toLowerCase() == "none"){
						return {
							isCollapsed: true,
							mark: null
						}
					}else{
						rg = sel.createRange();
						return {
							isCollapsed: rg.text && rg.text.length?false:true,
							mark: {
								range: rg,
								pRange: true
							}
						};
					}
				}
				bm = {};

				//'IE' way for selections.
				try{
					// createRange() throws exception when dojo in iframe
					// and nothing selected, see #9632
					rg = sel.createRange();
					bm.isCollapsed = !(sel.type == 'Text' ? rg.htmlText.length : rg.length);
				}catch(e){
					bm.isCollapsed = true;
					return bm;
				}
				if(sel.type.toUpperCase() == 'CONTROL'){
					if(rg.length){
						bm.mark=[];
						var i=0,len=rg.length;
						while(i<len){
							bm.mark.push(rg.item(i++));
						}
					}else{
						bm.isCollapsed = true;
						bm.mark = null;
					}
				}else{
					bm.mark = rg.getBookmark();
				}
			}else{
				console.warn("No idea how to store the current selection for this browser!");
			}
			return bm; // Object
		};

		this.moveToBookmark = function(/*Object*/ bookmark){
			// summary:
			//		Moves current selection to a bookmark.
			// bookmark:
			//		This should be a returned object from getBookmark().

			// TODO: merge additional code from Editor._moveToBookmark into this method

			var mark = bookmark.mark;
			if(mark){
				if(doc.getSelection){
					// W3C Range API (FF, WebKit, Opera, etc)
					var sel = win.getSelection();
					if(sel && sel.removeAllRanges){
						if(mark.pRange){
							var n = mark.node;
							n.selectionStart = mark.start;
							n.selectionEnd = mark.end;
						}else{
							sel.removeAllRanges();
							sel.addRange(mark);
						}
					}else{
						console.warn("No idea how to restore selection for this browser!");
					}
				}else if(doc.selection && mark){
					//'IE' way.
					var rg;
					if(mark.pRange){
						rg = mark.range;
					}else if(lang.isArray(mark)){
						rg = doc.body.createControlRange();
						//rg.addElement does not have call/apply method, so can not call it directly
						//rg is not available in "range.addElement(item)", so can't use that either
						array.forEach(mark, function(n){
							rg.addElement(n);
						});
					}else{
						rg = doc.body.createTextRange();
						rg.moveToBookmark(mark);
					}
					rg.select();
				}
			}
		};

		this.isCollapsed = function(){
			// summary:
			//		Returns true if there is no text selected
			return this.getBookmark().isCollapsed;
		};
	};

	// singleton on the main window
	var selection = new SelectionManager(window);

	// hook for editor to use class
	selection.SelectionManager = SelectionManager;

	return selection;
});

},
'dijit/_base/typematic':function(){
define(["../typematic"], function(){

	/*=====
	return {
		// summary:
		//		Deprecated, for back-compat, just loads top level module
	};
	=====*/

});

},
'dijit/_base':function(){
define([
	"./main",
	"./a11y",	// used to be in dijit/_base/manager
	"./WidgetSet",	// used to be in dijit/_base/manager
	"./_base/focus",
	"./_base/manager",
	"./_base/place",
	"./_base/popup",
	"./_base/scroll",
	"./_base/sniff",
	"./_base/typematic",
	"./_base/wai",
	"./_base/window"
], function(dijit){

	// module:
	//		dijit/_base

	/*=====
	return {
		// summary:
		//		Includes all the modules in dijit/_base
	};
	=====*/

	return dijit._base;
});

},
'dojo/window':function(){
define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie") || has("trident"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
						&& ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){
							elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
						}
						elPos.x = 0;
						elPos.y = 0;
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	 1  && lang.setObject("dojo.window", window);

	return window;
});

},
'dijit/_FocusMixin':function(){
define([
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/_WidgetsInTemplateMixin':function(){
define([
	"dojo/_base/array", // forEach()
	"dojo/aspect", // after()
	"dojo/_base/declare", // declare()
	"dojo/_base/lang",	// hitch()
	"dojo/parser" // parse()
], function(array, aspect, declare, lang, parser){

	// module:
	//		dijit/_WidgetsInTemplateMixin

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		// contextRequire: Function
		//		Used to provide a context require to the dojo/parser in order to be
		//		able to use relative MIDs (e.g. `./Widget`) in the widget's template.
		contextRequire: null,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				if(this.containerNode && !this.searchContainerNode){
					// Tell parse call below not to look for widgets inside of this.containerNode
					this.containerNode.stopParser = true;
				}

				parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					contextRequire: this.contextRequire,
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}).then(lang.hitch(this, function(widgets){
					this._startupWidgets = widgets;

					// _WidgetBase::destroy() will destroy any supporting widgets under this.domNode.
					// If we wanted to, we could call this.own() on anything in this._startupWidgets that was moved outside
					// of this.domNode (like Dialog, which is moved to <body>).

					// Hook up attach points and events for nodes that were converted to widgets
					for(var i = 0; i < widgets.length; i++){
						this._processTemplateNode(widgets[i], function(n,p){
							// callback to get a property of a widget
							return n[p];
						}, function(widget, type, callback){
							// callback to do data-dojo-attach-event to a widget
							if(type in widget){
								// back-compat, remove for 2.0
								return widget.connect(widget, type, callback);
							}else{
								// 1.x may never hit this branch, but it's the default for 2.0
								return widget.on(type, callback, true);
							}
						});
					}

					// Cleanup flag set above, just in case
					if(this.containerNode && this.containerNode.stopParser){
						delete this.containerNode.stopParser;
					}
				}));

				if(!this._startupWidgets){
					throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " +
						"unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// Override _AttachMixin._processNode to skip DOMNodes with data-dojo-type set.   They are handled separately
			// in the _beforeFillContent() code above.

			if(getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")){
				return true;
			}

			return this.inherited(arguments);
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this._startupWidgets = null;
			this.inherited(arguments);
		}
	});
});

},
'dijit/form/FilteringSelect':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.mixin
	"dojo/when",
	"./MappedTextBox",
	"./ComboBoxMixin"
], function(declare, lang, when, MappedTextBox, ComboBoxMixin){

	// module:
	//		dijit/form/FilteringSelect

	return declare("dijit.form.FilteringSelect", [MappedTextBox, ComboBoxMixin], {
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//
		//		- There is a drop down list of possible values.
		//		- You can only enter a value from the drop down list.  (You can't
		//			enter an arbitrary value.)
		//		- The value submitted with the form is the hidden value (ex: CA),
		//			not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//
		//		- If you type in some text then it will filter down the list of
		//			possible values in the drop down list.
		//		- List can be specified either as a static list or via a javascript
		//			function (that can get the list from a server)

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		_isValidSubset: function(){
			return this._opened;
		},

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return !!this.item || (!this.required && this.get('displayedValue') == ""); // #5974
		},

		_refreshState: function(){
			if(!this.searchTimer){ // state will be refreshed after results are returned
				this.inherited(arguments);
			}
		},

		_callbackSetLabel: function(
						/*Array*/ result,
						/*Object*/ query,
						/*Object*/ options,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback from dojo.store after lookup of user entered value finishes

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((query && query[this.searchAttr] !== this._lastQuery) || (!query && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: don't modify display value on bad input
				//#3285: change CSS to indicate error
				this.set("value", '', priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
			}else{
				this.set('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// Callback when a data store query completes.
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(query[this.searchAttr] !== this._lastQuery){
				return;
			}
			this.inherited(arguments);

			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for get('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }

			if(item === undefined){
				if(value === null || value === ''){
					value = '';
					if(!lang.isString(displayedValue)){
						this._setDisplayedValueAttr(displayedValue||'', priorityChange);
						return;
					}
				}

				var self = this;
				this._lastQuery = value;
				when(this.store.get(value), function(item){
					self._callbackSetLabel(item? [item] : [], undefined, undefined, priorityChange);
				});
			}else{
				this.valueNode.value = value;
				this.inherited(arguments, [value, priorityChange, displayedValue, item]);
			}
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			this.inherited(arguments);
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.  label should corresponding to item.searchAttr.

			if(label == null){ label = ''; }

			// This is called at initialization along with every custom setter.
			// Usually (or always?) the call can be ignored.   If it needs to be
			// processed then at least make sure that the XHR request doesn't trigger an onChange()
			// event, even if it returns after creation has finished
			if(!this._created){
				if(!("displayedValue" in this.params)){
					return;
				}
				priorityChange = false;
			}

			// Do a reverse lookup to map the specified displayedValue to the hidden value.
			// Note that if there's a custom labelFunc() this code
			if(this.store){
				this.closeDropDown();
				var query = lang.clone(this.query); // #6196: populate query with user-specifics

				// Generate query
				var qs = this._getDisplayQueryString(label), q;
				if(this.store._oldAPI){
					// remove this branch for 2.0
					q = qs;
				}else{
					// Query on searchAttr is a regex for benefit of dojo/store/Memory,
					// but with a toString() method to help dojo/store/JsonRest.
					// Search string like "Co*" converted to regex like /^Co.*$/i.
					q = this._patternToRegExp(qs);
					q.toString = function(){ return qs; };
				}
				this._lastQuery = query[this.searchAttr] = q;

				// If the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox.   Set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				this._set("displayedValue", label);	// for watch("displayedValue") notification
				var _this = this;
				var options = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					}
				};
				lang.mixin(options, this.fetchProperties);
				this._fetchHandle = this.store.query(query, options);
				when(this._fetchHandle, function(result){
					_this._fetchHandle = null;
					_this._callbackSetLabel(result || [], query, options, priorityChange);
				}, function(err){
					_this._fetchHandle = null;
					if(!_this._cancelingQuery){	// don't treat canceled query as an error
						console.error('dijit.form.FilteringSelect: ' + err.toString());
					}
				});
			}
		},

		undo: function(){
			this.set('displayedValue', this._lastDisplayedValue);
		}
	});
});

},
'dijit/form/_ButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/has",
	"../registry"        // registry.byNode
], function(declare, dom, has, registry){

	// module:
	//		dijit/form/_ButtonMixin

	var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin to add a thin standard API wrapper to a normal HTML button
		// description:
		//		A label should always be specified (through innerHTML) or the label attribute.
		//
		//		Attach points:
		//
		//		- focusNode (required): this node receives focus
		//		- valueNode (optional): this node's value gets submitted with FORM elements
		//		- containerNode (optional): this node gets the innerHTML assignment for label
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// label: HTML String
		//		Content to display in button.
		label: "",

		// type: [const] String
		//		Type of button (submit, reset, button, checkbox, radio)
		type: "button",

		__onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to divert the real click onto the hidden INPUT that has a native default action associated with it
			// type:
			//		private
			e.stopPropagation();
			e.preventDefault();
			if(!this.disabled){
				// cannot use on.emit since button default actions won't occur
				this.valueNode.click(e);
			}
			return false;
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions
			if(this.disabled){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			if(this.onClick(e) === false){
				e.preventDefault();
			}
			var cancelled = e.defaultPrevented;

			// Signal Form/Dialog to submit/close.  For 2.0, consider removing this code and instead making the Form/Dialog
			// listen for bubbled click events where evt.target.type == "submit" && !evt.defaultPrevented.
			if(!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form){
				for(var node = this.domNode; node.parentNode; node = node.parentNode){
					var widget = registry.byNode(node);
					if(widget && typeof widget._onSubmit == "function"){
						widget._onSubmit(e);
						e.preventDefault(); // action has already occurred
						cancelled = true;
						break;
					}
				}
			}

			return !cancelled;
		},

		postCreate: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		onClick: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback for when button is clicked.
			//		If type="submit", return true to perform submit, or false to cancel it.
			// type:
			//		callback
			return true;		// Boolean
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			this._set("label", content);
			var labelNode = this.containerNode || this.focusNode;
			labelNode.innerHTML = content;
		}
	});

	if(has("dojo-bidi")){
		ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {
			_setLabelAttr: function(){
				this.inherited(arguments);
				var labelNode = this.containerNode || this.focusNode;
				this.applyTextDir(labelNode);
			}
		});
	}

	return ButtonMixin;
});

},
'dijit/registry':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
	"./main"	// dijit._scopeName
], function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'curam/layout/TabContainer':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.layout.TabContainer
 * @namespace Customized dijit.layout.TabContainer class in order to change the
 * behavior when a tab is closed.
 */
define(["dojo/_base/declare",
        "dijit/layout/TabContainer",
        "dojo/text!curam/layout/resources/TabContainer.html",
        "curam/inspection/Layer",
        "dojo/_base/connect",
        "curam/layout/ScrollingTabController",
        "dijit/layout/TabController"
        ], function(declare, TabContainer, template, layer, connect, CuramScrollingTabController,
                TabController) {
        
/*
 * Modification History
 * --------------------
 * 14-May-2019  JD  [RTC242058] Override postMixInProperties so 
 * 								CuramScrollingTabController can be used.
 * 23-Aug-2018  BD  [RTC229425] Overriden the method selectChild 
 *                              to publish to alert the tabwiget selected.
 * 25-Oct-2017  GB  [RTC177937] Adding a method to update tab 
 * 								title when changing tabs.
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Added publishing of
 * /curam/tab/closing event.)
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 24-Oct-2012  SK  [CR00346419] Now destroys the unnecessary references to avoid
 *                    holding memory.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format. 
 * 17-Dec-2010  DG  [CR00239200] Do not select tabs when destroying container.
 * 29-Sep-2010  MK  [CR00221781] Revised to change tab by responding to
 *                    the onRemoveChild event.
 * 03-Aug-2010  MK  [CR00211743] Initial Version.
 */
 
var CuramTabContainer = declare("curam.layout.TabContainer", dijit.layout.TabContainer,
  /**
   * @lends curam.layout.TabContainer
   */
{
  // The "dijitAlingTop" CSS class has been added to the "tablistSpacer" div in the template string.
  // The template string is actually defined in _TabContainerBase.js. No information on why this is needed
  // but it is obviously it was an alignment issue with the ootb Dojo widget. However, it "looks wrong".
  // If there was a bug with the ootb alignment (e.g. it didn't align to the center), then we should have fixed that
  // instaead of using "dijitAlignTop" to "push up" the contents to the center. It sounds to me like we are using
  // "align top" to make something "align center" !! Needs more investigation.  
  templateString: template,
  
  /**
   * The index of the currently selected tab.
   * @private
   */
  _theSelectedTabIndex: 0,

  /**
   * The page associated with the currently selected tab.
   * @private
   */
  _thePage: null,

  /**
   * The list of tabs.
   * @private
   */
  _theChildren: null,

  /**
   * Override of the superclass method in order to connect
   * the _changeTab function to the onRemoveChild event.
   */
	postCreate: function() {
		    this.inherited(arguments);
		    var tl = this.tablist;
		    this.connect(tl, 'onRemoveChild', '_changeTab');
		    this.connect(tl, 'onSelectChild', 'updateTabTitle');
		    layer.register("curam/layout/TabContainer", this);
	
	},

	selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
		this.inherited(arguments);
		dojo.publish("curam/tab/selected",[page.id]);
	},
	
	
  /**
   * Updates the tab title when changing tabs.
   */
  updateTabTitle: function() {
	  curam.util.setBrowserTabTitle();
  },

  /**
    * This method implements the Curam specific behavior to
    * be executed when a tab is closed.
    *
    * @private
    */
  _changeTab: function(){
    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._beingDestroyed) {
      this._thePage = null;
      this._theChildren = null;
      return;
    }
    if (this._theChildren == null) {
      return;
    }
    // if the tab currently being closed is not the one in display
    // then we don't want to change focus
    if (this._theChildren[this._theSelectedTabIndex] != this._thePage) {
      this.selectChild(this._theChildren[this._theSelectedTabIndex]);
      this._thePage = null;
      this._theChildren = null;
      return;
    }

    // display correct tab.
    if (this._theChildren.length < 1 ) { // no tabs open
      this._thePage = null;
      return;
    } else if (this._theChildren.length == 1 ) { // only one tab open
      this.selectChild(this._theChildren[this._theChildren.length-1]);
      this._thePage = null;
      this._theChildren = null;
    } else { // more than one tab open

      if (this._theSelectedTabIndex == (this._theChildren.length - 1)){
        // closing the right most tab
        this.selectChild(this._theChildren[this._theChildren.length-2]);

      } else if (this._theSelectedTabIndex == 0) {
        // closing the left most tab
       this.selectChild(this._theChildren[1]);

      } else {
        // closing a tab that is neither the left or right most tab
        // we can be guaranteed there is at least three tabs
        if (this._theChildren.length > 2) {
          this.selectChild(this._theChildren[this._theSelectedTabIndex + 1]);
        }
      }
      this._thePage = null;
      this._theChildren = null;
    }
  },

  /**
   * Override of the parent method.
   */
  removeChild: function(/*dijit._Widget*/ page){
    // Overrides dijit.layout.TabContainer.removeChild()

    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._started && !this._beingDestroyed) {
      // find the index of the selected tab
      // need to find this before the call to inherited as the call to
      // inherited reset the selected tab.
      var children = this.getChildren();
      var i = 0;
      var selectedTabIndex = 0;
      for (i = 0; i < children.length; i++){
        if (children[i].get('selected')) {
          selectedTabIndex = i;
          break;
        }
      }

      // store the values so that they will be accessible by
      // _changeTab method when it responds to the firing.
      // of the onRemoveChild event
      this._theSelectedTabIndex = selectedTabIndex;
      this._thePage = page;
      this._theChildren = children;

      // Trigger any cleanup events associated with the closing tab
      var tabWidgetId = page.id;
      connect.publish("/curam/tab/closing", [tabWidgetId]);
    }

    // Call the superclass. It can handle destruction cleanly on its own.
    this.inherited(arguments);
  },
  
  postMixInProperties: function() {
	    // Scrolling controller only works for horizontal non-nested tabs
	    if(!this.controllerWidget){
	      this.controllerWidget =
	          (this.tabPosition == "top" || this.tabPosition == "bottom")
	          && !this.nested
	          ? CuramScrollingTabController : TabController;
	    }

	    this.inherited(arguments);
	  }
  
});


return CuramTabContainer;
});
},
'dijit/_base/wai':function(){
define([
	"dojo/dom-attr", // domAttr.attr
	"dojo/_base/lang", // lang.mixin
	"../main",	// export symbols to dijit
	"../hccss"			// not using this module directly, but loading it sets CSS flag on <html>
], function(domAttr, lang, dijit){

	// module:
	//		dijit/_base/wai

	var exports = {
		// summary:
		//		Deprecated methods for setting/getting wai roles and states.
		//		New code should call setAttribute()/getAttribute() directly.
		//
		//		Also loads hccss to apply dj_a11y class to root node if machine is in high-contrast mode.

		hasWaiRole: function(/*Element*/ elem, /*String?*/ role){
			// summary:
			//		Determines if an element has a particular role.
			// returns:
			//		True if elem has the specific role attribute and false if not.
			//		For backwards compatibility if role parameter not provided,
			//		returns true if has a role
			var waiRole = this.getWaiRole(elem);
			return role ? (waiRole.indexOf(role) > -1) : (waiRole.length > 0);
		},

		getWaiRole: function(/*Element*/ elem){
			// summary:
			//		Gets the role for an element (which should be a wai role).
			// returns:
			//		The role of elem or an empty string if elem
			//		does not have a role.
			 return lang.trim((domAttr.get(elem, "role") || "").replace("wairole:",""));
		},

		setWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Sets the role on an element.
			// description:
			//		Replace existing role attribute with new role.

			domAttr.set(elem, "role", role);
		},

		removeWaiRole: function(/*Element*/ elem, /*String*/ role){
			// summary:
			//		Removes the specified role from an element.
			//		Removes role attribute if no specific role provided (for backwards compat.)

			var roleValue = domAttr.get(elem, "role");
			if(!roleValue){ return; }
			if(role){
				var t = lang.trim((" " + roleValue + " ").replace(" " + role + " ", " "));
				domAttr.set(elem, "role", t);
			}else{
				elem.removeAttribute("role");
			}
		},

		hasWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Determines if an element has a given state.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		true if elem has a value for the given state and
			//		false if it does not.

			return elem.hasAttribute ? elem.hasAttribute("aria-"+state) : !!elem.getAttribute("aria-"+state);
		},

		getWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Gets the value of a state on an element.
			// description:
			//		Checks for an attribute called "aria-"+state.
			// returns:
			//		The value of the requested state on elem
			//		or an empty string if elem has no value for state.

			return elem.getAttribute("aria-"+state) || "";
		},

		setWaiState: function(/*Element*/ elem, /*String*/ state, /*String*/ value){
			// summary:
			//		Sets a state on an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.setAttribute("aria-"+state, value);
		},

		removeWaiState: function(/*Element*/ elem, /*String*/ state){
			// summary:
			//		Removes a state from an element.
			// description:
			//		Sets an attribute called "aria-"+state.

			elem.removeAttribute("aria-"+state);
		}
	};

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'curam/util/ResourceBundle':function(){
/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define(["dojo/_base/declare",
        "dojo/i18n",
        "dojo/string"
        ], function(declare, i18n, string) {

/*
 * Modification History
 * --------------------
 * 20-May-2013  MV  [CR00383012] Fail if there are no properties loaded.
 * 19-May-2012  BOS [CR00346368] Use new Dojo AMD format.
 * 15-Jun-2012  MV  [CR00329034] Added proper documentation.
 * 11-Jun-2012  MV  [CR00328689] Initial version.
 */

/**
 * @name curam.util.ResourceBundle
 * @namespace Provides access to localizable resources.
 * <p/>
 * The process for getting localized messaged from a resource bundle consists
 * of two steps: <ol>
 * <li>Load the resources using <code>dojo.requireLocalization()</code></li>
 * <li>Create an instance of <code>curam.util.ResourceBunlde</code> class
 *      to access the localized resources.</li>
 * </ol>
 *
 * <h2>Loading Resources</h2>
 * In most cases the call to load resources should look like this:
 * <code><pre>dojo.requireLocalization("curam.application", "MyResources")</pre></code>
 * <p/>
 * "curam.application" is the default package into which all localizable
 * resources are placed by Curam infrastructure.
 * <p/>
 * "MyResources" is an example of a resource bundle name. Resource bundle name
 * will be specific to your own JavaScript code and it is derived from the name
 * of the related resource bundle *.properties file.
 *
 * <h2>Accessing Localized Resources</h2>
 * Previously loaded localized resources can be accessed in the following way:
 * <code><pre>dojo.require("curam.util.ResourceBundle");
 * var bundle = new curam.util.ResourceBundle("MyResources");
 * var localizedMessage = bundle.getProperty("myPropertyKey");
 * </pre></code>
 * Note in the above example there is no need to specify the default package
 * name "curam.appliciation" - the infrastructure will use the default
 * if no package is specified. This should be the case in most normal
 * situations.
 *
 * <h2>Resource File Naming and Content</h2>
 * The localizable resources for your JavaScript are expected in the standard
 * Java Properties format.
 * <p/>
 * By convention the name of the resource file for your JavaScript should be
 * derived from name of the JavaScript file itself. For example if your
 * JavaScript file is called "MyJavaScript.js" then related localizable
 * resources should be placed in <code>MyJavaScript.js.properties</code> file.
 * This .properties file can be placed anywhere in the component directory, but
 * by convention it should be in the same directory as the related *.js file.
 * The only exception to this, is that a *.js file within a WebContent directory
 * cannot have it's associated .properties file within the same directory - the
 * associated .properties file must be placed within a directory outside of the
 * WebContent directory.
 * <p/>
 * The tranlations of the resource bundle should then be placed in files named
 * in the following way (again following the Java standard naming):
 * <code>MyJavaScript.js_fr_CA.properties</code>,
 * <code>MyJavaScript.js_fr.properties</code>,
 * <code>MyJavaScript.js_cs_CZ.properties</code>, etc.
 * <p/>
 * Sample content of a resource file is as follows:
 * <code><pre>myPropertyKey=A localizable message.
 * another.property.key=Another localizable message.
 * propertyKey3=A message with %s value placeholders %s.
 * </pre></code>
 * Please note property keys with dots are allowed and string value
 * substitution into mesages is supported.
 */
 var ResourceBundle = declare("curam.util.ResourceBundle", null,
/**
 * @lends curam.util.ResourceBundle.prototype
 */
{
  _bundle: undefined,

  /**
   * Constructor takes bundle name and optionally locale.
   *
   * @param {String} possiblyQualifiedBundleName Bundle name. Optionally
   *           qualified with package name. E.g. "my.package.MyResourceBundle".
   * @param {String} [locale] Locale string in the following format:
   *            <code> en-US</code> where "en" is language code and "US"
   *            is variant as per IETF specification.
   */
  constructor: function(possiblyQualifiedBundleName, locale) {
    var parts = possiblyQualifiedBundleName.split(".");
    var bundleName = parts[parts.length - 1];
    var packageName = parts.length == 1 ? "curam.application"
        : possiblyQualifiedBundleName.slice(0,
            possiblyQualifiedBundleName.length - bundleName.length - 1);
    try {
      var b = i18n.getLocalization(packageName, bundleName, locale);
      if (this._isEmpty(b)) {
        throw new Error("Empty resource bundle.");

      } else {
        this._bundle = b;
      }

    } catch (e) {
      throw new Error("Unable to access resource bundle: " + packageName + "."
          + bundleName + ": " + e.message);
    }
  },
  
  /**
   * Checks if the passed bundle is empty or has some properties.
   * @param bundle The bundle object to check.
   * @returns {Boolean} True if the bundle if empty, false if it contains
   *            properties.
   */
  _isEmpty: function(bundle) {
    for (var prop in bundle) {
      // if it has at least one property, return false - it is not empty
      return false;
    }
    // no properties - return true as it is empty
    return true;
  },

  /**
   * Gets the localized value of a specified property, optionally replacing any
   * placeholders with appropriate values from specified array.
   *
   * @param {String} key The property key of the required message.
   * @param {Array} [values] An array of values to be used for replacing
   *            placeholders within the specified message.
   * @returns {String} Value of the requested localized property from
   *            the bundle.
   */
  getProperty: function(key, values) {
    var msg = this._bundle[key];

    var result = msg;
    if (values) {
      result = string.substitute(msg, values);
    }

    return result;
  }
  });
 return ResourceBundle;
});
},
'dijit/_KeyNavMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dijit/registry",
	"dijit/_FocusMixin"        // to make _onBlur() work
], function(array, declare, domAttr, keys, lang, on, registry, _FocusMixin){

	// module:
	//		dijit/_KeyNavMixin

	return declare("dijit._KeyNavMixin", _FocusMixin, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// tabIndex: String
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: null,

		postCreate: function(){
			this.inherited(arguments);

			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			domAttr.set(this.domNode, "tabIndex", this.tabIndex);

			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
				keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
				keyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, "_onLeftArrow");
				keyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, "_onRightArrow");
				keyCodes[keys.UP_ARROW] = lang.hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = lang.hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string"
					? this.childSelector
					: lang.hitch(this, "childSelector");
			this.own(
				on(this.domNode, "keypress", lang.hitch(this, "_onContainerKeypress")),
				on(this.domNode, "keydown", lang.hitch(this, "_onContainerKeydown")),
				on(this.domNode, "focus", lang.hitch(this, "_onContainerFocus")),
				on(this.containerNode, on.selector(childSelector, "focusin"), function(evt){
					self._onChildFocus(registry.getEnclosingWidget(this), evt);
				})
			);
		},

		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getLastFocusableChild());
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){
				return;
			}

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used to be used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focus
			widget.focus(last ? "end" : "start");

			// Don't set focusedChild here, because the focus event should trigger a call to _onChildFocus(), which will
			// set it.   More importantly, _onChildFocus(), which may be executed asynchronously (after this function
			// returns) needs to know the old focusedChild to set its tabIndex to -1.
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container itself gets focus.
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child.
			//
			//		TODO for 2.0 (or earlier): Instead of having the container tabbable, always maintain a single child
			//		widget as tabbable, Requires code in startup(), addChild(), and removeChild().
			//		That would avoid various issues like #17347.
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively).
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){
				return;
			}

			this.focus();
		},

		_onFocus: function(){
			// When the container gets focus by being tabbed into, or a descendant gets focus by being clicked,
			// set the container's tabIndex to -1 (don't remove as that breaks Safari 4) so that tab or shift-tab
			// will go to the fields after/before the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");

			this.inherited(arguments);
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)

			// TODO: for 2.0 consider changing this to blur whenever the container blurs, to be truthful that there is
			// no focused child at that time.

			domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(this.focusedChild){
				this.focusedChild.set("tabIndex", "-1");
				this.lastFocusedChild = this.focusedChild;
				this._set("focusedChild", null);
			}
			this.inherited(arguments);
		},

		_onChildFocus: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Called when a child widget gets focus, either by user clicking
			//		it, or programatically by arrow key handling code.
			// description:
			//		It marks that the current node is the selected one, and the previously
			//		selected node no longer is.

			if(child && child != this.focusedChild){
				if(this.focusedChild && !this.focusedChild._destroyed){
					// mark that the previously focusable node is no longer focusable
					this.focusedChild.set("tabIndex", "-1");
				}

				// mark that the new node is the currently selected one
				child.set("tabIndex", this.tabIndex);
				this.lastFocused = child;		// back-compat for Tree, remove for 2.0
				this._set("focusedChild", child);
			}
		},

		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private

			var element = item.domNode,
				text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "",
				currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();

			return (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop a11yclick and _HasDropdown from seeing SPACE if we're doing keyboard searching
				evt.preventDefault(); // stop IE from scrolling, and most browsers (except FF) from sending keypress
				this._keyboardSearch(evt, ' ');
			}
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			// Ignore:
			// 		- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)
			//		- control sequences like CMD-Q.
			//		- the SPACE key (only occurs on FF)
			//
			// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search
			// in progress, then SPACE is handled in _onContainerKeyDown.
			if(evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey){
				return;
			}

			evt.preventDefault();
			evt.stopPropagation();

			this._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());
		},

		_keyboardSearch: function(/*Event*/ evt, /*String*/ keyChar){
			// summary:
			//		Perform a search of the widget's options based on the user's keyboard activity
			// description:
			//		Called on keypress (and sometimes keydown), searches through this widget's children
			//		looking for items that match the user's typed search string.  Multiple characters
			//		typed within 1 sec of each other are combined for multicharacter searching.
			// tags:
			//		private
			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = lang.hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';
					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem && currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				});

			search();
			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){ break; }
				}else{
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue && child.isFocusable()){
					return child;	// dijit/_WidgetBase
				}
			}while(child != wrappedValue);
			// no focusable child found
			return null;	// dijit/_WidgetBase
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			if(child){
				child = child.domNode;
				while(child){
					child = child[dir < 0 ? "previousSibling" : "nextSibling"];
					if(child  && "getAttribute" in child){
						var w = registry.byNode(child);
						if(w){
							return w; // dijit/_WidgetBase
						}
					}
				}
			}
			return null;	// dijit/_WidgetBase
		}
	});
});

},
'dojo/store/util/QueryResults':function(){
define(["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}

	var isPromise = !!results.then;
	// if it is a promise it may be frozen
	if(isPromise){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		// Always add the iterative methods so a QueryResults is
		// returned whether the environment is ES3 or ES5
		results[method] = function(){
			var args = arguments;
			var result = when(results, function(results){
				Array.prototype.unshift.call(args, results);
				return QueryResults(array[method].apply(array, args));
			});
			// forEach should only return the result of when()
			// when we're wrapping a promise
			if(method !== "forEach" || isPromise){
				return result;
			}
		};
	}

	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(results.total == null){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});

},
'dijit/form/_ListBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(declare, on, winUtils){

	// module:
	//		dijit/form/_ListBase

	return declare("dijit.form._ListBase", null, {
		// summary:
		//		Focus-less menu to handle UI events consistently.
		//		Abstract methods that must be defined externally:
		//
		//		- onSelect: item is active (mousedown but not yet mouseup, or keyboard arrow selected but no Enter)
		//		- onDeselect:  cancels onSelect
		// tags:
		//		private

		// selected: DOMNode
		//		currently selected node
		selected: null,

		_listConnect: function(/*String|Function*/ eventType, /*String*/ callbackFuncName){
			// summary:
			//		Connects 'containerNode' to specified method of this object
			//		and automatically registers for 'disconnect' on widget destroy.
			// description:
			//		Provide widget-specific analog to 'connect'.
			//		The callback function is called with the normal event object,
			//		but also a second parameter is passed that indicates which list item
			//		actually received the event.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect
			//		before the widget is destroyed.
			// tags:
			//		private

			var self = this;
			return self.own(on(self.containerNode,
				on.selector(
					function(eventTarget, selector, target){
						return eventTarget.parentNode == target;
					},
					eventType
				),
				function(evt){
					self[callbackFuncName](evt, this);
				}
			));
		},

		selectFirstNode: function(){
			// summary:
			//		Select the first displayed item in the list.
			var first = this.containerNode.firstChild;
			while(first && first.style.display == "none"){
				first = first.nextSibling;
			}
			this._setSelectedAttr(first, true);
		},

		selectLastNode: function(){
			// summary:
			//		Select the last displayed item in the list
			var last = this.containerNode.lastChild;
			while(last && last.style.display == "none"){
				last = last.previousSibling;
			}
			this._setSelectedAttr(last, true);
		},

		selectNextNode: function(){
			// summary:
			//		Select the item just below the current selection.
			//		If nothing selected, select first node.
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectFirstNode();
			}else{
				var next = selectedNode.nextSibling;
				while(next && next.style.display == "none"){
					next = next.nextSibling;
				}
				if(!next){
					this.selectFirstNode();
				}else{
					this._setSelectedAttr(next, true);
				}
			}
		},

		selectPreviousNode: function(){
			// summary:
			//		Select the item just above the current selection.
			//		If nothing selected, select last node (if
			//		you select Previous and try to keep scrolling up the list).
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectLastNode();
			}else{
				var prev = selectedNode.previousSibling;
				while(prev && prev.style.display == "none"){
					prev = prev.previousSibling;
				}
				if(!prev){
					this.selectLastNode();
				}else{
					this._setSelectedAttr(prev, true);
				}
			}
		},

		_setSelectedAttr: function(/*DomNode*/ node, /*Boolean*/ scroll){
			// summary:
			//		Does the actual select.
			// node:
			//		The option to select
			// scroll:
			//		If necessary, scroll node into view.  Set to false for mouse/touch to
			//		avoid jumping problems on mobile/RTL, see https://bugs.dojotoolkit.org/ticket/17739.
			if(this.selected != node){
				var selectedNode = this.selected;
				if(selectedNode){
					this.onDeselect(selectedNode);
				}
				if(node){
					if(scroll){
						winUtils.scrollIntoView(node);
					}
					this.onSelect(node);
				}
				this._set("selected", node);
			}else if(node){
				this.onSelect(node);
			}
		}
	});
});

},
'dijit/form/_FormWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", //  1 , has("msapp")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormWidget

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/form/_FormValueWidget"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.  Use set('disabled', ...) instead.
			kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		setValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('value', ...) instead.
			kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
			this.set('value', value);
		},

		getValue: function(){
			// summary:
			//		Deprecated.  Use get('value') instead.
			kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified).
			// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
			// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
			// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
			// Regarding escaping, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
			this.inherited(arguments);
		}
	});
});

},
'dijit/Viewport':function(){
define([
	"dojo/Evented",
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff",	// has("ie"), has("ios")
	"dojo/window" // getBox()
], function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
});

},
'curam/widget/MenuItem':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.widget.MenuItem
 * @namespace Customized dijit.widget.MenuItem class in order to add extra
 * functionality to close all tabs.
 */
define(["dijit/MenuItem",
        "dojo/_base/declare",
        "dojo/text!dijit/templates/MenuItem.html"
        ], function(MenuItem, declare, template) {

/*
 * Modification History
 * --------------------
 * 08-Aug-2019  JD   [RTC249365]  Added _setLabelAttr to strip out HTML tags
 * from the label and aria-label of a menu item.
 * 27-Oct-2012  BOS  [CR00211743] Initial Version.
 */

var CuramMenuItem = declare("curam.widget.MenuItem", MenuItem,
  /**
   * @lends curam.widget.MenuItem
   */
{
  templateString: template,

  /**
   * The value of the onClick event that will be used when the user executes an
   * on click event.
   * @private
   */
  onClickValue: "",

  /**
   * New function that may be called by the onClick event, in order to close all
   * tabs.
   */
  _onClickAll:function(evt){
    var tabContainer = curam.tab.getTabContainer();
    var children = tabContainer.getChildren();
    for (var i = 0; i < children.length; i++){
      // Check if a child is closable or not, 
      // only the closable child can be closed down.
      if (children[i].closable) {
        tabContainer.closeChild(children[i]);
      }
    }
  },
  
  /**
   * Overriding dojo function to strip out HTML tags that can be contained in the
   * aria-label. Added due to accessibility defect where a blank image is added to
   * disabled menu items, and the _setLabelAttr function is adding the HTML for the
   * blank image to the aria-label.
   */
  _setLabelAttr: function(val){
	// Regex to strip out HTML tags from label.  
	// Did not directly strip them from val as containerNode's
	// innerHTML is set to the value of val, so it may be legitimate
	// to have HTML here.
	var removeHTMLTags = /<[a-zA-Z\/][^>]*>/g;
	var valText = val.replace(removeHTMLTags,'');
	this._set("label", valText);
	var shortcutKey = "";
	var text;
	var ndx = val.search(/{\S}/);
	if(ndx >= 0){
		shortcutKey = val.charAt(ndx + 1);
		var prefix = val.substr(0, ndx);
		var suffix = val.substr(ndx + 3);
		text = prefix + shortcutKey + suffix;
		val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
	}else{
		text = val;
	}
	// Repeating regex here to strip out HTML tags from aria-label.
	text = text.replace(removeHTMLTags,'');
	this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
	this.containerNode.innerHTML = val;
	this._set('shortcutKey', shortcutKey);
  }
});

return CuramMenuItem;
});


},
'curam/tab':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  Copyright IBM Corporation 2009,2022. All Rights Reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dijit/registry",
        "dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/dom-class",
        "curam/inspection/Layer",
        "curam/define",      
        "curam/util",
        "curam/util/ScreenContext"
        ], function(registry, dom, domAttr, domConstruct, domClass, layer) {
  
  /*
   * Modification History
   * --------------------
   * 09-Jun-2022  CM  [RTC277941] Remove code from previous defect fix on RTC277941.
   * 12-Apr-2022  CM  [RTC277107] Allow section tabs with a listed default page-id 
   *                  to be refreshed correctly on the non default page. 
   * 11-Aug-2021  SK  [RTC272800] refreshMainContentPanel now uses decoupled 
   *                              progress spinner invocation.
   * 20-Nov-2020  FG  [RTC231001] Changes due to the removal of IEG1.  
   * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 25-Mar-2014  MV  [CR00423311] Add function to detect internal application.  
   * 28-Sep-2013  BOS [CR00396277] Modified getSelectedTab() and 
   *                    onSectionSelected() functions to ensure an undefined. 
   *                    tab container handled correctly.
   * 28-Sep-2011  MV  [CR00288956] Refactored code to get separate
   *      getCurrentSectionId function.
   * 29-Jul-2011  MV  [CR00269970] Added missing semicolons.
   * 14-Feb-2011  PK  [CR00251730] Added "refreshMainContentPanel" method.
   * 14-Jan-2011  DG  [CR00242400] Changed "getContainerTab" to do a bottom-up
   *                    search. This is much, much simpler.
   * 12-Jan-2011  DG  [CR00238642] Fixed "getContainerTab" to find the tab for an
   *                    node even if the tab is not in the currently selected
   *                    section. Added copyright notice.
   * 17-Nov-2010  DG  [CR00217921] Clean-up of selected tab retrieval.
   * 27-Oct-2010  SK  [CR00224193] the situation where the content panel frame
   *                    is not present is now allowed.
   * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
   *                    tab-app-controller.js.
   * 21-Jul-2010  PK  [CR00211095] Added methods for handling default pages in a
   *                    section.
   * 16-Jul-2010  MV  [CR00210541] Fixed the getTabContainer() function to also
   *                    work in contexts other than the main window.
   * 28-Jun-2010  SD  [CR00204622] Smart Panel additions.
   * 02-Jul-2010  PK  [CR00203531] Updated to support section tab container.
   * 04-Jun-2010  MV  [CR00202412] Generalize the code that executes functions
   *                    on tab close.
   * 11-Feb-2010  MV  [CR00188844] Code format cleanup.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 24-Nov-2009  MV  [CR00175837] Remove debug output from getTabCOntainer.
   * 20-Nov-2009  MV  [CR00175581] Fix getSelectedTab function, remove
   *                    refreshCurrentTab function, add getTabController function.
   * 18-Nov-2009  MV  [CR00172452] Add more tab related functions.
   * 03-Sep-2009  MLB [CR00164883] Added function to refresh the current tab.
   * 06-Aug-2009  MV  [CR00164029] Initial version.
   * 24-Jun-2010 BD  [CR00204119] Updated how the content panel iframe is returned
   */
  /**
   * Contains functions of general use for the tabbed UI.
   */
  curam.define.singleton("curam.tab", {
    SECTION_TAB_CONTAINER_ID: "app-sections-container-dc",
    SMART_PANEL_IFRAME_ID: "curam_tab_SmartPanelIframe",
    toBeExecutedOnTabClose: [],
    
    /**
     * @private
     *
     * Used for testing: when this is set by the test code the value
     * will be returned from the getSelectedTab() function instead of the real
     * selected tab.
     */
    _mockSelectedTab: null,

    // Returns the currently selected tab widget.
    getSelectedTab: function(sectionID) {
      // supports testing code that uses curam.tab API
      if (curam.tab._mockSelectedTab) {
        return curam.tab._mockSelectedTab;
      }

      if (curam.tab.getTabContainer(sectionID)) {
        return curam.tab.getTabContainer(sectionID).selectedChildWidget;
      }    
    },

    getTabContainer: function(sectionID) {
      return curam.tab.getTabContainerFromSectionID(sectionID
          || curam.tab.getCurrentSectionId());
    },
    
    /**
     * Determines ID of the currently selected section.
     * By default throws an error when no current section is found.
     * 
     * @param {boolean} [suppressNotFoundError] If this option is set to true
     *          the function will not throw err when no current section
     *          is found.
     * 
     * @return ID of the currently selected section or null
     *          if "suppressNotFoundError" parameter is true.
     */
    getCurrentSectionId: function(suppressNotFoundError) {
      var sectionTabContainer = curam.util.getTopmostWindow().dijit.byId(
          curam.tab.SECTION_TAB_CONTAINER_ID);
      if (sectionTabContainer) {
        // children of the curam.tab.SECTION_TAB_CONTAINER_ID have id's that
        // start with the section ID and have a 4 character suffix. See
        // the ApplicationSectionRenderer.
        var childID = sectionTabContainer.selectedChildWidget.domNode.id;
        return childID.substring(0, childID.length - 4);

      } else {
        if (!suppressNotFoundError) {
          throw new Error(
              "curam.tab.getCurrentSectionId() - application section"
                + " tab container not found");
        }
      }

      return null;
    },
    
    /**
     * Determines whether we are running within a tabbed UI (internal
     * application) or not.
     * 
     * @return True if we are in tabbed UI, otherwise false.
     */
    inTabbedUI: function() {
      return curam.tab.getCurrentSectionId(true) != null;
    },

    getTabContainerFromSectionID: function(sectionID) {
      var tabContainer = registry.byId(sectionID + "-stc");
      // TODO: not sure what this should do now that sections have been
      // introduced
      if (!tabContainer && window.parent && window.parent != window) {
        tabContainer =
          curam.util.getTopmostWindow().dijit.byId(sectionID + "-stc");
      }
      return tabContainer;
    },

    // Returns the unique widget ID for the specified tab.
    getTabWidgetId: function(tab) {
      return tab.id;
    },

    // Returns the unique widget ID for the currently selected tab.
    getSelectedTabWidgetId: function() {
      return curam.tab.getTabWidgetId(curam.tab.getSelectedTab());
    },

    /**
     * Gets the tab that contains the given node. The node is typically the
     * "iframe" element (or its parent element) within the tab, but it can be
     * any other descendant node of the tab widget.
     *
     * @param {Node} node The node within the tab to be identified.
     * @return The tab content pane containing the given node.
     */
    getContainerTab: function(node) {
      var widget = dijit.getEnclosingWidget(node);

      if (widget && !widget.tabDescriptor) {
        // A valid tab has a "curam.tab.TabDescriptor" object. This is probably
        // a different widget nested within the tab. Look further up the tree.
        widget = curam.tab.getContainerTab(widget.domNode.parentNode);
      }

      if (!widget || !widget.tabDescriptor) {
        throw "Containing tab widget could not be found for node: " + node;
      }
      return widget;
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getContentPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab(),
          iframe = null;
      
      if (targetTab) {
        iframe = dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              // is-cp-iframe output by "ContentPanelRenderer".
              return domAttr.get(item,"iscpiframe") == "true";
            })[0];
      }
      return iframe ? iframe : null;
    },
    
    /**
     * Refreshes the main content panel for the specified tab. If the tab is not
     * specified, the currently selected one will be used.
     * @tab The tab to reload the main content panel for. 
     */
    refreshMainContentPanel: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab();
      curam.util.getTopmostWindow().dojo.publish('/curam/progress/display', [targetTab.domNode]);
      
      var iframe = curam.tab.getContentPanelIframe(tab);
      iframe.contentWindow.curam.util.publishRefreshEvent();
      // specifically pass false so that browser uses cached resources
      // where possible
      iframe.contentWindow.location.reload(false);
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getSmartPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab();
      var iframe =
        dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              return item.id == curam.tab.SMART_PANEL_IFRAME_ID;
            })[0];

      return iframe;
    },

    unsubscribeOnTabClose: function(unsubscribeToken, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          dojo.unsubscribe(unsubscribeToken);
          return true;
        }

        return false;
      });
    },

    executeOnTabClose: function(func, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          func();
          return true;
        }

        return false;
      });
    },

    doExecuteOnTabClose: function(tabWidgetId) {
      var remainingFuncs = new Array();
      for (var i = 0; i < curam.tab.toBeExecutedOnTabClose.length; i ++) {
        var func = curam.tab.toBeExecutedOnTabClose[i];
        if (!func(tabWidgetId)) {
          remainingFuncs.push(func);
        }
      }

      curam.tab.toBeExecutedOnTabClose = remainingFuncs;
    },

    // Returns a handler function that handles the /curam/main-content/page/loaded events,
    // but only for the specified tab.
    getHandlerForTab: function(handler, tabWidgetId) {
      return function(pageId, actualTabWidgetId) {
        if (actualTabWidgetId == tabWidgetId) {
          handler(pageId, tabWidgetId);
        } else {
          // no action - event was for a different tab
        }
      };
    },

    getTabController: function() {
      return curam.util.getTopmostWindow().curam.ui.UIController;
    },

    initTabLinks: function(tabWindow) {
      dojo.query("a").forEach(
        function(link) {
          if (link.href.indexOf('#') != 0
              && link.href.indexOf('javascript:') != 0
              && (link.href.indexOf('Page.do') > -1
                        || link.href.indexOf('Frame.do') > -1)) {
            if (link.href.indexOf('&o3ctx') < 0
              && link.href.indexOf('?o3ctx') < 0) {
              var separator = (link.href.indexOf('?') > -1) ? "&" : "?";
          link.href += separator + jsScreenContext.toRequestString();
            }
          }
       });
      elements = document.forms;
      for (var i = 0; i < elements.length; ++i) {
        elem = elements[i];
        var ctxField = dom.byId('o3ctx');
        if (!ctxField) {
          var ctx = new curam.util.ScreenContext();
          ctx.setContextBits('ACTION');
          domConstruct.create("input", {"type": "hidden", "name": "o3ctx",
                                 "value": ctx.getValue()
                               }, elem);
        }
        domConstruct.create("input", {"type": "hidden", "name": "o3prv",
              "value": jsPageID}, elem);
      }

      if (elements.length > 0) {
        curam.util.getTopmostWindow().dojo.publish("curam.fireNextRequest", []);
      }
    },

    initContent: function(window, pageId) {
      var contentDiv = dom.byId('content');
      domClass.remove(contentDiv, "hidden-panel");
      return;
    },

    /**
     * This setups a listener on the SECTION_TAB_CONTAINER_ID tab container to
     * handle when a section tab is selected. This method is invoked from
     * JavaScript output from the ApplicationsSectionsRenderer Java class.
     */
    setupSectionSelectionListener: function() {
      dojo.subscribe(curam.tab.SECTION_TAB_CONTAINER_ID + "-selectChild",
          curam.tab.onSectionSelected) ;
    },

    /**
     * Checks if a section has a default page specified and if the section is
     * currently "empty" (i.e. nothing displayed in it). If so, it loads the
     * default default in the section.
     *
     * This function responds to the standard "selectChild" event provided by the
     * Dijit TabContainer and is setup by the setupSectionSelectionListener method
     * above.
     */
    onSectionSelected: function(section) {
      // The curamDefaultPageID attribute is added by the setSectionDefaultPage
      // method below. The Dijit TabContainer selectChild event passes the
       // selected child to the listener.
      if (section.curamDefaultPageID) {
        // The section has a default page. Check if anything has been opened up
        // in this section already. If not, then we trigger a request for that
        // page.

        // The tab container containing the "object" tabs will either be a direct
        // child of the sections tab container, or it will be nested within
        // a border container.
        var objectTabContainer;
        if (section.id.substring(
              section.id.length - 4, section.id.length) == "-sbc") {
          // This means it's a border container so extract the section ID and
          // find the nested tab container.
          var sectionID = section.id.substring(0, section.id.length - 4);
          objectTabContainer = curam.tab.getTabContainer(sectionID);
        } else {
          // This means the object tab container is a direct child of the section
          // tab container, so it's passed in by the "selectChild" event of the
          // section tab container.
          objectTabContainer = section;
        }

        // If the tab container does not have any children, then load the
        // default page.
        if (objectTabContainer 
          && objectTabContainer.getChildren().length == 0) {
              

       	      curam.tab.getTabController().handleUIMPageID(
        	    section.curamDefaultPageID, true);
          	
        
         // TODO: now that the page has been loaded, can we set a flag on the
         // section so the code *before* the getChildren().length == 0 above
         // is not executed again. Just a minor optimization.
        }
        return true;
      }
      return false;
    },

    /**
     * Sets the section's default pageID as a custom attribute on the Dijit
     * container. The container can be either a border container or a tab
     * container which has a specific naming convention which is the section ID
     * plus a suffix of "-sbc" for a border container and "-stc" for a tab
     * container. The ApplicationSectionsRenderer generates the call to this
     * function and will set the containers ID appropriately.
     */
    setSectionDefaultPage: function(sectionDijitContainerID, defaultPageID) {
      var dijitContainer = registry.byId(sectionDijitContainerID);
      if (dijitContainer) {
        // The "curamDefaultPageID" custom attribute is used by the
        // onSectionSelected method above.
        dijitContainer.curamDefaultPageID = defaultPageID;
      } else {
        throw "curam.tab.setSectionDefaultPage() - cannot find section dijit ID:"
              + sectionDijitContainerID;
      }
    },
    
    /**
     * Notifies the Smart Panel that its content page is loaded and ready to
     * receive updates from the tab's content page. This is done by publishing
     * an event, or, if the listeners are not set up yet, an attribute set on
     * the Smart Panel frame is used.
     */
    publishSmartPanelContentReady: function() {
            var rendererLoadedEvent = "smartpanel.content.loaded";
            //use the window object as cannot assume the currently selected tab is
            //the tab containing the Smart Panel of interest.
            var smartPanel = window.frameElement; 
            smartPanel.setAttribute("_SPContentLoaded", "true");
            curam.util.getTopmostWindow().dojo.publish(rendererLoadedEvent, [smartPanel]);
    }
    
  });
  layer.register("curam/tab", curam.tab);
 
  return curam.tab;
});

},
'dijit/_base/place':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/lang", // lang.isArray, lang.mixin
	"dojo/window", // windowUtils.getBox
	"../place",
	"../main"	// export to dijit namespace
], function(array, lang, windowUtils, place, dijit){

	// module:
	//		dijit/_base/place


	var exports = {
		// summary:
		//		Deprecated back compatibility module, new code should use dijit/place directly instead of using this module.
	};

	exports.getViewport = function(){
		// summary:
		//		Deprecated method to return the dimensions and scroll position of the viewable area of a browser window.
		//		New code should use windowUtils.getBox()

		return windowUtils.getBox();
	};

	exports.placeOnScreen = place.at;

	exports.placeOnScreenAroundElement = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
		//		for the "around" argument and finds a proper processor to place a node.
		//		Deprecated, new code should use dijit/place.around() instead.

		// Convert old style {"BL": "TL", "BR": "TR"} type argument
		// to style needed by dijit.place code:
		//		[
		//			{aroundCorner: "BL", corner: "TL" },
		//			{aroundCorner: "BR", corner: "TR" }
		//		]
		var positions;
		if(lang.isArray(aroundCorners)){
			positions = aroundCorners;
		}else{
			positions = [];
			for(var key in aroundCorners){
				positions.push({aroundCorner: key, corner: aroundCorners[key]});
			}
		}

		return place.around(node, aroundNode, positions, true, layoutNode);
	};

	exports.placeOnScreenAroundNode = exports.placeOnScreenAroundElement;
	/*=====
	exports.placeOnScreenAroundNode = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Position node adjacent or kitty-corner to aroundNode
		//		such that it's fully visible in viewport.
		//		Deprecated, new code should use dijit/place.around() instead.
	};
	=====*/

	exports.placeOnScreenAroundRectangle = exports.placeOnScreenAroundElement;
	/*=====
	exports.placeOnScreenAroundRectangle = function(node, aroundRect, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except that the "around"
		//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
		//		instead of a dom node.
		//		Deprecated, new code should use dijit/place.around() instead.
	};
	=====*/

	exports.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
		// summary:
		//		Deprecated method, unneeded when using dijit/place directly.
		//		Transforms the passed array of preferred positions into a format suitable for
		//		passing as the aroundCorners argument to dijit/place.placeOnScreenAroundElement.
		// position: String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		// leftToRight: Boolean
		//		Whether the popup will be displaying in leftToRight mode.

		var align = {};
		array.forEach(position, function(pos){
			var ltr = leftToRight;
			switch(pos){
				case "after":
					align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
					break;
				case "before":
					align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
					break;
				case "below-alt":
					ltr = !ltr;
					// fall through
				case "below":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
					align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
					break;
				case "above-alt":
					ltr = !ltr;
					// fall through
				case "above":
				default:
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
					align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
					break;
			}
		});
		return align;
	};

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'dijit/form/_ComboBoxMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-style", // domStyle.get
	"dojo/keys", // keys.DOWN_ARROW keys.PAGE_DOWN keys.PAGE_UP keys.UP_ARROW
	"../_WidgetBase",
	"../_TemplatedMixin",
	"./_ComboBoxMenuMixin",
	"./_ListMouseMixin"
], function(declare, domClass, domStyle, keys,
			_WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin){


	// module:
	//		dijit/form/_ComboBoxMenu

	return declare("dijit.form._ComboBoxMenu",[_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		//		Abstract methods that must be defined externally:
		//
		//		- onChange: item was explicitly chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		//		- onPage: next(1) or previous(-1) button pressed
		// tags:
		//		private

		// TODO for 2.0 or earlier: stop putting stuff inside this.containerNode.   Switch to using this.domNode
		// or a different attach point.    See _TemplatedMixin::searchContainerNode.
		templateString: "<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;' role='listbox'>"
				+"<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>"
				+"<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>"
				+"</div>",

		baseClass: "dijitComboBoxMenu",

		postCreate: function(){
			this.inherited(arguments);
			if(!this.isLeftToRight()){
				domClass.add(this.previousButton, "dijitMenuItemRtl");
				domClass.add(this.nextButton, "dijitMenuItemRtl");
			}
			this.containerNode.setAttribute("role","listbox");
		},

		_createMenuItem: function(){
			// note: not using domConstruct.create() because need to specify document
			var item = this.ownerDocument.createElement("div");
			item.className = "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl");
			item.setAttribute("role", "option");
			return item;
		},

		onHover: function(/*DomNode*/ node){
			// summary:
			//		Add hover CSS
			domClass.add(node, "dijitMenuItemHover");
		},

		onUnhover: function(/*DomNode*/ node){
			// summary:
			//		Remove hover CSS
			domClass.remove(node, "dijitMenuItemHover");
		},

		onSelect: function(/*DomNode*/ node){
			// summary:
			//		Add selected CSS
			domClass.add(node, "dijitMenuItemSelected");
		},

		onDeselect: function(/*DomNode*/ node){
			// summary:
			//		Remove selected CSS
			domClass.remove(node, "dijitMenuItemSelected");
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = domStyle.get(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this.selectNextNode();
			}
			while(scrollamount<height){
				var highlighted_option = this.getHighlightedOption();
				if(up){
					// stop at option 1
					if(!highlighted_option.previousSibling ||
						highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this.selectPreviousNode();
				}else{
					// stop at last option
					if(!highlighted_option.nextSibling ||
						highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this.selectNextNode();
				}
				// going backwards
				var newscroll = this.domNode.scrollTop;
				scrollamount += (newscroll-oldscroll)*(up ? -1:1);
				oldscroll = newscroll;
			}
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.keyCode){
				case keys.DOWN_ARROW:
					this.selectNextNode();
					return false;
				case keys.PAGE_DOWN:
					this._page(false);
					return false;
				case keys.UP_ARROW:
					this.selectPreviousNode();
					return false;
				case keys.PAGE_UP:
					this._page(true);
					return false;
				default:
					return true;
			}
		}
	});
});

},
'cm/_base/_dom':function(){
define(["dojo/dom", 
        "dojo/dom-style",
        "dojo/dom-class"], function(dom, domStyle, domClass) {
  
/*
  This file includes generic functions for use with the DOM.
*/

/*
 * Modification History
 * --------------------
 * 24-Mar-2010 BD  [CR00191575] Added exit function to getParentByType() when 
 *                              the document root is reached. Handles the 
 *                              iframe scenario.
 */

  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  dojo.mixin(cm, {
    nextSibling: function(node, tagName) {
      //  summary:
            //            Returns the next sibling element matching tagName
      return cm._findSibling(node, tagName, true);
    },
    
    prevSibling: function(node, tagName) {
      //  summary:
            //            Returns the previous sibling element matching tagName
      return cm._findSibling(node, tagName, false);
    },
    
    getInput: function(name, multiple) {
      if(!dojo.isString(name)){
        return name;
      }
      var inputs = dojo.query("input[name='" + name + "'],select[name='" + name + "']");
      return multiple ? (inputs.length > 0 ? inputs : null) 
                                                                                  : (inputs.length > 0 ? inputs[0]:null);
    },
    
    getParentByClass: function(node, classStr) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      while (node) {
        if(domClass.contains(node, classStr)){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
    
    getParentByType: function(node, type) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      type = type.toLowerCase();
      var docRoot = "html";
      while (node) {
        // Give up when you reach the root of the doc,
        // applies to iframes
        if(node.tagName.toLowerCase() == docRoot){
          break;
        }
        if(node.tagName.toLowerCase() == type){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
  
    replaceClass: function(node, newCls, oldCls) {
      // summary:
      //   Replaces a single css class with another.
      //   node:   The node to operate on.
      //   newCls: The class to be added
      //   oldCls: The class to be removed
      domClass.remove(node, oldCls);
      domClass.add(node, newCls);
    },
    
    setClass: function(/* HTMLElement */node, /* string */classStr){
                  //      summary
                  //      Clobbers the existing list of classes for the node, replacing it with
                  //      the list given in the 2nd argument. Returns true or false
                  //      indicating success or failure.
                  node = dom.byId(node);
                  var cs = new String(classStr);
                  try{
                          if(typeof node.className == "string"){
                                  node.className = cs;
                          }else if(node.setAttribute){
                                  node.setAttribute("class", classStr);
                                  node.className = cs;
                          }else{
                                  return false;
                          }
                  }catch(e){
                          dojo.debug("dojo.html.setClass() failed", e);
                  }
                  return true;
          },
  
    _findSibling: function(node, tagName, forward) {
      
      if(!node) { return null; }
      if(tagName) { tagName = tagName.toLowerCase(); }
      var param = forward ? "nextSibling":"previousSibling";
            do {
                    node = node[param];
            } while(node && node.nodeType != 1);
  
            if(node && tagName && tagName != node.tagName.toLowerCase()) {
                    return cm[forward ? "nextSibling":"prevSibling"](node, tagName);
            }
            return node;  //      Element
    },
    
    getViewport: function(){
                  // summary: returns a viewport size (visible part of the window)
          
                  // FIXME: need more docs!!
                  var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
                  if(dojo.isMozilla){
                          return {w: dd.clientWidth, h: w.innerHeight};   // Object
                  }else if(!dojo.isOpera && w.innerWidth){
                          return {w: w.innerWidth, h: w.innerHeight};             // Object
                  }else if (!dojo.isOpera && dd && dd.clientWidth){
                          return {w: dd.clientWidth, h: dd.clientHeight}; // Object
                  }else if (b.clientWidth){
                          return {w: b.clientWidth, h: b.clientHeight};   // Object
                  }
                  return null;    // Object
          },
          
          toggleDisplay: function(node) {
            domStyle.set(node, "display", domStyle.get(node, "display") == "none" ? "": "none");
          },
          
          
          
          endsWith: function(/*string*/str, /*string*/end, /*boolean*/ignoreCase){
                  // summary:
                  //      Returns true if 'str' ends with 'end'
          
                  if(ignoreCase){
                          str = str.toLowerCase();
                          end = end.toLowerCase();
                  }
                  if((str.length - end.length) < 0){
                          return false; // boolean
                  }
                  return str.lastIndexOf(end) == str.length - end.length; // boolean
          },
          
          hide: function(n){
                  domStyle.set(n, "display", "none");
          },
          
          show: function(n){
                  domStyle.set(n, "display", "");
          }
  });
  
  return cm;
});

},
'dijit/_base/focus':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/dom", // dom.isDescendant
	"dojo/_base/lang", // lang.isArray
	"dojo/topic", // publish
	"dojo/_base/window", // win.doc win.doc.selection win.global win.global.getSelection win.withGlobal
	"../focus",
	"../selection",
	"../main"	// for exporting symbols to dijit
], function(array, dom, lang, topic, win, focus, selection, dijit){

	// module:
	//		dijit/_base/focus

	var exports = {
		// summary:
		//		Deprecated module to monitor currently focused node and stack of currently focused widgets.
		//		New code should access dijit/focus directly.

		// _curFocus: DomNode
		//		Currently focused item on screen
		_curFocus: null,

		// _prevFocus: DomNode
		//		Previously focused item on screen
		_prevFocus: null,

		isCollapsed: function(){
			// summary:
			//		Returns true if there is no text selected
			return dijit.getBookmark().isCollapsed;
		},

		getBookmark: function(){
			// summary:
			//		Retrieves a bookmark that can be used with moveToBookmark to return to the same range
			var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
			return sel.getBookmark();
		},

		moveToBookmark: function(/*Object*/ bookmark){
			// summary:
			//		Moves current selection to a bookmark
			// bookmark:
			//		This should be a returned object from dijit.getBookmark()

			var sel = win.global == window ? selection : new selection.SelectionManager(win.global);
			return sel.moveToBookmark(bookmark);
		},

		getFocus: function(/*Widget?*/ menu, /*Window?*/ openedForWindow){
			// summary:
			//		Called as getFocus(), this returns an Object showing the current focus
			//		and selected text.
			//
			//		Called as getFocus(widget), where widget is a (widget representing) a button
			//		that was just pressed, it returns where focus was before that button
			//		was pressed.   (Pressing the button may have either shifted focus to the button,
			//		or removed focus altogether.)   In this case the selected text is not returned,
			//		since it can't be accurately determined.
			//
			// menu: dijit/_WidgetBase|{domNode: DomNode} structure
			//		The button that was just pressed.  If focus has disappeared or moved
			//		to this button, returns the previous focus.  In this case the bookmark
			//		information is already lost, and null is returned.
			//
			// openedForWindow:
			//		iframe in which menu was opened
			//
			// returns:
			//		A handle to restore focus/selection, to be passed to `dijit.focus`
			var node = !focus.curNode || (menu && dom.isDescendant(focus.curNode, menu.domNode)) ? dijit._prevFocus : focus.curNode;
			return {
				node: node,
				bookmark: node && (node == focus.curNode) && win.withGlobal(openedForWindow || win.global, dijit.getBookmark),
				openedForWindow: openedForWindow
			}; // Object
		},

		// _activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		_activeStack: [],

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle to pass to unregisterIframe()
			return focus.registerIframe(iframe);
		},

		unregisterIframe: function(/*Object*/ handle){
			// summary:
			//		Unregisters listeners on the specified iframe created by registerIframe.
			//		After calling be sure to delete or null out the handle itself.
			// handle:
			//		Handle returned by registerIframe()

			handle && handle.remove();
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle to pass to unregisterWin()

			return focus.registerWin(targetWindow, effectiveNode);
		},

		unregisterWin: function(/*Handle*/ handle){
			// summary:
			//		Unregisters listeners on the specified window (either the main
			//		window or an iframe's window) according to handle returned from registerWin().
			//		After calling be sure to delete or null out the handle itself.

			handle && handle.remove();
		}
	};

	// Override focus singleton's focus function so that dijit.focus()
	// has backwards compatible behavior of restoring selection (although
	// probably no one is using that).
	focus.focus = function(/*Object|DomNode */ handle){
		// summary:
		//		Sets the focused node and the selection according to argument.
		//		To set focus to an iframe's content, pass in the iframe itself.
		// handle:
		//		object returned by get(), or a DomNode

		if(!handle){ return; }

		var node = "node" in handle ? handle.node : handle,		// because handle is either DomNode or a composite object
			bookmark = handle.bookmark,
			openedForWindow = handle.openedForWindow,
			collapsed = bookmark ? bookmark.isCollapsed : false;

		// Set the focus
		// Note that for iframe's we need to use the <iframe> to follow the parentNode chain,
		// but we need to set focus to iframe.contentWindow
		if(node){
			var focusNode = (node.tagName.toLowerCase() == "iframe") ? node.contentWindow : node;
			if(focusNode && focusNode.focus){
				try{
					// Gecko throws sometimes if setting focus is impossible,
					// node not displayed or something like that
					focusNode.focus();
				}catch(e){/*quiet*/}
			}
			focus._onFocusNode(node);
		}

		// set the selection
		// do not need to restore if current selection is not empty
		// (use keyboard to select a menu item) or if previous selection was collapsed
		// as it may cause focus shift (Esp in IE).
		if(bookmark && win.withGlobal(openedForWindow || win.global, dijit.isCollapsed) && !collapsed){
			if(openedForWindow){
				openedForWindow.focus();
			}
			try{
				win.withGlobal(openedForWindow || win.global, dijit.moveToBookmark, null, [bookmark]);
			}catch(e2){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
	};

	// For back compatibility, monitor changes to focused node and active widget stack,
	// publishing events and copying changes from focus manager variables into dijit (top level) variables
	focus.watch("curNode", function(name, oldVal, newVal){
		dijit._curFocus = newVal;
		dijit._prevFocus = oldVal;
		if(newVal){
			topic.publish("focusNode", newVal);	// publish
		}
	});
	focus.watch("activeStack", function(name, oldVal, newVal){
		dijit._activeStack = newVal;
	});

	focus.on("widget-blur", function(widget, by){
		topic.publish("widgetBlur", widget, by);	// publish
	});
	focus.on("widget-focus", function(widget, by){
		topic.publish("widgetFocus", widget, by);	// publish
	});

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'curam/util/ScreenContext':function(){
define(["dojo/_base/declare"], function(declare) {
  
  var CONTEXT_KEYS = {
      DEFAULT_CONTEXT: 112,
      SAMPLE22: 2,
      SAMPLE21: 1,
      SAMPLE13: 4,
      SAMPLE12: 2,
      SAMPLE11: 1,
      EXTAPP: 1048576,
      SMART_PANEL: 262144,
      NESTED_UIM: 131072,
      ORG_TREE: 65536,
      CONTEXT_PANEL: 32768,
      LIST_ROW_INLINE_PAGE: 8192,
      LIST_EVEN_ROW: 16384,
      TAB: 4096,
      TREE: 2048,
      AGENDA: 1024,
      POPUP: 512,
      MODAL: 256,
      HOME: 128,
      HEADER: 64,
      NAVIGATOR: 32,
      FOOTER: 16,
      OVAL: 8,
      RESOLVE: 4,
      ACTION: 2,
      ERROR: 1,
      EMPTY: 0
  };
  
  var CTX_NAMES = [['ERROR', 'ACTION', 'RESOLVE', 'OPT_VALIDATION',
                       'FOOTER', 'NAVIGATOR', 'HEADER',
                       'HOME_PAGE', 'MODAL', 'POPUP', 'AGENDA','TREE', 'TAB', 
                       'LIST_EVEN_ROW', 'LIST_ROW_INLINE_PAGE', 'CONTEXT_PANEL', 
                       'ORG_TREE','NESTED_UIM','SMART_PANEL',
                       'EXTAPP'],
                   ['SAMPLE11', 'SAMPLE12','SAMPLE13'],
                   ['SAMPLE21','SAMPLE22']];
  
  var ScreenContext = declare("curam.util.ScreenContext", null, {
    constructor: function(initialContext){
      // summary:
      //    Sets up the ScreenContext with either the initialContext parameter
      //    or a default context
      
      if (initialContext) {
        
        this.setContext(initialContext);
      } else {
        // What's the point of the OR here? Aren't they the same?
        this.currentContext = [
              CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]];
      }
    },
    
    setContext: function(newContext) {
      // summary:
      //    Sets the context. If null, a default context is used.
      var tmp = this.setup(newContext);
      
      this.currentContext =  
        ((tmp == null) ? 
         ([CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]]) : (tmp));
    },
  
    addContextBits: function(contextBits, idx) {
      // summary:
      //    Adds context bits to the existing context
      if (!contextBits) {
        return;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        this.currentContext[navig] |= pContext;
      }
      return this.currentContext[navig];
    },
  
    addAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      var navig = (idx)? idx : 0;
      this.currentContext[navig] = 4294967295;
      return this.currentContext[navig];
    },
  
    clear: function(contextBits, idx) {
      // summary:
      //    Clears the given named context bits
      if (!contextBits) {
        this.clearAll();
        return;
      }
      var navig = (idx)? idx : 0;
      if (contextBits == 0) {
        return this.currentContext[navig];
      }
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var clearedBits = this.currentContext[navig] & pContext;
        this.currentContext[navig] ^= clearedBits;
      }
      return this.currentContext[navig];
    },
  
    clearAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      if (idx) {
        this.currentContext[idx] = 0;
      } else {
        for (var i = 0; i <this.currentContext.length; i++) {
          this.currentContext[i] = 0;
        }
      }
    },
  
    updateStates: function(newContext) {
      this.clear('ERROR|ACTION|RESOLVE');
      this.currentContext[0] = this.currentContext[0] | (newContext & 7);
    },
  
    hasContextBits: function(contextBits, idx) {
      if (!contextBits) {
        return false;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var merge = this.currentContext[navig] & pContext;
        
        return (merge == pContext);
      }
      return false;
    },
  
    getValue: function() {
      // summary:
      //    Gets the value of the context.
      var outputVal = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        outputVal += this.currentContext[i] + "|";
      }
      return outputVal.substring(0,outputVal.length-1);
    },
  
    toRequestString: function() {
      return "o3ctx=" + this.getValue();
    },
  
    toBinary: function() {
      var binaryStr = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        binaryStr += this.currentContext[i].toString(2) + "|";
      }
      return binaryStr.substring(0,binaryStr.length-1);
    },
  
    toString: function() {
      var accumulatedContext = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        var ctxList = "";
        var j = 0;
        while (j < CTX_NAMES[i].length) {
          if (((this.currentContext[i] >> j) & 1) != 0) {
            ctxList +="," + CTX_NAMES[i][j];
          }
          j++;
        }
        if (ctxList == '') {
          return "{}";
        }
        accumulatedContext += 
          "|" + ctxList.replace(",", "{") + ((ctxList.length == 0)?"" : "}");
      }
      return accumulatedContext.substring(1);
    },
  
    parseContext: function(contextString) {
      var tmpString = contextString.replace(/,/g, "|");
      
      var parts = tmpString.split("|");
      var tmp = isNaN(parts[0]) ? parseInt(CONTEXT_KEYS[parts[0]]) : parts[0];
      
      for(var i = 1; i < parts.length; i++){
        tmp = tmp | (isNaN(parts[i]) ? parseInt(CONTEXT_KEYS[parts[i]]) : parts[i]);
      }

      return (isNaN(tmp) ? null : tmp);
    },
  
    setup: function(stringWithBars) {
      // summary:
      //    Sets up the context using a string delimited by '|'
      if (!stringWithBars) {
        return null;
      }
      var initialArray = ("" + stringWithBars).split("|");
      var resultArray = new Array(initialArray.length);
      
      for (var i = 0; i < initialArray.length; i++) {
        resultArray[i] = 
            this.parseContext(initialArray[initialArray.length - i - 1]);
        resultArray[i] = resultArray[i] | resultArray[i];
        if (!resultArray[i] 
              || isNaN(resultArray[i]) 
              || resultArray[i] > 4294967295) {
          return null;
        }
      }
      return resultArray;
    }
  });
  
  return ScreenContext;
});

},
'dijit/a11y':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // domStyle.style
	"dojo/_base/lang", // lang.mixin()
	"dojo/sniff", // has("ie")  1 
	"./main"	// for exporting methods to dijit namespace
], function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	 1  && lang.mixin(dijit, a11y);

	return a11y;
});

},
'dijit/form/_ToggleButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_ToggleButtonMixin

	return declare("dijit.form._ToggleButtonMixin", null, {
		// summary:
		//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

		// checked: Boolean
		//		Corresponds to the native HTML `<input>` element's attribute.
		//		In markup, specified as "checked='checked'" or just "checked".
		//		True if the button is depressed, or the checkbox is checked,
		//		or the radio button is selected, etc.
		checked: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-pressed",

		_onClick: function(/*Event*/ evt){
			var original = this.checked;
			this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
			var ret = this.inherited(arguments); // the user could reset the value here
			this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
			return ret;
		},

		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this._set("checked", value);
			var node = this.focusNode || this.domNode;
			if(this._created){ // IE is not ready to handle checked attribute (affects tab order)
				// needlessly setting "checked" upsets IE's tab order
				if(domAttr.get(node, "checked") != !!value){
					domAttr.set(node, "checked", !!value); // "mixed" -> true
				}
			}
			node.setAttribute(this._aria_attr, String(value)); // aria values should be strings
			this._handleOnChange(value, priorityChange);
		},

		postCreate: function(){ // use postCreate instead of startup so users forgetting to call startup are OK
			this.inherited(arguments);
			var node = this.focusNode || this.domNode;
			if(this.checked){
				// need this here instead of on the template so IE8 tab order works
				node.setAttribute('checked', 'checked');
			}

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.checked;
			}
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time

			this._hasBeenBlurred = false;

			// set checked state to original setting
			this.set('checked', this.params.checked || false);
		}
	});
});

},
'dijit/_Widget':function(){
define([
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if( 1 ){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dojo/touch':function(){
define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"],
function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			};
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			};
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}

	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.

		if(mouse.isRight(e)){
			return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
		}

		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				}

				win.doc.addEventListener(moveType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						function createMouseEvent(type){
							//create the synthetic event.
							//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
							var evt = document.createEvent("MouseEvents");
							evt._dojo_click = true;
							evt.initMouseEvent(type,
								true, //bubbles
								true, //cancelable
								e.view,
								e.detail,
								src.screenX,
								src.screenY,
								src.clientX,
								src.clientY,
								e.ctrlKey,
								e.altKey,
								e.shiftKey,
								e.metaKey,
								0, //button
								null //related target
							);
							return evt;
						}
						var mouseDownEvt = createMouseEvent("mousedown");
						var mouseUpEvt = createMouseEvent("mouseup");
						var clickEvt = createMouseEvent("click");

						setTimeout(function(){
							on.emit(target, "mousedown", mouseDownEvt);
							on.emit(target, "mouseup", mouseUpEvt);
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						if(clickTracker && !e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox")
								&& e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO"){
								 // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								 // but it is still needed for checkboxes and radio buttons, otherwise in some cases
								 // the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(has("touch")){
		if(hasPointer){
			// MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener(pointer.down, function(evt){
					doClicks(evt, pointer.move, pointer.up);
				}, true);
			});
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
						lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});

					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}

				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
						lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	 1  && (dojo.touch = touch);

	return touch;
});

},
'idx/string':function(){
/*
 * Licensed Materials - Property of IBM
 * (C) Copyright IBM Corp. 2010, 2012 All Rights Reserved
 * US Government Users Restricted Rights - Use, duplication or 
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/_base/lang","idx/main","dojo/string"], function (dLang,iMain,dString)
{
    /**
 	 * @name idx.string
 	 * @namespace Provides Javascript utility methods in addition to those provided by Dojo.
 	 */
	var iString = dLang.getObject("string", true, iMain);
	var regexChars = "\\[]()^.+*{}?!=-";
	var regexCache = {};
	var regexCacheCount = 0;
	var regexCacheMax = 50;

	/**
	 * @public 
	 * @function
	 * @name idx.string.unescapedIndexOf
	 * @description Searches the specified text for the first unescaped index of
	 *              a character contained in the specified string of characters.
	 * @param {String} text The text to search.
	 * @param {String} chars The characters for which to search (any of these).
	 * @param {String} escaper The optional character to use for escaping (defaults to "\\").
	 * @param {Number} limit The optional limit to the number of indexes desired in case only
	 *                 the first or first few are needed (use null, undefined, zero, false, or
	 * 	               a negative number to indicate no limit).
	 * @returns {Number[]} The array of indexes at which one of the specified characters
	 *                     is found or an empty array if not found.
	 */
	iString.unescapedIndexesOf = function(/*string*/ text, 
										  /*string*/ chars, 
										  /*string*/ escaper,
										  /*number*/ limit) {
		if (!chars || (chars.length == 0)) {
			throw "One or more characters must be provided to search for unescaped characters: "
				  + " chars=[ " + chars + " ], escaper=[ " + escaper + " ], text=[ " + text + " ]";
		}
		if (!escaper || escaper.length == 0) {
			escaper = "\\";
		}
		if (escaper.length > 1) {
			throw "The escaper must be a single character for unescaped character search: "
				  + " escaper=[ " + escaper + " ], chars=[ " + chars
				  + " ], text=[ " + text + " ]";
		}
		if (chars.indexOf(escaper) >= 0) {
			throw "The escaping character cannot also be a search character for unescaped character search: "
				  + " escaper=[ " +  escaper + " ], separators=[ " + separators
				+ " ] text=[ " + text + " ]";
			
		}
		if ((limit === null) || (limit === undefined) || (limit === 0) || (limit === false)) {
			limit = -1;
		}
		if (limit < 0) limit = 0;
		var result = [];
		var index = 0;
		var escaping = false;
		var current = null;
		for (index = 0; index < text.length; index++) {
			current = text.charAt(index);
			if (escaping) {
				escaping = false;
				continue;
			}
			if (current == escaper) {
				escaping = true;
				continue;
			}
			if (chars.indexOf(current) >= 0) {
				result.push(index);
				if (limit && (result.length == limit)) break;
			}
		}
		return result;
	};

	/**
	 * @public 
	 * @function
	 * @name idx.string.unescapedSplit
	 * @description Similar to iString.parseTokens, this function will split the
	 * 	            the specified text on unescaped separator characters, but will 
	 *              NOT remove any escaping in the original text so that the elements
	 *              in the returned array will still contain any original escaping.
	 * @param {String} text The text to split.
	 * @param {String} separators The optional string containing the separator 
	 *                 characters (defaults to ",")
	 * @param {String} escaper The optional character to use for escaping (defaults to "\\").
	 * @param {Number} limit The optional limit to the number of tokens desired in case only
	 *                 the first or first few are needed (use null, undefined, zero, false, or
	 * 	               a negative number to indicate no limit).
	 * @returns {String[]} Return an array of string parts.
	 */
	iString.unescapedSplit = function(/*string*/  text, 
	                                  /*string*/  separators, 
								      /*string*/  escaper,
								  	/*number*/ limit) {
		if (!separators || (separators.length == 0)) {
			separators = ",";
		}
		if (!escaper || escaper.length == 0) {
			escaper = "\\";
		}
		if (escaper.length > 1) {
			throw "The escaper must be a single character for escaped split: "
				  + " escaper=[ " + escaper + " ], separators=[ " + separators
				  + " ], text=[ " + text + " ]";
		}
		if (separators.indexOf(escaper) >= 0) {
			throw "The escaping character cannot also be a separator for escaped split: "
				  + " escaper=[ " +  escaper + " ], separators=[ " + separators
				+ " ] text=[ " + text + " ]";
			
		}
		if ((limit === null) || (limit === undefined) || (limit === 0) || (limit === false)) {
			limit = -1;
		}
		if (limit < 0) limit = 0;
		var result = [];
		var index = 0;
		var escaping = false;
		var current = null;
		var start = 0;
		for (index = 0; index < text.length; index++) {
			current = text.charAt(index);
			if (escaping) {
				escaping = false;
				continue;
			}
			if (current == escaper) {
				escaping = true;
				continue;
			}
			if (separators.indexOf(current) >= 0) {
				if (start == index) {
					result.push("");
				} else {
					result.push(text.substring(start,index));
				}
				start = index + 1;
				if (limit && (result.length == limit)) break;
			}
		}
		if ((!limit) || (limit && result.length < limit)) {
			if (start == text.length) {
				result.push("");
			} else {
				result.push(text.substring(start));
			}
		}
		return result;						
	};
	
	/**
	 * @public 
	 * @function
	 * @name idx.string.parseTokens
	 * @description Similar to iString.unescapedSplit, this function will split the
	 * 	            the specified text on unescaped separator characters, but will 
	 *              also remove any escaping in the original text when creating the
	 *              tokens unless those escaped characters are included in the optional
	 *              "specialChars" parameter (in which case they remain escaped if 
	 *              they are escaped in the original).
	 * @param {String} text The text to split.
	 * @param {String} separators The optional string containing the separator 
	 *        characters (defaults to ",")
	 * @param {String} escaper The optional character to use for escaping (defaults to "\\").
	 * @param {String} specialChars The optional string of special characters that if escaped
	 *                              in the original text should remain escaped in the tokens.
	 * @returns {String[]} Return an array of string parts.
	 */
	iString.parseTokens = function(/*string*/  text, 
	                               /*string*/  separators, 
								   /*string*/  escaper,
								   /*string*/  specialChars) {
		if (!separators || (separators.length == 0)) {
			separators = ",";
		}
		if (!escaper || escaper.length == 0) {
			escaper = "\\";
		}
		if (escaper.length > 1) {
			throw "The escaper must be a single character for token parsing: "
				  + " escaper=[ " + escaper + " ], separators=[ " + separators
				  + " ], text=[ " + text + " ]";
		}
		if (separators.indexOf(escaper) >= 0) {
			throw "The escaping character cannot also be a separator for token parsing: "
				  + " escaper=[ " +  escaper + " ], separators=[ " + separators
				+ " ] text=[ " + text + " ]";
			
		}
		if (specialChars && specialChars.length == 0) {
			specialChars = null;
		}
		var index = 0;
		var result = [];
		var start = 0;
		var escaping = false;
		var part = "";
		var end = -1;
		var current = null;
		for (index = 0; index < text.length; index++) {
			current = text.charAt(index);
			end = -1;
			if (!escaping && current==escaper) {
				if (specialChars && ((index+1)<text.length) 
				    && (specialChars.indexOf(current)>=0)) {
					// we have an escaped special character
					index++;
					continue;
				}
				
				// take the characters up to and excluding the current
				part = part + text.substring(start, index);
				
				// set the starting position to the next character
				start = index + 1;
				escaping = true;
				continue;
			}
			// check if we are escaping
			if (escaping) {
				escaping = false;
				continue;
			}
			// check if the current character is a separator
			if (separators.indexOf(current) >= 0) {
				end = index;
			}
							
			if (end >= 0) {
				part = part + text.substring(start, end);
				start = end + 1;
				result.push(part);
				part = "";
			}
		}
		
		// get the last part
		if ((end < 0) && (start < text.length)) {
			part = part + text.substring(start);
			result.push(part);
		} else if ((end >= 0)||escaping) {
			result.push(part);
		}
				
		return result;
	};
		
	/**
	 * @public 
	 * @function
	 * @name idx.string.escapedChars
	 * @description Escapes the specified characters in the specified text using the 
	 *              specified escape character.  The escape character is also escaped
	 *              using itself.
	 * @param {String} text The text to be escaped.
	 * @param {String} The string containing the characters to be escaped.
	 * @param {String} escaper The optional character to use for escaping (defaults to "\\").
	 * @returns {String[]} Return the escaped text.
	 */
	iString.escapeChars = function(/*string*/ text, /*string*/ chars, /*string*/ escaper) {
		if (!chars || (chars.length == 0)) {
			chars = "";
		}
		if (!escaper || escaper.length == 0) {
			escaper = "\\";
		}
		if (escaper.length > 1) {
			throw "The escaper must be a single character for escaped split: "
				  + " escaper=[ " + escaper + " ], chars=[ " + chars
				  + " ], text=[ " + text + " ]";
		}
		if (chars.indexOf(escaper) >= 0) {
			throw "The escaping character cannot also be a separator for escaped split: "
				  + " escaper=[ " +  escaper + " ], chars=[ " + chars
				+ " ] text=[ " + text + " ]";
			
		}
		var chars = chars + escaper;
		var regex = regexCache[chars];
		var pattern = "";
		if (! regex) {
			pattern = "([";
			for (index = 0; index < chars.length; index++) {
				if (regexChars.indexOf(chars.charAt(index)) >= 0) {
					pattern = pattern + "\\";
				}
				pattern = pattern + chars.charAt(index);
			}
			pattern = pattern + "])";
			try {
				regex = new RegExp(pattern, "g");
			} catch (e) {
				console.log("Pattern: " + pattern);
				throw e;
			}
			if (regexCacheCount < regexCacheMax) {
				regexCache[chars] = regex;
				regexCacheCount++;
			}
		}
		return text.replace(regex, escaper + "$1");
	};
		
	/**
	 * @public 
	 * @function
	 * @name idx.string.escapedJoin
	 * @description Joins the array into a single string separated by the specified 
	 *              separator and using the specified escaper to escape the separator.
	 * @param {String[]} arr The array of objects to join as a string.
	 * @param {String} separator The single-character string containing the separator character.
	 * @param {String} escaper The optional single character to use for escaping (defaults to "\\")
	 * @returns {String[]} Return an array of string parts.
	 */
	iString.escapedJoin = function(/*array*/ arr, /*string*/ separator, /*string*/ escaper) {
		if (!separator || (separator.length == 0)) {
			separator = ",";
		}
		if (separator.length > 1) {
			throw "Only one separator character can be used in escapedJoin: "
					" separator=[ " + separator + " ], text=[ " + text + " ]";
		}
		if (!escaper || escaper.length == 0) {
			escaper = "\\";
		}
		if (escaper.length > 1) {
			throw "The escaper must be a single character for escaped split: "
				  + " escaper=[ " + escaper + " ], separator=[ " + separator
				  + " ], text=[ " + text + " ]";
		}
		if (separator.indexOf(escaper) >= 0) {
			throw "The escaping character cannot also be a separator for escaped split: "
				  + " escaper=[ " +  escaper + " ], separator=[ " + separator
				+ " ] text=[ " + text + " ]";
			
		}
	
		var index = 0;
		var result = "";
		var part = null;
		var prefix = "";
		
		for (index = 0; index < arr.length; index++) {
			part = arr[index];
			part = iString.escapeChars(part, separator, escaper);
			result = result + prefix + part;
			prefix = separator;
		}
		
		return result;
	};
	
	/**
	 * @public 
	 * @function
	 * @name idx.string.startsWith
	 * @description Checks if the specified text starts with the specified prefix.
	 * @param {String} text The text to look at.
	 * @param {String} prefix The prefix to check for.
	 * @returns {Boolean} Return true if string "text" starts with "prefix"
	 */
	iString.startsWith = function(/*string*/ text, /*string*/ prefix){
		return (dLang.isString(text) && dLang.isString(prefix) && text.indexOf(prefix) === 0); // Boolean
	};
	
	/**
	 * @public 
	 * @function
	 * @name idx.string.endsWith
	 * @description Checks if the specified text ends with the specified suffix.
	 * @param {String} text The text to look at.
	 * @param {String} suffix The suffix to check for.
	 * @returns {Boolean} Return true if string "text" ends with "suffix"
	 */
	iString.endsWith = function(/*string*/ text, /*string*/ suffix){
		return (dLang.isString(text) && dLang.isString(suffix) && text.lastIndexOf(suffix) === text.length - suffix.length); // Boolean
	};

	/**	
	 * @public 
	 * @function
	 * @name idx.string.equalsIgnoreCase
	 * @description Case insensitive check for string equality.
	 * @param {String} s1 The first string.
	 * @param {String} s2 The second string.
	 * @returns {Boolean} Return true if string "s1" equals to "s2" with ignoring case
	 */
	iString.equalsIgnoreCase = function(/*string*/ s1, /*string*/ s2){
		return (dLang.isString(s1) && dLang.isString(s2) && s1.toLowerCase() === s2.toLowerCase()); // Boolean
	};
	
	/**	
	 * @public 
	 * @function
	 * @name idx.string.isNumber
	 * @description Checks if the specified parameter is a number and is finite.
	 * @param {Number} n The value to check.
	 * @returns {Boolean} Return true if 'n' is a Number
	 */
	iString.isNumber = function(/*number*/ n){
		return (typeof n == "number" && isFinite(n)); // Boolean
	};
	
	/**
	 * @public 
	 * @function
	 * @name idx.string.nullTrim
	 * @description Trims the specified string, and if it is empty after trimming, returns null.  
	 *              If the specified parameter is null or undefined, then null is returned.
	 * @param {String} str the string to trim
	 * @returns {String} Trimmed string or null if nothing left
	 */
    iString.nullTrim = function(/*String*/ str) {
            if (! str) return null;
            var result = dString.trim(str);
            return (result.length == 0) ? null : result;
        };
        
     /**
	 * @public 
	 * @function
	 * @name idx.string.propToLabel
	 * @description Converts a property name that is typically separated by camel case into a
	 *              psuedo label (i.e.: one that is not translated but based off the property
	 *              name but formatted nicer).  This method converts dots/periods into slashes. 
	 * @param {String} propName The property name to convert.
	 * @returns {String} The converted psuedo-label.
      *
      */
     iString.propToLabel = function(/*String*/ propName) {
     	if (!propName) return propName;
     	
	    // split the property name at any case switches or underscores
	    propName = dString.trim(propName);
	    var upperProp = propName.toUpperCase();
	    var lowerProp = propName.toLowerCase();
	    var index = 0;
	    var result = "";
	    var prevResult = "";
	    var prevUpper = false;
	    var prevLower = false;

		for (index = 0; index < propName.length; index++) {
	    	var upperChar = upperProp.charAt(index);
	        var lowerChar = lowerProp.charAt(index);
	        var origChar  = propName.charAt(index);

	        var upper = ((upperChar == origChar) && (lowerChar != origChar));
	        var lower = ((lowerChar == origChar) && (upperChar != origChar));

	        // check for spaces or underscores
	        if ((origChar == "_") || (origChar == " ")) {
	        	if (prevResult == " ") continue;
	         	prevResult = " ";
	            prevUpper  = upper;
	            prevLower  = lower;
	            result = result + prevResult;
	            continue;
	        }
	           
	        // check for dot notation
	        if (origChar == ".") {
	        	prevResult = "/";
	        	prevUpper = upper;
	        	prevLower = lower;
	        	result = result + " " + prevResult + " ";
	        	continue;
	        }

	        // check if this is the first character
	        if ((index == 0) || (prevResult == " ")) {
	        	prevResult = upperChar; 
	            prevUpper  = upper;
	            prevLower  = lower;
	            result = result + prevResult;
	            continue;
	        }

	        if ((!upper) && (!lower)) {
	        	if (prevUpper || prevLower) {
	            	result = result + " ";
	            }

	            // the character is not alphabetic, and neither is this one
	            prevUpper = upper;
	            prevLower = lower;
	            prevResult = origChar;

	            result = result + prevResult;
	            continue;
	        }

	        if ((!prevUpper) && (!prevLower)) {
	        	// previous character was non-alpha, but this one is alpha
	        	var prevSlash = (prevResult == "/");
	            prevUpper = upper;
	            prevLower = lower;
	            prevResult = upperChar;
	            if (prevSlash) {
	            	result = result + prevResult;
	            } else {
	            	result = result + " " + prevResult;
	            }
	            continue;
	        }

	        // if we get here then both the previous and current character are
	        // alphabetic characters so we need to detect shifts in case
	        if (upper && prevLower) {
	        	// we have switched cases
	            prevResult = upperChar;
	            prevUpper  = upper;
	            prevLower = lower;
	            result = result + " " + prevResult;
	            continue;
	        }

	        // if we get here then we simply use the lower-case version
	        prevResult = lowerChar;
	        prevUpper  = upper;
	        prevLower  = lower;
	        result = result + prevResult;
	 	}
	    
	    // return the result
	    return result;        
     };
     
     return iString;
});

},
'dojo/request':function(){
define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'curam/widget/IDXFilteringSelect':function(){
/*
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * Copyright IBM Corporation 2012.
 *
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the US
 * Copyright Office.
 */

define(["dijit/registry",
        "dojo/_base/declare",
        "dojo/on", 
        "dojo/dom", 
        "dojo/text!curam/widget/templates/IDXComboBox.html",
        "idx/form/FilteringSelect"
        ], function(registry, declare, on, template) {
  /*
   * Modification History
   * --------------------
     * 27-Mar-2014  AS  [CR00426939] Rollback changes done in CR00416476.
     * 27-Mar-2014  AS  [CR00416476] Removed the hint text causing problem 
     *                               with Jaws.
     * 10-Mar-2014  AS  [CR00415345] Handled the enter key on open dropdown.
     * 29-Oct-2013 NLH [CR00405850]   Initial version.
     */

    /**
     * @name curam.widget.IDXFilteringSelect
     * @namespace Override of the Dojo oneui ComboBox in order to make the oneui Combobox
     *              accessible using screen reader.
     * 
     * 
     */
    var IDXFilteringSelect = declare("curam.widget.IDXFilteringSelect", idx.oneui.form.FilteringSelect,
    /**
     * @lends curam.widget.IDXFilteringSelect.prototype
     */
    {
      templateString: template,
      // Flag which indicates if the enter key is used on open dropdown
      enterKeyOnOpenDropDown: false,
      
      postCreate : function() {
        // Attached a keyboard event listener so that we can set a flag
        // indicating enter is pressed in open state of dropdown
        on(this.focusNode, "keydown",function(e){
          var widget = registry.byNode(dom.byId("widget_" + e.target.id)); 
          if(e.keyCode == dojo.keys.ENTER && widget._opened) {
            widget.enterKeyOnOpenDropDown = true;
           }
         });
         
        this.inherited(arguments);
      }
    });
    
    return IDXFilteringSelect;
  });
},
'dijit/form/_FormValueWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

	// module:
	//		dijit/form/_FormValueWidget

	return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
		// directly in the template as read by the parser in order to function. IE is known to specifically
		// require the 'name' attribute at element creation time.  See #8484, #8660.

		_layoutHackIE7: function(){
			// summary:
			//		Work around table sizing bugs on IE7 by forcing redraw

			if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
				var domNode = this.domNode;
				var parent = domNode.parentNode;
				var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
				var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
				var _this = this;
				while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
					(function ping(){
						var disconnectHandle = _this.connect(parent, "onscroll",
							function(){
								_this.disconnect(disconnectHandle); // only call once
								pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
								_this.defer(function(){
									pingNode.style.filter = origFilter;
								}); // restore custom filter, if any
							}
						);
					})();
					parent = parent.parentNode;
				}
			}
		}
	});
});

},
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\ttabIndex=\"-1\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\n/></span>\n",
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,textDirNode\"\n\t\trole=\"presentation\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<span data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<span class=\"dijitInline dijitIcon dijitMenuExpand\"></span>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</span>\n\t</td>\n</tr>\n",
'url:curam/layout/resources/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer dijitAlignTop\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container dijitAlignClient\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:curam/widget/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTab\" id=\"${id}_tabButtonContainer\">\n  <div role=\"presentation\" class='dijitTabInnerDiv'>\n    <div role=\"presentation\" class='dijitTabContent'>\n\t    <span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t    <div role=\"presentation\" aria-labelledby='${id}'>\n\t\t    <span data-dojo-attach-point='containerNode,focusNode' class='tabLabel' id='${id}'></span>\n\t\t    <button class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t\t        tabindex=\"-1\">\n\t\t\t    <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>Close Tab</span>\n        \t</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:idx/widget/templates/HoverHelpTooltip.html':"<div class=\"idxOneuiHoverHelpTooltip idxOneuiHoverHelpTooltipLeft\" role=\"alert\"\r\n\t><div\r\n\t\t><span data-dojo-attach-point=\"closeButtonNode\" class=\"idxOneuiHoverHelpTooltipCloseIcon\" \r\n\t\t\tdata-dojo-attach-event=\"ondijitclick: hideOnClickClose\" role=\"button\" aria-label=\"${buttonClose}\"\r\n\t\t\t><span class=\"idxHoverHelpCloseText\">x</span\r\n\t\t></span\r\n\t></div\r\n\t><div data-dojo-attach-point=\"outerContainerNode\" class=\"idxOneuiHoverHelpTooltipContainer idxOneuiHoverHelpTooltipContents\"\r\n\t\t><div data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\r\n\t\t><a target=\"_blank\" href=\"#updateme\" role=\"link\" class=\"idxOneuiHoverHelpTooltipLearnLink\" data-dojo-attach-point=\"learnMoreNode\"><span>${learnMoreLabel}</span></a\r\n\t></div\r\n\t><div class=\"idxOneuiHoverHelpTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\r\n></div>",
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"focusNode\" role=\"button\">\n  <div role=\"presentation\" class=\"dijitTabInnerDiv\">\n    <div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\">\n\t<span role=\"presentation\" class=\"dijitInline dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n</div>  </div>\n</div>",
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTabInner dijitTabContent\">\n\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point='containerNode,focusNode' class='tabLabel'></span>\n\t<span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t  role=\"presentation\">\n\t\t<span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t\t\t></span>\n</div>\n",
'url:dijit/form/templates/DropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\taria-haspopup=\"true\"\n\tdata-dojo-attach-point=\"_popupStateNode\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\n\t/></div\n></div>\n",
'url:curam/layout/resources/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition} tabStrip-disabled dijitLayoutContainer\"><!-- CURAM-FIX: removed style=\"visibility:hidden, dd the tabStrip-disabled class by default.\" -->\n\t<div data-dojo-type=\"curam.layout._ScrollingTabControllerMenuButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_menuBtn\"\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"Navigation menu\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_leftBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:'Navigation left'\"\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_rightBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:'Navigation right'\"\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper dijitTabContainerTopNone dijitAlignClient' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip dijitTabContainerTop-tabs'></div>\n\t</div>\n</div>",
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\"\n\t   cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n",
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n></div>\n",
'url:curam/widget/templates/IDXComboBox.html':"<div id=\"widget_${id}\" class=\"dijitReset dijitInline idxComposite\" \n  ><div class=\"idxLabel dijitInline dijitHidden\" dojoAttachPoint=\"labelWrap\"\n    ><span class=\"idxRequiredIcon\">*&nbsp</span\n    ><label for=\"widget_${id}\" dojoAttachPoint=\"compLabelNode\"\n    ></label\n  ></div\n  ><div class=\"dijitInline\"\n    ><div class=\"dijit dijitInline dijitReset dijitInlineTable dijitLeft\" role=\"listbox\" dojoAttachPoint=\"stateNode,oneuiBaseNode,_aroundNode,_popupStateNode\"\n      ><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer' dojoAttachPoint=\"_buttonNode\" role=\"presentation\"\n      ><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n      ${_buttonInputDisabled}\n      /></div\n      ><div class=\"dijitReset dijitInputField dijitInputContainer\" role=\"listbox\" dojoAttachPoint=\"inputContainer\" dojoAttachEvent=\"onmouseenter: _onInputContainerEnter, onmouseleave: _onInputContainerLeave\"\n        ><input class='dijitReset dijitInputInner' ${!nameAttrSetting}  type=\"text\" autocomplete=\"off\" dojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\" \n      /></div\n    ></div\n    ><div class=\"idxUnit dijitInline dijitHidden\" dojoAttachPoint=\"compUnitNode\"\n    ></div\n    ><div class='dijitReset dijitValidationContainer dijitInline' dojoAttachPoint=\"iconNode\"\n      ><div class=\"dijitValidationIcon\"\n      ><input class=\"dijitReset dijitInputField  dijitValidationInner\" value=\"&#935;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"/\n    ></div></div\n    ><div class=\"dijitHidden idxHintOutside\" dojoAttachPoint=\"compHintNode\"></div\n  ></div\n></div>",
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition} tabStrip-disabled dijitLayoutContainer\"><!-- CURAM-FIX: removed style=\"visibility:hidden, dd the tabStrip-disabled class by default.\" -->\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_menuBtn\"\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"Navigation menu\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_leftBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:'Navigation left'\"\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_rightBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:'Navigation right'\"\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper dijitTabContainerTopNone dijitAlignClient' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip dijitTabContainerTop-tabs'></div>\n\t</div>\n</div>",
'*now':function(r){r(['dojo/i18n!*preload*dojo/nls/cdej-ua-ieg*["ar","ca","cs","da","de","el","en-gb","en-us","es-es","fi-fi","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nl-nl","nb","pl","pt-br","pt-pt","ru","sk","sl","sv","th","tr","zh-tw","zh-cn","ROOT"]']);}
}});
define("dojo/cdej-ua-ieg", [], 1);
