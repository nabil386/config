require({cache:{
'dojo/request/default':function(){
define([
	'exports',
	'require',
	'../has'
], function(exports, require, has){
	var defId = has('config-requestProvider'),
		platformId;

	if( 1  || has('host-webworker')){
		platformId = './xhr';
	}else if( 0 ){
		platformId = './node';
	/* TODO:
	}else if( 0 ){
		platformId = './rhino';
   */
	}

	if(!defId){
		defId = platformId;
	}

	exports.getPlatformDefaultId = function(){
		return platformId;
	};

	exports.load = function(id, parentRequire, loaded, config){
		require([id == 'platform' ? platformId : defId], function(provider){
			loaded(provider);
		});
	};
});

},
'cm/_base/_behavior':function(){

/*
 * Modification History
 * --------------------
 * 24-Jul-2012 MV  [CR00336202] Stop relying on Dojo nonpublic API.  
 */

define(["dojo/behavior"
        ], function() {
  
  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  dojo.mixin(cm, {
    behaviors: {},
    addedBehaviors: {},

    addBehavior: function(name) {
      // summary: Adds a previously registered behavior to the page.
    //          If the behavior with the given name has not been 
    //          registered, no action is taken.
      var b = cm.behaviors[name];
      
      //Only add any particular behavior once.
      if(b && !cm.addedBehaviors[name]) {
        dojo.behavior.add(b);
        cm.addedBehaviors[name] = true;
        dojo.behavior.apply();
      }
    },
    
    registerBehavior: function(name, behavior) {
      cm.behaviors[name] = behavior;
    }
  });
  
  return cm;
});

},
'curam/date':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013,2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 10-Oct-2013 SK  [CR00411875] Month names override implemented.
   */

define(["curam/define", "dojo/date", "curam/date/locale", "dojo/date/stamp" ],
         function(def, date, loc, stamp) {
  
  curam.define.singleton("curam.date", {
    /* externally set locale used when testing */
        testLocale: null,
        
   /**
    * Determines if the passed string matches the date format
    * (hence is a valid date).
    *
    * @str the string to be checked.
    * @fmt the valid date format.
    */
    isDate: function(str,fmt) {
      return (curam.date.getDateFromFormat(str,fmt) != 0);
    },
   /**
    * Compares two dates to determine if the first one is greater than the
    * second one, or they are equal.
    * 
    * @param d1 The first formatted date string to be compared
    * @param df1 The format string for the first date.
    * @param d2 The second formatted date string to be compared
    * @param df2 The format string for the second date.
    * @return 1 if date1 is greater than date2, 0 if the dates are equal.
    *        -1 if either of the two dates is in an invalid format
    *        (NOTE: the previous usage didn't cater for the situation d2 < d1)
    */
    compareDates: function(d1,df1,d2,df2) {
      var d1 = curam.date.getDateFromFormat(d1, df1);
      if (d1 == 0) {
        return -1;
      }
      var d2 = curam.date.getDateFromFormat(d2, df2);
      if (d2 == 0) {
        return -1;
      }
      // could return -1 for d2 > d1, but obviously the previous usage
      // does not allow this (see description)
      return date.compare(d1, d2, "date");
    },
   /**
    * Formats the date using the specified format.
    *
    * @param d the JavaScript Date object
    * @param fmt the date format string .
    * @return the date string in the output format specified.
    */
    formatDate: function(d,fmt) {
      var result = loc.format(d, {selector:"date", datePattern:fmt, locale:curam.date.getLocale()});
      return result;
    },
  /**
   * Converts the given string into JavaScript Date object.
   * 
   * Original doc:
   * This function takes a date string and a format string. It matches
   * If the date string matches the format string, it returns the 
   * getTime() of the date. If it does not match, it returns 0.
   *
   * This function uses the same format strings as the 
   * java.text.SimpleDateFormat class, with minor exceptions.
   *
   * The format string can be "ISO8601" or consist of the following 
   * abbreviations:
   * 
   * Field        | Full Form          | Short Form
   * -------------+--------------------+-----------------------
   * Year         | yyyy (4 digits)    | yy (2 digits), y (2 or 4 digits)
   * Month        | MMM (name or abbr.)| MM (2 digits), M (1 or 2 digits)
   * Day of Month | dd (2 digits)      | d (1 or 2 digits)
   * Hour (1-12)  | hh (2 digits)      | h (1 or 2 digits)
   * Hour (0-23)  | HH (2 digits)      | H (1 or 2 digits)
   * Hour (0-11)  | KK (2 digits)      | K (1 or 2 digits)
   * Hour (1-24)  | kk (2 digits)      | k (1 or 2 digits)
   * Minute       | mm (2 digits)      | m (1 or 2 digits)
   * Second       | ss (2 digits)      | s (1 or 2 digits)
   * AM/PM        | a                  |
   *
   * Examples:
   *  "MMM d, y" matches: January 01, 2000
   *                      Dec 1, 1900
   *                      Nov 20, 00
   *  "m/d/yy"   matches: 01/20/00
   *                      9/2/00
   *  "MMM dd, yyyy hh:mm:ssa" matches: "January 01, 2000 12:30:45AM"
   * ------------------------------------------------------------------
   * @param str the formatted Date string
   * @param fmt the format to be used to parse the date string.
   * @return the parsed JavaScript Date object or 0 if the parsing fails.
   */
   getDateFromFormat: function(str,fmt) {
     var res = loc.parse(str, {selector:"date", datePattern:fmt, locale:curam.date.getLocale() });
     return (res == null) ? "0" : res;
   },
  /**
   * Parses a ISO8601 String and returns a Date object
   * 
   * @param val The string in ISO8601 format
   * @return A JavaScript Date object
   */  
   ISO8601StringToDate: function(val) {
      return stamp.fromISOString(val);
    },
    /**
     * Gets the locale to be used by the date functions.
     * 
     * @returns the locale specified on the page, the locale set by the testing environment,
     * or the default fall-back locale.
     */
    getLocale: function()  {
      var appLoc = (typeof jsL != "undefined" && jsL)
                     ? jsL : (curam.config ? curam.config.locale : null);
      return appLoc || curam.date.testLocale || 'en';
    }
  });
  return curam.date;
});
},
'dojo/date':function(){
define(["./has", "./_base/lang"], function(has, lang){
// module:
//		dojo/date

var date = {
	// summary:
	//		Date manipulation utilities
};

date.getDaysInMonth = function(/*Date*/dateObject){
	// summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

date.isLeapYear = function(/*Date*/dateObject){
	// summary:
	//		Determines if the year of the dateObject is a leap year
	// description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
date.getTimezoneName = function(/*Date*/dateObject){
	// summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	// description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	// summary:
	//		Compare two date objects by date, time, or both.
	// description:
	//		Returns 0 if equal, positive if a > b, else negative.
	// date1:
	//		Date object
	// date2:
	//		Date object.  If not specified, the current Date is used.
	// portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}

	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	// summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	// date: Date
	//		Date object to start with
	// interval:
	//		A string representing the interval.  One of the following:
	//		"year", "month", "day", "hour", "minute", "second",
	//		"millisecond", "quarter", "week", "weekday"
	// amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accommodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo/cldr/supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	// summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	// date1:
	//		Date object
	// date2:
	//		Date object.  If not specified, the current Date is used.
	// interval:
	//		A string representing the interval.  One of the following:
	//		"year", "month", "day", "hour", "minute", "second",
	//		"millisecond", "quarter", "week", "weekday"
	//
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(date.difference(date1, date2, "day"));
			var weeks = parseInt(date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

// Don't use setObject() because it may overwrite dojo/date/stamp (if that has already been loaded)
 1  && lang.mixin(lang.getObject("dojo.date", true), date);

return date;
});

},
'curam/modal/CuramCarbonModal':function(){
/*
 *  IBM Confidential
 *  
 *  OCO Source Materials
 *  
 *  Copyright IBM Corporation 2020,2022.
 *  
 *  The source code for this program is not published or otherwise divested
 *  of its trade secrets, irrespective of what has been deposited with the 
 *  US Copyright Office
 */

/*
 * Modification History
 * --------------------
 * 12-Dec-2022  AT [SPM-126340] Pass the frameID as part of the form-change event.
 * 09-Dec-2002 COC [SPM-126340] Removed isAutorecoveryAlready and updated the hideAndClose beforeClose publish 
 * event to also include the href.
 * 08-Dec-2022 AT [SPM-126340] Autorecovery refactor.
 * 02-Dec-2022 COC [SPM-126118] Moved the autorecovery logic from hideAndClose to AutoRecoveryAPI.js file.
 * 01-Dec-2022 AT [SPM-126293] Support for publish of message when all form components have registered.
 * 29-Nov-2022 COC [SPM-126183] Moved the autorecovery logic in the postCreate further down so it didnt 
 * matter if the modal had a submit button or not. 
 * 24-Nov-2022 COC [SPM-126222] Moved the auto recovery functionality over to the AutoRecoveryAPI.js.
 * 18-Nov-2022 AT [SPM-126057] Added logic to handle auto recovery in wizards.
 * 17-Nov-2022 COC [SPM-125684] Updates based on changes for the multiple tab flows adding isAutorecoveryAlready
 * and a new publish event for createAutorecovery.
 * 08-Nov-2022 COC [SPM-125563] Added the auto recovery enabled condition around the new functionality.
 * 26-Oct-2022 BD  [SPM-125943] Removing the auto recovery instance and add topic when the modal
 * is restored.
 * 26-Aug-2022 COC [SPM-125576] Auto recovery to include the foreground page in the local cache.
 * 28-Jun-2022 SO  [RTC278171] Fix esc key press issue on the remaining scenarios.
 * 14-Jun-2022 BOS [RTC278134] For passive modals, fixing issue where passive state bleeding
 * from one modal to another.
 * 31-May-2022 BOS [RTC278071] Fix issue where buttons missing on next steps of wizard
 * where they are not configured on a previous step.
 * 12-May-2022 BOS [RTC277988] Activate spinner if user selects search button.
 * 20-Apr-2022 BOS [RTC277698] Fixing incorrect window unsubscription for custom
 *                             address service event.
 * 12-Apr-2022 GB  [RTC277636] Hiding the modal footer buttons when in a passive modal.
 * 07-Apr-2022 BOS [RTC277603] Hookpoint to enable draggable modals.
 * 28-Mar-2022 GG  [RTC274773] Reverted order of execution when unloading the dialog 
 *							   to make sure _setModalCurrentlyOpening(false) has priority. 
 * 03-Mar-2022 SK  [RTC276972] Added the exclusion for the user preferences dialog to avoid regiserting
 *                             the content click interceptors of that handcrafted dialog.
 * 03-Mar-2022 SK  [RTC276972] Avoiding adding buttons for ipn clicks.
 * 03-Mar-2022 SK  [RTC276972] Re-activating the modal buttons following the onclick-specific handling.
 * 21-Jan-2022 SK  [RTC274885] Corrected the unconditional back-focus statement leading to the session timeout errors.
 * 06-Oct-2021 BOS [RTC273988] Update to how data-testid attribute handled for buttons.
 * 06-Oct-2021 GB  [RTC273983] Adding the new parameter to returnFocusToPopupActionAnchorElement function.
 * 04-Oct-2021 SK  [RTC273901] Changed the way the progress and transition background is managed for
 *                             frequency pattern and file download situations.
 * 29-Sep-2021 GB  [RTC273619] Added data-testid to the carbon buttons.
 * 08-Sep-2021 SK  [RTC273365] Corrected the button display logic for IEG scripts and removed the
 *                             transition background.
 * 31-Aug-2021 SK  [RTC273217] Adjusted the buttons cleanup logic to ensure visually smoother
 *                             transition. 
 * 25-Aug-2021 SK  [RTC273075] Added contentClickWatcher and the related logic to account for
 *                             navigating link clicks on the content pages within the modal context.
 * 20-Aug-2020 SK  [RTC273004] Button visibility condition corrected; adjusted visibility class
                               name to avoid naming clash; renamed the external this reference to
                               avoid using of the JavaScript keyword.
 * 16-Aug-2021 LS  [RTC272772] Move focus to tab warning or error modal when opened
 * 11-Aug-2021 SK  [RTC272800] Progress Spinner invocation changed.
 * 04-Aug-2021 SO  [RTC272685] Accessibility fix: added EventListener for ESC key press on Buttons, Close (X) and Help icons
 * 29-Jun-2021 SK  [RTC272800] Refactored so that modal buttons are destroyed on transition.
 * 15-Jun-2021 SK  [RTC272800] Refactoring  and changes to prevent memory leaks.
 * 11-Jun-2021 BOS  [RTC271517] Clean up references to ModalLayoutHelper to improve
 * performance.
 * 03-Jun-2021 BD   [RTC271240] Updated method hideAndClose to get window from the 
 * curam.util.PLACEHOLDER_WINDOW_LIST variable.
 * 01-Jun-2021 SK   [RTC271310] Performance improvements.
 * 05-May-2021 BD   [RTC266244] Updated method hideAndClose to return the focus
 * to a popup-action anchor.
 * 19-Apr-2021 ZV   [RTC270088] Dismiss progress spinner on close
 * 19-Apr-2021 BOS  [RTC270090] Fix wizard cancel button and buttons from IEG.
 * 15-Mar-2021 BOS  [RTC269160] Handling buttons configured as JSON object
 * rather than HTML string.
 * 19-Feb-2021 BOS  [RTC268393] Fixes according to design specificaton.
 * 31-Jan-2021 BOS  [RTC267877] Overriding hide function.
 * 02-Dec-2020 BOS  [RTC266982] Initial version.
 */

/**
 * @name curam.CuramCarbonModal
 * @namespace Implements a Curam dialog based on the Carbon Design Language.
 */
define(["dojo/text!curam/layout/resources/CuramCarbonModal.html",
		"dojo/_base/declare",
		"dojo/dom-construct",
		"dijit/_Widget",
		"dijit/_Templated",
        "curam/modal/CuramBaseModal",
        "curam/ModalUIMController",
        "curam/util/onLoad",
        "curam/util",
        "dojo/aspect",
        "curam/debug",
        "curam/ui/PageRequest"
        ], function(template, declare, domConstruct, _Widget, _Templated, curamBaseModal,
        		modalUIMController, _ONLOAD, util, asp, debug) {

		return declare("curam.modal.CuramCarbonModal", [curamBaseModal, _Widget,_Templated], {

		  templateString: template,
		  modalContainerBaseModifier : 'bx--modal-container--',
		  carbonInstantiatedNode: null,
		  modalSPMComponentRoot:null,
		  currentPageID: null,
		  modalSizeClassName: 'md',
	      carbonModal: null,
	      isWizardModal: false,
	      isIEGModal: null,
	      cancelButtonID: null,
	      redirectPageID: null,
	      isRedirectModal:  false,
	      closingDialogEvent: null,
	      addButttonEvent: null,
		  _setCarbonModalAttr: { node: "carbonModalNode", type: "innerHTML" },
		  carbonModalController: null,
		  resizeController: null,
		  isAlreadyShown: false,
		  hasSingleModalButton: false,
		  primaryButtonOnViewModalID: null,
		  hasMultipleButtons: true,
		  hasMultipleSubmitButtons: false,
		  tlw: null,
		  tabbingBackwards: null,
		  isIEGScript: false,
		  isAgendaPlayer: false,
		  helpIconEnabled: false,
		  wRef: null, /* A reference to the content frame */
		  closingAlready:false,
		  closeTitle: LOCALISED_MODAL_CLOSE_BUTTON,
		  helpAltText: LOCALISED_MODAL_HELP_ALT,
		  helpTitle: LOCALISED_MODAL_HELP_TITLE,
		  btnRequestCont: 0,
		  isOwnAction: false,
		  isContentAction: false,
		  cleanupFooter: false,
		  actionSource:false,
          preventAction:false,
          fqWatchers:[],
          isIPNNav:false,

		  constructor: function(args) {
            this.iframeHref = args.href;
		  },
		  
		  /**
		   * Units for width and height of modal.
		   */
		  _getUnits: function() {
		    return '%';
		  },
		  
		  /**
		   * Set the width on the Iframe in the modal to be 100% (using units separately) 
		   * This way the full availble width (1 of 4 widths available) will be used in the Curam Carbon Dialog.
		   */
		  _calculateWidth: function() {
		    // TODO: Add extra logging for Curam Dialog
			return '100';
		  },
		  
		  /**
		   * Set the initial height on the Iframe in the modal to be 100%. 
		   */
		  _calculateHeight: function() {
		    return '100';
		  },
		  
		 
		  /**
		   * Determines the size if the modal taking the fixed width as an input.
		   */
		  _determineSize: function(context) {
		    // TODO: Add extra logging for Curam Dialog
			this.inherited(arguments);
			// set one of the 4 width categories specifiying the width in pixels as an input
			if (context.windowOptions) {
			  this.setModalSizeClassName(context.windowOptions["width"]);
			}			  
		  },
		  
		  /**
		   * Sets up the help icon.
		   */
		  _setupHelpIcon: function(context) { 
		    // In some scenarios the context will not be passed at all.
		    // The code below handles this case.
		    var enable = typeof context != "undefined"
		        ? context.helpEnabled : false;
		      var extension = enable ? context.helpExtension : "";
		      var pageId = enable ? context.pageID : "";
			  if (!enable) {
				this.helpIcon.classList.add('is-not-displayed');
			  } else {
			    this.helpIconEnabled = true;
				this.helpIcon.dataset.pageid = pageId;				  
			  }
		  },
		  
		  displayHelp: function(e) {
			  if (!e.keyCode || e.keyCode === 13) {
			    var locale=curam.config?curam.config.locale:jsL;
		        //Construct the help URL for Modal window
			    var url = "./help.jsp?pageID=" + this.helpIcon.dataset.pageid;
		        window.open(url);
			  }
		  },
		  prepareAction:function() {
			this.menuWatcher && this.menuWatcher.remove();
			this.formWatcher && this.formWatcher.remove();
			this.contentClickWatcher && this.contentClickWatcher.remove();
			!this.isIEGScript && this.modalFooter.setAttribute("style", "opacity:0.6;");
            this.cleanupFooter = true;
            this.btnRequestCont = 0;
		  },
		  actionEarly:function(){
			this.prepareAction();
		    this.isContentAction = true;
		  },
          actionLate:function(){
        	this.prepareAction();
		  },
		  /**
		   * Word Integration is an exception:
		   * the only button should not be discarded at any stage.
		   */
          actionWord:function(submitBtnId, evt) {
        	this.isOwnAction = true;
        	this.wRef && this.wRef.curam.util.clickButton(submitBtnId);
  		  },		  
		  /**
		   * Processes the submit event by delegating it to the underlying
		   * content frame.
		   */
		  actionSubmit:function(submitBtnId, evt) {
	        this.isOwnAction = true;
			this.actionEarly();
			this.wRef && this.wRef.curam.util.clickButton(submitBtnId);
			this.isContentAction = false;
			if (!this.preventAction) {
	          dojo.publish('/curam/progress/display', [this.containerNode, 100]);
			} else {
			  this.modalFooter.removeAttribute('style'); // reset opacity
			}
		  },
		  /**
		   * Processes the click event by delegating it to the underlying
		   * content frame.
		   */
		  actionClick:function(evt, onClick) {
		    this.preventAction = false;
            this.isOwnAction = true;
		    this.actionEarly();
		    var thisRef = this;
            var reactivate;
		    if (onClick) {
		      // if onclick function then execute it. No need to check if is a function
		      // it cant come from anywhere else
		      onClick(evt);
              reactivate = setTimeout(function(){
                clearTimeout(reactivate);
                thisRef.modalFooter.removeAttribute('style');                
              },5000);
		    } else {
		      this.wRef && this.wRef.curam.dialog.modalEventHandler(evt);
		    }
		    this.isContentAction = false;
			var targetCheck = evt.target.dataset && evt.target.dataset.href;
			if (targetCheck && targetCheck.indexOf('FileDownload') > -1) {
			   reactivate = setTimeout(function(){
			    dojo.publish('/curam/progress/unload');
                clearTimeout(reactivate);
                thisRef.modalFooter.removeAttribute('style'); // reset opacity
			  }, 3000);
			}
		    dojo.publish('/curam/progress/display', [this.containerNode]);    
		  },
		  /**
		   * Destroys the internal references at the end of the modal dialog
		   * life cycle.
		   */		  
		  actionCleanup:function(evt) {
			this.wRef && (this.wRef.spm = null);
	        this.carbonModalController = null;
		  },
		  /**
		   * Disable close icon.
		   */
		  _setClosableAttr: function(closeable) {	     
		    // closeIcon is queried with the modal ID to avoid misplacement
			  this.closeButton.setAttribute('style', 'display:' + (!!closeable ? 'block' : 'none'));
		  },
		  
		  /**
		   * Check if this is  a wizard.
		   */  
		  checkIfWizardModal: function() {
		    var thisRef = this;
		    var checkIfWizardModal = this.tDojo.subscribe("/curam/CuramCarbonModal/wizardModalIndicator", this, function() {
			  thisRef.isWizardModal = true;
			  thisRef.modalFooter && thisRef.modalFooter.classList && thisRef.modalFooter.classList.add('bx--modal-footer--progress');
			  thisRef.tDojo.unsubscribe(checkIfWizardModal);
			});
		  },
		  
		  /**
		   * Check if this is  a wizard.
		   */  
		  checkIfIEGModal: function() {
		    var thisRef = this;
		    var checkIfIEGModal = this.tDojo.subscribe("/curam/CuramCarbonModal/iegModalIndicator", this, function() {
			  thisRef.isIEGModal = true;
			  thisRef.tDojo.unsubscribe(checkIfIEGModal);
			});
		  },
		  
		  /**
		   * Check if this is a non standard modal button arrangement on the footer.
		   * The following scenarios are what constitutes a non standard modal button arrangement currently:
		   * (1) Passive Modal - no buttons configured.
		   * (2) A solitary button - the norm is for at least 2, cancel and an action button.
		   * (3) Multiple submit buttons - if there are multiple submit buttons then one should be declared as the default one.
		   */ 
		  checkIfNonStandardModalButtons: function() {
		    var thisRef = this;
		    var checkIfNonStandardModalFooter =
		    	this.tDojo.subscribe("/curam/CuramCarbonModal/nonStandardModalFooter", this, function(nonStandardBtnConfig) {
		    	  if (nonStandardBtnConfig) {
			        if (nonStandardBtnConfig.numButtons) {
			          var numButtons = nonStandardBtnConfig.numButtons;
			         if (numButtons == 0) {
			            var currentPageID = this.iframe && this.iframe.contentWindow.jsPageID;
			            if (currentPageID) {
			              curam.util.getTopmostWindow().dojo.global.passiveModalPageID = currentPageID;
			            }
			          } else if (numButtons == 1) {
			            thisRef.hasSingleModalButton = true; 
			          }
			          thisRef.hasMultipleButtons = (numButtons <= 1);
			        } else if (nonStandardBtnConfig.hasDefaultSubmitButton) {
			          thisRef.hasMultipleSubmitButtons = true;  
			        }
			      }
			      thisRef.tDojo.unsubscribe(checkIfNonStandardModalFooter);
			});
		  },

          /**
		   * Update style on cancel button.
		   */
          updateWizardCancelStyle: function() {
		    // default to secondary button
		    var buttonStyleClassName = "bx--btn--secondary";
		    if (this.hasSingleModalButton) {
		      buttonStyleClassName = "bx--btn--primary";
		    }
		    if (this.cancelButtonID != null) {
		      var cancelButton = document.getElementById(this.cancelButtonID);
		      if (this.isWizardModal) {
		        buttonStyleClassName = "bx--btn--ghost";
		      }
		    }
		    if (cancelButton) {
		      cancelButton.classList.add(buttonStyleClassName);
		    }		    
		  },
		  
          /**
		   * Update style on cancel button.
		   */
          updateRegularCancelStyle: function() {
            var cancelButton = false;
            if (this.cancelButtonID != null) {
              cancelButton = document.getElementById(this.cancelButtonID);
            }
            if (cancelButton) {
              if (cancelButton.classList.contains('bx--btn--secondary')
                   || cancelButton.classList.contains('bx--btn--primary')) {
                // do not restyle it
                return;
              } else {
                // default to secondary button
                var buttonStyleClassName = "bx--btn--secondary";
                if (this.hasSingleModalButton) {
                  buttonStyleClassName = "bx--btn--primary";
                }
                cancelButton.classList.add(buttonStyleClassName);
              }
            }
		  },
		  
		  /**
		   * Checks for primary button on a view modal.
		   */
		  checkPrimaryButtonOnViewModal: function() {
		    if (this.primaryButtonOnViewModalID != null) {
		      return document.getElementById(this.primaryButtonOnViewModalID);
		    }
		  }, 
		  
		    
		  /**
		   * Show the modal after setting its size. This will be determined by the base dialog when everything has
		   * been instantiated.
		   */
		  show: function(context) {
		    // TODO: Add extra logging for Curam Dialog
		    // Help icon set up called by base modal class
		    	    	    
		    // cater for scenario where a modal started as passive modal but is not longer one
		    // ensure not agenda player OR IEG before doing so
		    if (!this.isIEGScript && !this.isAgendaPlayer) {
		      if (this.modalFooter.classList.contains('is-not-displayed')) {
	            this.modalFooter.classList.remove('is-not-displayed');
	          }
		    }
		   
			this.manageModalFooterButtons();

			if (this.isIEGScript || this.isWizardModal) {
			  this.updateWizardCancelStyle();
			} else {
			  this.updateRegularCancelStyle();
			}
			// show all buttons eventually; any exclusions?
			this.modalFooter.childNodes.forEach(function(btn){
              btn.classList.remove('is-not-displayed');
			});
			var modalIframeContent;
			// some arbitrary default height in case something goes wrong!
			var contentScrollHeight = 800;
			// exiting IEG script is if we were previously in an IEG Script but now we are exiting it
			var isExitingFromIEGScript = this.isIEGScript && !curam.util.getTopmostWindow().exitingIEGScript;
			this.isIEGScript = this.tlw.exitingIEGScript;

			var modalButtons = this.modalFooter.children;
		    var modalSizeCSSClassName = this.modalContainerBaseModifier + this.modalSizeClassName;
		    
		    if (this.isIEGScript) {
		    	var forms = this.iframe.contentWindow.document.body.getElementsByTagName("FORM");
		    	modalIframeContent = forms ? forms[0] : undefined;
		       // we expect the 2nd element to be the form need to check it first.
		       if (modalIframeContent && modalIframeContent.tagName == "FORM") {
		    	 !this.modalFooter.classList.contains('is-not-displayed')
                    && this.modalFooter.classList.add('is-not-displayed');
		       }
		    } else {
		      modalIframeContent = this.iframe.contentWindow.document.querySelector('#content');
		      // Display footer if exiting IEG script
		      if (isExitingFromIEGScript) {
                       if (this.modalFooter.classList.contains('is-not-displayed')) {
	              this.modalFooter.classList.remove('is-not-displayed');
	            }    
		      }
		    }
		    if (modalIframeContent && modalIframeContent != null) {
		      contentScrollHeight = modalIframeContent.scrollHeight;
		    }
		    
		    // TODO: The extra amount to be hardcoded is not correct ('110'). Need to find a more robust
		    // dynamic way to do this
		    if (contentScrollHeight) {
		      // Modals that have a scollbar may need extra height especially in relation to
		      // modals that have an address cluster at the end where the last field is barely visible
		      // If no scollbar is required on modal , 50 pixles should suffice BUT for modals with scrollbars
		      // increase this more
		      var heightAdjustment = contentScrollHeight < this.modalContainer.scrollHeight ? 50: 110;
		      var modalHeight = this.isIEGScript ? contentScrollHeight : contentScrollHeight + heightAdjustment;
		      this.iframe.style.height = modalHeight + "px";
		    }

		   // Update content css so that the observer will catch the correct size based on its children element
			if (modalIframeContent && modalIframeContent.style) {
			  modalIframeContent.style.position = "relative";
			  modalIframeContent.style.top = "0px";
			}
			if (window.spm && modalIframeContent) {
			  this.resizeController = new window.spm.helpers.ModalLayoutHelper(this.containerNode, this.uimController, this.iframe, modalIframeContent, this.isIEGScript);
              this.resizeController.register();
			}
			this.modalContainer.classList.add(modalSizeCSSClassName);
		    if (this.iframe) {
		      // align the content of iframe nicely with carbon heading e.t.c
		      this.iframe.classList.add("bx--modal-content__iframe-wrapper");
			}
		    this.carbonModalNode.classList.add("is-visible");
            !this.isIEGScript && this.modalFooter.removeAttribute('style');
	     	        // If passive modal then enable selecting outside modal to close
	        var currentID = this.iframe && this.iframe.contentWindow.jsPageID;
	        var passiveID = curam.util.getTopmostWindow().dojo.global.passiveModalPageID;
	        if (currentID && passiveID && (currentID == passiveID)) {
	          // ensure that no buttons in footer before we hide it, only if its empty
	          // will we hide it
	          if (!this.modalFooter.classList.contains('is-not-displayed')) {
	             this.modalFooter.classList.add('is-not-displayed');
	          }
	          this.carbonInstantiatedNode = this.carbonModalController.create(this.carbonModalNode);
	          this.carbonInstantiatedNode.show();
	        }
	        // indicate that the modal is already shown
		    this.isAlreadyShown = true;
		    // spinner cancelled by base class!
		  },
  
		  /**
		   * Sets the width to carbon size taking the modal width as an input to do the caculation.
		   * There are 4 sizes in total:
		   * 'xs' (extra small)
		   * 'sm' (small)
		   * 'md' (medium)
		   * 'lg' (large)
		   */
		  setModalSizeClassName: function(modalWidth) {
            // TODO: Add extra logging for Curam Dialog
	    	if (modalWidth) {
	 	      if (modalWidth <= 420) {
                this.modalSizeClassName = 'xs';
              } else if (modalWidth > 420 && modalWidth <= 576) {
                this.modalSizeClassName = 'sm';
              } else if (modalWidth > 768 && modalWidth < 1200) {
                this.modalSizeClassName = 'lg';
              } else if (modalWidth >= 1200) {
                this.modalSizeClassName = 'xlg';
              }
	 	    }
		  },
		    
          manageModalFooterButtons: function() {
            // TODO: Although unlikey what if there is a wizard configured, with duplicate page ID in the group? 
            // Do we need to hnadle this scenario ?? -- BOS
        	var thisRef = this;
            this.preventAction = false;
            if (!this.ipnWatcher) {
              this.ipnWatcher = asp.before(this.uimController, 'handleIPNTabClick', function(tab) {
                thisRef.isIPNNav = true;
              });
            }
        	if (!this._isCDEJModal && this.wRef) { // exclude the frequency pattern and any other oddities
        	  this.menuWatcher = asp.before(this.wRef.curam.util, "clickHandlerForListActionMenu", function(){
        	    thisRef.actionLate();
        	  });
        	  this.formWatcher = asp.after(this.wRef, "dc", function(result){
          	    if (result) {
          	      thisRef.actionEarly();
          	    }
          	    return result;
              });
              this.contentClickWatcher = asp.after(this.wRef, "clickMarker", function(result){
                thisRef.actionLate();                
                return result;
              });
        	} else if (this.iframeHref.indexOf("frequency-editor.jsp") > -1) {          
              var carrier = this.iframe.contentWindow;
              var fnPrevent = function(result){
	            thisRef.preventAction = !result;
                return result;
              }
              this.fqWatchers.push(
		        asp.after(carrier.curam.util.FrequencyEditor, 'validateDailyPattern', fnPrevent),
	            asp.after(carrier.curam.util.FrequencyEditor, 'validateWeeklyPattern', fnPrevent),
	            asp.after(carrier.curam.util.FrequencyEditor, 'validateBimonthlyData', fnPrevent),
	            asp.after(carrier.curam.util.FrequencyEditor, 'validateMonthlyData', fnPrevent),
	            asp.after(carrier.curam.util.FrequencyEditor, 'validateBimonthlyData', fnPrevent),
	            asp.after(carrier.curam.util.FrequencyEditor, 'validateYearlyData', fnPrevent)
              );
            }
        	var currentPageID = this.iframe.contentWindow.jsPageID;
			this.actionSource = currentPageID;
            // add spacing between buttons for multiple button set
            if (this.hasMultipleButtons) {
              this.modalFooter.classList.add('bx--btn-set');
            }
            this.hasSingleModalButton = (this.btnRequestCont == 1);
            this.isOwnAction = false;
            this.isContentAction = false;
            this.isIPNNav = false;
		  },
		    
		 /**
		  * Overridden hide function from base modal, but we are actually closing as opposed to hiding.
		  * The base version hides modals when closing. It only destroys all modals when initially showing one.
		  * Opposite approach is taken here where we are going to going to actually close it as oppose
		  * to hide it as the chances of having to open same modal again are not that high.
		  */
		  hide: function(modalID) {
		    if (!this.closingAlready) {
              this.closingAlready = true;
              dojo.publish('/curam/progress/unload');
		      this.hideAndClose(modalID);
            }
          },
		    
          /**
           * When the escape key is pressed ensure the dialog closes.
           */
          escapeOnClose: function(evt) {
            // check it is the esc key
            if (evt.keyCode === 27) {
            var self = this;
              self.carbonModalNode.classList.remove("is-visible");                               
            }
          },
          
          hideAndClose: function(modalID) {
			if (curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton) {
		  		curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton = false;
			}
			curam.util.getTopmostWindow().dojo.global.passiveModalPageID = undefined;
			this.fqWatchers && this.fqWatchers.splice(0, this.fqWatchers.length);
            curam.debug.log("curam.modal.CuramBaseModal._modalClosedHandler calling curam.util.setBrowserTabTitle");
		    if(this.parentWindow){
			  curam.util.setBrowserTabTitle(this.parentWindow.document.title);
			  // if custom events add them to the unsubscribes list
			  if (this.iframe && this.iframe.contentWindow) {
			    var customEvents = this.iframe.contentWindow.__customEventSubscriptions;
			    if (customEvents) {
			      for (var x = 0; x < customEvents.length; x++) {
			        this.unsubscribes.push(customEvents[x]);
			      }
			    }
			  }
			} else{
			  curam.util.setBrowserTabTitle();
			}
            this.tDojo.publish("/curam/dialog/BeforeClose", [ this.id, this.iframe.id ]);
            this.tDojo.unsubscribe(this.addButttonEvent);
            // destroy everything
            if (this._scrollConnected){
              this._scrollConnected = false;
            }
            if (this._relativePosition){
              delete this._relativePosition;
            }  
  		    curam.dialog.removeFromDialogHierarchy(this.iframe.contentWindow);
		    curam.dialog.removeFromDialogHierarchy(this.parentWindow);  
            dojo.forEach(this.modalconnects, dojo.disconnect);
            this.modalconnects && this.modalconnects.splice(0, this.modalconnects.length);
  		    dojo.forEach(this.unsubscribes, this.tDojo.unsubscribe);
  		    this.unsubscribes && this.unsubscribes.splice(0, this.unsubscribes.length);
		    _ONLOAD.removeSubscriber(this._getEventIdentifier(), this.onLoadSubsequentHandler);
            if (this._explodeNode && this._explodeNode.parentNode) {
              this._explodeNode.parentNode.removeChild(this._explodeNode);
            }
            this.tDojo.publish("/curam/dialog/close/appExitConfirmation", [this.id]);
            this._markAsActiveDialog(false);
            if (typeof this.parentWindow != "undefined" && this.parentWindow != null) {
              this.parentWindow.focus();
            }
            if (modalID && !modalID instanceof Event) {
              this.tlw.modalsToDestroy.push(modalID);
            } else {
              this.tlw.modalsToDestroy.push(this.modalSPMComponentRoot.id);
            }
            
			// Remove an objects stored in session storage for that modal
			sessionStorage.removeItem("firstPageHitAfterModalOpened");
		    this.carbonModalNode.classList.remove("is-visible");
		    this.parentWindow && curam.util.returnFocusToPopupActionAnchorElement(this.parentWindow);
		  },
  
          _destroyOldModals: function() {
            if (this.tlw.modalsToDestroy) {
              var mId = null;
              while ((mId = this.tlw.modalsToDestroy.pop()) != null) {
                var nodeToRemove = document.querySelector('#' + mId);
                if (nodeToRemove && nodeToRemove.parentNode != null) {
                  nodeToRemove.parentNode.removeChild(nodeToRemove);
                  nodeToRemove = null;
                }
              }
              // just the additional precaution
              this.tlw.modalsToDestroy.splice(0, this.tlw.modalsToDestroy.length);
            }
          },
  		    
		  preventForwardsTabEscFromModal: function(e) {
            var modalID = this.modalSPMComponentRoot.id;
		    var targetID = this.helpIconEnabled ? "_modal-help" : "_modal-button-close";
            var targetIconNode = document.getElementById(modalID + targetID);
            this.handleTabbingForwards(e, targetIconNode);
		  },
  
		  preventBackwardsTabEscFromModal: function(e) {
            var modalID = this.modalSPMComponentRoot.id;
		    var endOfModalID = "modal-end_" + modalID;
		    var helpButtonID = modalID + "_modal-help";
            this.handleTabbingBackwards(e, helpButtonID, endOfModalID);
		  },
		    
		  handleSubmitBtnStyling: function(isDefaltSubmitButton, hasMultipleSubmitButtons) {
		    var className = " bx--btn--primary";
		    if (hasMultipleSubmitButtons && !isDefaltSubmitButton) {
		      className = " bx--btn--secondary";
		    }
		    return className;
		  },

		  buildButtonHTML: function(currentHTMLString, attibuteName, attributeValue) {
            // TODO: encode URI?
			var updatedHTMLString =  attributeValue != undefined ? currentHTMLString + attibuteName + "='" + attributeValue + "'" : currentHTMLString;
			return updatedHTMLString;
          },    

          createHTMLFromButtonJson: function(jsonObj) {
            htmlString = "";
            htmlString = this.buildButtonHTML(htmlString, 'data-href', jsonObj.href);
            htmlString = this.buildButtonHTML(htmlString, 'keepmodal', jsonObj.keepmodal);
            htmlString = this.buildButtonHTML(htmlString, 'accesskey', jsonObj.accesskey);
            htmlString = this.buildButtonHTML(htmlString, 'onmouseover', jsonObj.onmouseover);
            htmlString = this.buildButtonHTML(htmlString, 'onmouseout', jsonObj.onmouseout);
            htmlString = this.buildButtonHTML(htmlString, 'buttonid', jsonObj.buttonid);
            htmlString = this.buildButtonHTML(htmlString, 'data-control', jsonObj.datacontrol);
            return htmlString;
          },
          
          indciatesCancelButton: function(href) {
            // indicates cancel button on wizard or regular modal
            var rpuParam = curam.util.Constants.RETURN_PAGE_PARAM;
            var isValid = (href != undefined);
            var isHashHref = isValid && (href.length == 1) && (href.indexOf("#") != -1);
            if (isValid && (href.length == 0 || href.indexOf("keepModal=") == -1 && href.indexOf(rpuParam + "=") == -1) && !isHashHref) { 
              return true;
            }
            return false;
          },   
                
          postMixInProperties: function() {
            this.inherited(arguments);
        	this.tlw = curam.util.getTopmostWindow();
        	this.tDojo = this.tlw.dojo;
          },
          
          /**
		   * Enables draggable modals by including a hookpoint.
		   */
          enableDraggableHookpoint: function(rootElement) {
	        try {
	          require(["curam/application/modal/ModalHooks"], function(hooks) {
                hooks.enableDraggableModals(rootElement);
              });
	        } catch(e) {
	            curam.debug.log("WARNING: The file curam.util.modal.ModalHooks.js is not found");
	        } 
          },
          
		  /**
		   * Initiates the rendering of the Curam Dialog in Carbon.
		   */
		  postCreate: function() {
		    this.inherited(arguments);

			// Hide the modal footer for the Agenda Player using Eventing
			this.agendaGuard = this.tDojo.subscribe('agenda/buttons/loaded', (function() {
				this.modalFooter && this.modalFooter.classList.add('is-not-displayed');
				this.isAgendaPlayer = true;
			
			}).bind(this));

		    // get modal controller from bundle
		    this.carbonModalController = spm.Modal;
		    // initialize modal ibe calling to base functionality
		    this.initModal(arguments);
		      
            // NOTE: important to call after initModal - or, if initModal is extracted, this should be
		    // part of that method - after the actual destruction!
            this.tlw.modalsToDestroy = [];
		    this.modalSPMComponentRoot = this.carbonModalNode.parentNode;
	        document.body.appendChild(this.modalSPMComponentRoot);
	        this.rootNode = document.getElementById(this.modalSPMComponentRoot.id);
	        var thisRef = this;
	        
	        // Hookpoint for draggable modals
	        this.enableDraggableHookpoint(this.rootNode.firstElementChild);
          
	        this.checkIfWizardModal();
	        this.checkIfNonStandardModalButtons();
	        this.checkIfIEGModal();
	          
	        var redirectingModal = this.tDojo.subscribe("/curam/CuramCarbonModal/redirectingModal", this, (function() {
	          this.isRedirectModal = true;
			}).bind(this));

            // Ensure that the DOM is removed after hiding otherwise will cause side effects for other modals
            // if we do not clean up after they dismiss by slecting outside the modal
	        var carbonAfterHiddenEvent = this.carbonModalController.options.eventAfterHidden;
	          
	        document.addEventListener(carbonAfterHiddenEvent, (function(evt) {
	          evt.stopPropagation();
	          this.hideAndClose();
            }).bind(this));
		    	
		    // default (576 - 768 width)
		    this.setModalSizeClassName(this.width);

		    var buttonID = 0;
		    	
		    this.addButttonEvent =
		    	this.tDojo.subscribe("/curam/CuramCarbonModal/addModalButton",
	    	        this, function(buttonJson, buttonText, isSubmitButton, isDefaultSubmitButton, wRef) {
	    	      if (this.iframe.contentWindow.jsPageID !== wRef.jsPageID) {
                    return;
	        	  }
	        	  
	        	  if (this.isIPNNav) {
                    return;
                  }	 	

	    	      if (buttonJson && !typeof buttonJson === 'object') {
		            throw new Error(buttonJson + " is not a valid object for this button");
		          }

	    	     // on a modal with 1 button, and a redirect happens reset the variable that indicates 1 button
	    	     // so that the styling of the buttons won't get messed up   
	    	     if (this.isRedirectModal) {
	    	       this.hasSingleModalButton = undefined;
	    	     }
	    	     
	    	     this.wRef = wRef;
	    	     var wordButton = false;
                 // button id based exception for Word Integration
	    	     if (buttonJson.buttonid && buttonJson.buttonid=='commitDocChangesBtnIE') {
	    	       this.isOwnAction = true;
	    	       wordButton = true;
	    	     }
	    	     this.btnRequestCont +=1;

	    	     if (!this.isOwnAction) { // reload was initiated by the content, do not re-add buttons
	    	       if (!this._isCDEJModal && !this.isContentAction && this.actionSource == wRef.jsPageID){
		    	      this.btnRequestCont = 0;
	                  return;
	               } else {
	            	 if (this.cleanupFooter) {
	            	   this.modalFooter.innerHTML = '';
                       this.cleanupFooter = false;
	            	 }
	               }
	    	     } else {
		           if (this.cleanupFooter) {
	            	 this.modalFooter.innerHTML = '';
                     this.cleanupFooter = false;			
		           }
	             }

	    	     var modalButtonID = buttonJson && buttonJson.buttonid ? buttonJson.buttonid : this.modalSPMComponentRoot.id + "_modal-button_" + buttonID;
               	 if (this.hasSingleModalButton) {
               	   this.primaryButtonOnViewModalID = modalButtonID;
               	 }
               	 var additionalBtnClass = this.hasSingleModalButton ? " bx--btn--primary" : " bx--btn--secondary";
                 var href = buttonJson && buttonJson.href;
               	 // if the href is defined accordingly then mark it as the cancel button
                 if (this.indciatesCancelButton(href)) {
	    	       this.cancelButtonID = modalButtonID;
	    	            
	    	       // TODO: In handcrafted JSPs the modal button can be added same time as shown so 
	    	       // need to check if already being shown need to add the style right now! Check what
	    	       // is causing this in hadcrafted JSP
	    	       additionalBtnClass = "";
	    	       if (this.isAlreadyShown) {
	    	         // is a wizard and has more than one button
	    	         additionalBtnClass = this.isWizardModal && !this.hasSingleModalButton ? " bx--btn--ghost" : additionalBtnClass;
	    	        }
	    	    }
                  var classNameForSubmitButton = this.handleSubmitBtnStyling(isDefaultSubmitButton, this.hasMultipleSubmitButtons);
                  var extraClassName = isSubmitButton ? classNameForSubmitButton : additionalBtnClass;

                  var buttonOpeningTag = buttonJson ? this.createHTMLFromButtonJson(buttonJson) + ">" : ">";
                  var newButton = domConstruct.toDom("<button " + buttonOpeningTag + buttonText + "</button>");

                  newButton.setAttribute('type', 'button');
                  newButton.setAttribute('tabIndex', '0');
                  if (buttonJson.dataTestId && buttonJson.dataTestId !== null) {
                  	newButton.setAttribute('data-testid', buttonJson.dataTestId);
                  }
                  newButton.setAttribute('id', modalButtonID);

                  ("bx--btn" + extraClassName).split(' ').forEach(function(cls) {
                    newButton.classList.add(cls);  
                  });
                  this.isRedirectModal
                      && !newButton.classList.contains('is-not-displayed')
                      && newButton.classList.add('is-not-displayed');
                  // see if we reach this initialization point! and, if we have wRef.
                  // or, if we should pass on onClick in this case.
                  if (!isSubmitButton) {	  
                    newButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (thisRef.wRef && buttonJson && buttonJson.onclick) {
                      thisRef.actionClick(e, thisRef.wRef.Function(buttonJson.onclick));
                    } else {
                      thisRef.actionClick(e);
                    }
                  });              
                   //close modal on ESC key press on ordinary buttons
                    newButton.addEventListener('keydown', function(e) {
                        if(e.keyCode === 27){
                           e.stopPropagation();
                           thisRef.carbonModalNode.classList.remove("is-visible");
                        }
                    });
                } else {
                  var submitButtonID = isSubmitButton.id;
                  if (wordButton) {
                    newButton.addEventListener('click', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      thisRef.actionWord(submitButtonID, e);
                    }); 
                    
                    //close modal on ESC key press on buttons with actionWord
                    newButton.addEventListener('keydown', function(e) {
                      	if(e.keyCode === 27){
                           e.preventDefault();
                           e.stopPropagation();
                           thisRef.hideAndClose(); 
                            }
                          });
                    
                  } else {
                    newButton.addEventListener('click', function(e) {
                      e.preventDefault();
                      e.stopPropagation();
                      thisRef.actionSubmit(submitButtonID, e);
                    });
                  }
                  this.wRef.dojo.subscribe('curam/CarbonWrapper/cleanup', function(e){
                    thisRef.actionCleanup();
               	  });
				  //close modal on ESC key press on buttons with action submit
				  newButton.addEventListener('keydown', function(e) {
				  	if(e.keyCode === 27){
					  e.preventDefault();
				      e.stopPropagation();
				      thisRef.hideAndClose(); 
				    }
				  });
                }                

              domConstruct.place(newButton,this.modalFooter);
              buttonID++;
	    	  });
		      this.containerNode.appendChild(this.uimController.domNode);
		      
		      // listen for subscriptions if a users selects search button
		      this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/spinner",  function(e) { thisRef._displaySpinner(thisRef);
		      }));
		    },

		    /**
		     * Override for the base class method to add different clean up algorithm on modal close.
		     */
			initModal: function(arguments) {
              this._destroyOldModals();
              this._verticalModalSpace = 100;
              this.draggable = false;
              var maxRatio = 0.9;
              this.maximumWidth = (dijit.getViewport().w * maxRatio) - this._horizontalModalSpace;
              this.maximumHeight = (dijit.getViewport().h * maxRatio) - this._verticalModalSpace;
              this.unsubscribes = [];
              this.modalconnects = [];
              this._isCDEJModal =
				      (this.iframeHref.indexOf("CDEJ/popups") > -1 
				        || this.iframeHref.indexOf("frequency-editor.jsp") > -1
                        || this.iframeHref.indexOf("user-pref") > -1);
              this._initParentWindowRef();
              curam.dialog.pushOntoDialogHierarchy(this.parentWindow || this.tlw);
              this._registerInitListener();

              var subscribeTokenUnload = dojo.subscribe("/curam/dialog/iframeUnloaded",
						this, function(dialogId, targetWin) {
				          if (this.id == dialogId) {
                            curam.dialog.removeFromDialogHierarchy(targetWin);
				            this.initDone = false;
				            this._registerInitListener();
				          }
				      });
			  this.unsubscribes.push(subscribeTokenUnload);
			  curam.util.getTopmostWindow().dojo.global.passiveModalPageID = undefined;

              var onLoadInitHandler = 
				    	(function(iframeId, context) {
				    		_ONLOAD.removeSubscriber(this._getEventIdentifier(), onLoadInitHandler);
                            curam.dialog.pushOntoDialogHierarchy(this.iframe.contentWindow);
				            this._determineSize(context);
			   
				            if (!this.isRegisteredForClosing) {
				              this.unsubscribes.push(this.tDojo.subscribe("/curam/dialog/close", this, function(dialogId) {
				              if (this.id == dialogId) {
				                this.hide();
				                //release the watcher aspect
				                this.menuWatcher && this.menuWatcher.remove();
				                this.formWatcher && this.formWatcher.remove();
                                this.contentClickWatcher && this.contentClickWatcher.remove();
                                this.ipnWatcher.remove();
				                // reset the modallayout controller
				                this.resizeController && this.resizeController.reset();
                                this.resizeController = null;
								this.tDojo.unsubscribe(this.agendaGuard);
								this.agendaGuard = null;
		               			if (this.wRef) {
		               			  this.wRef.dojo.publish('curam/CarbonWrapper/cleanup');
                                  this.wRef = null;
		               			}
						        wRef = null; /* destroy the ref retained by closure */
								// cleanup window references
								// make sure we release iframe content - avoid memory leaks
								this.iframe.setAttribute('src', '');
								this.iframe = null;
								delete this.parentWindow;
								this.uimController.destroyRecursive(false);
								delete this.uimController;
							    this.destroyRecursive(false);/* destroy the modal wrapper dom*/
							    window.webpackJsonpspm = null;
				              }
				            }));
				        this.isRegisteredForClosing = true;
				      }
				      this.doShow(context);
				      this._notifyModalDisplayed();
				    }).bind(this);
			    
				    _ONLOAD.addSubscriber(this._getEventIdentifier(), onLoadInitHandler);
				    if (this._isCDEJModal) {
                      _ONLOAD.addSubscriber(this._getEventIdentifier(), function(iframeId, context){
      				    var frameRef = document.querySelector('#' + iframeId);
                    	if (frameRef) {
				          frameRef.focus();
				          frameRef.contentWindow.focusFirst && frameRef.contentWindow.focusFirst();
				        }
				      });
				    }		    
				    var isFirstLoad = true;
				    this.onLoadSubsequentHandler = (function(iframeId, context) {
                      if (isFirstLoad) {
				        isFirstLoad = false;
				      } else {
				        if (!context.modalClosing) {
                          curam.dialog.pushOntoDialogHierarchy(this.iframe.contentWindow);
				          this._determineSize(context);
				          this._position(true);
				          this.doShow(context);
				          this._notifyModalDisplayed();
				        }
				      }
                      var frameRef = document.querySelector('#' + iframeId);
                      frameRef &&
				        frameRef.setAttribute("title",
				        		[ LOCALISED_MODAL_FRAME_TITLE,
				        		  frameRef.contentWindow.document.title].join(' - '));
				    }).bind(this);
				    _ONLOAD.addSubscriber(this._getEventIdentifier(), this.onLoadSubsequentHandler);

				    this.unsubscribes.push(this.tDojo.subscribe("/curam/dialog/iframeFailedToLoad", this,
				      function(dialogId) {
				        if (this.id == dialogId) {
				          _ONLOAD.removeSubscriber(this._getEventIdentifier(), onLoadInitHandler);
				          this._determineSize({ height: 450, title: 'Error!' });
				          this.doShow();
				          this._notifyModalDisplayed();
				        }
				    }));
				    this.unsubscribes.push(
				        this.tDojo.subscribe("/curam/dialog/displayed", this, function() {
							  curam.util._setModalCurrentlyOpening(false);
							}),
				      this.tDojo.subscribe("/curam/dialog/displayed", this, this._setFocusHandler),
				    	this.tDojo.subscribe("/curam/dialog/displayed", this, function(dialogId) {
				          (dialogId == this.id) && this.tDojo.publish("/curam/dialog/AfterDisplay", [ dialogId ]);
				        })
				      );
				    
				    var isAbsoluteUrl = function(inputUrl) {
				      return inputUrl.indexOf(":") > 0;
				    };
				    var fullUrl = isAbsoluteUrl(this.iframeHref) ? this.iframeHref
				        : this._getBaseUrl(this.tlw.location.href) + jsL
				          + "/" + this.iframeHref;

				    this.uimController = new modalUIMController({
				      uid:this.id,
				      url: fullUrl,
				      loadFrameOnCreate: false,
				      inDialog: true,
				      iframeId:this._getEventIdentifier(),
				      width: this._calculateWidth(this.width) + "px",
				      height: this.maximumHeight + "px"
				    });
				    this.iframe = this.uimController.getIFrame();
				    this.set("content", this.uimController.domNode);
				    this.iframe.classList.add(this._getEventIdentifier());
				    this.unsubscribes.push(
				      this.tDojo.subscribe("/curam/dialog/displayed", this, this._modalDisplayedHandler),
				      this.tDojo.subscribe("/curam/dialog/closed", this, this._modalClosedHandler)
				    );
				    this._registerOnIframeLoad(this._loadErrorHandler.bind(this));
				    this.uimController.loadPage();
				  },
	  		  
	 		  _initParentWindowRef: function() {
	 			   if (!this.parentWindow) {
	 			      var candidate = curam.tab.getContentPanelIframe();
	 			      candidate && (this.parentWindow = candidate.contentWindow);
	 			   } else {
	 				 this.inherited(arguments);
	 			   }
	 			 }

		  });
});
},
'curam/UIMController':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013,2020. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

 /*
  * Modification History
  * --------------------
  * 15-Oct-2021  SO [RTC274016] Fix for Unnecessary scrollbars in dialogs(removed inline height)
  * 15-Jun-2021   SK  Minor changes in logging to prevent memory picture distortion
  * by the DevTools (direct object dumps).
  * 04-Dec-2020  BOS [RTC266982] Updated the setDimensionsForModalDialog to
  * take account of the units being passed in rather than hardcoded.
  * 21-Sep-2015  AB  [CR00466868] Modal dialogs and browser tab titles issue.
  * 24-Aug-2015  AB  [CR00465809] Dynamic browser tab titles.
  * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
  * 18-Jul-2013  SB  [CR00388308] Added publish event for tab context in modals.
  * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
  *                include required bundle.
  * 15-Feb-2013  SK  [CR00366971] Now properly clears content before redrawing.
  * 13-Dec-2012  PK  [CR00361104] Added missing dependency.
  * 15-Oct-2012  BOS [CR00346368] Localized debug messages to console.  
  * 11-Sep-2012  MV  [CR00339639] Performance related update: do not declare
  *    dependency on TabController module - not needed.
  * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
  * 11-Jun-2011  MV  [CR00327652] Move HTML template to a separate file. 
  * 23-Oct-2012  SK  [CR00346419] Correctly unsubscribes frok onload registry
  *    when closing a tab to avoid memory leak.  
  * 11-Sep-2012  MV  [CR00339639] Performance related update: do not declare
  *    dependency on TabController module - not needed.
  * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
  * 11-Jun-2011  MV  [CR00327652] Move HTML template to a separate file. 
  * 27-Sep-2011  MV  [CR00288663] Adjust a dialog height when IPN tabs exist. 
  * 28-Apr-2011  AF  [CR00264788] Added title attribute to generated frame.
  * 17-Feb-2011  PK  [CR00253211] The "absoluteURL" instance variable was not
  *                    being reset when "setURL" was called.
  * 01-Feb-2011  MV  [CR00250375] Publish load finished event when load without
  *    tabs is done.
  * 20-Jan-2011  MV  [CR00243263] Publish load finished event when full load
  *    is done.
  * 14-Jan-2011  MK  [CR00240138] Update _getFullURL function to only add the
  *                    o3nocache parameter if it does not already exist in the
  *                    URL.
  * 04-Jan-2011  MV  [CR00240081] Ignore request to show tab container
  *    if there are no tabs to show. Code cleanup.
  * 16-Dec-2010  PK  [CR00238879] Added auto-sizing for use in the application
  *                    team's CoverFlow widget.
  * 28-Nov-2010  MV  [CR00232623] Fix dialog-related sizing.
  * 18-Nov-2010  MV  [CR00231387] Perform cleanup on widget destroy.
  * 16-Jun-2010  BD  [CR00204119] Initial version.
  */

define(["dojo/text!curam/layout/resources/UIMController.html",
        "dojo/_base/declare",
        "dijit/_Widget",
        "dijit/_Templated",
        "dijit/layout/ContentPane",
        "curam/inspection/Layer",
        "curam/tab",
        "curam/debug",
        "dojo/dom-style",
        "dojo/dom-attr",
        "curam/util",
        "curam/util/onLoad"      
        ], function(template, declare, widget, templated, contentPane, layer,
            tab, debug, domStyle, domAttr) {

/**
 * @name curam.UIMController
 * @namespace Create and manage a widget that controls an IFRAME that is known
 * to load UIM pages. The controller will handle official communications
 * from the IFRAME to the parent window using the event system.
 * This will bridge the gap created by security restrictions that stop parent
 * windows manipulating the content of IFRAMES they control.
 * 
 * The controller also provides "In Page Navigation" functionality by creating
 * a tab controller to handle the page linking described by In Page Navigation
 * in the UIM file.
 *
 */
  
  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  
  var UIMController = declare("curam.UIMController", [dijit._Widget, dijit._Templated],
/**
 * @lends curam.UIMController.prototype
 */
{
  //NB: This value is duplicated in v6_common.css. Search for "TAB_HEIGHT" in
  //that file to find corresponding CSS values. They need to be updated if
  //any change is made to this value.
  TAB_HEIGHT: 20,

  // EVENT.TOPIC_PREFIX: String
  //          "UIMController.InPageNav_" the topic prefix for the IPN page load 
  //          event. The uid of the particular instance of the UIMController 
  //          completes the topic.
  EVENT: {
   TOPIC_PREFIX: "UIMController.InPageNav_"
  },
  
  TOPIC_LOADED: "/curam/uim/controller/loaded",
  
  // frameLoadEvent: String
  //          The topic on which to listen for a page load event.
  frameLoadEvent: "", 
  // frameLoadEvent: String
  //          The unique identifier for this instance of a UIMController.
  uid:"",
  // frameLoadEvent: String
  //          The url of the page that is loaded into the IFrame.
  url:"",
  // tabControllerId: String
  //          The id of the tab controller. Used to reference events on the
  //          tabController.
  tabControllerId: "",
  // oldTabsTitlesList: Array
  //          A list of the old(current) tab titles.
  oldTabsTitlesList:[],
  // newTabsTitlesList: Array
  //          A list of the new tab titles received from the iframe load event
  newTabsTitlesList:[],
  // widgetsInTemplate: Boolean
  //          Indicates that there are widgets to be processed in the template. 
  widgetsInTemplate: true,
  // finishedLoadingTabs: Boolean
  //          Indicates that the tabs have finished loading. 
  finishedLoadingTabs: false,
  // className: String
  //          A String representing classes to be added to the div wrapper. 
  classList: "",
  // iframeId: String
  //    The id of the iframe
  iframeId:"",
  // height: String
  //    The height of the widget
  height:"",
    // width: String
    //    The width of the widget
  width:"",
  // iframeClassList: String
  //          A comma separated list of classes to be added to the iframe. 
  iframeClassList: "",
  // iscpiframe: Boolean
  //          an attribute that indicates this is the content panel frame. 
  iscpiframe: "false",
  // ipnTabClickEvent: Tab Click Event 
  //          the event that occurs when a tab is clicked on this widget.
  ipnTabClickEvent:null,
  // title: String 
  //        Title attribute value for iframe. 
  title: "",
  // handleIPNTabClickListener: Event listener
  //          an attribute that stores the listener for the Tab Click event. 
  //          Can be switched on and off to avoid circular references when
  //          Tabs are being loaded.
  handleIPNTabClickListener:null,
  // inPageNavItems: Object array
  //          An array of inPageNavigation objects representing the in page
  //          navigation links.
  inPageNavItems:null,
  
  // Indicates whether the iframe should be loaded when the UIMController is
  // created. If set to false, the frame will not be loaded and it will be up
  // to the "owner" of the UIMController to load the page. For example, an
  // expandable list only wants to load the iframe when the toggle button
  // is clicked.
  loadFrameOnCreate: true,
  
  // Indicates if the frame element of this widget should size itself according
  // to the size of the UIM page loaded within it. It uses the height provided
  // by the "curam.util.onLoad" API.
  resizeFrameOnLoad: false,
  
  
    templateString: template,
    
  /**
   * Specifies if the controller is used within a dialog.
   */
  inDialog: false,

  /**
   * Constructor, create a UIMController widget.
   *   
   * @param uid
   *    a unqiue identifier for this widget.
   * @param url
   *    The page that will be initially loaded into the iframe.
   */
  constructor: function(args) {
    if (!args.uid) {
      throw "'uid' attribute not provided to constructor for"
            + " curam.UIMController(url,uid)";
    }
    
    this.uid = "uimcontroller_" + args.uid;
    this.tabControllerId = "uimcontroller_tc_" + args.uid;
    this.newTabsTitlesList = [];
    this.ipnTabClickEvent = this.tabControllerId + "-selectChild";
    
    if (this.height == "") {
      this.height = "99%";
    }
    
    if (this.width == "") {
      this.width = "99%";
    }
    
    curam.debug.log(debug.getProperty("curam.UIMController.new") 
      + " curam.UIMController()...");
    curam.debug.log("curam.UIMController " 
      + debug.getProperty("curam.UIMController.identifier") + " " +this.uid);
    curam.debug.log("curam.UIMController " 
      + debug.getProperty("curam.UIMController.url") + " " + this.url);
    curam.debug.log("curam.UIMController " 
        + debug.getProperty("curam.UIMController.identifier") 
        + " " + this.tabControllerId);
    curam.debug.log("curam.UIMController: newTabsTitlesList " 
        + " " + this.newTabsTitlesList);
   layer.register("curam/UIMController", this);
  
    return this.uimController;
  },
  
  /**
   * postCreate, after the widget has been created add a listener for events
   * coming from the iframe, then load the iframe. It is important that the
   * order is maintained here as adding the listener after loading the iframe
   * will mean the events are missed.
   */
  postCreate: function() {

    //width and height specified on dom node in application.css
	  if (jsScreenContext.hasContextBits("EXTAPP")) {
		  domAttr.set(this.domNode, 
			"style", {"height": this.height,"width": this.width});  
	  }
    curam.debug.log(
        "UIMController Height: " + domStyle.get(this.domNode,"height"));
    curam.debug.log(
        "UIMController Width: " + domStyle.get(this.domNode,"width"));
    
    this.frameLoadEvent = this.EVENT.TOPIC_PREFIX + this.frame.id;
    
    this.setURL(this.url);

    // subscribe for onLoad events on the iframe
    var fLoadFunct = dojo.hitch(this, "processFrameLoadEvent"); 
    curam.util.onLoad.addSubscriber(this.frame.id, fLoadFunct);
    dojo.connect(this, "destroy", function() {
      curam.util.onLoad.removeSubscriber(this.iframeId, fLoadFunct);
      this.fLoadFunct = null;
    });
    if (jsScreenContext.hasContextBits("EXTAPP")) {
    	
       if (this.inDialog) {
    	  // Set the initial dimensions of the iframe.
    	  // The width is particularly important for correct automatic height
    	  // calculation in dialogs
    	   domStyle.set(this.frame, {
    	   width: this.width,
    	   height: this.height
    	    });
          }
       }
    curam.debug.log("curam.UIMController: loadFrameOnCreate=" 
      + this.loadFrameOnCreate);
    curam.debug.log("curam.UIMController " 
        + debug.getProperty("curam.UIMController.url") + this.url);
    if(this.loadFrameOnCreate == true && typeof(this.url) != "undefined"){
      curam.debug.log("curam.UIMController: " 
        + debug.getProperty("uram.UIMController.loading"));
      this.loadPage();
    }
  },
  
  setURL: function(url) {
    if (url.indexOf("Page.do") == -1) {
      this.absoluteURL = true;
      this.url = url;
    } else {
      this.absoluteURL = false;
      this.url = this._trimURL(url);
    }
  },
  
  /**
   * Process the object returned from a frame load event. Extract
   * in page navigation if it exists in the frame and trigger the
   * Tab Controller for the UIMController.
   * If no In Page Navigation then hide the Tab Controller if it
   * is currently being displayed.
   *
   * @param iframeID
   *    ID of the iframe on which the load event occurred.
   * @param context
   *    The data received from the event published by the IFrame.
   */
  processFrameLoadEvent: function(iframeID, context) {
    curam.debug.log(
        "curam.UIMController: processFrameLoadEvent " 
        + debug.getProperty("curam.UIMController.processing.IPN") + context);

      this.inPageNavItems = context.inPageNavItems;
      curam.debug.log("curam.UIMController: processFrameLoadEvent: " 
        + debug.getProperty("curam.UIMController.processing"));
      curam.debug
        .log("curam.UIMController.processFrameLoadEvent: this.tabController: " 
          + this.tabController);

      if (this.resizeFrameOnLoad == true) {
        var newPageHeight = context.height;
        
        curam.debug.log(debug.getProperty("curam.UIMController.resizing") 
          + newPageHeight);
        if (newPageHeight) {
          domStyle.set(this.getIFrame(), { height: newPageHeight + "px" });
        }
      }
      
      // If no IPN hide the tabcontainer and exit.
      curam.debug.log(debug.getProperty("curam.UIMController.IPN.items")
    		  + JSON.stringify(this.inPageNavItems));
      if (!this.hasInPageNavigation()) {
        curam.debug.log(debug.getProperty("curam.UIMController.no.IPN"));
        this.clearIPNTabs();
        if (!this._tabControllerHidden()) {
           curam.debug.log(debug.getProperty("curam.UIMController.hiding"));
           this.showTabContainer(false);
        }
        dojo.publish(this.TOPIC_LOADED);

        // Only update browser tab title when a non-dialog frame has
        // loaded. Titles during modal dialogs are handled by the
        // curam.ModalDialog._loadErrorHandler function.
        if(this.inDialog === false) {
          // Update the browser tab title
          curam.debug.log("curam.UIMController.processFrameLoadEvent calling curam.util.setBrowserTabTitle");
          curam.util.setBrowserTabTitle();
        }
        return;
      }
      
      curam.debug.log(debug.getProperty("curam.UIMController.extract"));
      var newSelectedTabIndex = -1;
      // Extract the data from the published event.
      for(var i = 0; i < this.inPageNavItems.length; i++) {
        this.newTabsTitlesList.push(this.inPageNavItems[i].title);
        if (this.inPageNavItems[i].selected == true) {
          newSelectedTabIndex = i;
        }      
        curam.debug.log(
            debug.getProperty("curam.UIMController.IPN.") + "[" 
            + this.inPageNavItems[i].title + ", " 
            + this.inPageNavItems[i].href + ", "  
            + this.inPageNavItems[i].selected + "]" );
      }

      // Test if the tab titles have changed.
      // Note: There are a number of ways we could view equality. The title
      // might be the same but the link could be different, or vice versa, or 
      // the order of items have changed. For now we are doing a simple 
      // compare on the list of titles for order and equality, if they are 
      // different in these ways we reload all tabs.
      var tabsChanged = 
        !(this.compareLists(this.oldTabsTitlesList, this.newTabsTitlesList));

      if (tabsChanged) {
        this.clearIPNTabs(this);
        this.createIPNTabs(this.inPageNavItems);

        // if there were no tabs previously then we need to show the 
        // Tab Controller and call the resize function to trigger a redraw.
        if (this._tabControllerHidden()) {
          this.showTabContainer(true);
        }
        
      } else {
        curam.debug.log(debug.getProperty("curam.UIMController.no.change"));
        if (newSelectedTabIndex > -1) {
          var currentSelectedTabIndex =
            this.tabController.getIndexOfChild(
                this.tabController.selectedChildWidget);
          if (currentSelectedTabIndex != newSelectedTabIndex) {
            curam.debug.log(debug.getProperty("curam.UIMController.change") 
                + currentSelectedTabIndex 
                + debug.getProperty("curam.UIMController.to") 
                + newSelectedTabIndex);
        
            // In this case the selected tab is bing updated as a result of a
            // page being loaded from an external source, as opposed to a user
            // clicking on of the in-page navigation tabs. The listener for the
            // selected child event has to be switched off to prevent an infinite
            // loop.
            this.toggleIPNTabClickEventListener("off");
            this.tabController.selectChild(
                this.tabController.getChildren()[newSelectedTabIndex]);
            // Now that the tab has been selected, switch on the listener again
            // to respond to input from the user.
            this.toggleIPNTabClickEventListener("on");
          }
        }      
      }
      this.newTabsTitlesList = [];
      curam.debug.log(debug.getProperty("curam.UIMController.clear") 
        + this.newTabsTitlesList);
      this.finishedLoadingTabs = true;
    
      dojo.publish(this.TOPIC_LOADED);
      dojo.publish("/curam/tab/labelUpdated");
  },
  
  /**
   * Determines if the in-page navigation tab controller is hidden or not.
   *
   * @private
   * 
   * @return True if the in-page navigation tab controller is hidden,
   *    otherwise true.
   */
  _tabControllerHidden: function() {
    return domStyle.get(this.tabController.domNode, "display") == "none";
  },
  
  /**
   * Switches on or off the In Page Navigation Tab Click listener. The
   * listener reacts to tab select events, but because these occur when
   * creating or destroying tabs we must have the ability to switch off 
   * the listeners until these processes have finished to avoid 
   * unwanted behaviour.
   *
   * @param switchIs
   *      "on" or "off"
   */
  toggleIPNTabClickEventListener: function(switchIs) {
    if (switchIs == "off") {
      if (this.handleIPNTabClickListener != null) {
        // Stop listening for tab select events while the tab container redraws, 
        // otherwise we end up in a continuous loop where the redraw causes a 
        // select and the select causes a redraw.
        curam.debug.log(debug.getProperty("curam.UIMController.off.listener"));
        dojo.unsubscribe(this.handleIPNTabClickListener);
      }     
    
    } else {
      curam.debug.log(debug.getProperty("curam.UIMController.on.listener"));
      this.handleIPNTabClickListener = 
        this.subscribe(
            this.ipnTabClickEvent, dojo.hitch(this, this.handleIPNTabClick));
    }
  },
  
  /**
   * React to a user tab select on the in page navigation tabs.
   * After the tabs have finished loading extract the url from the tab 
   * object and pass it to the handlePageRequest function on the 
   * Curam TabController.
   *
   * @param tab
   *    The tab that was clicked.
   */
  handleIPNTabClick: function(tab) {
    if (this.finishedLoadingTabs) {
      curam.debug.log(debug.getProperty("curam.UIMController.finishing"));
      
      // Reset the indicator for the next tab click.
      this.finishedLoadingTabs = false;

      // Set the new url by using the title of the selected tab to look up the 
      // associated URL.
      this.setURL(this._getURLByTitle(tab.title));
      // reload the frame
      this.loadPage();
    }
  },    
  
  /**
   * Given a Dijit TabController and a list of items, create a Dijit
   * ContentPane for each item in the list and add it to the Dijit
   * TabController to create a list of tabs.
   *
   * @param newTabs
   *    An array of objects representing the new tabs.
   */
  createIPNTabs: function(newTabs) {
    this.toggleIPNTabClickEventListener("off");
    if (!this.tabController) {
      console.error(
       "curam.UIMController.createIPNTabs: " 
         + debug.getProperty("uram.UIMController.no.widget")
       + " '" + this.tabControllerId + "'");
       
    } else {
      curam.debug.log("curam.UIMController.createIPNTabs: " 
        + debug.getProperty("curam.UIMController.creating.tabs") + newTabs);
      var selectedTab = null;
      for (var i = 0; i < newTabs.length; i++) {
        var cp = new dijit.layout.ContentPane({
          title: newTabs[i].title
        });
        this.tabController.addChild(cp);
        if(newTabs[i].selected == true || selectedTab==null){
          selectedTab = cp;
        }
        // Maintain the list of Tab Titles.
        this.oldTabsTitlesList.push(newTabs[i].title);
        curam.debug.log("curam.UIMController.createIPNTabs: " 
          + debug.getProperty("curam.UIMController.adding.tabs") 
          + newTabs[i].title);      
      }

      this.tabController.startup();
      this.tabController.selectChild(selectedTab);
      
    }
    this.toggleIPNTabClickEventListener("on");
    this.newTabsTitlesList = [];
  },
  
  clearIPNTabs: function() {
    // summary: 
    //      Given the id of a Dijit TabContainer find the widget and 
    //      remove all tabs from the controller by removing the children.
    //      Destroy each child as it is removed.
    //
    var failedToClearTabs = false;
    curam.debug.log("curam.UIMController.clearIPNTabs: " 
        + debug.getProperty("curam.UIMController.clearing.tabs") 
        + this.oldTabsTitlesList);
    this.toggleIPNTabClickEventListener("off");
    try {
      this.tabController.destroyDescendants();
    } catch(e) {
      // Fix me.. Why are descendants not being destroyed, dojo upgrade 1/9/1.10
      // ? -- BOS
      curam.debug.log("curam.UIMController.clearIPNTabs - this.tabController.destroyDescendants(): " 
          +  debug.getProperty("curam.UIMController.clear.warning"));
      failedToClearTabs = true; 
    }
    this.tabController.selectedChildWidget = null;
    this.oldTabsTitlesList=[];
    this.toggleIPNTabClickEventListener("on");
    
    if (!failedToClearTabs) {
      curam.debug.log("curam.UIMController.createIPNTabs: " 
          + debug.getProperty("curam.UIMController.clearing.notify") 
          + this.oldTabsTitlesList);
    }   
  },
  
  compareLists: function(list1, list2){

    // summary: 
    //    Given 2 arrays compare the items in each array for equality, 
    //    if the count, values or order do not match return false, else true.
    //
    // parameter : list1, an array.
    // parameter : list2, an array.
    
    curam.debug.log("curam.UIMController.compareLists: " 
      + debug.getProperty("curam.UIMController.comparing.tabs"));
    curam.debug
      .log(debug.getProperty("curam.UIMController.tab.list1") + list1);
    curam.debug
      .log(debug.getProperty("curam.UIMController.tab.list1") + list2);
    var result = true;
    if(list1.length != list2.length){
      result = false;
    }
    for(var i = 0; i < list1.length; i++){
      if(list1[i] != list2[i]){
        result = false;
      }
    }
    curam.debug.log(debug.getProperty("curam.UIMController.result") + result);
    return result;
  },
  

  _getURLByTitle: function (title){
    // summary:
    //    Given a title for a tab return the associated url from the map of
    //    navigation items.
    // parameter: title, this is the title of the tab. 
   
    var url = null;
    dojo.forEach(this.inPageNavItems, function(navItem){
      if(navItem.title == title){
        url = navItem.href;
      }
    });
    curam.debug.log(url);
    return url;
  },
  
  /**
   * Utility method which trims a href down to just
   * "PageIDPage.do?queryString"
   */
  _trimURL: function(href) {
    var idx=href.lastIndexOf("/");
    if (idx>-1 && idx <= href.length) {
      return href.substring(idx + 1);
    
    } else {
      return href;
    }
  },
  
  hasInPageNavigation: function() {
    return this.inPageNavItems != null;
  },
  
  getIFrame: function(){
    // summary:
    //   Returns the iframe created by this widget.
    return this.frame;
  },
  
  /**
   * Sets the 'src' attribute of the iframe created by this widget.
   * 
   * @param {dojo.Deferred} [deferred]
   *    The instance of dojo.Deferred to be notified when the frame
   *    has finished loading.
   */
  loadPage: function(deferred) {
    if (typeof(this.url) == "undefined" || this.url == null) {
      var e = new Error(
          "curam.UIMController: Cannot load page as URL has not been set");
      if (deferred) {
        deferred.errback(e);
      }
      throw e;
    }
    
    if (deferred) {
      // when the frame is loaded, notify the listeners
      var st = curam.util.subscribe(this.TOPIC_LOADED, function() {
        curam.util.unsubscribe(st);
        deferred.callback();
      });
    }

    var fullURL = this._getFullURL();
    curam.debug.log(
        "curam.UIMController.loadPage(): " 
          + debug.getProperty("curam.UIMController.set.source")
        + this.frame.id + " to url: " + fullURL);
      domAttr.set(this.frame, "src", fullURL);
  },
  
  _getFullURL: function() {
    if (typeof(this.absoluteURL) != "undefined" && this.absoluteURL == true) {
      return this.url;
    }
    
    var urlAppend;
    if (this.url.indexOf("?") == -1) {
      urlAppend = "?";
    } else {
      urlAppend = "&";
    }
    // The "url" attribute of this class is always in the form:
    // PageIDPage.do?queryString
    // To set the source of the iframe we have to add the locale.
    // The iframe can exist in the "top level AppController.do" or within a
    // UIM page (e.g. iframes used in expandable list are nested *within* the
    // iframe used for the UIM page itself) we have to be carefull with the
    // use of relative URLs. For an iframe that exists in the "top level" page
    // we can set it's src attribute to "en/PageIDPage.do?queryString". This
    // is relative to "http://baseURL/Curam" and so will load the UIM page as
    // http://baseURL/Curam/en/PageIDPage.do?queryString.
    // However, when the iframe exists *within* a UIM page the URL would be
    // to relative to "http://baseURL/Curam/locale/". Without adjusting the
    // relative path we'd end up with an iframe with a src of, which doesn't
    // exist (the two locales in the path):
    // http://baseURL/Curam/en/en/PageIDPage.do?queryString
    // So, we check if we are not in the context of the top level window we
    // know we are within a UIM page and relative to
    // "http://baseURL/Curam/locale/". Therefore, we avoid adding the locale
    // in this case.
    var locale = curam.config ? curam.config.locale : jsL;
    var urlPrefix = "";
    if (window == curam.util.getTopmostWindow()) {
      // it's the "top level" window so we need to add the locale to the URL.
      urlPrefix = locale + "/";
    }

    // only add the o3nocache parameter if it does not already exist, adding it
    // more than once will cause the modal to fail to load.
    if (this.url.indexOf("o3nocache=") == -1) {
      return urlPrefix + this.url
             + urlAppend + curam.util.getCacheBusterParameter();
    } else {
      return urlPrefix + this.url;
    }       
  },
  
  showTabContainer: function(show) {
    if (show && !this.hasInPageNavigation()) {
      curam.debug.log(debug.getProperty("curam.UIMController.ignore.reuest"));
      return;
    }
    
    domStyle.set(this.frameWrapper, "top",
        (show ? this.TAB_HEIGHT + 7 : "0") + "px");

    domStyle.set(this.tabController.domNode, "display",
        show ? "block" : "none");
    
    // NOTE: Fix only needed for chrome !!
    // Temperary fox for chrome where in page navigation within modal not
    // displayed unless overflow must not be set to hidden.. What is cause of
    // this tough.. Styling or dojo upgrade to 1.9/1.10?? -- BOS
    if (this.hasInPageNavigation()) {
      domStyle.set(this.tabController.domNode.parentNode,"overflow","visible");  
    }
    
    if (show) {
      this.tabController.resize();
    }
  }, 
  
  setDimensionsForModalDialog: function(w, h, context) {
    curam.debug.log("curam.UIMController:setDimensionsForModalDialog() - "
                    + "w=" + w + ", h=" + h);
    
    // Set the dimensions of the iframe
    domStyle.set(this.frame, {
      width: w,
      height: h
    });
    
    // Set the width of the tab container. Note, the height is fixed by the
    // "ipnTabController" CSS class applied in the dijit template.
    domStyle.set(this.tabController.domNode, {
      width: w
    });

    if (typeof(context.inPageNavItems) != "undefined") {
      // means we have tabs to show so set the dimensions of this
      // UIMControllers's root node to match the width of the iframe and the
      // height adjusted to allow for the tab container
      h += this.TAB_HEIGHT + 5;
      curam.debug.log("cura.UIMController:setDimensionsForModalDialog() - "
          + debug.getProperty("curam.UIMController.height"));
    }

    domStyle.set(this.domNode, {
      width: w,
      height: h
    });
  },

  destroy: function() {
    this.iframe = null;
    this.inPageNavItems = null;
    dojo.unsubscribe(this.handleIPNTabClickListener);
    this.tabController.destroy();

    this.inherited(arguments);
  }
  });
  
  return UIMController;
});

},
'curam/util/ui/form/renderer/TextEditRendererFormEventsAdapter':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022
 *
 */
define(["dojo/_base/declare", "curam/util/ui/form/renderer/GenericRendererFormEventsAdapter"], function(declare, GenericRendererFormEventsAdapter) {

	/*
	 * Modification History
	 * --------------------
	 * 14-oct-2022  BD [SPM125820] Initial version.
	 */

	/**
	 * @namespace Functions specific to the context panel.
	 */


	var TextEditRendererFormEventsAdapter = declare("curam.util.ui.form.renderer.TextEditRendererFormEventsAdapter", GenericRendererFormEventsAdapter,
      /** @lends curam.util.ui.form.renderer.TextEditRenderer */ {

			setFormElementValue: function(value) {
				this.element.value = value;
			},

			getFormElementValue: function() {
				return this.getFormElement().value;
			},

		});

	return TextEditRendererFormEventsAdapter;
});
},
'curam/ajax':function(){
/*
 * Copyright 2009-2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 27-Feb-2014  MV  [CR00419961] Move to common AJAX request API.
 * 31-Jan-2012 MV [CR00302081] Move away from global context. 
 */

define(['curam/util/Request'
        ], function(curamRequest) {

var AJAXCall = function(dataTarget, inputProviderName) {
  this.target=dataTarget;
  this.inputProvider = inputProviderName || 'null';
};

var theAJAXCall = {
  doRequest: function (opAlias, params, isPopup, synchronous) {
    var theServlet = "../servlet/JSONServlet";

    var filler = this;

      if (isPopup) theServlet= "../" + theServlet;

      var oData = {
          caller: this.target.id,
          operation: opAlias,
          inputProvider: this.inputProvider,
          args: params
      };

      function processResult(oResult, opAlias){
        oResult = dojo.fromJson(oResult);
          if (oResult instanceof Array) {
            if (oResult.length > 1) {
              if (opAlias == "getCodeTableSubset") {
                filler.fillCTWithBlank(oResult); 
              } else { 
                filler.fillCT(oResult);
              }
            } else {
              if (opAlias == "getCodeTableSubset") {
                // have to handle code tables with one item
                filler.fillCTWithBlank(oResult);            
              } else {
                filler.fillSingle(oResult, true);
              }
            }
          } else {
            filler.fillSingle(oResult);
          }
      };

      curamRequest.post({
        url:theServlet,
        handleAs:   "text",
        load: function(data, evt){
          processResult(data, opAlias);
        },
        error: function(){
          alert("error");
        },
        content: {"content": dojo.toJson(oData)},
        preventCache: true,
        sync: synchronous
      });
  },

  fillCT: function (theResult) {
    this.target.options.length = 0;
    for (var i = 0; i < theResult.length; i++) {
      this.target.options[i] = new Option(theResult[i]["descr"], theResult[i]["code"], theResult[i]["default"]);
    }
  },

  fillCTWithBlank: function (theResult) {
    this.target.options.length = 0;
    this.target.options[0] = new Option("");
    for (var i = 0; i < theResult.length; i++) {
      this.target.options[i+1] = new Option(theResult[i]["descr"], theResult[i]["code"]);
    }
  },

  fillSingle: function (theResult, arrayed) {
    if (arrayed) {
      this.target.value = theResult[0]["value"];
    } else {
      this.target.value = theResult["value"];
    }
  }
};

dojo.mixin(AJAXCall.prototype, theAJAXCall);

// Keep the functions in the global scope for backwards compatibility.
// TODO: remove when code calling these functions is updated
dojo.global.AJAXCall = AJAXCall;

return AJAXCall;
});

},
'curam/util/Request':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration
 * 04-Mar-2014  MV  [CR00421036] Use new LocalConfig API to read options, make
 *      login page detector configurable, add documentation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

define(['dojo/_base/xhr',
        'curam/debug',
        "curam/util/ResourceBundle",
        "curam/inspection/Layer",
        'curam/util/LocalConfig'
        ], function(xhr, debug, bundle, layer, localConfig) {

        var requestBundle = new bundle("curam.application.Request");

      // holds custom login page detector function, if one was provided
      // by the API client
      _isLoginPage = null,
        
      /**
       * Check for a login page based on the presence of this HTML tag:
       * <form action="j_security_check" ...>
       * 
       * @param request The XHR request object.
       * @return True if the response is a login page, otherwise False.
       */
      isLoginPage = function(request) {
        // if custom login page detector was provided use it
        if (_isLoginPage) {
          return _isLoginPage(request);

        // or fall back to default detection method
        } else {
          return request.responseText.indexOf(
              "action=\"j_security_check\"") > 0;
        }
      },

      errorDisplayHookpoint = function(err, ioargs) {
        if (isLoginPage(ioargs.xhr)) {
          // session timeout scenario
          debug.log(requestBundle.getProperty('sessionExpired'));
        } else {
          // display generic error message
          debug.log(requestBundle.getProperty('ajaxError'));
        }

        // log the error
        debug.log(err);
        debug.log('HTTP status was: ' + ioargs.xhr.status);
      },
      
      _xhr = function(method, args) {
        var ajaxDebugMode =
                localConfig.readOption('ajaxDebugMode', 'false') == 'true';

        var error = args.error;
        
        // only enable common error handling if debug mode is on
        if (ajaxDebugMode) {
          args.error = function(err, ioargs) {
            if (args.errorHandlerOverrideDefault !== true) {
              errorDisplayHookpoint(err, ioargs);
            }

            // make sure custom error handler gets called, if there is one
            if (error) {
              error(err, ioargs);
            }
          };
        }

        var deferred = method(args);
        return deferred;
      };

  /**
   * @name curam.util.Request
   * @namespace AJAX request API with common error handling and login page
   * detection. It is designed as a near drop-in replacement for the dojo.xhr*
   * group of functions.
   * <p/>
   * By default this API will behave exactly like it's dojo.xhr* counterpart.
   * <p/>
   * But if the "curam.trace.javascript.ajax.report" application property is set
   * to true then common error reporting is used, causing every AJAX request
   * failure to be reported to the user in a friendly dialog with details
   * written to the JavaScript trace log (if it is enabled).<br/>
   * Session timeouts will be reported differently, asking the user to log
   * in again.
   * <p/>
   * Note that by default the common reporting will work alongside any custom
   * error handlers specified by the API client. However if
   * the "errorHandlerOverrideDefault" property is present on the args
   * object and is set to true, then a provided custom error handler will
   * override the default handling provided by this API.
   */
  var Request = 
    /**
     * @lends curam.util.Request.prototype
     */
    {
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html">dojo.xhrPost</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the post() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrPost.html#dojo-xhrpost-supported-object-properties">dojo.xhrPost documentation</a>
       * @returns {dojo.Deferred} Same return type as get(). See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      post: function(args) {
        return _xhr(xhr.post, args);
      },
      
      /**
       * This function works exactly like
       * <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html">dojo.xhrGet</a>
       * only it additionally provides common error handling for AJAX requests.
       *
       * @param args This object defines how the get() should operate.
       *  For detailed information see
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#dojo-xhrget-supported-object-properties">dojo.xhrGet documentation</a>
       * @returns {dojo.Deferred} See
       *  <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#return-type-dojo-deferred">dojo.xhrGet return type</a>
       *  for details.
       */
      get: function(args) {
        return _xhr(xhr.get, args);
      },
      
      /**
       * Allows to optionally customize the way to detect that a response
       * from an AJAX request is a login page.
       * 
       * This is optional and if custom detector function is not provided
       * the API will by default recognize login pages that contain a HTML form
       * that submits into the standard "j_security_check" mechanism.
       * 
       * If null is passed the default detection method will be used.
       * 
       * @param {function(dojoXhrRequestObject)::boolean} detectorFunction
       *        The function to be used for detecting login page based on the
       *        <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/xhrGet.html#handling-status-codes">Dojo XHR
       *        request object.</a>
       */
      setLoginPageDetector: function(detectorFunction) {
        _isLoginPage = detectorFunction;
      },
      
      checkLoginPage: function(args) {
        return isLoginPage(args);
      }
     };
    layer.register("curam/util/Request", Request);

  return Request;
});

},
'curam/widget/DropDownButton':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/_base/declare",
        "dojo/text!curam/widget/templates/DropDownButton.html",
        "dijit/form/DropDownButton",
        "curam/widget/_HasDropDown"
        ], function(declare, template) {
  
/*
 * Modification History
 * --------------------
 * 14-May-2019 JD [RTC242058]    Updated to use curam/widget/_HasDropDown.
 * 10-Jan-2013 SB [CR00357346]   Initial version.
 */

  /**
   * @name curam.widget.DropDownButton
   * @namespace Override of the Dojo DropDownButton in order to make the DropDownButton
   * accessible using screen reader.
   * 
   * 
   */
  var DropDownButton = declare("curam.widget.DropDownButton", [dijit.form.DropDownButton, curam.widget._HasDropDown],
  /**
   * @lends curam.widget.DropDownButton.prototype
   */
  {
    templateString: template
  });
  
  return DropDownButton;
});

},
'cm/_base/_form':function(){
define([], function() {
  
/*
  This file provides common functions that are used
  to manipulate HTML forms.
*/

  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  dojo.mixin(cm, {
  
    checkAll: function(/*Boolean*/value, /*Node*/fromNode) {
      // summary: Sets the check state of one or more checkboxes 
      //           to the value specified. All checkboxes inside the
      //           node 'fromNode' are affected.
      cm.query("input[type='checkbox']", fromNode)
        .forEach("item.checked = " + (value ? "true" : "false"));
    },
    
    setFormSubmitted: function(form, wasSubmitted) {
      // summary: Sets the flag on the form to state whether or not it was 
      //           previously submitted. If any onSubmit handler for a form 
      //           (e.g. validation) cancels the onSubmit event, it should 
      //           call this method, passing false as the second parameter.
      form._alreadySubmitted = wasSubmitted;
    },
  
    wasFormSubmitted: function(form) {
      // summary: returns true if the form was previously submitted, false otherwise.
      return form._alreadySubmitted;
    },
    
    getFormItems: function() {
      // summary: Returns an object that provides access to information on
      //           the form elements on the page. The object contains the
      //           following methods:
      //            length(): returns the number of inputs on the page. Takes
      //                       no parameters
      //            getNames(): returns an array of strings, each element is a
      //                          form element name. Takes no parameters.
      //            getInputs(boolean): returns an array of DOM input elements.
      //                        If the boolean 'true' is passed to the method,
      //                        it only returns inputs that are mandatory.
      //            getTargetPath(index): returns the target path of an input.
      //                        The parameter to the function can be either
      //                        the string name of the input, or an integer index.
      //            getLabel(index): returns the string label for the input.
      //                        The parameter to the function can be either
      //                        the string name of the input, or an integer index.
      //            getDomain(index): returns the data Domain for the input.
      //                        The parameter to the function can be either
      //                        the string name of the input, or an integer index.
      //            isMandatory(index): returns true if the input is mandatory. Otherwise
      //                        false is returned.
      //                        The parameter to the function can be either
      //                        the string name of the input, or an integer index.
      if(cm._formItems) {
        return cm._formItems;
      }
      
      // The form metadata is stored in the input with the name "__o3fmeta"
      var formItemsInput = dojo.query("input[name='__o3fmeta']");
      var data = formItemsInput.length > 0 ? 
                                                  dojo.fromJson(formItemsInput[0].value) : {};
      var names = [];
      for(var x in data) {
        names.push(x);
      }
      
      // Create a function that has child functions.  This accesses the 
      // 'data' and 'names' arrays above.
      cm._formItems = new function() {
        this.length = function(){
          return names.length;
        };
        this.getNames = function(){
          return names;
        };
        // List the inputs on the page. If the mandatory flag is set to true,
        // only mandatory inputs are returned.
        this.getInputs = function(mandatory) {
          var inputs = [];
          dojo.forEach(names, function(name, index){
            if(!mandatory || this.isMandatory(index)){
              inputs.push("[name='" + name + "']");
            } 
          }, this);
          return inputs.length > 0 ? dojo.query(inputs.join(",")) : [];
        };
        function fn(dataIdx) {
          return function(index) {
            var d = data[dojo.isString(index) ? index : names[index]];
            return d ?  d[dataIdx]:null;
          };
        }
        this.getTargetPath = fn(0);
        this.getLabel = fn(1);
        this.getDomain = fn(2);
        this.isMandatory = fn(3);
      };
      return cm._formItems;
    }
  });
  
  return cm;
});

},
'dijit/MenuBar':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys.DOWN_ARROW
	"./_MenuBase",
	"dojo/text!./templates/MenuBar.html"
], function(declare, keys, _MenuBase, template){

	// module:
	//		dijit/MenuBar

	return declare("dijit.MenuBar", _MenuBase, {
		// summary:
		//		A menu bar, listing menu choices horizontally, like the "File" menu in most desktop applications

		templateString: template,

		baseClass: "dijitMenuBar",

		// By default open popups for MenuBar instantly
		popupDelay: 0,

		// _isMenuBar: [protected] Boolean
		//		This is a MenuBar widget, not a (vertical) Menu widget.
		_isMenuBar: true,

		// parameter to dijit.popup.open() about where to put popup (relative to this.domNode)
		_orient: ["below"],

		_moveToPopup: function(/*Event*/ evt){
			// summary:
			//		This handles the down arrow key, opening a submenu if one exists.
			//		Unlike _MenuBase._moveToPopup(), will never move to the next item in the MenuBar.
			// tags:
			//		private

			if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
				this.onItemClick(this.focusedChild, evt);
			}
		},

		focusChild: function(item){
			// Overload focusChild so that whenever a new item is focused and the menu is active, open its submenu immediately.

			this.inherited(arguments);
			if(this.activated && item.popup && !item.disabled){
				this._openItemPopup(item, true);
			}
		},

		_onChildDeselect: function(item){
			// override _MenuBase._onChildDeselect() to close submenu immediately

			if(this.currentPopupItem == item){
				this.currentPopupItem = null;
				item._closePopup(); // this calls onClose
			}

			this.inherited(arguments);
		},

		// Arrow key navigation
		_onLeftArrow: function(){
			this.focusPrev();
		},
		_onRightArrow: function(){
			this.focusNext();
		},
		_onDownArrow: function(/*Event*/ evt){
			this._moveToPopup(evt);
		},
		_onUpArrow: function(){
		},

		onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
			// summary:
			//		Handle clicks on an item.   Also called by _moveToPopup() due to a down-arrow key on the item.
			//		Cancels a dropdown if already open and click is either mouse or space/enter.
			//		Don't close dropdown due to down arrow.
			// tags:
			//		private
			if(item.popup && item.popup.isShowingNow && (!/^key/.test(evt.type) || evt.keyCode !== keys.DOWN_ARROW)){
				item.focusNode.focus();
				this._cleanUp(true);
			}else{
				this.inherited(arguments);
			}
		}
	});
});

},
'dijit/Viewport':function(){
define([
	"dojo/Evented",
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff",	// has("ie"), has("ios")
	"dojo/window" // getBox()
], function(Evented, on, domReady, has, winUtils){

	// module:
	//		dijit/Viewport

	/*=====
	return {
		// summary:
		//		Utility singleton to watch for viewport resizes, avoiding duplicate notifications
		//		which can lead to infinite loops.
		// description:
		//		Usage: Viewport.on("resize", myCallback).
		//
		//		myCallback() is called without arguments in case it's _WidgetBase.resize(),
		//		which would interpret the argument as the size to make the widget.
	};
	=====*/

	var Viewport = new Evented();

	var focusedNode;

	domReady(function(){
		var oldBox = winUtils.getBox();
		Viewport._rlh = on(window, "resize", function(){
			var newBox = winUtils.getBox();
			if(oldBox.h == newBox.h && oldBox.w == newBox.w){ return; }
			oldBox = newBox;
			Viewport.emit("resize");
		});

		// Also catch zoom changes on IE8, since they don't naturally generate resize events
		if(has("ie") == 8){
			var deviceXDPI = screen.deviceXDPI;
			setInterval(function(){
				if(screen.deviceXDPI != deviceXDPI){
					deviceXDPI = screen.deviceXDPI;
					Viewport.emit("resize");
				}
			}, 500);
		}

		// On iOS, keep track of the focused node so we can guess when the keyboard is/isn't being displayed.
		if(has("ios")){
			on(document, "focusin", function(evt){
				focusedNode = evt.target;
			});
			on(document, "focusout", function(evt){
				focusedNode = null;
			});
		}
	});

	Viewport.getEffectiveBox = function(/*Document*/ doc){
		// summary:
		//		Get the size of the viewport, or on mobile devices, the part of the viewport not obscured by the
		//		virtual keyboard.

		var box = winUtils.getBox(doc);

		// Account for iOS virtual keyboard, if it's being shown.  Unfortunately no direct way to check or measure.
		var tag = focusedNode && focusedNode.tagName && focusedNode.tagName.toLowerCase();
		if(has("ios") && focusedNode && !focusedNode.readOnly && (tag == "textarea" || (tag == "input" &&
			/^(color|email|number|password|search|tel|text|url)$/.test(focusedNode.type)))){

			// Box represents the size of the viewport.  Some of the viewport is likely covered by the keyboard.
			// Estimate height of visible viewport assuming viewport goes to bottom of screen, but is covered by keyboard.
			box.h *= (orientation == 0 || orientation == 180 ? 0.66 : 0.40);

			// Above measurement will be inaccurate if viewport was scrolled up so far that it ends before the bottom
			// of the screen.   In this case, keyboard isn't covering as much of the viewport as we thought.
			// We know the visible size is at least the distance from the top of the viewport to the focused node.
			var rect = focusedNode.getBoundingClientRect();
			box.h = Math.max(box.h, rect.top + rect.height);
		}

		return box;
	};

	return Viewport;
});

},
'dijit/Dialog':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/sniff", // has("ie") has("opera")  1 
	"dojo/window", // winUtils.getBox, winUtils.get
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"./focus",
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_CssStateMixin",
	"./form/_FormMixin",
	"./_DialogMixin",
	"./DialogUnderlay",
	"./layout/ContentPane",
	"./layout/utils",
	"dojo/text!./templates/Dialog.html",
	"./a11yclick",	// template uses ondijitclick
	"dojo/i18n!./nls/common"
], function(require, array, aspect, declare, Deferred,
			dom, domClass, domGeometry, domStyle, fx, i18n, keys, lang, on, ready, has, winUtils,
			Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin,
			DialogUnderlay, ContentPane, utils, template){

	// module:
	//		dijit/Dialog

	var resolvedDeferred = new Deferred();
	resolvedDeferred.resolve(true);

	var _DialogBase = declare("dijit._DialogBase" + (has("dojo-bidi") ? "_NoBidi" : ""), [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {
		templateString: template,

		baseClass: "dijitDialog",

		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		// Map widget attributes to DOMNode attributes.
		_setTitleAttr: { node: "titleNode", type: "innerHTML" },

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: manager.defaultDuration,

		// refocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		//		A Toggle to modify the default focus behavior of a Dialog, which
		//		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit/_DialogMixin._getFocusItems()`.
		_lastFocusItem: null,

		// draggable: Boolean
		//		Toggles the movable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,
		_setDraggableAttr: function(/*Boolean*/ val){
			// Avoid _WidgetBase behavior of copying draggable attribute to this.domNode,
			// as that prevents text select on modern browsers (#14452)
			this._set("draggable", val);
		},

		// maxRatio: Number
		//		Maximum size to allow the dialog to expand to, relative to viewport size
		maxRatio: 0.9,

		// closable: Boolean
		//		Dialog show [x] icon to close itself, and ESC key will close the dialog.
		closable: true,
		_setClosableAttr: function(val){
			this.closeButtonNode.style.display = val ? "" : "none";
			this._set("closable", val);
		},

		postMixInProperties: function(){
			var _nlsResources = i18n.getLocalization("dijit", "common");
			lang.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			domStyle.set(this.domNode, {
				display: "none",
				position: "absolute"
			});
			this.ownerDocumentBody.appendChild(this.domNode);

			this.inherited(arguments);

			aspect.after(this, "onExecute", lang.hitch(this, "hide"), true);
			aspect.after(this, "onCancel", lang.hitch(this, "hide"), true);

			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this.resize();
			this._position();

			if(this.autofocus && DialogLevelManager.isTop(this)){
				this._getFocusItems();
				focus.focus(this._firstFocusItem);
			}

			this.inherited(arguments);
		},

		focus: function(){
			this._getFocusItems();
			focus.focus(this._firstFocusItem);
		},

		_endDrag: function(){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport,
			//		and also adjust position to be fully within the viewport, so user doesn't lose access to handle
			var nodePosition = domGeometry.position(this.domNode),
				viewport = winUtils.getBox(this.ownerDocument);
			nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
			nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
			this._relativePosition = nodePosition;
			this._position();
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.titleBar });
				aspect.after(this._moveable, "onMoveStop", lang.hitch(this, "_endDrag"), true);
			}else{
				domClass.add(node, "dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": array.map(this["class"].split(/\s/),function(s){
					return s + "_underlay";
				}).join(" "),
				_onKeyDown: lang.hitch(this, "_onKey"),
				ownerDocument: this.ownerDocument
			};
		},

		_size: function(){
			// TODO: remove for 2.0
			this.resize();
		},

		_position: function(){
			// summary:
			//		Position the dialog in the viewport.  If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the dialog.  Otherwise, use the Dialog's stored relative offset,
			//		adjusted by the viewport's scroll.
			if(!domClass.contains(this.ownerDocumentBody, "dojoMove")){    // don't do anything if called during auto-scroll
				var node = this.domNode,
					viewport = winUtils.getBox(this.ownerDocument),
					p = this._relativePosition,
					bb = p ? null : domGeometry.position(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
					;
				domStyle.set(node, {
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.keyCode == keys.TAB){
				this._getFocusItems();
				var node = evt.target;
				if(this._firstFocusItem == this._lastFocusItem){
					// don't move focus anywhere, but don't allow browser to move focus off of dialog either
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._firstFocusItem && evt.shiftKey){
					// if we are shift-tabbing from first focusable item in dialog, send focus to last item
					focus.focus(this._lastFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}else if(node == this._lastFocusItem && !evt.shiftKey){
					// if we are tabbing from last focusable item in dialog, send focus to first item
					focus.focus(this._firstFocusItem);
					evt.stopPropagation();
					evt.preventDefault();
				}
			}else if(this.closable && evt.keyCode == keys.ESCAPE){
				this.onCancel();
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			if(this.open){
				return resolvedDeferred.promise;
			}

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized = true;
			}

			if(this._fadeOutDeferred){
				// There's a hide() operation in progress, so cancel it, but still call DialogLevelManager.hide()
				// as though the hide() completed, in preparation for the DialogLevelManager.show() call below.
				this._fadeOutDeferred.cancel();
				DialogLevelManager.hide(this);
			}

			// Recenter Dialog if user scrolls browser.  Connecting to document doesn't work on IE, need to use window.
			// Be sure that event object doesn't get passed to resize() method, because it's expecting an optional
			// {w: ..., h:...} arg.
			var win = winUtils.get(this.ownerDocument);
			this._modalconnects.push(on(win, "scroll", lang.hitch(this, "resize", null)));

			this._modalconnects.push(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));

			domStyle.set(this.domNode, {
				opacity: 0,
				display: ""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this.resize();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new Deferred(lang.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			// If delay is 0, code below will delete this._fadeInDeferred instantly, so grab promise while we can.
			var promise = this._fadeInDeferred.promise;

			fadeIn = fx.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: lang.hitch(this, function(){
					DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: lang.hitch(this, function(){
					if(this.autofocus && DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems();
						focus.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.resolve(true);
					delete this._fadeInDeferred;
				})
			}).play();

			return promise;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo/promise/Promise
			//		Promise object that resolves when the display animation is complete

			// If we haven't been initialized yet then we aren't showing and we can just return.
			// Likewise if we are already hidden, or are currently fading out.
			if(!this._alreadyInitialized || !this.open){
				return resolvedDeferred.promise;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new Deferred(lang.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));

			// fire onHide when the promise resolves.
			this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));

			// If delay is 0, code below will delete this._fadeOutDeferred instantly, so grab promise while we can.
			var promise = this._fadeOutDeferred.promise;

			fadeOut = fx.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: lang.hitch(this, function(){
					this.domNode.style.display = "none";
					DialogLevelManager.hide(this);
					this._fadeOutDeferred.resolve(true);
					delete this._fadeOutDeferred;
				})
			}).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return promise;
		},

		resize: function(dim){
			// summary:
			//		Called with no argument when viewport scrolled or viewport size changed.  Adjusts Dialog as
			//		necessary to keep it visible.
			//
			//		Can also be called with an argument (by dojox/layout/ResizeHandle etc.) to explicitly set the
			//		size of the dialog.
			// dim: Object?
			//		Optional dimension object like {w: 200, h: 300}

			if(this.domNode.style.display != "none"){

				this._checkIfSingleChild();

				if(!dim){
					if(this._shrunk){
						// If we earlier shrunk the dialog to fit in the viewport, reset it to its natural size
						if(this._singleChild){
							if(typeof this._singleChildOriginalStyle != "undefined"){
								this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
								delete this._singleChildOriginalStyle;
							}
						}
						array.forEach([this.domNode, this.containerNode, this.titleBar, this.actionBarNode], function(node){
							if(node){	// because titleBar may not be defined
								domStyle.set(node, {
									position: "static",
									width: "auto",
									height: "auto"
								});
							}
						});
						this.domNode.style.position = "absolute";
					}

					// If necessary, shrink Dialog to fit in viewport and have some space around it
					// to indicate that it's a popup.  This will also compensate for possible scrollbars on viewport.
					var viewport = winUtils.getBox(this.ownerDocument);
					viewport.w *= this.maxRatio;
					viewport.h *= this.maxRatio;

					var bb = domGeometry.position(this.domNode);
					if(bb.w >= viewport.w || bb.h >= viewport.h){
						dim = {
							w: Math.min(bb.w, viewport.w),
							h: Math.min(bb.h, viewport.h)
						};
						this._shrunk = true;
					}else{
						this._shrunk = false;
					}
				}

				// Code to run if user has requested an explicit size, or the shrinking code above set an implicit size
				if(dim){
					// Set this.domNode to specified size
					domGeometry.setMarginBox(this.domNode, dim);

					// And then size this.containerNode
					var layoutNodes = [];
					if(this.titleBar){
						layoutNodes.push({domNode: this.titleBar, region: "top"});
					}
					if(this.actionBarNode){
						layoutNodes.push({domNode: this.actionBarNode, region: "bottom"});
					}
					var centerSize = {domNode: this.containerNode, region: "center"};
					layoutNodes.push(centerSize);

					var contentDim = utils.marginBox2contentBox(this.domNode, dim);
					utils.layoutChildren(this.domNode, contentDim, layoutNodes);

					// And then if this.containerNode has a single layout widget child, size it too.
					// Otherwise, make this.containerNode show a scrollbar if it's overflowing.
					if(this._singleChild){
						var cb = utils.marginBox2contentBox(this.containerNode, centerSize);
						// note: if containerNode has padding singleChildSize will have l and t set,
						// but don't pass them to resize() or it will doubly-offset the child
						this._singleChild.resize({w: cb.w, h: cb.h});
						// TODO: save original size for restoring it on another show()?
					}else{
						this.containerNode.style.overflow = "auto";
						this._layoutChildren();		// send resize() event to all child widgets
					}
				}else{
					this._layoutChildren();		// send resize() event to all child widgets
				}

				if(!has("touch") && !dim){
					// If the user has scrolled the viewport then reposition the Dialog.  But don't do it for touch
					// devices, because it will counteract when a keyboard pops up and then the browser auto-scrolls
					// the focused node into view.
					this._position();
				}
			}
		},

		_layoutChildren: function(){
			// Override _ContentPaneResizeMixin._layoutChildren because even when there's just a single layout child
			// widget, sometimes we don't want to size it explicitly (i.e. to pass a dim argument to resize())

			array.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_DialogBase = declare("dijit._DialogBase", _DialogBase, {
			_setTitleAttr: function(/*String*/ title){
				this._set("title", title);
				this.titleNode.innerHTML = title;
				this.applyTextDir(this.titleNode);
			},

			_setTextDirAttr: function(textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this.set("title", this.title);
				}
			}
		});
	}

	var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {
		// summary:
		//		A modal dialog Widget.
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.).
		// example:
		// |	<div data-dojo-type="dijit/Dialog" data-dojo-props="href: 'test.html'"></div>
		// example:
		// |	var foo = new Dialog({ title: "test dialog", content: "test content" });
		// |	foo.placeAt(win.body());
		// |	foo.startup();
	});
	Dialog._DialogBase = _DialogBase;	// for monkey patching and dojox/widget/DialogSimple

	var DialogLevelManager = Dialog._DialogLevelManager = {
		// summary:
		//		Controls the various active "levels" on the page, starting with the
		//		stuff initially visible on the page (at z-index 0), and then having an entry for
		//		each Dialog shown.

		_beginZIndex: 950,

		show: function(/*dijit/_WidgetBase*/ dialog, /*Object*/ underlayAttrs){
			// summary:
			//		Call right before fade-in animation for new dialog.
			//		Saves current focus, displays/adjusts underlay for new dialog,
			//		and sets the z-index of the dialog itself.
			//
			//		New dialog will be displayed on top of all currently displayed dialogs.
			//
			//		Caller is responsible for setting focus in new dialog after the fade-in
			//		animation completes.

			// Save current focus
			ds[ds.length - 1].focus = focus.curNode;

			// Set z-index a bit above previous dialog
			var zIndex = ds[ds.length - 1].dialog ? ds[ds.length - 1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
			domStyle.set(dialog.domNode, 'zIndex', zIndex);

			// Display the underlay, or if already displayed then adjust for this new dialog
			DialogUnderlay.show(underlayAttrs, zIndex - 1);

			ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
		},

		hide: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Called when the specified dialog is hidden/destroyed, after the fade-out
			//		animation ends, in order to reset page focus, fix the underlay, etc.
			//		If the specified dialog isn't open then does nothing.
			//
			//		Caller is responsible for either setting display:none on the dialog domNode,
			//		or calling dijit/popup.hide(), or removing it from the page DOM.

			if(ds[ds.length - 1].dialog == dialog){
				// Removing the top (or only) dialog in the stack, return focus
				// to previous dialog

				ds.pop();

				var pd = ds[ds.length - 1];	// the new active dialog (or the base page itself)

				// Adjust underlay
				if(ds.length == 1){
					// Returning to original page.  Hide the underlay.
					DialogUnderlay.hide();
				}else{
					// Popping back to previous dialog, adjust underlay.
					DialogUnderlay.show(pd.underlayAttrs, pd.zIndex - 1);
				}

				// Adjust focus.
				// TODO: regardless of setting of dialog.refocus, if the exeucte() method set focus somewhere,
				// don't shift focus back to button.  Note that execute() runs at the start of the fade-out but
				// this code runs later, at the end of the fade-out.  Menu has code like this.
				if(dialog.refocus){
					// If we are returning control to a previous dialog but for some reason
					// that dialog didn't have a focused field, set focus to first focusable item.
					// This situation could happen if two dialogs appeared at nearly the same time,
					// since a dialog doesn't set it's focus until the fade-in is finished.
					var focus = pd.focus;
					if(pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))){
						pd.dialog._getFocusItems();
						focus = pd.dialog._firstFocusItem;
					}

					if(focus){
						// Refocus the button that spawned the Dialog.   This will fail in corner cases including
						// page unload on IE, because the dijit/form/Button that launched the Dialog may get destroyed
						// before this code runs.  (#15058)
						try{
							focus.focus();
						}catch(e){
						}
					}
				}
			}else{
				// Removing a dialog out of order (#9944, #10705).
				// Don't need to mess with underlay or z-index or anything.
				var idx = array.indexOf(array.map(ds, function(elem){
					return elem.dialog;
				}), dialog);
				if(idx != -1){
					ds.splice(idx, 1);
				}
			}
		},

		isTop: function(/*dijit/_WidgetBase*/ dialog){
			// summary:
			//		Returns true if specified Dialog is the top in the task
			return ds[ds.length - 1].dialog == dialog;
		}
	};

	// Stack representing the various active "levels" on the page, starting with the
	// stuff initially visible on the page (at z-index 0), and then having an entry for
	// each Dialog shown.
	// Each element in stack has form {
	//		dialog: dialogWidget,
	//		focus: returnFromGetFocus(),
	//		underlayAttrs: attributes to set on underlay (when this widget is active)
	// }
	var ds = Dialog._dialogStack = [
		{dialog: null, focus: null, underlayAttrs: null}    // entry for stuff at z-index: 0
	];

	// If focus was accidentally removed from the dialog, such as if the user clicked a blank
	// area of the screen, or clicked the browser's address bar and then tabbed into the page,
	// then refocus.   Won't do anything if focus was removed because the Dialog was closed, or
	// because a new Dialog popped up on top of the old one, or when focus moves to popups
	focus.watch("curNode", function(attr, oldNode, node){
 		// Note: if no dialogs, ds.length==1 but ds[ds.length-1].dialog is null
		var topDialog = ds[ds.length - 1].dialog;

		// If a node was focused, and there's a Dialog currently showing, and not in the process of fading out...
		// Ignore focus events on other document though because it's likely an Editor inside of the Dialog.
		if(node && topDialog && !topDialog._fadeOutDeferred && node.ownerDocument == topDialog.ownerDocument){
			// If the node that was focused is inside the dialog or in a popup, even a context menu that isn't
			// technically a descendant of the the dialog, don't do anything.
			do{
				if(node == topDialog.domNode || domClass.contains(node, "dijitPopup")){ return; }
			}while(node = node.parentNode);

			// Otherwise, return focus to the dialog.  Use a delay to avoid confusing dijit/focus code's
			// own tracking of focus.
			topDialog.focus();
		}
	});

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/TooltipDialog"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return Dialog;
});

},
'dojo/date/locale':function(){
define([
	"../_base/lang",
	"../_base/array",
	"../date",
	/*===== "../_base/declare", =====*/
	"../cldr/supplemental",
	"../i18n",
	"../regexp",
	"../string",
	"../i18n!../cldr/nls/gregorian",
	"module"
], function(lang, array, date, /*===== declare, =====*/ supplemental, i18n, regexp, string, gregorian, module){

// module:
//		dojo/date/locale

var exports = {
	// summary:
	//		This modules defines dojo/date/locale, localization methods for Date.
};
lang.setObject(module.id.replace(/\//g, "."), exports);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.

// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
				case 'L':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = [
							"months",
							c == 'L' ? "standAlone" : "format",
							widthList[l-3]
						].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = exports._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = exports._getDayOfYear(dateObject); pad = true;
					break;
				case 'e':
				case 'c':
					var d = dateObject.getDay();
					if(l<2){
						s = (d - supplemental.getFirstDayOfWeek(options.locale) + 8) % 7
						break;
					}
					// fallthrough
				case 'E':
					d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = [
							"days",
							c == 'c' ? "standAlone" : "format",
							widthList[l-3]
						].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = dateObject.getHours() < 12 ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = exports._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = exports._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						string.pad(Math.floor(Math.abs(offset)/60), 2),
						string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = string.pad(s, l); }
			return s;
		});
	}

/*=====
var __FormatOptions = exports.__FormatOptions = declare(null, {
	// selector: String
	//		choice of 'time','date' (default: date and time)
	// formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	// datePattern:String
	//		override pattern with this string
	// timePattern:String
	//		override pattern with this string
	// am: String
	//		override strings for am in times
	// pm: String
	//		override strings for pm in times
	// locale: String
	//		override the locale used to determine formatting rules
	// fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	// strict: Boolean
	//		(parse only) strict parsing, off by default
});
=====*/

exports._getZone = function(/*Date*/ dateObject, /*boolean*/ getName, /*__FormatOptions?*/ options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


exports.format = function(/*Date*/ dateObject, /*__FormatOptions?*/ options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo/date/locale.addCustomFormats() method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = exports._getGregorianBundle(locale),
		str = [],
		sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\'/g,'').replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

exports.regexp = function(/*__FormatOptions?*/ options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return exports._parseInfo(options).regexp; // String
};

exports._parseInfo = function(/*__FormatOptions?*/ options){
	options = options || {};
	var locale = i18n.normalizeLocale(options.locale),
		bundle = exports._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

exports.parse = function(/*String*/ value, /*__FormatOptions?*/ options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo/date/locale.addCustomFormats() method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = exports._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = array.every(match, function(v, i){
		if(!i){return true;}
		var token = tokens[i-1],
			l = token.length,
			c = token.charAt(0);
		switch(c){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
						result[0] = (v < cutoff) ? century + v : century - 100 + v;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
			case 'L':
				if(l>2){
					var months = bundle['months-' +
							    (c == 'L' ? 'standAlone' : 'format') +
							    '-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = array.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = array.indexOf(months, v);
					if(v == -1){
//						console.log("dojo/date/locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
			case 'c':
				var days = bundle['days-' +
						  (c == 'c' ? 'standAlone' : 'format') +
						  '-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = array.map(days, function(d){return d.toLowerCase();});
				}
				v = array.indexOf(days, v);
				if(v == -1){
//					console.log("dojo/date/locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo/date/locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo/date/locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo/date/locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	array.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
			case 'L':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
			case 'e':
			case 'c':
				s = '.+?'; // match anything including spaces until the first pattern delimiter is found such as a comma or space
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
					s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}

var _customFormats = [];
var _cachedGregorianBundles = {};
exports.addCustomFormats = function(/*String*/ packageName, /*String*/ bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo/date/locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
	_cachedGregorianBundles = {};
};

exports._getGregorianBundle = function(/*String*/ locale){
	if(_cachedGregorianBundles[locale]){
		return _cachedGregorianBundles[locale];
	}
	var gregorian = {};
	array.forEach(_customFormats, function(desc){
		var bundle = i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = lang.mixin(gregorian, bundle);
	}, this);
	return _cachedGregorianBundles[locale] = gregorian; /*Object*/
};

exports.addCustomFormats(module.id.replace(/\/date\/locale$/, ".cldr"),"gregorian");

exports.getNames = function(/*String*/ item, /*String*/ type, /*String?*/ context, /*String?*/ locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = exports._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

exports.isWeekend = function(/*Date?*/ dateObject, /*String?*/ locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

exports._getDayOfYear = function(/*Date*/ dateObject){
	// summary:
	//		gets the day of the year as represented by dateObject
	return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

exports._getWeekOfYear = function(/*Date*/ dateObject, /*Number*/ firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((exports._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

return exports;
});

},
'curam/widget/AppBannerComboBoxMixin':function(){
define(["dijit/form/ComboBoxMixin",
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.mixin
	"dojo/text!curam/widget/templates/AppBannerDropDownBox.html"
], function(ComboBoxMixin, declare, lang, template){


	// module:
	//		curam/widget/AppBannerComboBoxMixin

	var CuramAppBannerComboBoxMixin = declare("curam.widget.AppBannerComboBoxMixin", ComboBoxMixin, {
		
		templateString: template
		
	});
	return CuramAppBannerComboBoxMixin;
});

},
'dijit/_Templated':function(){
define([
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

	// module:
	//		dijit/_Templated

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_processNode: function(baseNode, getAttrFunc){
			var ret = this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var role = getAttrFunc(baseNode, "waiRole");
			if(role){
				baseNode.setAttribute("role", role);
			}
			var values = getAttrFunc(baseNode, "waiState");
			if(values){
				array.forEach(values.split(/\s*,\s*/), function(stateValue){
					if(stateValue.indexOf('-') != -1){
						var pair = stateValue.split('-');
						baseNode.setAttribute("aria-"+pair[0], pair[1]);
					}
				});
			}

			return ret;
		}
	});
});

},
'dojo/require':function(){
define(["./_base/loader"], function(loader){
	return {
		dynamic:0,
		normalize:function(id){return id;},
		load:loader.require
	};
});

},
'curam/cdsl/store/IdentityApi':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare',
        'dojo/json'
        ],
    function(declare, json) {
  
  /**
   * @name curam.cdsl.store.IdentityApi
   * @namespace API for determining identity of objects used in CuramStore.
   * 
   * By default this class determines identity by using the "id" attribute
   * of items.
   * You can easily create subclasses and override the getIdentityAttributes()
   * function to return an array of attributes that should be used
   * for determining identity for compound keys.
   * 
   * The class can be then passed into the CuramStore constructor
   * and it will be used instead of the default implementation.
   */
  var IdentityApi = declare(null,
  /**
   * @lends curam.cdsl.store.IdentityApi.prototype
   */
  {
    /**
     * Gets identity for the specified Struct.
     * 
     * @param {curam/cdsl/Struct} item The Struct to get identity for.
     * 
     * @returns {Number|String} Identity value.
     */
    getIdentity: function(item) {
      var idProp = this.getIdentityPropertyNames()[0];
      if (typeof item[idProp] === 'object') {
        throw new Error(
  'Complex identity attributes are not supported by this implementation.');
      }
      return item[idProp];
    },
    
    /**
     * Resolve identity back into it's constituent property names and values
     * and return these in an object.
     *
     * @param identity The identity to parse.
     * @returns {Object} An object populated with properties corresponding
     *  to identity key values.
     */
    parseIdentity: function(identity) {
      var result = {};
      result[this.getIdentityPropertyNames()[0]] = identity;
      return result;
    },
    
    /**
     * Gives names of the properties used in identity determination. 
     * 
     * @returns {Array} Array of identity property names.
     */
    getIdentityPropertyNames: function() {
      return ['id'];
    }
  });
  
  return IdentityApi;
});

},
'dijit/MenuSeparator':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_Contained",
	"dojo/text!./templates/MenuSeparator.html"
], function(declare, dom, _WidgetBase, _TemplatedMixin, _Contained, template){

	// module:
	//		dijit/MenuSeparator

	return declare("dijit.MenuSeparator", [_WidgetBase, _TemplatedMixin, _Contained], {
		// summary:
		//		A line between two menu items

		templateString: template,

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});
});

},
'dijit/form/ToggleButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

	// module:
	//		dijit/form/ToggleButton


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons.

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'curam/util/Dialog':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.util.Dialog
 * @namespace Provides the ability to open arbitrary (non-UIM) content
 * in a Curam dialog.
 * 
 * It is required that the non-UIM page you are opening in a dialog resides
 * on the same Internet domain as the Curam application you are integrating
 * with.
 * <p/>
 * To open a custom page in a dialog you have to <ul>
 * <li> in the Curam application make the API call to load the custom page
 *      in a dialog </li>
 * <li> hook the custom page into the dialog API </li> </ul>
 * 
 * To hook the custom page into the dialog API, you first need to load the code,
 * preferably using <code>dojo.require("curam.util.Dialog");</code>
 * This assumes that you are using Dojo and you have access to the Curam
 * infrastructure JavaScript libraries.
 * <p/>
 * If this is not true for your pages, you will need to load the code
 * in the page header with standard <code>script</code> HTML elements.
 * The necesary script files are
 * <code>/CDEJ/jscript/curam/util/Dialog.js</code>,
 * <code>/CDEJ/jscript/curam/dialog.js</code>
 * and <code>/CDEJ/jscript/cdej.js</code>.
 * <p/>
 * The important API functions that must be called from your page are:<ul>
 * <li><code>{@link curam.util.Dialog.init}</code> in the page header.</li>
 * <li><code>{@link curam.util.Dialog.pageLoadFinished} when the page has been
 * fully loaded.</code></li></ul>
 * <p/>
 * To control the dialog size and title text you must register custom
 * functions by calling the following API in the page header:<ul>
 * <li><code>{@link curam.util.Dialog.registerGetSizeFunc}</code></li>
 * <li><code>{@link curam.util.Dialog.registerGetTitleFunc}</code></li></ul>
 * <p/>
 * Optionally you can also register custom handlers for the following events:<ul>
 * <li>AfterDisplay</li>
 * <li>BeforeClose</li></ul>
 * 
 * If linking from a dialog back into the Curam application is required,
 * this is done using the {@link curam.util.Dialog.close} function.
 */
define(["curam/util",
        "curam/define",
        "curam/dialog",
        "dojo/on",
        "curam/util/onLoad",
        "curam/debug"
        ], function(util, define, dialog, on, onLoad, debug) {

/*
 * Modification History
 * --------------------
 * 11-Oct-2019  CM  [RTC253441] Fix blank modal after IEG script on Chrome with iPad.
 * 10-Oct-2019  CM  [RTC253438] Add check for modals exiting an IEG script to use the 
 *                  onbeforeunload event, as modals exiting an IEG script weren't 
 *                  closing correctly in IE11 browsers.
 * 21-Aug-2018  BD  [RTC229425] Removed the handler to the unload event after it happen
 *                  to avoid memory leak.
 * 13-Aug-2018  SK  [RTC234604] Moved the cleanup to the unload instead
 *                  of onbeforeunload.
 * 03-Jul-2013  MV  [CR00390548] Remove IEG2 specific processing.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 03-Feb-2011  MV  [CR00253193] Add special processing in case IEG2
 *    is the client of the API - will be removed later on.
 * 03-Feb-2011  MV  [CR00250687] Notify the parent of the page unload.
 * 18-Jan-2011  MV  [CR00243263] Ensure handlers are released properly. Remove
 *    the use of alias for the window object.
 * 12-Jan-2011  PK  [CR00231655] Fixed issue with registerGetSizeFunc() not
 *                    correctly registering the specified sizing function.
 * 18-Nov-2010  MV  [CR00231655] Take dialog size into account properly.
 * 29-Sep-2010  MV  [CR00221605] Refactor to enable easy change of the context
 *      the API works on.
 */
  
/**
 * Creating Resource Bundle Object to access localized resources.
 */ 
  
 define.singleton("curam.util.Dialog",
/**
 * @lends curam.util.Dialog.prototype
 */
{  
  /**
   * Holds ID of the dialog in the current context.
   * @private
   */
  _id: null,
  
  /**
   * Holds the tokens for unsubscribing handlers on dialog close.
   * @private
   */
  _unsubscribes: [],
  
  /**
   * Boolean variable for a dialog modal with IEG script.
   * @private
   */
  _modalWithIEGScript: false,

  /**
   * Opens the specified non-UIM page in a Curam dialog.
   * 
   * @param {String} path URL path to the page to display in the dialog, without
   *              the query string.
   * @param {Object} pageParameters An object containing the required page
   *      parameters, or null if no page parameters are required.
   *      The following format is expected:
   *                        <code>{ param1Name:"value", param2Name:248 }</code>
   *      The infrastructure handles URL-encoding the values so do NOT encode
   *      them yourself.
   * @param {Object} [dialogSize] An object representing the required size
   *    of the dialog in pixels. The following form is required:
   *        <code>{ width:500, height:300 }</code> If size is not specified
   *      the default size will be used instead.
   */
  open: function(path, pageParameters, dialogSize) {
    var url = path + curam.util.makeQueryString(pageParameters);
    var anchor = { href: url };
    var windowOptions = null;
    if (dialogSize) {
      windowOptions = "width=" + dialogSize.width
          + ",height=" + dialogSize.height;
    }
    window.jsModals = true;
    curam.util.openModalDialog(anchor, windowOptions);
  },
    
  /**
   * Initializes the dialog infrastructure.
   *
   * Must be called in the header of the page loaded in the dialog.
   */
  init: function() {
    // receive the dialogId for the current context
    var topWin = curam.util.getTopmostWindow();
    var unsToken = topWin.dojo.subscribe("/curam/dialog/SetId", null,
        function(dialogId) {
          curam.util.Dialog._id = dialogId;
          
          curam.debug.log(debug.getProperty("curam.util.Dialog.id.success"), 
            curam.util.Dialog._id);

          topWin.dojo.unsubscribe(unsToken);
        });
    curam.util.Dialog._unsubscribes.push(unsToken);
    
    // publish the init event
    // this also triggers the /curam/dialog/SetId event
    // to get the ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!curam.util.Dialog._id) {
      curam.debug.log(debug.getProperty("curam.util.Dialog.id.fail"));
    }

    if (curam.util.Dialog._modalWithIEGScript) {
        dojo.addOnUnload(function() {

        // ensure any event handlers are released on page unload
        curam.util.Dialog._releaseHandlers();

        // notify interested parties of the iframe unload
        window.parent.dojo.publish(
          "/curam/dialog/iframeUnloaded", [ curam.util.Dialog._id, window ]);
        });

      } else {
        var signal = on(window, 'unload', function() {
          signal.remove();	
          // ensure any event handlers are released on page unload
          curam.util.Dialog._releaseHandlers();

          // notify interested parties of the iframe unload
          window.parent.dojo.publish(
            "/curam/dialog/iframeUnloaded", [ curam.util.Dialog._id, window ]);
        });
    }
    
  },
  
  /**
   * Initializes the dialog infrastructure for an IEG script on a dialog.
   * Must be called in the header of the page loaded in the dialog. This
   * calls the onbeforeunload, because IE 11 and Edge browsers cannot
   * handle the onunload call correctly. See RTC251740
   * 
   */
  initModalWithIEGScript: function() {

    curam.util.Dialog._modalWithIEGScript = true;

    curam.util.Dialog.init();
  },
  
  /**
   * Registers a custom function to get the dialog title text.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getTitle A function that returns the text to be displayed
   *                  in the dialog title bar.
   */
  registerGetTitleFunc: function(getTitle) {
    curam.util.onLoad.addPublisher(function(context) {
      context.title = getTitle();
    });
  },
  
  /**
   * Registers a custom function to get the dialog size.
   *
   * Can be optioanally called in the header of the page loaded in the dialog.
   * 
   * @param {Function} getSize A function that returns an object
   *      in the following form: <code>{ width:500, height:300 }</code>
   */
  registerGetSizeFunc: function(getSize) {
    curam.util.onLoad.addPublisher(function(context) {
      context.windowOptions = getSize();
    });
  },
  
  /**
   * Registers a custom function that will be called after the dialog appears
   * on the screen.
   * 
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the AfterDisplay event.
   */
  registerAfterDisplayHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/AfterDisplay", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Registers a custom function that will be called before the dialog
   * is closed.
   *
   * Must be called in the header of the page loaded in the dialog.
   * 
   * @param {Function} handler The handler function for the BeforeClose event.
   */
  registerBeforeCloseHandler: function(handler) {
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsubscribes.push(topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId === curam.util.Dialog._id) {
            handler();
          }
        }));
  },
  
  /**
   * Notifies the dialog infrastructure that the page has been fully loaded.
   *
   * Must be called by the page after it finishes loading in the dialog.
   * (E.g. dojo.addOnLoad(curam.Dialog.pageLoadFinished))
   */
  pageLoadFinished: function() {
    // ensure the handlers are unregistered on dialog close
    var topWin = curam.util.getTopmostWindow();
    curam.util.Dialog._unsTokenReleaseHandlers = topWin.dojo.subscribe(
        "/curam/dialog/BeforeClose", null, function(dialogId) {
          if (dialogId == curam.util.Dialog._id) {
            curam.util.Dialog._releaseHandlers(topWin);
          }
        });
     
    // invoke the onLoad API 
    curam.util.onLoad.execute();
  },
  
  /**
   * Releases any registered handlers.
   * @param {Object} topWindow. The top most window.
   * @private
   */
  _releaseHandlers: function(topWindow) {
	
    var topWin;
    
    if (topWindow) {
      topWin = topWindow;
    } else {
      topWin = curam.util.getTopmostWindow();
    }

    dojo.forEach(curam.util.Dialog._unsubscribes, topWin.dojo.unsubscribe);
    curam.util.Dialog._unsubscribes = [];
    
    topWin.dojo.unsubscribe(curam.util.Dialog._unsTokenReleaseHandlers);
    curam.util.Dialog._unsTokenReleaseHandlers = null;
  },
  
  /**
   * Closes the dialog, optionally refreshing or redirecting the parent window.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Boolean} [refreshParent=false] Should the parent be refreshed
   *              when this dialog closes?
   * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
   *      should be redirected to when this dialog closes. Alternatively
   *      a full URL including the page parameters can be passed.
   * @param {Object} [pageParameters] Page parameters to be used when
   *        redirecting the parent to the new page. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        The infrastructure handles URL-encoding the values so do NOT encode
   *        them yourself.
   *        If full URL is specified then the pageParameters are ignored.
   */
  close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
      /*optional*/ pageParameters) {
    
    var parentWindow = curam.dialog.getParentWindow(window);
    
    // Dialog._id may be lost on iPad - recover from frame ID
    if (typeof(curam.util.Dialog._id) === "undefined" || curam.util.Dialog._id == null) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.util.Dialog._id = modalID;
      
      debug.log("curam.util.Dialog.closeAndSubmitParent() " 
          + debug.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    if (refreshParent && !newPageIdOrFullUrl) {
      curam.dialog.forceParentRefresh();
      parentWindow.curam.util.redirectWindow(null);
      
    } else if (newPageIdOrFullUrl) {
      var newParentUrl = newPageIdOrFullUrl;
      // distinguish between pageId and full URL
      if (newPageIdOrFullUrl.indexOf("Page.do") == -1 && newPageIdOrFullUrl.indexOf("Action.do") == -1) {
        newParentUrl = newPageIdOrFullUrl + "Page.do"
            + curam.util.makeQueryString(pageParameters);
      }

      parentWindow.curam.util.redirectWindow(newParentUrl);
    }

    var topWin = curam.util.getTopmostWindow();
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  },
  
  /**
   * Closes the dialog and submit the parent page, where the form parameters
   * will be optionally passed to. This method is design for the senario where
   * the parent page has an <code>ACTION</code> phase.
   * 
   * Must be called in the context of the page loaded in the dialog. I.e.
   * you cannot close a dialog from an "outside" context.
   * 
   * @param {Object} [formParameters] Form parameters to be used in the form of
   *        the parent page when it is being submitted. The following format
   *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
   *        Those parameters should not be encoded. The parameter name should be
   *        the order of the input fields in the form, e.g. '1' means the first
   *        input field in the form.
   */
  closeAndSubmitParent: function(/*optional*/ formParameters) {
    var parentWindow = curam.dialog.getParentWindow(window);
    // Get the form of the parent page.
    var parentWindowForm = parentWindow.document.forms["mainForm"];
    var topWin = curam.util.getTopmostWindow();
    
    // Dialog._id may be lost on iPad - recover from frame ID
    if (typeof(curam.util.Dialog._id) === "undefined" || curam.util.Dialog._id == null) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.util.Dialog._id = modalID;
      
      debug.log("curam.util.Dialog.closeAndSubmitParent() " 
          + debug.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    // Check if the from in the parent window exists or not. If not, simply 
    // close the modal and return. The parent page will not be submitted.
    if (parentWindowForm == null || parentWindowForm == undefined) {
      //Close the modal
      topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
      return;
    }
        
    // Define the function used to check if the "formParameters" object is
    // empty or not.
    var isEmpty = function (object) {
      for (var property in object) {
        if (object.hasOwnProperty(property)) {
          return false;
        }
      }
      return true;
    };

    
    // Set the from parameters to the corresponding input fields 
    // in the form of the parent page that will be submitted.
    if (formParameters && !isEmpty(formParameters)) {
      // Reset and assign new form parameters to the input fields
      var inputFieldListUnfiltered = dojo.query("#" + parentWindowForm.id + " > " +
      "input[type=text]");
	 
      var inputFieldList = dojo.filter(inputFieldListUnfiltered, function(node){
        return node.readOnly == false;
      });
	  
      dojo.forEach(inputFieldList, function(node) {
          node.value = "";
      });
    
      for (var fieldName in formParameters) {
        var inputField = inputFieldList[parseInt(fieldName)];
        
        if (inputField) {
          var hiddenInputForDropDown = dojo.query(
                   "input[name=" + inputField.id + "]", parentWindowForm)[0];
            if (hiddenInputForDropDown) {
              hiddenInputForDropDown.value = formParameters[fieldName];
            } else {
              inputField.value = formParameters[fieldName];
            }
        
        }
      }
    } else {
      // Do nothing. No form paramters are passed down. Keep the existing string
      // in the from input fields.
    }
	
    //Submit the parent page.
    parentWindow.dojo.publish("/curam/page/refresh");
    parentWindowForm.submit();
    
    //Close the modal
    topWin.dojo.publish("/curam/dialog/close", [ curam.util.Dialog._id ]);
  },

  /**
   * Opens a modal window with confirm/cancel options for the current file
   * download.
   * <p>
   * The modal informs the user that the file they are about to download
   * contains sensitive personal information and warns them to clear their
   * browser cache afterwards if using a public computer. It then lists
   * instructions on how to clear the cache for their specific browser.
   * <p>
   * This method should be returned by the onclick function of a link when
   * that link is being rendered.
   * <p>
   * Example Java Renderer code:
   * <pre>
   * anchor.setAttribute("onclick",
   *     "return curam.util.Dialog.fileDownloadAnchorHandler('" + url
   *         + "');");
   * </pre>
   * The messages displayed to the user can be overridden using a copy of
   * the <code>GenericModalError.js.properties</code> file.
   *
   * @param {String} url The URL to be accessed when the user confirms
   *        that they want to download the file.
   */
  fileDownloadAnchorHandler: function(url) {
    // This method is just a wrapper to publicly expose
    // curam.util.fileDownloadAnchorHandler(url)
    return curam.util.fileDownloadAnchorHandler(url);
  }

  });
  
});
},
'dijit/CheckedMenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"./MenuItem",
	"dojo/text!./templates/CheckedMenuItem.html",
	"./hccss"
], function(declare, domClass, MenuItem, template){

	// module:
	//		dijit/CheckedMenuItem

	return declare("dijit.CheckedMenuItem", MenuItem, {
		// summary:
		//		A checkbox-like menu item for toggling on and off

		// Use both base classes so we get styles like dijitMenuItemDisabled
		baseClass: "dijitMenuItem dijitCheckedMenuItem",

		templateString: template,

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			this.domNode.setAttribute("aria-checked", checked ? "true" : "false");
			this._set("checked", checked);	// triggers CSS update via _CssStateMixin
		},

		iconClass: "",	// override dijitNoIcon

		role: "menuitemcheckbox",

		// checkedChar: String
		//		Character (or string) used in place of checkbox icon when display in high contrast mode
		checkedChar: "&#10003;",

		onChange: function(/*Boolean*/ /*===== checked =====*/){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(evt){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.onClick(evt);
		}
	});
});

},
'dojox/html/_base':function(){
define([
	"dojo/_base/declare",
	"dojo/Deferred",
	"dojo/dom-construct",
	"dojo/html",
	"dojo/_base/kernel",
	"dojo/_base/lang",
	"dojo/ready",
	"dojo/_base/sniff",
	"dojo/_base/url",
	"dojo/_base/xhr",
	"dojo/when",
	"dojo/_base/window"
], function(declare, Deferred, domConstruct, htmlUtil, kernel, lang, ready, has, _Url, xhrUtil, when, windowUtil){

/*
	Status: don't know where this will all live exactly
	Need to pull in the implementation of the various helper methods
	Some can be static method, others maybe methods of the ContentSetter (?)

	Gut the ContentPane, replace its _setContent with our own call to dojox.html.set()


*/
	var html = kernel.getObject("dojox.html", true);

	if(has("ie")){
		var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
	}

	// css at-rules must be set before any css declarations according to CSS spec
	// match:
	// @import 'http://dojotoolkit.org/dojo.css';
	// @import 'you/never/thought/' print;
	// @import url("it/would/work") tv, screen;
	// @import url(/did/you/now.css);
	// but not:
	// @namespace dojo "http://dojotoolkit.org/dojo.css"; /* namespace URL should always be a absolute URI */
	// @charset 'utf-8';
	// @media print{ #menuRoot {display:none;} }

	// we adjust all paths that dont start on '/' or contains ':'
	//(?![a-z]+:|\/)

	var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;

	var adjustCssPaths = html._adjustCssPaths = function(cssUrl, cssText){
		// summary:
		//		adjusts relative paths in cssText to be relative to cssUrl
		//		a path is considered relative if it doesn't start with '/' and not contains ':'
		// description:
		//		Say we fetch a HTML page from level1/page.html
		//		It has some inline CSS:
		//	|		@import "css/page.css" tv, screen;
		//	|		...
		//	|		background-image: url(images/aplhaimage.png);
		//
		//		as we fetched this HTML and therefore this CSS
		//		from level1/page.html, these paths needs to be adjusted to:
		//	|		@import 'level1/css/page.css' tv, screen;
		//	|		...
		//	|		background-image: url(level1/images/alphaimage.png);
		//
		//		In IE it will also adjust relative paths in AlphaImageLoader()
		//	|		filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
		//		will be adjusted to:
		//	|		filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
		//
		//		Please note that any relative paths in AlphaImageLoader in external css files wont work, as
		//		the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
		//		not relative to the CSS file that declares it

		if(!cssText || !cssUrl){ return; }

		// support the ImageAlphaFilter if it exists, most people use it in IE 6 for transparent PNGs
		// We are NOT going to kill it in IE 7 just because the PNGs work there. Somebody might have
		// other uses for it.
		// If user want to disable css filter in IE6  he/she should
		// unset filter in a declaration that just IE 6 doesn't understands
		// like * > .myselector { filter:none; }
		if(alphaImageLoader){
			cssText = cssText.replace(alphaImageLoader, function(ignore, pre, delim, url, post){
				return pre + (new _Url(cssUrl, './'+url).toString()) + post;
			});
		}

		return cssText.replace(cssPaths, function(ignore, delimStr, strUrl, delimUrl, urlUrl, media){
			if(strUrl){
				return '@import "' + (new _Url(cssUrl, './'+strUrl).toString()) + '"' + media;
			}else{
				return 'url(' + (new _Url(cssUrl, './'+urlUrl).toString()) + ')' + media;
			}
		});
	};

	// attributepaths one tag can have multiple paths, example:
	// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
	// <img style='filter:progid...AlphaImageLoader(src="noticeTheSrcHereRunsThroughHtmlSrc")' src="img">
	var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;

	var adjustHtmlPaths = html._adjustHtmlPaths = function(htmlUrl, cont){
		var url = htmlUrl || "./";

		return cont.replace(htmlAttrPaths,
			function(tag, start, name, delim, relUrl, delim2, cssText, end){
				return start + (name ?
							(name + '=' + delim + (new _Url(url, relUrl).toString()) + delim)
						: ('style=' + delim2 + adjustCssPaths(url, cssText) + delim2)
				) + end;
			}
		);
	};

	var snarfStyles = html._snarfStyles = function	(/*String*/cssUrl, /*String*/cont, /*Array*/styles){
		/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
		// also return any attributes from this tag (might be a media attribute)
		// if cssUrl is set it will adjust paths accordingly
		styles.attributes = [];

		cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)style\b/ig,"&lt;$1Style").replace(/<(\/?)link\b/ig,"&lt;$1Link").replace(/@import "/ig,"@ import \"");
			}
		);
		return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi,
			function(ignore, styleAttr, cssText, linkAttr, delim, href){
				// trim attribute
				var i, attr = (styleAttr||linkAttr||"").replace(/^\s*([\s\S]*?)\s*$/i, "$1");
				if(cssText){
					i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
				}else{
					i = styles.push('@import "' + href + '";');
					attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, ""); // remove rel=... and href=...
				}
				if(attr){
					attr = attr.split(/\s+/);// split on both "\n", "\t", " " etc
					var atObj = {}, tmp;
					for(var j = 0, e = attr.length; j < e; j++){
						tmp = attr[j].split('='); // split name='value'
						atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1"); // trim and remove ''
					}
					styles.attributes[i - 1] = atObj;
				}
				return "";
			}
		);
	};

	var snarfScripts = html._snarfScripts = function(cont, byRef){
		// summary:
		//		strips out script tags from cont
		// byRef:
		//		byRef = {errBack:function(){/*add your download error code here*/, downloadRemote: true(default false)}}
		//		byRef will have {code: 'jscode'} when this scope leaves
		byRef.code = "";

		//Update script tags nested in comments so that the script tag collector doesn't pick
		//them up.
		cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)script\b/ig,"&lt;$1Script");
			}
		);

		function download(src){
			if(byRef.downloadRemote){
				// console.debug('downloading',src);
				//Fix up src, in case there were entity character encodings in it.
				//Probably only need to worry about a subset.
				src = src.replace(/&([a-z0-9#]+);/g, function(m, name) {
					switch(name) {
						case "amp"	: return "&";
						case "gt"	: return ">";
						case "lt"	: return "<";
						default:
							return name.charAt(0)=="#" ? String.fromCharCode(name.substring(1)) : "&"+name+";";
					}
				});
				xhrUtil.get({
					url: src,
					sync: true,
					load: function(code){
						if(byRef.code !=="") {
						   code = "\n" + code;
						}
						byRef.code += code+";";
					},
					error: byRef.errBack
				});
			}
		}

		// match <script>, <script type="text/..., but not <script type="dojo(/method)...
		return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?>([\s\S]*?)<\/script>/gi,
			function(ignore, delim, src, code){
				if(src){
					download(src);
				}else{
					if(byRef.code !=="") {
					   code = "\n" + code;
					}
					byRef.code += code+";";
				}
				return "";
			}
		);
	};

	var evalInGlobal = html.evalInGlobal = function(code, appendNode){
		// we do our own eval here as dojo.eval doesn't eval in global crossbrowser
		// This work X browser but but it relies on a DOM
		// plus it doesn't return anything, thats unrelevant here but not for dojo core
		appendNode = appendNode || windowUtil.doc.body;
		var n = appendNode.ownerDocument.createElement('script');
		n.type = "text/javascript";
		appendNode.appendChild(n);
		n.text = code; // DOM 1 says this should work
	};

	html._ContentSetter = declare(/*===== "dojox.html._ContentSetter", =====*/ htmlUtil._ContentSetter, {
		// adjustPaths: Boolean
		//		Adjust relative paths in html string content to point to this page
		//		Only useful if you grab content from a another folder than the current one
		adjustPaths: false,
		referencePath: ".",
		renderStyles: false,

		executeScripts: false,
		scriptHasHooks: false,
		scriptHookReplacement: null,

		_renderStyles: function(styles){
			// insert css from content into document head
			this._styleNodes = [];
			var st, att, cssText, doc = this.node.ownerDocument;
			var head = doc.getElementsByTagName('head')[0];

			for(var i = 0, e = styles.length; i < e; i++){
				cssText = styles[i]; att = styles.attributes[i];
				st = doc.createElement('style');
				st.setAttribute("type", "text/css"); // this is required in CSS spec!

				for(var x in att){
					st.setAttribute(x, att[x]);
				}

				this._styleNodes.push(st);
				head.appendChild(st); // must insert into DOM before setting cssText

				if(st.styleSheet){ // IE
					st.styleSheet.cssText = cssText;
				}else{ // w3c
					st.appendChild(doc.createTextNode(cssText));
				}
			}
		},

		empty: function() {
			this.inherited("empty", arguments);

			// empty out the styles array from any previous use
			this._styles = [];
		},

		onBegin: function() {
			// summary:
			//		Called after instantiation, but before set();
			//		It allows modification of any of the object properties - including the node and content
			//		provided - before the set operation actually takes place
			//		This implementation extends that of dojo.html._ContentSetter
			//		to add handling for adjustPaths, renderStyles on the html string content before it is set
			this.inherited("onBegin", arguments);

			var cont = this.content,
				node = this.node;

			var styles = this._styles;// init vars

			if(lang.isString(cont)){
				if(this.adjustPaths && this.referencePath){
					cont = adjustHtmlPaths(this.referencePath, cont);
				}

				if(this.renderStyles || this.cleanContent){
					cont = snarfStyles(this.referencePath, cont, styles);
				}

				// because of a bug in IE, script tags that is first in html hierarchy doesnt make it into the DOM
				//	when content is innerHTML'ed, so we can't use dojo.query to retrieve scripts from DOM
				if(this.executeScripts){
					var _t = this;
					var byRef = {
						downloadRemote: true,
						errBack:function(e){
							_t._onError.call(_t, 'Exec', 'Error downloading remote script in "'+_t.id+'"', e);
						}
					};
					cont = snarfScripts(cont, byRef);
					this._code = byRef.code;
				}
			}
			this.content = cont;
		},

		onEnd: function() {
			// summary:
			//		Called after set(), when the new content has been pushed into the node
			//		It provides an opportunity for post-processing before handing back the node to the caller
			//		This implementation extends that of dojo.html._ContentSetter

			var code = this._code,
				styles = this._styles;

			// clear old stylenodes from the DOM
			// these were added by the last set call
			// (in other words, if you dont keep and reuse the ContentSetter for a particular node
			// .. you'll have no practical way to do this)
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					domConstruct.destroy(this._styleNodes.pop());
				}
			}
			// render new style nodes
			if(this.renderStyles && styles && styles.length){
				this._renderStyles(styles);
			}

			// Deferred to signal when this function is complete
			var d = new Deferred();

			// Setup function to call onEnd() in the superclass, for parsing, and resolve the above Deferred when
			// parsing is complete.
			var superClassOnEndMethod = this.getInherited(arguments),
				args = arguments,
				callSuperclass = lang.hitch(this, function(){
					superClassOnEndMethod.apply(this, args);

					// If parser ran (parseContent == true), wait for it to finish, otherwise call d.resolve() immediately
					when(this.parseDeferred, function(){ d.resolve(); });
				});

			if(this.executeScripts && code){
				// Evaluate any <script> blocks in the content
				if(this.cleanContent){
					// clean JS from html comments and other crap that browser
					// parser takes care of in a normal page load
					code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, '');
				}
				if(this.scriptHasHooks){
					// replace _container_ with this.scriptHookReplace()
					// the scriptHookReplacement can be a string
					// or a function, which when invoked returns the string you want to substitute in
					code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
				}
				try{
					evalInGlobal(code, this.node);
				}catch(e){
					this._onError('Exec', 'Error eval script in '+this.id+', '+e.message, e);
				}

				// Finally, use ready() to wait for any require() calls from the <script> blocks to complete,
				// then call onEnd() in the superclass, for parsing, and when that is done resolve the Deferred.
				// For 2.0, remove the call to ready() (or this whole if() branch?) since the parser can do loading for us.
				ready(callSuperclass);
			}else{
				// There were no <script>'s to execute, so immediately call onEnd() in the superclass, and
				// when the parser finishes running, resolve the Deferred.
				callSuperclass();
			}

			// Return a promise that resolves after the ready() call completes, and after the parser finishes running.
			return d.promise;
		},

		tearDown: function() {
			this.inherited(arguments);
			delete this._styles;
			// only tear down -or another set() - will explicitly throw away the
			// references to the style nodes we added
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					domConstruct.destroy(this._styleNodes.pop());
				}
			}
			delete this._styleNodes;
			// reset the defaults from the prototype
			// XXX: not sure if this is the correct intended behaviour, it was originally
			// dojo.getObject(this.declaredClass).prototype which will not work with anonymous
			// modules
			lang.mixin(this, html._ContentSetter.prototype);
		}

	});

	html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
		// TODO: add all the other options
			// summary:
			//		inserts (replaces) the given content into the given node
			// node:
			//		the parent element that will receive the content
			// cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
			// params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			// example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//	|	dojo.html.set(node, "some string");
			//	|	dojo.html.set(node, contentNode, {options});
			//	|	dojo.html.set(node, myNode.childNodes, {options});

		if(!params){
			// simple and fast
			return htmlUtil._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			var op = new html._ContentSetter(lang.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};

	return html;
});

},
'curam/widget/_HasDropDown':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 14-May-2019  JD  [RTC242058]  Initial version.
   */

define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"dijit/registry", // registry.byNode()
	"dijit/focus",
	"dijit/popup",
	"dijit/_FocusMixin",
	"dijit/a11y",
	"dijit/_HasDropDown",
	"curam/util"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focusUtil, popup, _FocusMixin, a11y){


	// module:
	//		dijit/_HasDropDown

	return declare("curam.widget._HasDropDown", [dijit._HasDropDown], {
		
		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				
				// CURAM-FIX: Added evt object as parameter
				onCancel: function(evt){
					self.closeDropDown(evt, true);
				},
				// END CURAM-FIX:
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				this._origStyle = ddNode.style.cssText;
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		/* CURAM-FIX: overriding default dojo focus behaviour*/
		closeDropDown: function(/*Event*/ evt, /*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected
			

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					
					// Look for the next node to focus on
					var nodeToFocusOn = this._getNextFocusableNode(
							evt, this.ownerDocument, this.focusNode);
					
					// If the next node to focus on is found, focus on that.
					// Otherwise, focus on the focusNode of the widget.
					if(nodeToFocusOn.focus){
						nodeToFocusOn.focus();
					} else {
						this.focus();
					}
				
				}
				popup.close(this.dropDown);
				this._opened = false;
			}
			
			if(this._origStyle){
				this.dropDown.domNode.style.cssText = this._origStyle;
				delete this._origStyle;
			}
		},
		
		// Find the next or previous focusable node depending on whether TAB or SHIFT-TAB was pressed.
		// If one is not found, the current focused node is returned.
		_getNextFocusableNode: function(evt, document, currentFocusableNode) {
			
			var nodeToFocusOn = currentFocusableNode;
			var topWindow = curam.util.getTopmostWindow();
			
			// If the TAB key is pressed.
			if(evt && evt.keyCode == keys.TAB){

				// Get all the focusable elements in the current document
				var focusable = this._findFocusableElementsInDocument(document);
				var focusableLength = focusable.length;
				// Get the index of the current focused node.
				var indexOfNode = focusable.indexOf(currentFocusableNode);
								
				if(indexOfNode > -1){
					
					  // If the SHIFT button was not clicked
					  if(!evt.shiftKey){
						  
						  indexOfNode++;
						  var nextNode = null;
						  for(var i = indexOfNode; i < focusable.length; i++){
							  // If the node is not hidden by a parent element and is not a dijitMenuItem
							  if(focusable[i].offsetParent !== null && !domClass.contains(focusable[i], "dijitMenuItem")){
								  nextNode = focusable[i];
								  break;
							  }
						  }
						  
						  if(nextNode && nextNode.nodeName.toLowerCase() !== "iframe") {
							  
							  nodeToFocusOn = nextNode;
						  } else if(nextNode && nextNode.nodeName.toLowerCase() === "iframe"){
							  
							  // Find the focusable node in the iframe. Returns null if no node is found.
							  nextNode = this._findFocusableElementInIframe(nextNode, evt.shiftKey);
							  
							  // The node to focus on has been found.
							  if(nextNode) {
								  nodeToFocusOn = nextNode;
							  }
						  } else if(this.ownerDocument !== topWindow.document){
							  
							  // It's possible the widget is the last focusable element within
							  // a nested iframe. In this case, the focus should move to the next
							  // focusable element in the parent window.
							  var currentDocument = this.ownerDocument;
							  while(currentDocument !== topWindow.document && !nextNode){
								  
								  // Get parent document and check for focusable element there!
								  // If not found, check to see if there is another parent window
								  // and retrieve it's document, then repeat.
								  var parentWindow = window.parent;
								  var parentDocument = parentWindow.document || parentWindow.contentDocument || parentWindow.contentWindow.document;
								  nextNode = this._findFocusableElementInParentDocument(parentDocument, evt.shiftKey);
								  currentDocument = parentDocument;
							  }
							  
							  if(nextNode){
								  // The node to focus on has been found.
								  nodeToFocusOn = nextNode;
							  }
						  }
						  
					  } else {
						  
						  // If SHIFT-TAB was pressed
						  indexOfNode--;
						  var previousNode = null;
						  for(var i = indexOfNode; i > -1; i--){
							  // If the node is not hidden by a parent element.
							  if(focusable[i].offsetParent !== null){
								  previousNode = focusable[i];
								  break;
							  }
						  }
						  
						  if(previousNode && previousNode.nodeName.toLowerCase() !== "iframe") {
							  
							  nodeToFocusOn = previousNode;
						  } else if(previousNode && previousNode.nodeName.toLowerCase() === "iframe"){
							  
							  // Find the focusable node in the iframe. Returns null if no node is found.
							  previousNode = this._findFocusableElementInIframe(previousNode, evt.shiftKey);
							  
							  // The node to focus on has been found.
							  if(previousNode) {
								  nodeToFocusOn = previousNode;
							  }
						  } else if(this.ownerDocument !== topWindow.document){
							  
							  // It's possible the widget is the first focusable element within
							  // a nested iframe. In this case, the focus should move to the previous
							  // focusable element in the parent window.
							  var currentDocument = this.ownerDocument;
							  while(currentDocument !== topWindow.document && !previousNode){
								  
								  // Get parent document and check for focusable element there!
								  // If not found, check to see if there is another parent window
								  // and retrieve it's document, then repeat.
								  var parentWindow = window.parent;
								  var parentDocument = parentWindow.document || parentWindow.contentDocument || parentWindow.contentWindow.document;
								  previousNode = this._findFocusableElementInParentDocument(parentDocument, evt.shiftKey);
								  currentDocument = parentDocument;
							  }
							  
							  if(previousNode){
								  // The node to focus on has been found.
								  nodeToFocusOn = previousNode;
							  }
							  
						  }
						  
					  }
				}
				
			}
			
			// Either the next/previous focusable node or the current focusable node.
			return nodeToFocusOn;
			
		},
		
		// Finds all focusable elements in a given document.
		_findFocusableElementsInDocument: function(document) {
			
			// This finds any native focusable elements, with the exception
			// of buttons with the class dijitTabCloseButton as well as anything
			// that has a tabIndex greater than -1.
			var focusableDomElements = document.querySelectorAll(
					'button:not(.dijitTabCloseButton), [href], input, select, object, iframe, area, textarea, [tabindex]:not([tabindex="-1"])');
			var focusable = [];

			for(var i = 0; i < focusableDomElements.length; i++){
				// If the element itself is shown and is a native tabbable
				// element or has a tabIndex greater than -1, add it to the array.
				if(a11y._isElementShown(focusableDomElements[i])) {
					if(a11y.isTabNavigable(focusableDomElements[i])){
						focusable.push(focusableDomElements[i]);
					} else if(focusableDomElements[i].nodeName.toLowerCase() === "iframe"){
						// If the element is an iframe add it to the array regardless as the nested
						// elements could be focusable.
						focusable.push(focusableDomElements[i]);
					}
				}
				
			}
			
			return focusable;
		},
		
		// Find a focusable element in the document of the parent window.
		// The element selected will depend on whether the SHIFT key was pressed.
		_findFocusableElementInParentDocument: function(document, shiftKeyPressed){
		  
		  var parentFocusable = this._findFocusableElementsInDocument(document);
		  var currentIframeFound = false;
		  var indexOfIframe = 0;
		  var focusNode = null;

		  if(!shiftKeyPressed) {
			  for(var i = 0; i < parentFocusable.length; i++){
			    
			    // Looking to find the index of the current iframe
			    if(parentFocusable[i].nodeName.toLowerCase() === "iframe"){
			      if(parentFocusable[i].contentDocument === this.ownerDocument){
			        currentIframeFound = true;
			        indexOfIframe = i;
			        break;
			      }
			    }
	
			  }
		  } else {
			  for(var i = parentFocusable.length - 1; i > -1; i--){
			    
			    // Looking to find the index of the current iframe
			    if(parentFocusable[i].nodeName.toLowerCase() === "iframe"){
			      if(parentFocusable[i].contentDocument === this.ownerDocument){
			        currentIframeFound = true;
			        indexOfIframe = i;
			        break;
			      }
			    }
	
			  }
		  }
		  
		  if(currentIframeFound){

		    // Find the next focusable element that occurrs after
		    // the current iframe.
		    if(!shiftKeyPressed) {
			    indexOfIframe++;
			    for(var i = indexOfIframe; i < parentFocusable.length; i++){
			      if(parentFocusable[i].offsetParent !== null){
			        focusNode = parentFocusable[i];
			        break;
			      }
			    }
			  } else {
			    // Find the previous focusable element that occurred before
			    // the current iframe.
			    indexOfIframe--;
			    for(var i = indexOfIframe; i > -1; i--){
			      if(parentFocusable[i].offsetParent !== null){
			        focusNode = parentFocusable[i];
			        break;
			      }
			    }
			}
		    
		    // If the element found is another iframe, look for a focusable element in here.
		    if(focusNode && focusNode.nodeName.toLowerCase() === "iframe"){
		      focusNode = this._findFocusableElementInIframe(focusNode, shiftKeyPressed);
		    }
		    
		  }
		  
		  return focusNode;
		   
		  
		},
		
		// Finds a focusable element within a given iframe. If the supplied node is not
		// an iframe, it just returns that node. If the supplied node is an iframe,
		// but no focusable elements are found, null is returned.
		_findFocusableElementInIframe: function(node, shiftKeyPressed){
			
			var iframeNode = node;
			
			while(iframeNode && iframeNode.nodeName.toLowerCase() === "iframe"){
				  
			  // Get the iframe document and find the focusable elements within.
			  var iframeDoc = iframeNode.contentDocument || iframeNode.contentWindow.document;
			  var iframeFocusable = this._findFocusableElementsInDocument(iframeDoc);
			  if(iframeFocusable.length > 0){

			  if(!shiftKeyPressed){
				  
				  // If the next node is an iframe element, we want to focus on the
				  // first focusbale element within the iframe.
				  // If the first focusable element is a another iframe, then find the
				  // first focusbable element within that.
			      indexOfNode = 0;
				  // Navigate forwards through the iframe elements.
			      for(var i = indexOfNode; i < iframeFocusable.length; i++){
			        // If the node is not hidden by a parent element.
			        if(iframeFocusable[i].offsetParent !== null){
			          iframeNode = iframeFocusable[i];
			          break;
			        }
			      }
			    } else {
				  // If the previous node is an iframe element, we want to focus on the
				  // last focusbale element within the iframe.
				  // If the last focusable element is a another iframe, then find the
				  // last focusbable element within that.
			    	
			      indexOfNode = iframeFocusable.length - 1;
			      // Work backwards through the iframes elements.
			      for(var i = indexOfNode; i > -1; i--){
			        // If the element is not hidden by a parent element.
			        if(iframeFocusable[i].offsetParent !== null){
			          iframeNode = iframeFocusable[i];
			          break;
			        }
			      }
			    }
			  } else {
			    // Need to cater for empty iframes. This prevents infinite loop.
			    iframeNode = null;
			  }
			  
			}
			
			return iframeNode;
			
		}
		/* END CURAM-FIX */
		
	});
});

},
'dijit/_DialogMixin':function(){
define([
	"dojo/_base/declare", // declare
	"./a11y"	// _getTabNavigable
], function(declare, a11y){

	// module:
	//		dijit/_DialogMixin

	return declare("dijit._DialogMixin", null, {
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		// actionBarTemplate: String
		//		HTML snippet to show the action bar (gray bar with OK/cancel buttons).
		//		Blank by default, but used by ConfirmDialog/ConfirmTooltipDialog subclasses.
		actionBarTemplate: "",

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//		Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//		Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//		Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit/form/DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = a11y._getTabNavigable(this.domNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	});
});

},
'curam/widget/FilteringSelect':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2021. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * Override of the Dojo FilteringSelect in order to get it to display
 * items in the drop down when the associated value is the empty string.
 * 
 */
define(["dijit/registry",
        "dojo/_base/declare",
        "dojo/on", 
        "dojo/dom",
        "dojo/dom-construct",
        "dojo/keys",
        "dojo/sniff",
        "dijit/form/FilteringSelect",
        "curam/widget/ComboBoxMixin"
        ], function(registry, declare, on, dom, domConstruct, keys, has) {
  
  /*
   * Modification History
   * --------------------
   * 28-Jan-2021  JD  [RTC265372] Update startup() so only role=listbox is added
   *                  for IE. Edge Chromium requires it to be combobox for JAWs
   *                  to announce it correctly and for it to be interactive.
   * 16-Dec-2019  SH  [RTC252278] Add missing dojo/keys module and prevent Enter
   *            from submitting the form on option select.
   * 18-Nov-2910  SH  [RTC252278] Added overrides to _selectOption and _onKey 
   *  				  in order to place cursor at start of selected option 
   * 07-Aug-2019  RS  [RTC242763] Added `required: false`, which overrides the 
   *                  default value 'required: True'
   * 20-Nov-2015  AZ  [CR00472692] Load custom ComboBoxMixin for accessibility.
   * 10-Mar-2014  AS  [CR00415345] Modified the role of widget 
   *                    to listbox from combobox. Also handled the
   *                  enter key on open dropdown.
   * 15-Nov-2011  PK  [CR00297778] Ported to Dojo 1.7.
   * 03-Nov-2011  JY  [CR00296248] Added a blank option to the <select> element 
   *                  where there is no option
   * 31-Oct-2011  MV  [CR00289694] Fixed the superclass' method call.
   * 25-Oct-2011  JY  [CR00295925] Updated postMixInProperties() function to
   *                  ignore handling the blank option that contains a comment.
   * 19-Oct-2011  JY  [CR00295026] Overwrite _callbackSetLabel() function to set
   *                  an particular code "__o3_INVALID" for the invalid inputs.
   * 22-Oct-2010  MK  [CR00222181] Initial version.
   */
  /**
   * @name curam.widget.FilteringSelect
   * @namespace Get it to display items in the drop down when the associated
   *              value is the empty string.
   */
  var FilteringSelect = declare("curam.widget.FilteringSelect", [dijit.form.FilteringSelect, curam.widget.ComboBoxMixin],
  /**
   * @lends curam.widget.FilteringSelect.prototype
   */
  {
      // Flag which indicates if the enter key is used on open dropdown
      enterKeyOnOpenDropDown: false,
      // This flag is set to `true` in dijit.form.FilteringSelect, which makes the screen reader 
      // read `required` for all FilteringSelect widgets.
      required: false,
    
      postMixInProperties: function(){
          /*
           * Add a blank option to the <select> element where there is no option,
           * to enable users to open a empty dropdown list in this widget.
           * 
           */
          if (!this.store) {
            if (dojo.query("> option", this.srcNodeRef)[0] == undefined) {
              domConstruct.create("option", {innerHTML:"<!--__o3_BLANK-->"}, this.srcNodeRef);
            }
          }
          
          
            if(!this.get("store") && this.srcNodeRef.value == '') {
              var srcNodeRef = this.srcNodeRef,
                  nodes = dojo.query("> option[value='']", srcNodeRef);
            
      
            if (nodes.length && nodes[0].innerHTML != "<!--__o3_BLANK-->") {
              this.displayedValue = dojo.trim(nodes[0].innerHTML);
            }
          }   
    
          this.inherited(arguments);
      },
  
      postCreate : function() {
        // Attached a keyboard event listener so that we can set a flag
        // indicating enter is pressed in open state of dropdown
        on(this.focusNode, "keydown",function(e){
          var widget = registry.byNode(dom.byId("widget_" + e.target.id)); 
          if(e.keyCode == dojo.keys.ENTER && widget._opened) {
            widget.enterKeyOnOpenDropDown = true;
           }
         });
        
        this.inherited(arguments);
      },
      
      startup : function(){
        // We have to change role to listbox as Jaws do not work correctly
        // in IE when role is combobox.
        if (has('trident')) {
          this.domNode.setAttribute("role", "listbox");
        }
        this.inherited(arguments);
      },
  
      /**
       * Overwrite _callbackSetLabel() function to make the FilteringSelect widget
       * set a particular code "__o3_INVALID" for the invalid inputs, instead
       * of setting an empty string.
       * 
         */
        _callbackSetLabel: function(
          /*Array*/ result,
          /*Object*/ query,
          /*Object*/ options,
          /*Boolean?*/ priorityChange){
        //  summary:
          //              Callback from dojo.store after lookup of user entered value finishes
    
        //  setValue does a synchronous lookup,
        //  so it calls _callbackSetLabel directly,
        //  and so does not pass dataObject
        //  still need to test against _lastQuery in case it came too late
          if((query && query[this.searchAttr] !== this._lastQuery)
              || (!query && result.length && this.get("store").getIdentity(result[0]) != this._lastQuery)){
          return;
        }
        if(!result.length){
            //#3268: don't modify display value on bad input
          //    #3285: change CSS to indicate error
            
            // CURAM CUSTOMIZATION START - This is the only customization made to
            // the ootb _callbackSetLabel method in Dojo's FilteringSelect. The
            // specific change is:
            // The second parameter below has been changed from "" to "__o3_INVALID".
            this.set("value", "__o3_INVALID", priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
            // CURAM CUSTOMIZATION END
        }else{
            this.set('item', result[0], priorityChange);
        }
      },
      
      /**
       * Override _onKey to handle pressing Enter key on a dropdown.
       */
      _onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			if(evt.charCode >= 32){
				return;
			} // alphanumeric reserved for searching

			var key = evt.charCode || evt.keyCode;

			// except for cutting/pasting case - ctrl + x/v
			if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
				return; // throw out spurious events
			}

			var pw = this.dropDown;
			var highlighted = null;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//
			//	1. when drop down is not yet shown:
			//		- if user presses the down arrow key, call loadDropDown()
			//	2. when drop down is already displayed:
			//		- on ESC key, call closeDropDown()
			//		- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(evt.altKey || evt.ctrlKey || evt.metaKey){
				return;
			} // don't process keys with modifiers  - but we want shift+TAB

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					evt.stopPropagation();
					evt.preventDefault();
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}
						// prevent submit if ENTER was to choose an item
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						/* CURAM-FIX: RTC252278 - move the cursor to the start of the input area */
						// this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
						this._setCaretPos(this.focusNode, 0); // move cursor to start and cancel highlighting

						var oldvalue = this._resetValue; 
						var newvalue = this.displayedValue;
						if (oldvalue != newvalue) {
							evt.stopPropagation();
							evt.preventDefault();
						}
						/* END CURAM-FIX */
					}
				// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
						break;
					}
					if(highlighted){
						this._selectOption(highlighted);
					}
				// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;
			}
		},
		
		/**
	       * Override _selectOption to fix cursor placement.
	       */
        _selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			/* CURAM-FIX: RTC252278 - move the cursor to the start of the input area */
			// this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._setCaretPos(this.focusNode, 0);
			/* END CURAM-FIX */

			this._handleOnChange(this.value, true);
			// Remove aria-activedescendant since the drop down is no loner visible
			// after closeDropDown() but _announceOption() adds it back in
			this.focusNode.removeAttribute("aria-activedescendant");
		}
      
  });
  
  return FilteringSelect;
});

},
'dijit/_Widget':function(){
define([
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, has, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){


// module:
//		dijit/_Widget


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Old base class for widgets.   New widgets should extend `dijit/_WidgetBase` instead
	// description:
	//		Old Base class for Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//
	//		- declaratively/programatically specifying widget initialization parameters like
	//			onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//		- ondijitclick:
	//			Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//		- focus related functions:
	//			In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//			dijit/_base/focus.js.
	//		- deprecated methods
	//		- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//
	//		- browser sniffing (putting browser class like `dj_ie` on `<html>` node)
	//		- high contrast mode sniffing (add `dijit_a11y` class to `<body>` if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params /*===== ,srcNodeRef =====*/){
		// summary:
		//		Create the widget.
		// params: Object|null
		//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
		//		and functions, typically callbacks like onClick.
		//		The hash can contain any of the widget's properties, excluding read-only properties.
		// srcNodeRef: DOMNode|String?
		//		If a srcNodeRef (DOM node) is specified:
		//
		//		- use srcNodeRef.innerHTML as my contents
		//		- if this is a behavioral widget then apply behavior to that srcNodeRef
		//		- otherwise, replace srcNodeRef with my generated DOM tree

		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String|Function*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE,
			// normalization of onkeypress/onkeydown to behave like firefox, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			// Remove in 2.0.
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		This method is deprecated, use get() or set() directly.
		// name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		// value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// tags:
		//		deprecated

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit/_WidgetBase[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
		//		Called when another widget becomes the selected pane in a
		//		`dijit/layout/TabContainer`, `dijit/layout/StackContainer`,
		//		`dijit/layout/AccordionContainer`, etc.
		//
		//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit/layout/StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if( 1 ){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dijit/form/_SearchMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/string", // string.substitute
	"dojo/when",
	"../registry"	// registry.byId
], function(declare, keys, lang, query, string, when, registry){

	// module:
	//		dijit/form/_SearchMixin


	return declare("dijit.form._SearchMixin", null, {
		// summary:
		//		A mixin that implements the base functionality to search a store based upon user-entered text such as
		//		with `dijit/form/ComboBox` or `dijit/form/FilteringSelect`
		// tags:
		//		protected

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies maximum number of search results to return per query
		pageSize: Infinity,

		// store: [const] dojo/store/api/Store
		//		Reference to data provider object used by this ComboBox.
		//		The store must accept an object hash of properties for its query. See `query` and `queryExpr` for details.
		store: null,

		// fetchProperties: Object
		//		Mixin to the store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to `store` to initially filter the items.
		//		ComboBox overwrites any reference to the `searchAttr` and sets it to the `queryExpr` with the user's input substituted.
		query: {},

		// list: [const] String
		//		Alternate to specifying a store.  Id of a dijit/form/DataList widget.
		list: "",
		_setListAttr: function(list){
			// Avoid having list applied to the DOM node, since it has native meaning in modern browsers
			this._set("list", list);
		},

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 200,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// queryExpr: String
		//		This specifies what query is sent to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the results are only exact matches, a "starting with" match,
		//		etc.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the query should ignore case when matching possible items
		ignoreCase: true,

		_patternToRegExp: function(pattern){
			// summary:
			//		Helper function to convert a simple pattern to a regular expression for matching.
			// description:
			//		Returns a regular expression object that conforms to the defined conversion rules.
			//		For example:
			//
			//		- ca*   -> /^ca.*$/
			//		- *ca*  -> /^.*ca.*$/
			//		- *c\*a*  -> /^.*c\*a.*$/
			//		- *c\*a?*  -> /^.*c\*a..*$/
			//
			//		and so on.
			// pattern: string
			//		A simple matching pattern to convert that follows basic rules:
			//
			//		- * Means match anything, so ca* means match anything starting with ca
			//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
			//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
			//
			//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
			//		represented by \\ to be treated as an ordinary \ character instead of an escape.

			return new RegExp("^" + pattern.replace(/(\\.)|(\*)|(\?)|\W/g, function(str, literal, star, question){
				return star ? ".*" : question ? "." : literal ? literal : "\\" + str;
			}) + "$", this.ignoreCase ? "mi" : "m");
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				this.searchTimer = this.searchTimer.remove();
			}
			if(this._queryDeferHandle){
				this._queryDeferHandle = this._queryDeferHandle.remove();
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){
					this._cancelingQuery = true;
					this._fetchHandle.abort();
					this._cancelingQuery = false;
				}
				if(this._fetchHandle.cancel){
					this._cancelingQuery = true;
					this._fetchHandle.cancel();
					this._cancelingQuery = false;
				}
				this._fetchHandle = null;
			}
		},

		_processInput: function(/*Event*/ evt){
			// summary:
			//		Handles input (keyboard/paste) events
			if(this.disabled || this.readOnly){ return; }
			var key = evt.charOrCode;

			var doSearch = false;
			this._prev_key_backspace = false;

			switch(key){
				case keys.DELETE:
				case keys.BACKSPACE:
					this._prev_key_backspace = true;
					this._maskValidSubsetError = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..) shouldn't start a search..
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				if(!this.store){
					this.onSearch();
				}else{
					this.searchTimer = this.defer("_startSearchFromInput", 1);
				}
			}
		},

		onSearch: function(/*===== results, query, options =====*/){
			// summary:
			//		Callback when a search completes.
			//
			// results: Object
			//		An array of items from the originating _SearchMixin's store.
			//
			// query: Object
			//		A copy of the originating _SearchMixin's query property.
			//
			// options: Object
			//		The additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.
			//
			// tags:
			//		callback
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value);
		},

		_startSearch: function(/*String*/ text){
			// summary:
			//		Starts a search for elements matching text (text=="" means to return all items),
			//		and calls onSearch(...) when the search completes, to display the results.

			this._abortQuery();
			var
				_this = this,
				// Setup parameters to be passed to store.query().
				// Create a new query to prevent accidentally querying for a hidden
				// value from FilteringSelect's keyField
				query = lang.clone(this.query), // #5970
				options = {
					start: 0,
					count: this.pageSize,
					queryOptions: {		// remove for 2.0
						ignoreCase: this.ignoreCase,
						deep: true
					}
				},
				qs = string.substitute(this.queryExpr, [text.replace(/([\\\*\?])/g, "\\$1")]),
				q,
				startQuery = function(){
					var resPromise = _this._fetchHandle = _this.store.query(query, options);
					if(_this.disabled || _this.readOnly || (q !== _this._lastQuery)){
						return;
					} // avoid getting unwanted notify
					when(resPromise, function(res){
						_this._fetchHandle = null;
						if(!_this.disabled && !_this.readOnly && (q === _this._lastQuery)){ // avoid getting unwanted notify
							when(resPromise.total, function(total){
								res.total = total;
								var pageSize = _this.pageSize;
								if(isNaN(pageSize) || pageSize > res.total){ pageSize = res.total; }
								// Setup method to fetching the next page of results
								res.nextPage = function(direction){
									//	tell callback the direction of the paging so the screen
									//	reader knows which menu option to shout
									options.direction = direction = direction !== false;
									options.count = pageSize;
									if(direction){
										options.start += res.length;
										if(options.start >= res.total){
											options.count = 0;
										}
									}else{
										options.start -= pageSize;
										if(options.start < 0){
											options.count = Math.max(pageSize + options.start, 0);
											options.start = 0;
										}
									}
									if(options.count <= 0){
										res.length = 0;
										_this.onSearch(res, query, options);
									}else{
										startQuery();
									}
								};
								_this.onSearch(res, query, options);
							});
						}
					}, function(err){
						_this._fetchHandle = null;
						if(!_this._cancelingQuery){	// don't treat canceled query as an error
							console.error(_this.declaredClass + ' ' + err.toString());
						}
					});
				};

			lang.mixin(options, this.fetchProperties);

			// Generate query
			if(this.store._oldAPI){
				// remove this branch for 2.0
				q = qs;
			}else{
				// Query on searchAttr is a regex for benefit of dojo/store/Memory,
				// but with a toString() method to help dojo/store/JsonRest.
				// Search string like "Co*" converted to regex like /^Co.*$/i.
				q = this._patternToRegExp(qs);
				q.toString = function(){ return qs; };
			}

			// set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this._lastQuery = query[this.searchAttr] = q;
			this._queryDeferHandle = this.defer(startQuery, this.searchDelay);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var list = this.list;
				if(list){
					this.store = registry.byId(list);
				}
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/Destroyable':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/declare"
], function(array, aspect, declare){

	// module:
	//		dijit/Destroyable

	return declare("dijit.Destroyable", null, {
		// summary:
		//		Mixin to track handles and release them when instance is destroyed.
		// description:
		//		Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,
		//		dojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.
		//		Then call destroy() later to destroy this instance and release the resources.

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this class, releasing any resources registered via own().
			this._destroyed = true;
		},

		own: function(){
			// summary:
			//		Track specified handles and remove/destroy them when this instance is destroyed, unless they were
			//		already removed/destroyed manually.
			// tags:
			//		protected
			// returns:
			//		The array of specified handles, so you can do for example:
			//	|		var handle = this.own(on(...))[0];

			var cleanupMethods = [
				"destroyRecursive",
				"destroy",
				"remove"
			];

			array.forEach(arguments, function(handle){
				// When this.destroy() is called, destroy handle.  Since I'm using aspect.before(),
				// the handle will be destroyed before a subclass's destroy() method starts running, before it calls
				// this.inherited() or even if it doesn't call this.inherited() at all.  If that's an issue, make an
				// onDestroy() method and connect to that instead.
				var destroyMethodName;
				var odh = aspect.before(this, "destroy", function (preserveDom){
					handle[destroyMethodName](preserveDom);
				});

				// Callback for when handle is manually destroyed.
				var hdhs = [];
				function onManualDestroy(){
					odh.remove();
					array.forEach(hdhs, function(hdh){
						hdh.remove();
					});
				}

				// Setup listeners for manual destroy of handle.
				// Also computes destroyMethodName, used in listener above.
				if(handle.then){
					// Special path for Promises.  Detect when Promise is resolved, rejected, or
					// canceled (nb: cancelling a Promise causes it to be rejected).
					destroyMethodName = "cancel";
					handle.then(onManualDestroy, onManualDestroy);
				}else{
					// Path for other handles.  Just use AOP to detect when handle is manually destroyed.
					array.forEach(cleanupMethods, function(cleanupMethod){
						if(typeof handle[cleanupMethod] === "function"){
							if(!destroyMethodName){
								// Use first matching method name in above listener (prefer destroyRecursive() to destroy())
								destroyMethodName = cleanupMethod;
							}
							hdhs.push(aspect.after(handle, cleanupMethod, onManualDestroy, true));
						}
					});
				}
			}, this);

			return arguments;		// handle
		}
	});
});

},
'dojo/request':function(){
define([
	'./request/default!'/*=====,
	'./_base/declare',
	'./promise/Promise' =====*/
], function(request/*=====, declare, Promise =====*/){
	/*=====
	request = function(url, options){
		// summary:
		//		Send a request using the default transport for the current platform.
		// url: String
		//		The URL to request.
		// options: dojo/request.__Options?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.__Promise = declare(Promise, {
		// response: dojo/promise/Promise
		//		A promise resolving to an object representing
		//		the response from the server.
	});
	request.__BaseOptions = declare(null, {
		// query: String|Object?
		//		Query parameters to append to the URL.
		// data: String|Object?
		//		Data to transfer.  This is ignored for GET and DELETE
		//		requests.
		// preventCache: Boolean?
		//		Whether to append a cache-busting parameter to the URL.
		// timeout: Integer?
		//		Milliseconds to wait for the response.  If this time
		//		passes, the then the promise is rejected.
		// handleAs: String?
		//		How to handle the response from the server.  Default is
		//		'text'.  Other values are 'json', 'javascript', and 'xml'.
	});
	request.__MethodOptions = declare(null, {
		// method: String?
		//		The HTTP method to use to make the request.  Must be
		//		uppercase.
	});
	request.__Options = declare([request.__BaseOptions, request.__MethodOptions]);

	request.get = function(url, options){
		// summary:
		//		Send an HTTP GET request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.post = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.put = function(url, options){
		// summary:
		//		Send an HTTP POST request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	request.del = function(url, options){
		// summary:
		//		Send an HTTP DELETE request using the default transport for the current platform.
		// url: String
		//		URL to request
		// options: dojo/request.__BaseOptions?
		//		Options for the request.
		// returns: dojo/request.__Promise
	};
	=====*/
	return request;
});

},
'curam/util/Dropdown':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2021, 2022
 *
 */

/**
 * @name curam.util.Dropdown
 * @namespace Provides the capability to update a dropdown form control on
 * a page.
 * 
 * <p/>
 * The important API functions that can be called on your page are:<ul>
 * <li><code>{@link curam.util.Dropdown.updateDropdownItems}</code> to update the items in a dropdown.</li>
 * <li><code>{@link curam.util.Dropdown.resetDropdownToEmpty}</code> to reseet the dropdown to be empty.</li></ul>
 */
define(["dojo/_base/declare"], function(declare) {

  /*
   * Modification History
   * --------------------
   * 23-Nov-2022  COC [SPM-126083] Added function setSelectedOnDropdownIDByCodevalue.
   * 12-Oct-2022  COC [SPM-125815] Updated the dojo publish for setSelectedItem to run 
   * at the Top Most Window.
   * 07-Apr-2022  BOS [RTC277603] Adding new functions for programatically selecting
   * an item from a dropdown.
   * 22-Jun-2021  BOS [RTC271787] New API for updating dropdowns on a pge.
   */
    
  /**
   * Creating a new instance of the dropdown.
   */ 
    
   var Dropdown = declare("curam.util.Dropdown", null,
  /**
   * @lends curam.util.Dropdown.prototype
   */
  {
  
    /**
     * Constructor that is empty and take no arguments.
     */
    constructor: function() {
    },
    
  
    /**
     * Updates the dropdown - as identified by the specified ID - with a new set of
     * items that will populate it once the user expands it.
     *
     * @param {String} dropdownInputID The specified ID which identifies the dropdown
     * on the page that is going to be updated.
     * @param {Array} [idList] An array of IDs to identify each item in the dropdown.
     * @param {Array} [descriptionList] An array of descriptions that will be used as the text
     * displayed for each item in the dropdown.
     */
     updateDropdownItems: function(dropdownInputID, idList, descriptionList) {
       // both 'idList' and 'descriptionList' must of type array
       if (idList.constructor !== Array || descriptionList.constructor !== Array) {
         throw new Error("Both " + idList + " and " + descriptionList + " must be an array");
       }
      
       // both arrays must be same length
       if (idList.length != descriptionList.length) {
         throw new Error("Both " + idList + " and " + descriptionList + " must have the same number of items");
       }
      
       // check spm (and thereby SPMUIComponents library available)
       if (window.spm) {
        // unmount current ddropdown (by ID)
        window.spm.requireCarbonAddons().then(function(addons) { addons.ComboBox.unmount(window, dropdownInputID)});
      
        var items = [];
          for (var i = 0; i < idList.length; i++) {
           item = {};
           item.id = dropdownInputID + "_" + idList[i];
            item.text = descriptionList[i];
            item.value = idList[i];
            items.push(item);
          }
       
          // labels configured from CDEJResources.propertries
          labelConfig = curam.util.getTopmostWindow().__dropdownLabelConfig;
          var labels = labelConfig ? labelConfig : {};
          // TODO: Should combobox options and attributes be configurable or will they be 
          // inheritied from initial configuration anyway? BOS
          var config = {inputId: dropdownInputID, items: items, attributes: {}, comboBoxOptions: {}, labels: labels, iframeWindow: window};
    
          // update the dropdown based on config. It is really juts the 'items' being updated!
          window.spm.requireCarbonAddons().then(function(addons) { addons.ComboBox.render(config)});
       }
      
    },
    
    /**
     * Resets the dropdown to be empty so that it will not contain any items when the user
     * expands it.
     *
     * @param {String} dropdownInputID The specified ID which identifies the dropdown
     * on the page that is going to be reset to be empty.
     */
    resetDropdownToEmpty: function(dropdownInputID) {
      this.updateDropdownItems(dropdownInputID, [], []);
    },
    
    /**
    * Sets the selected value on a dropdown, according to the specified description.
    * @param {String} dropdownID The specified ID which identifies the dropdown.
    * @param {String} description The specified description to be set as the selected value.
    */
    setSelectedOnDropdownByDescription:function(dropdownID, description){
      if (dropdownID) {
	      var targetDropdownID = dropdownID.lastIndexOf("_wrapper") != -1 ? dropdownID.substring(0, dropdownID.lastIndexOf("_wrapper")) : dropdownID;
		    dojo.publish('/curam/comboxbox/setSelectedItem', [targetDropdownID, undefined, description]);
	    }
	  },

    /**
    * Sets the selected value on a dropdown, according to the specified code table value.
    * @param {String} dropdownID The specified ID which identifies the dropdown.
    * @param {String} codeValue The specified code table value to be set as the selected value.
    */
	  setSelectedOnDropdownIDByCodevalue:function(dropdownID, codeValue){
	    if (dropdownID) {
	      var targetDropdownID = dropdownID.lastIndexOf("_wrapper") != -1 ? dropdownID.substring(0, dropdownID.lastIndexOf("_wrapper")) : dropdownID;
        curam.util.getTopmostWindow().dojo.publish('/curam/comboxbox/setSelectedItem'.concat(dropdownID), [targetDropdownID, codeValue]);
	    }
	  },
	
	/**
    * Sets the selected value on a dropdown, according to the specified code table value.
    * @param {String} dropdownID The specified ID which identifies the dropdown.
    * @param {String} codeValue The specified code table value to be set as the selected value.
    */
	setSelectedOnDropdownByCodevalue:function(dropdownID, codeValue){
	  if (dropdownID) {
	    var targetDropdownID = dropdownID.lastIndexOf("_wrapper") != -1 ? dropdownID.substring(0, dropdownID.lastIndexOf("_wrapper")) : dropdownID;
      curam.util.getTopmostWindow().dojo.publish('/curam/comboxbox/setSelectedItem', [targetDropdownID, codeValue]);
	  }
	},
    
    /**
     * Invokes the specified callback function if the following conditions are met. 
     * <ol>
     * <li>The specified ID matches that of a rendered dropdown form control on the page/modal</li>
     * <li>There is an OnChange event configured for the specified dropdown</li>
     * <li>The initial value on the dropdown is not blank</li>
     * </ol>
     *
     * @param {String} dropdownInputID The specified ID which identifies the dropdown.
     * @param {Function} callbackFunc The specified callback function that will be invoked if the
     * conditions are met.
     */
    executeActionFromInitialValueOnDropdown: function(dropdownInputID, callbackFunc) {
      this.dropdownInputID = dropdownInputID;
      var hasInitialValue = dojo.subscribe("/curam/comboxbox/initialValue", this, function(val, inputID) {
        // if the ID specified match the ID of the Dropdown broadcasting the initial value when there
        // is an OnChange event configured then we can invoke the specified function
	    if (this.dropdownInputID === inputID) {
	      this.__initialValueFromDropdown = val;
	      callbackFunc();
	      dojo.unsubscribe(hasInitialValue);
	    } 
	  });
    }
    });
   return Dropdown;
  });
},
'dojo/NodeList-traverse':function(){
define(["./query", "./_base/lang", "./_base/array"], function(dquery, lang, array){

// module:
//		dojo/NodeList-traverse

/*=====
return function(){
	// summary:
	//		Adds chainable methods to dojo/query() / NodeList instances for traversing the DOM
};
=====*/

var NodeList = dquery.NodeList;

lang.extend(NodeList, {
	_buildArrayFromCallback: function(/*Function*/ callback){
		// summary:
		//		builds a new array of possibly differing size based on the input list.
		//		Since the returned array is likely of different size than the input array,
		//		the array's map function cannot be used.
		var ary = [];
		for(var i = 0; i < this.length; i++){
			var items = callback.call(this[i], this[i], ary);
			if(items){
				ary = ary.concat(items);
			}
		}
		return ary;	//Array
	},

	_getUniqueAsNodeList: function(/*Array*/ nodes){
		// summary:
		//		given a list of nodes, make sure only unique
		//		elements are returned as our NodeList object.
		//		Does not call _stash().
		var ary = [];
		//Using for loop for better speed.
		for(var i = 0, node; node = nodes[i]; i++){
			//Should be a faster way to do this. dojo/query has a private
			//_zip function that may be inspirational, but there are pathways
			//in query that force nozip?
			if(node.nodeType == 1 && array.indexOf(ary, node) == -1){
				ary.push(node);
			}
		}
		return this._wrap(ary, null, this._NodeListCtor);	 // dojo/NodeList
	},

	_getUniqueNodeListWithParent: function(/*Array*/ nodes, /*String*/ query){
		// summary:
		//		gets unique element nodes, filters them further
		//		with an optional query and then calls _stash to track parent NodeList.
		var ary = this._getUniqueAsNodeList(nodes);
		ary = (query ? dquery._filterResult(ary, query) : ary);
		return ary._stash(this);  // dojo/NodeList
	},

	_getRelatedUniqueNodes: function(/*String?*/ query, /*Function*/ callback){
		// summary:
		//		cycles over all the nodes and calls a callback
		//		to collect nodes for a possible inclusion in a result.
		//		The callback will get two args: callback(node, ary),
		//		where ary is the array being used to collect the nodes.
		return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  // dojo/NodeList
	},

	children: function(/*String?*/ query){
		// summary:
		//		Returns all immediate child elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the child elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all immediate child elements for the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".container").children();
		//	|	});
		//		returns the four divs that are children of the container div.
		//		Running this code:
		//	|	dojo.query(".container").children(".red");
		//		returns the two divs that have the class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return lang._toArray(node.childNodes);
		}); // dojo/NodeList
	},

	closest: function(/*String*/ query, /*String|DOMNode?*/ root){
		// summary:
		//		Returns closest parent that matches query, including current node in this
		//		dojo/NodeList if it matches the query.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// root:
		//		If specified, query is relative to "root" rather than document body.
		// returns:
		//		the closest parent that matches the query, including the current
		//		node in this dojo/NodeList if it matches the query.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		//	|		<div class="red">Red One</div>
		//	|		Some Text
		//	|		<div class="blue">Blue One</div>
		//	|		<div class="red">Red Two</div>
		//	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".red").closest(".container");
		//	|	});
		//		returns the div with class "container".
		return this._getRelatedUniqueNodes(null, function(node, ary){
			do{
				if(dquery._filterResult([node], query, root).length){
					return node;
				}
			}while(node != root && (node = node.parentNode) && node.nodeType == 1);
			return null; //To make rhino strict checking happy.
		}); // dojo/NodeList
	},

	parent: function(/*String?*/ query){
		// summary:
		//		Returns immediate parent elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the parent elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		immediate parent elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".text").parent();
		//	|	});
		//		returns the two divs with class "blue".
		//		Running this code:
		//	|		query(".text").parent(".first");
		//		returns the one div with class "blue" and "first".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return node.parentNode;
		}); // dojo/NodeList
	},

	parents: function(/*String?*/ query){
		// summary:
		//		Returns all parent elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the child elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all parent elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".text").parents();
		//	|	});
		//		returns the two divs with class "blue", the div with class "container",
		// 	|	the body element and the html element.
		//		Running this code:
		//	|		query(".text").parents(".container");
		//		returns the one div with class "container".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			while(node.parentNode){
				node = node.parentNode;
				pary.push(node);
			}
			return pary;
		}); // dojo/NodeList
	},

	siblings: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").siblings();
		//	|	});
		//		returns the two divs with class "red" and the other div
		// 	|	with class "blue" that does not have "first".
		//		Running this code:
		//	|		query(".first").siblings(".red");
		//		returns the two div with class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var nodes = (node.parentNode && node.parentNode.childNodes);
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i] != node){
					pary.push(nodes[i]);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	next: function(/*String?*/ query){
		// summary:
		//		Returns the next element for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the next elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		the next element for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").next();
		//	|	});
		//		returns the div with class "red" and has innerHTML of "Red Two".
		//		Running this code:
		//	|	dojo.query(".last").next(".red");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var next = node.nextSibling;
			while(next && next.nodeType != 1){
				next = next.nextSibling;
			}
			return next;
		}); // dojo/NodeList
	},

	nextAll: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements that come after the nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements that come after the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red next">Red Two</div>
		// 	|		<div class="blue next">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").nextAll();
		//	|	});
		//		returns the two divs with class of "next".
		//		Running this code:
		//	|		query(".first").nextAll(".red");
		//		returns the one div with class "red" and innerHTML "Red Two".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var next = node;
			while((next = next.nextSibling)){
				if(next.nodeType == 1){
					pary.push(next);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	prev: function(/*String?*/ query){
		// summary:
		//		Returns the previous element for nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the previous elements.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		the previous element for nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".first").prev();
		//	|	});
		//		returns the div with class "red" and has innerHTML of "Red One".
		//		Running this code:
		//	|		query(".first").prev(".blue");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var prev = node.previousSibling;
			while(prev && prev.nodeType != 1){
				prev = prev.previousSibling;
			}
			return prev;
		}); // dojo/NodeList
	},

	prevAll: function(/*String?*/ query){
		// summary:
		//		Returns all sibling elements that come before the nodes in this dojo/NodeList.
		//		Optionally takes a query to filter the sibling elements.
		// description:
		//		The returned nodes will be in reverse DOM order -- the first node in the list will
		//		be the node closest to the original node/NodeList.
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		all sibling elements that come before the nodes in this dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".second").prevAll();
		//	|	});
		//		returns the two divs with class of "prev".
		//		Running this code:
		//	|		query(".first").prevAll(".red");
		//		returns the one div with class "red prev" and innerHTML "Red One".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = [];
			var prev = node;
			while((prev = prev.previousSibling)){
				if(prev.nodeType == 1){
					pary.push(prev);
				}
			}
			return pary;
		}); // dojo/NodeList
	},

	andSelf: function(){
		// summary:
		//		Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".second").prevAll().andSelf();
		//	|	});
		//		returns the two divs with class of "prev", as well as the div with class "second".
		return this.concat(this._parent);	// dojo/NodeList
	},

	//Alternate methods for the :first/:last/:even/:odd pseudos.
	first: function(){
		// summary:
		//		Returns the first node in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the first node in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".blue").first();
		//	|	});
		//		returns the div with class "blue" and "first".
		return this._wrap(((this[0] && [this[0]]) || []), this); // dojo/NodeList
	},

	last: function(){
		// summary:
		//		Returns the last node in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the last node in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|	query(".blue").last();
		//	|	});
		//		returns the last div with class "blue",
		return this._wrap((this.length ? [this[this.length - 1]] : []), this); // dojo/NodeList
	},

	even: function(){
		// summary:
		//		Returns the even nodes in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the even nodes in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".interior").even();
		//	|	});
		//		returns the two divs with class "blue"
		return this.filter(function(item, i){
			return i % 2 != 0;
		}); // dojo/NodeList
	},

	odd: function(){
		// summary:
		//		Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.
		// description:
		//		.end() can be used on the returned dojo/NodeList to get back to the
		//		original dojo/NodeList.
		// returns:
		//		the odd nodes in this dojo/NodeList
		// example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	require(["dojo/query", "dojo/NodeList-traverse"
		//	|	], function(query){
		//	|		query(".interior").odd();
		//	|	});
		//		returns the two divs with class "red"
		return this.filter(function(item, i){
			return i % 2 == 0;
		}); // dojo/NodeList
	}
});

return NodeList;
});

},
'curam/lnf':function(){
define(["dojo/dom",
        "dojo/dom-class",
        "curam/define"
        ], function(dom, domClass, define) {
  
  /*
    All javascript functions that alter the look and feel of a page
    should be added here. Examples of this are functions that may 
    add a new class name or inline styling to a node.
  */
  define.singleton("curam.lnf", {
    /* 
      The setCTParent function adds a class name of "codetable" to the table cell
      that contains a drop-down or multi-select box which is populated by arbitary
      list data. This class is added so different CSS can be applied to the cell
      so text input boxes will align correctly with drop-down or multi-select boxes.
    */
    setCTParent: function(id) {
      var selectNode = dom.byId(id);
      var selectParentNode = selectNode.parentNode;
      if(selectParentNode.tagName == "TD") {
        domClass.add(selectParentNode, "codetable");
      }
    }
  });
  
  return curam.lnf;
});

},
'dojo/data/util/filter':function(){
define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/filter
	// summary:
	//		TODOC

var filter = {};
lang.setObject("dojo.data.util.filter", filter);

filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	// summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	// description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//
	//		- ca*   -> /^ca.*$/
	//		- *ca*  -> /^.*ca.*$/
	//		- *c\*a*  -> /^.*c\*a.*$/
	//		- *c\*a?*  -> /^.*c\*a..*$/
	//
	//		and so on.
	// pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//
	//		- * Means match anything, so ca* means match anything starting with ca
	//		- ? Means match single character.  So, b?b will match to bob and bab, and so on.
	//		- \ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//
	//		To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//		represented by \\ to be treated as an ordinary \ character instead of an escape.
	// ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}

};

return filter;
});

},
'dojo/dnd/common':function(){
define(["../sniff", "../_base/kernel", "../_base/lang", "../dom"],
	function(has, kernel, lang, dom){

// module:
//		dojo/dnd/common

var exports = lang.getObject("dojo.dnd", true);
/*=====
// TODO: for 2.0, replace line above with this code.
var exports = {
	// summary:
	//		TODOC
};
=====*/

exports.getCopyKeyState = function(evt){
	return evt[has("mac") ? "metaKey" : "ctrlKey"]
};

exports._uniqueId = 0;
exports.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = kernel._scopeName + "Unique" + (++exports._uniqueId);
	}while(dom.byId(id));
	return id;
};

exports._empty = {};

exports.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " a button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

return exports;
});

},
'dijit/tree/ForestStoreModel':function(){
define([
	"dojo/_base/array", // array.indexOf array.some
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // global
	"dojo/_base/lang", // lang.hitch
	"./TreeStoreModel"
], function(array, declare, kernel, lang, TreeStoreModel){

// module:
//		dijit/tree/ForestStoreModel

return declare("dijit.tree.ForestStoreModel", TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description:
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//
	//		- onNewRootItem
	//		- onAddToRoot
	//		- onLeaveRoot
	//		- onNewItem
	//		- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo/data/Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		//		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope || kernel.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dijit/tree/dndSource.__Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo/data/api/Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(/* dijit/tree/dndSource.__Item */ /*===== args =====*/){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		this.inherited(arguments, [childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		]);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		//	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: lang.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					array.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo/data/api/Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(array.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* Object|Array */ oldValue,
					/* Object|Array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

});

},
'curam/util/ResourceBundle':function(){
/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define(["dojo/_base/declare",
        "dojo/i18n",
        "dojo/string"
        ], function(declare, i18n, string) {

/*
 * Modification History
 * --------------------
 * 20-May-2013  MV  [CR00383012] Fail if there are no properties loaded.
 * 19-May-2012  BOS [CR00346368] Use new Dojo AMD format.
 * 15-Jun-2012  MV  [CR00329034] Added proper documentation.
 * 11-Jun-2012  MV  [CR00328689] Initial version.
 */

/**
 * @name curam.util.ResourceBundle
 * @namespace Provides access to localizable resources.
 * <p/>
 * The process for getting localized messaged from a resource bundle consists
 * of two steps: <ol>
 * <li>Load the resources using <code>dojo.requireLocalization()</code></li>
 * <li>Create an instance of <code>curam.util.ResourceBunlde</code> class
 *      to access the localized resources.</li>
 * </ol>
 *
 * <h2>Loading Resources</h2>
 * In most cases the call to load resources should look like this:
 * <code><pre>dojo.requireLocalization("curam.application", "MyResources")</pre></code>
 * <p/>
 * "curam.application" is the default package into which all localizable
 * resources are placed by Curam infrastructure.
 * <p/>
 * "MyResources" is an example of a resource bundle name. Resource bundle name
 * will be specific to your own JavaScript code and it is derived from the name
 * of the related resource bundle *.properties file.
 *
 * <h2>Accessing Localized Resources</h2>
 * Previously loaded localized resources can be accessed in the following way:
 * <code><pre>dojo.require("curam.util.ResourceBundle");
 * var bundle = new curam.util.ResourceBundle("MyResources");
 * var localizedMessage = bundle.getProperty("myPropertyKey");
 * </pre></code>
 * Note in the above example there is no need to specify the default package
 * name "curam.appliciation" - the infrastructure will use the default
 * if no package is specified. This should be the case in most normal
 * situations.
 *
 * <h2>Resource File Naming and Content</h2>
 * The localizable resources for your JavaScript are expected in the standard
 * Java Properties format.
 * <p/>
 * By convention the name of the resource file for your JavaScript should be
 * derived from name of the JavaScript file itself. For example if your
 * JavaScript file is called "MyJavaScript.js" then related localizable
 * resources should be placed in <code>MyJavaScript.js.properties</code> file.
 * This .properties file can be placed anywhere in the component directory, but
 * by convention it should be in the same directory as the related *.js file.
 * The only exception to this, is that a *.js file within a WebContent directory
 * cannot have it's associated .properties file within the same directory - the
 * associated .properties file must be placed within a directory outside of the
 * WebContent directory.
 * <p/>
 * The tranlations of the resource bundle should then be placed in files named
 * in the following way (again following the Java standard naming):
 * <code>MyJavaScript.js_fr_CA.properties</code>,
 * <code>MyJavaScript.js_fr.properties</code>,
 * <code>MyJavaScript.js_cs_CZ.properties</code>, etc.
 * <p/>
 * Sample content of a resource file is as follows:
 * <code><pre>myPropertyKey=A localizable message.
 * another.property.key=Another localizable message.
 * propertyKey3=A message with %s value placeholders %s.
 * </pre></code>
 * Please note property keys with dots are allowed and string value
 * substitution into mesages is supported.
 */
 var ResourceBundle = declare("curam.util.ResourceBundle", null,
/**
 * @lends curam.util.ResourceBundle.prototype
 */
{
  _bundle: undefined,

  /**
   * Constructor takes bundle name and optionally locale.
   *
   * @param {String} possiblyQualifiedBundleName Bundle name. Optionally
   *           qualified with package name. E.g. "my.package.MyResourceBundle".
   * @param {String} [locale] Locale string in the following format:
   *            <code> en-US</code> where "en" is language code and "US"
   *            is variant as per IETF specification.
   */
  constructor: function(possiblyQualifiedBundleName, locale) {
    var parts = possiblyQualifiedBundleName.split(".");
    var bundleName = parts[parts.length - 1];
    var packageName = parts.length == 1 ? "curam.application"
        : possiblyQualifiedBundleName.slice(0,
            possiblyQualifiedBundleName.length - bundleName.length - 1);
    try {
      var b = i18n.getLocalization(packageName, bundleName, locale);
      if (this._isEmpty(b)) {
        throw new Error("Empty resource bundle.");

      } else {
        this._bundle = b;
      }

    } catch (e) {
      throw new Error("Unable to access resource bundle: " + packageName + "."
          + bundleName + ": " + e.message);
    }
  },
  
  /**
   * Checks if the passed bundle is empty or has some properties.
   * @param bundle The bundle object to check.
   * @returns {Boolean} True if the bundle if empty, false if it contains
   *            properties.
   */
  _isEmpty: function(bundle) {
    for (var prop in bundle) {
      // if it has at least one property, return false - it is not empty
      return false;
    }
    // no properties - return true as it is empty
    return true;
  },

  /**
   * Gets the localized value of a specified property, optionally replacing any
   * placeholders with appropriate values from specified array.
   *
   * @param {String} key The property key of the required message.
   * @param {Array} [values] An array of values to be used for replacing
   *            placeholders within the specified message.
   * @returns {String} Value of the requested localized property from
   *            the bundle.
   */
  getProperty: function(key, values) {
    var msg = this._bundle[key];

    var result = msg;
    if (values) {
      result = string.substitute(msg, values);
    }

    return result;
  }
  });
 return ResourceBundle;
});
},
'dijit/Menu':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/keys", // keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, dom, domAttr, domGeometry, domStyle, keys, lang, on, has, win, winUtils, pm, DropDownMenu, ready){

	// module:
	//		dijit/Menu

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Menu", DropDownMenu, {
		// summary:
		//		A context menu you can assign to multiple elements

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- replace srcNodeRef with my generated DOM tree

			this._bindings = [];
		},

		// targetNodeIds: [const] String[]
		//		Array of dom node ids of nodes to attach to.
		//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
		targetNodeIds: [],

		// selector: String?
		//		CSS expression to apply this Menu to descendants of targetNodeIds, rather than to
		//		the nodes specified by targetNodeIds themselves.  Useful for applying a Menu to
		//		a range of rows in a table, tree, etc.
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple targetNodeIds.   selector gives the same effect.
		// So, change targetNodeIds to a targetNodeId: "", remove bindDomNode()/unBindDomNode(), etc.

		/*=====
		// currentTarget: [readonly] DOMNode
		//		For context menus, set to the current node that the Menu is being displayed for.
		//		Useful so that the menu actions can be tailored according to the node
		currentTarget: null,
		=====*/

		// contextMenuForWindow: [const] Boolean
		//		If true, right clicking anywhere on the window will cause this context menu to open.
		//		If false, must specify targetNodeIds.
		contextMenuForWindow: false,

		// leftClickToOpen: [const] Boolean
		//		If true, menu will open on left click instead of right click, similar to a file menu.
		leftClickToOpen: false,
		// TODO: remove in 2.0, we have better ways of opening a menu with a left click, by extending _HasDropDown.

		// refocus: Boolean
		//		When this menu closes, re-focus the element which had focus before it was opened.
		refocus: true,

		postCreate: function(){
			if(this.contextMenuForWindow){
				this.bindDomNode(this.ownerDocumentBody);
			}else{
				array.forEach(this.targetNodeIds, this.bindDomNode, this);
			}
			this.inherited(arguments);
		},

		// thanks burstlib!
		_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns the window reference of the passed iframe
			// tags:
			//		private
			return winUtils.get(this._iframeContentDocument(iframe_el)) ||
				// Moz. TODO: is this available when defaultView isn't?
				this._iframeContentDocument(iframe_el)['__parent__'] ||
				(iframe_el.name && document.frames[iframe_el.name]) || null;	//	Window
		},

		_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
			// summary:
			//		Returns a reference to the document object inside iframe_el
			// tags:
			//		protected
			return iframe_el.contentDocument // W3
				|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
				|| (iframe_el.name && document.frames[iframe_el.name] && document.frames[iframe_el.name].document)
				|| null;	//	HTMLDocument
		},

		bindDomNode: function(/*String|DomNode*/ node){
			// summary:
			//		Attach menu to given node
			node = dom.byId(node, this.ownerDocument);

			var cn;	// Connect node

			// Support context menus on iframes.  Rather than binding to the iframe itself we need
			// to bind to the <body> node inside the iframe.
			if(node.tagName.toLowerCase() == "iframe"){
				var iframe = node,
					window = this._iframeContentWindow(iframe);
				cn = win.body(window.document);
			}else{
				// To capture these events at the top level, attach to <html>, not <body>.
				// Otherwise right-click context menu just doesn't work.
				cn = (node == win.body(this.ownerDocument) ? this.ownerDocument.documentElement : node);
			}


			// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
			var binding = {
				node: node,
				iframe: iframe
			};

			// Save info about binding in _bindings[], and make node itself record index(+1) into
			// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
			// start with a number, which fails on FF/safari.
			domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

			// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
			// loading yet, in which case we need to wait for the onload event first, and then connect
			// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
			// we need to monitor keyboard events in addition to the oncontextmenu event.
			var doConnects = lang.hitch(this, function(cn){
				var selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){
							return on.selector(selector, eventType);
						} :
						function(eventType){
							return eventType;
						},
					self = this;
				return [
					on(cn, delegatedEvent(this.leftClickToOpen ? "click" : "contextmenu"), function(evt){
						evt.stopPropagation();
						evt.preventDefault();

						if((new Date()).getTime() < self._lastKeyDown + 500){
							// Ignore contextmenu/click events that were already processed in keydown handler below.
							// But still call preventDefault() (above) so system context menu doesn't appear.
							return;
						}

						// Schedule context menu to be opened.
						// Note that this won't work will if the click was generated by the keyboard, while
						// focused on a <button> etc.   In that case evt.pageX and evt.pageY are either (0,0) or
						// wherever the mouse cursor is.  See keydown handler below.
						self._scheduleOpen(this, iframe, {x: evt.pageX, y: evt.pageY}, evt.target);
					}),
					on(cn, delegatedEvent("keydown"), function(evt){
						if(evt.keyCode == 93 ||									// context menu key
							(evt.shiftKey && evt.keyCode == keys.F10) ||		// shift-F10
							(self.leftClickToOpen && evt.keyCode == keys.SPACE)	// space key
						){
							evt.stopPropagation();
							evt.preventDefault();

							// Open the menu around evt.target.  Note that "this" and evt.target
							// are likely different, especially for global context menu, where "this" is <body>.
							self._scheduleOpen(this, iframe, null, evt.target);	// no coords - open near evt.target

							self._lastKeyDown = (new Date()).getTime();
						}
					})
				];
			});
			binding.connects = cn ? doConnects(cn) : [];

			if(iframe){
				// Setup handler to [re]bind to the iframe when the contents are initially loaded,
				// and every time the contents change.
				// Need to do this b/c we are actually binding to the iframe's <body> node.
				// Note: can't use connect.connect(), see #9609.

				binding.onloadHandler = lang.hitch(this, function(){
					// want to remove old connections, but IE throws exceptions when trying to
					// access the <body> node because it's already gone, or at least in a state of limbo

					var window = this._iframeContentWindow(iframe),
						cn = win.body(window.document);
					binding.connects = doConnects(cn);
				});
				if(iframe.addEventListener){
					iframe.addEventListener("load", binding.onloadHandler, false);
				}else{
					iframe.attachEvent("onload", binding.onloadHandler);
				}
			}
		},

		unBindDomNode: function(/*String|DomNode*/ nodeName){
			// summary:
			//		Detach menu from given node

			var node;
			try{
				node = dom.byId(nodeName, this.ownerDocument);
			}catch(e){
				// On IE the dom.byId() call will get an exception if the attach point was
				// the <body> node of an <iframe> that has since been reloaded (and thus the
				// <body> node is in a limbo state of destruction.
				return;
			}

			// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
			var attrName = "_dijitMenu" + this.id;
			if(node && domAttr.has(node, attrName)){
				var bid = domAttr.get(node, attrName) - 1, b = this._bindings[bid], h;
				while((h = b.connects.pop())){
					h.remove();
				}

				// Remove listener for iframe onload events
				var iframe = b.iframe;
				if(iframe){
					if(iframe.removeEventListener){
						iframe.removeEventListener("load", b.onloadHandler, false);
					}else{
						iframe.detachEvent("onload", b.onloadHandler);
					}
				}

				domAttr.remove(node, attrName);
				delete this._bindings[bid];
			}
		},

		_scheduleOpen: function(delegatedTarget, iframe, coords, target){
			// summary:
			//		Set timer to display myself.  Using a timer rather than displaying immediately solves
			//		IE problem: without the delay, focus work in "open" causes the system
			//		context menu to appear in spite of evt.preventDefault().
			// delegatedTarget: Element
			//		The node specified in targetNodeIds or matching selector that the menu is being opened for.
			// iframe: HTMLIframeElement?
			//		Set if target is inside the specified iframe.
			// coords: Object
			//		x/y position to center the menu around.  Undefined if menu was opened via keyboard.
			// target: Element
			//		The actual clicked node, either delegatedTarget or a descendant.

			if(!this._openTimer){
				this._openTimer = this.defer(function(){
					delete this._openTimer;
					this._openMyself({
						target: target,
						delegatedTarget: delegatedTarget,
						iframe: iframe,
						coords: coords
					});
				}, 1);
			}
		},

		_openMyself: function(args){
			// summary:
			//		Internal function for opening myself when the user does a right-click or something similar.
			// args:
			//		This is an Object containing:
			//
			//		- target: The node that is being clicked.
			//		- delegatedTarget: The node from this.targetNodeIds or matching this.selector,
			//		  either the same as target or an ancestor of target.
			//		- iframe: If an `<iframe>` is being clicked, iframe points to that iframe
			//		- coords: Mouse cursor x/y coordinates.  Null when opened via keyboard.
			//		  Put menu at specified position in iframe (if iframe specified) or otherwise in viewport.
			//
			//		_openMyself() formerly took the event object, and since various code references
			//		evt.target (after connecting to _openMyself()), using an Object for parameters
			//		(so that old code still works).

			var target = args.target,
				iframe = args.iframe,
				coords = args.coords,
				byKeyboard = !coords;

			// To be used by MenuItem event handlers to tell which node the menu was opened on
			this.currentTarget = args.delegatedTarget;

			// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
			// then near the node the menu is assigned to.
			if(coords){
				if(iframe){
					// Specified coordinates are on <body> node of an <iframe>, convert to match main document
					var ifc = domGeometry.position(iframe, true),
						window = this._iframeContentWindow(iframe),
						scroll = domGeometry.docScroll(window.document);

					var cs = domStyle.getComputedStyle(iframe),
						tp = domStyle.toPixelValue,
						left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
						top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

					coords.x += ifc.x + left - scroll.x;
					coords.y += ifc.y + top - scroll.y;
				}
			}else{
				coords = domGeometry.position(target, true);
				coords.x += 10;
				coords.y += 10;
			}

			var self = this;
			var prevFocusNode = this._focusManager.get("prevNode");
			var curFocusNode = this._focusManager.get("curNode");
			var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

			function closeAndRestoreFocus(){
				// user has clicked on a menu or popup
				if(self.refocus && savedFocusNode){
					savedFocusNode.focus();
				}
				pm.close(self);
			}

			pm.open({
				popup: this,
				x: coords.x,
				y: coords.y,
				onExecute: closeAndRestoreFocus,
				onCancel: closeAndRestoreFocus,
				orient: this.isLeftToRight() ? 'L' : 'R'
			});

			// Focus the menu even when opened by mouse, so that a click on blank area of screen will close it
			this.focus();
			if(!byKeyboard){
				// But then (when opened by mouse), mark Menu as passive, so that the first item isn't highlighted.
				// On IE9+ this needs to be on a delay because the focus is asynchronous.
				this.defer(function(){
					this._cleanUp(true);
				});
			}

			this._onBlur = function(){
				this.inherited('_onBlur', arguments);
				// Usually the parent closes the child widget but if this is a context
				// menu then there is no parent
				pm.close(this);
				// don't try to restore focus; user has clicked another part of the screen
				// and set focus there
			};
		},

		destroy: function(){
			array.forEach(this._bindings, function(b){
				if(b){
					this.unBindDomNode(b.node);
				}
			}, this);
			this.inherited(arguments);
		}
	});
});

},
'curam/util/TabNavigation':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

dojo.require("curam.util.ResourceBundle");

define(["dijit/registry",
        "dojo/dom",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "curam/inspection/Layer",
        "curam/debug",
        "curam/define",
        "curam/util",
        "curam/tab",
        "curam/util/Refresh"
        ], function(registry, dom, domStyle, domClass, domAttr, domConstruct, layer, debug) {
  
  /*
   * Modification History
   * --------------------
   * 07-Mar-2022  FN  [RTC254434]  Added _updateAriaMarkupForEnabledAndDisabledNavigationTabs to
   *                               fix issue with enabled/disabled navigation tabs.
   * 11-Aug-2021  SK  [RTC272800]  Progress spinner invocation is now decoupled.
   * 08-May-2020  JD  [RTC259879]  Adjusted inline stylings applied to iframe when loading iframe
   *                               and after iframe has loaded when tab navigation occurs.
   * 01-Apr-2020  FN  [RTC254726] Updated updateNavItemState() with accessibility attribute
   *                              when the in-page navigation button is disabled.
   * 24-Aug-2015  AB  [CR00465809] Dynamic browser tab titles.
   * 17-Oct-2014  MV  [CR00447421] Remove logic for refreshing on a tab load.
   *                               Moved to refresh controller.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 18-Oct-2012  SK [CR00346419] Additional memory clean-up when closing a tab.
   * 10-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
   * 07-Oct-2011  PK  [CR00289859] Dojo 1.6.1 upgrade and IE9+ support. 
   * 29-Jul-2011  MV  [CR00269970] Renaming class and event related to UI refresh.
   * 14-Feb-2011  MV  [CR00251754] Support re-displaying navigation tabs
   *    at a correct position.
   * 24-Jan-2011  JY  [CR00244068] Fix the border lines on the lists when flicking
   *                               between navigation tabs.
   * 08-Dec-2010  SC  [CR00232831] Updated to resolve issue with highlighting
   * 03-Dec-2010  MV  [CR00232963] Fix hiding and disabling of navigation items. 
   * 29-Nov-2010  MV  [CR00232623] Blank out child navigation buttons
   *    when switching tabs.
   * 23-Nov-2010  MV  [CR00232063] Rename tab navigation JavaScript to follow
   *   conventions. Only display child navs after the content has loaded.
   * 26-Aug-2010 MV  [CR00217499] Replace the use of escape() with the proper
   *      function to encode URL parameters. 
   * 19-Aug-2010  SJ [CR00213476] Removed the support that parses page parameter in URL  
   *                              from here and moved the same functionality to renderer.
   * 19-Jul-2010 AF  [CR00210899] Modified toggleChildMenu method so that it no
   *                              longer references dojo components.
   * 12-Jul-2010 MV  [CR00210064] Use CSS classes for styling navigation items.
   *                  Add further comments. Fix first level dynamic nav items.
   * 07-Jul-2010 MV  [CR00180694] Implement dynamic state update for navigation
   *                  items. Move JavaScript code from renderer to here.
   */
  
  /**
   * Manages the Navigation widget for the content area of the a Tab workspace.
   * 
   */
  curam.define.singleton("curam.util.TabNavigation", {
    CACHE_BUSTER: 0,
    CACHE_BUSTER_PARAM_NAME: "o3nocache",
    
    /**
     * Holds the ids of navigation items that should be disabled, i.e. not react
     * to the onclick events.
     */
    disabledItems: {},
    
    /**
     * Holds the list of navigation tabs for each object tab. To be used for
     * ordering of navigation tabs.
     */
    tabLists: {},
        
    /**
     * Initialize for a specific tab.
     */
    init: function(tabId, tabWidgetId) {
      // Subscribe to the select event on the Stack container.
      // Note, even though it is called child-nav-selectChild what has really happened is 
      // a parent menu item has been selected, which selects a child in the StackContainer.
      var childNav = tabId + "child-nav-selectChild";
      var parentSelectF = dojo.subscribe(childNav, "", function() {
        curam.util.TabNavigation.onParentSelect(null, tabId);
      });
      curam.tab.unsubscribeOnTabClose(parentSelectF, tabWidgetId);
    },
    
    /**
     * Re-act to a parent menu item being selected.
     * 
     * When a parent is selected find the related stack representing
     * the child menus and bring that one to the front. If it 
     * contains a set of child menus display it. Finally load
     * the page that is referenced from the child stack in the iframe.
     * 
     * @param parentMenuItem The object selected in the parent menu.
     *
     */
    onParentSelect: function(parentMenuItem, tabId) {
      // Get the child stack
      var childStackContainerId = tabId  + "-child-nav";   
      var childStackContainer = registry.byId(childStackContainerId);
      var loadPage = true;

      // If no parent menu item was passed to this function then
      // just get the currently selected one.
      if (!parentMenuItem){
        var loadPage = false;
        var parentTabContainerId = tabId  + "-parent-nav";
        var parentTabContainer = registry.byId(parentTabContainerId);
        parentMenuItem = parentTabContainer.selectedChildWidget;
      }

      // If the link was selected via a manual call to selectChild,
      // This attribute will be set and no call should be made to reload
      // the page - it has already been loaded by a content area link.
      if (parentMenuItem.curamDoNoReload) {
        loadPage = false;
        parentMenuItem.setAttribute("curamDoNoReload", null);
      }

      var childStackId = parentMenuItem.id + "-Stack";
      var childStack = registry.byId(childStackId);
        
      // Get the related child stack
      var href = domAttr.get(childStack.get("srcNodeRef"), "page-ref");
      
      // If the parent menu item does not have a direct page link find its child 
      // item that is selected and use that. If none found throw an error.
      if (!href) {
        var selectedChild = childStack;

        if(selectedChild) {
          var link = dojo.query("li.selected > div.link", selectedChild.id)[0];
          href = domAttr.get(link, "page-ref");
          
        } else {
          throw new Error("Could not find a page reference. The menu item '" 
           + parentMenuItem.id 
           + "' has no page reference and no selected child item was found.");       
        }
      }
      
      if(loadPage) {
        var ifr = curam.util.TabNavigation.getIframe(tabId);
        
        //Get the dom node 'body' inside the iframe
        if(dojo.isIE && dojo.isIE < 9) {
          ifrBody = ifr.contentWindow.document.body;
        } else {
          ifrBody = ifr.contentDocument.activeElement;
        }

        // run the following after the page has loaded in the iframe
        var postIframeLoadHandler = function() {
          childStackContainer.selectChild(childStack);
          domStyle.set(childStackContainer.domNode, "visibility", "visible");
          domStyle.set(ifr, "visibility", "visible");
          domStyle.set(ifr, "opacity", "1");

          // Update the browser tab title
          curam.debug.log("curam.util.TabNavigation.postIframeLoadHandler anon function calling curam.util.setBrowserTabTitle");
          curam.util.setBrowserTabTitle();
        };

        // now the onload event handling machinery, different for IE
        // and other browsers
        if (dojo.isIE && dojo.isIE < 9) {
          var lh = function() {
            if (ifr.readyState == "complete") {
              ifr.detachEvent('onreadystatechange', lh);
              postIframeLoadHandler();
            }
          };
          ifr.attachEvent('onreadystatechange', lh);
        
        } else {
          var dt = dojo.connect(ifr, "onload", null, function() {
            dojo.disconnect(dt);
            postIframeLoadHandler();
          });
        }
      
        // Load the target page in the iframe.
        
        //Hidden the borders in the lists by adding a specific CSS class
        dojo.query("div.list", ifrBody).forEach(function(node){
          domClass.add(node, "hidden");
        });
        
        domStyle.set(ifr, "opacity", "0");
        domStyle.set(childStackContainer.domNode, "visibility", "hidden");
        curam.util.TabNavigation.loadIframe(href, tabId);
      }
      
      // If there are no child menu items for the new page then hide the child menu.
      var open = curam.util.TabNavigation.childMenuExists(parentMenuItem);
      curam.util.TabNavigation.toggleChildMenu(open, tabId);
    },
    
    /**
     * Check if a child menu exists for the given parent menu item.
     *
     * @param parentMenuItem The object selected in the parent menu.
     *
     * @return True if the parent menu item has a child menu.
     */
    childMenuExists: function(parentMenuItem) {
      var stackId = parentMenuItem.id + "-Stack";
      var childMenus = dojo.query("#" + stackId + " ul");
      if(childMenus.length == 0) {
        return false;
      
      } else {
        return true;
      }
    },
    
    /**
     * Show or Hide the child menu panel.
     * 
     * Uses the "child-menu-width" attribute of the navigator widget to 
     * decide the width of the open panel.
     *
     * @param open A boolean value indicating whether the child menu panel
     * is to be displayed or hidden.
     */
    toggleChildMenu: function (open, tabId) {
      var navigationTabId = tabId + "-navigation-tab";
      var navigationTab = dom.byId(navigationTabId);
      var contentPanel = dojo.query(".content-area-container", navigationTab)[0];
      var childNavPanel = dojo.query(".child-nav", navigationTab)[0]; 

      if(!open) {
        var closedWidth = "0px";
        var leftObj = ((domStyle.getComputedStyle(contentPanel).direction == "ltr") ? { left: closedWidth } : { right: closedWidth });
        var widthObj = { width: closedWidth };
        domStyle.set(contentPanel, leftObj);
        domStyle.set(childNavPanel, widthObj);

      } else {
        var openWidth = domAttr.get(navigationTab, "child-menu-width");
        var leftObj = ((domStyle.getComputedStyle(contentPanel).direction == "ltr") ? { left: openWidth } : { right: openWidth });
        var widthObj = { width: openWidth };
        domStyle.set(contentPanel, leftObj);
        domStyle.set(childNavPanel, widthObj);
      }
    },
    
    /**
     * Handle selection of a child menu item.
     *
     * Given the selected item...
     * <ol>
     *  <li>load the referenced page in the iframe.</li>
     *  <li>clear the highlight on all child menu items.</li> 
     *  <li>highlight the selected child.</li>
     * </ol>
     * @param selectedItem the selected child item.
     */
    handleChildSelect: function (selectedItem, tabId, event) {
      if (!curam.util.TabNavigation.isSelectable(selectedItem.parentNode.id)) {
        dojo.stopEvent(dojo.fixEvent(event));
        return false;
      }
       
      var ul = curam.util.TabNavigation.getNext(selectedItem,"UL");
      
      var menuItems = ul.childNodes;
      
      // Reset all
      for(var i=0;i<menuItems.length;i++) {
        domClass.replace(menuItems[i], "not-selected", "selected");
      }
      // Set selected
      domClass.replace(selectedItem.parentNode, "selected", "not-selected");
      
      // Load the target
      var href = domAttr.get(selectedItem,"page-ref");
      curam.util.TabNavigation.loadIframe(href, tabId);
      
      return true;
    },
    
    isSelectable: function(tabId) {
      // Summary:
      //    Checks if the specified item should be processed as enabled.

      return !curam.util.TabNavigation.disabledItems[tabId];
    },
    
    getNext: function(startingNode, targetNodeName) {
       // Summary:
       //   Search UP from the given Node for the first instance of the target
       //   Node.
       //@param startingNode The Node from which the search will start.
       //@param targetNodeName The tag name of the node being sought.
       //@return The target Node.

      var parent = startingNode.parentNode;
      if(parent == null) {
        curam.debug.log(debug.getProperty("curam.util.TabNavigation.error",
                                           [targetNodeName]));
        return null;
      }

      if (parent.nodeName===targetNodeName) {
        return parent;
      
      } else {
        var parent = curam.util.TabNavigation.getNext(parent, targetNodeName);
        return parent;
      }
    },
   
    /**
     * Load the Iframe with the target page.
     */
    loadIframe: function(href, tabId) {
      var iframe = curam.util.TabNavigation.getIframe(tabId);

      curam.util.getTopmostWindow().dojo.publish('/curam/progress/display',
              [registry.getEnclosingWidget(iframe).domNode]);
      
      domAttr.set(iframe, "src", href + "&" + this.getCacheBusterParameter());
    },
    
    /**
     * Return the Iframe for the navigator.
     */
    getIframe: function(tabId) {
      var navigationTabId = tabId + "-navigation-tab";
      var navigationTab = dom.byId(navigationTabId);
      var iframes = dojo.query('iframe', navigationTab);
      return iframes[0];
    },
   
    getCacheBusterParameter: function() {
      return this.CACHE_BUSTER_PARAM_NAME + "=" 
          + new Date().getTime() + "_" 
          + this.CACHE_BUSTER++;
    },
   
    /**
     * 
     * Summary:
     * The listener calls the handler function when the page is loaded.
     * The listener is attached to the ContentPane widget. This has the
     * advantage that the listener is destroyed with the ContentPane.
     * (i.e. when the tab is closed.)
     * A second listener re-acts to selection of a tab.
     * 
     * @param dojoTabID The dojo tab ID
     * @param channel The navigation tab channel
     * @param invisible The list of tab IDs that should be hidden by default
     */
    setupOnParentSelect: function(dojoTabID, channel, hiddenTabs) {

      var widgetNode = dom.byId(dojoTabID + "-navigation-tab");
      var contentPane = curam.tab.getContainerTab(widgetNode);
      contentPane.subscribe(dojoTabID + "-child-nav-startup", function() {
        curam.util.TabNavigation.onParentSelect(null, dojoTabID);
        
        // For the listed tabs, ensure they are hidden by default
        var tabs = hiddenTabs.split(',');
        for (tabID in tabs) {
          var widget = 
            curam.util.TabNavigation.findNavItem("navItem_" 
                + this.id + "_" + tabs[tabID]);
          if (widget != null) {
            // Only if the widget exist, set to false to hide
            widget.set("curamVisible", false);
          }
        }                
      });
      
      contentPane.subscribe(channel, function(selected) {
        curam.util.TabNavigation.onParentSelect(selected, dojoTabID);
      });
    },

    /**
      * Setup the data and handlers necessary for dynamically updating
      * the tab navigation.
      *
      * @param tabWidgetId ID of the tab for the navigation.
      */
    setupRefresh: function(tabWidgetId) {

      curam.util.Refresh.setNavigationCallbacks(
          curam.util.TabNavigation.updateNavItemStates,
          curam.util.TabNavigation.getRefreshParams);

    },
   
    getRefreshParams: function(tabWidgetId) {
      // Summary:
      //    Returns URL parameters for getting updated state of navigation items.

      curam.debug.log("curam.util.TabNavigation.getRefreshParams(%s)", tabWidgetId);

      var navData = curam.util.TabNavigation.dynamicNavigationData[tabWidgetId];
      if (!navData) {
        curam.debug
          .log(debug.getProperty("curam.util.TabNavigation.no.dynamic"));
        return null;
      }

      // create the parameters required by the loaders code on the server side
      var params = "navId=" + navData.navigationId;
      params += "&navItemIds="
          + curam.util.toCommaSeparatedList(navData.dynamicNavItemIds);

      params += "&navLoaders="
          + curam.util.toCommaSeparatedList(navData.dynamicNavLoaders);

      params += "&navPageParameters=" + navData.pageParameters;
      
       return params;
    },
    
    updateNavItemStates: function(tabWidetId, data) {
      // Summary:
      //    Loops through the nav items in the result structure and updates
      //    the corresponding widgets.

      var result = data.navData;
      for (var i = 0; i < result.itemStates.length; i++) {
        curam.util.TabNavigation.updateNavItemState(result.itemStates[i], tabWidetId);
      }
      curam.util.TabNavigation._updateAriaMarkupForEnabledAndDisabledNavigationTabs();
    },

    _updateAriaMarkupForEnabledAndDisabledNavigationTabs: function (){
      var tabList;
      var totalNumberOfDisabledTabs;
      var resetCounter = "true";
      var disabledTabNameList = [];
      var tabListsContainerWrapper = dojo.query(".dijitTabContainerTop-tabs");
      var bundle = new curam.util.ResourceBundle("TabNavigation");

      tabListsContainerWrapper.forEach(function(tabListContainer){
        tabList = dojo.query('.tabLabel', tabListContainer);

        if(tabList.length > 0 && resetCounter == 'true'){
          totalNumberOfDisabledTabs = 0;
          disabledTabNameList = [];
          resetCounter = "false";
        }

          //Get a count of enabled/disabled tabs, save the names of the disabled ones
          //and update aria mark up at same occasion.
          tabList.forEach(function(tab){
            var divTabContainerId = tab.id+"_tabButtonContainer";
		    var divTabContainer = dojo.byId(divTabContainerId);
            if(!domClass.contains(divTabContainer, "disabled") &&
            (domClass.contains(divTabContainer, "visible") || domClass.contains(divTabContainer, "enabled, dijitChecked"))){       
              domAttr.set(tab, "aria-disabled", "false");
            }else{
              domAttr.set(tab, "aria-disabled", "true");
              totalNumberOfDisabledTabs++;
              var disabledTabName = domAttr.get(tab,'title');
              if(typeof(disabledTabName)!='undefined')
                disabledTabNameList.push(" " + disabledTabName);
            }
          });

          //Once we know the number of enabled/disabled tabs update aria markup
          tabList.forEach(function(tab, index){
            var tabAriaDisabledState = domAttr.get(tab,'aria-disabled');
            if(tabAriaDisabledState == "false"){
              var tabContext;
              var label = tabList[index].innerHTML;
              tab.setAttribute("title", label);
              if(totalNumberOfDisabledTabs == 1){
                tab.removeAttribute("aria-labelledby");
                tabContext =". " + bundle.getProperty("curam.navigation.tab") + " " + (index + 1) + " "
                + LOCALISED_TABCONTAINER_CONTEXT_OF
                + " " + tabList.length + ". " +  totalNumberOfDisabledTabs + " "
                + bundle.getProperty("curam.single.disabled.navigation.tab") + ": " + disabledTabNameList +".";
                tab.setAttribute("aria-label", label + tabContext);
              }else if(totalNumberOfDisabledTabs > 1){
                tab.removeAttribute("aria-labelledby");
                tabContext = ". " + bundle.getProperty("curam.navigation.tab") + " " + (index + 1) + " "
                + LOCALISED_TABCONTAINER_CONTEXT_OF
                + " " + tabList.length + ". " +  totalNumberOfDisabledTabs + " "
                + bundle.getProperty("curam.multiple.disabled.navigation.tab") + ": " + disabledTabNameList +".";
                tab.setAttribute("aria-label", label + tabContext);
              }else{
                tabContext =". " + bundle.getProperty("curam.navigation.tab") + " " + (index + 1) + " "
                + LOCALISED_TABCONTAINER_CONTEXT_OF
                + " " + tabList.length + ". ";
                tab.setAttribute("aria-label", label + tabContext);
              }
            }else{
              tab.removeAttribute("role");
              tab.removeAttribute("tabindex");
              tab.removeAttribute("aria-label");
            }
          });

        resetCounter = "true";
      });

    },

    /**
     * Updates the state (visibility and availability) of the specified
     * navigation item for the specified tab.
     */
    updateNavItemState: function(navItem, tabWidgetId) {

      var widget = curam.util.TabNavigation.findNavItem(
          "navItem_" + tabWidgetId + "_" + navItem.id);

      if (widget != null) {
        // handle side buttons (second level navigation)
        if (!widget.domNode) {
          // set the item as enabled/disabled for later use in the onclick handler
          curam.util.TabNavigation.disabledItems[widget.id] = !navItem.enabled;
          
          // set the appropriate visual styling for disabled items
          curam.util.swapState(widget, navItem.enabled, "enabled", "disabled");
          
          // show/hide items
          curam.util.swapState(widget, navItem.visible, "visible", "hidden");
          
          // add accessibility mark-up if button link is disabled
          var islinkButtonStateDisabled = domAttr.get(widget,"class").indexOf("disabled") > 0 ? true: false;
          if (islinkButtonStateDisabled){
            domAttr.set(widget.children[0],"aria-disabled", "true");
          }
        // handle Dojo tabs (first level navigation)
        } else {
          // set the item as enabled/disabled
          widget.set("curamDisabled", !navItem.enabled);
          widget.set("curamVisible",  navItem.visible);
        }
      }
    },
    
    findNavItem: function(className) {
      // Summary:
      //    Finds a navigation item by ID.
      // Distinguishes between navigation tabs and side buttons and returns
      // the appropriate one for the given ID.

      var nodes = dojo.query("." + className);
      if (nodes.length == 1) {
        var node = nodes[0];
        var widget = dijit.byNode(node);
        
        if (!widget) {
          // it is a side button
          return node;
        
        } else {
          // it is a Dijit tab, return its control button
          return widget.controlButton;
        }
      
      } else {
        curam.debug.log(debug
          .getProperty("curam.util.TabNavigation.item", [className]));
        return null;
      }
    },
    
    addRollOverClass: function (event) {
      // Summary:
      //   Adds hover class name to page group navigation items. This
      //   class name is then removed when the mouse moves off the item.
      domClass.add(event.target,"hover");
      curam.util.connect(event.target, "onmouseout", function(){
        domClass.remove(event.target,"hover");
      });
    },
    
    /**
     * Setup a listener for the page loaded event which can ensure
     * the correct tab is selected. This is called from the NavigationTabRenderer.
     */
    setupOnLoadListener: function(tabWidgetId, jsonPageToIdMap) {

      var pageToIdMap = dojo.fromJson(jsonPageToIdMap);
      var functionNavMap = function(pageId, tabWidgetId) {
        curam.util.TabNavigation.handleContentAreaUpdate(
          pageId, tabWidgetId, pageToIdMap);
      };
      var handler = curam.tab.getHandlerForTab(functionNavMap, tabWidgetId);
      var topWin = curam.util.getTopmostWindow();
      var unsubToken =
        topWin.dojo.subscribe("/curam/main-content/page/loaded", null, handler);
      curam.tab.unsubscribeOnTabClose(unsubToken, tabWidgetId);
    },
    
    /**
     * Sets up a tab list to be used for correct reordering of tabs when
     * they are hidden/redisplayed.
     * 
     * @param tabWidgetId
     *    The tab id for which the data is setup.
     * @param tabList
     *    An array of tab IDs in the right order. 
     */
    setupTabList: function(tabWidgetId, tabList) {
      if (!curam.util.TabNavigation.tabLists[tabWidgetId]) {
        curam.tab.executeOnTabClose(function() {
          delete curam.util.TabNavigation.tabLists[tabWidgetId];
        }, tabWidgetId);
      }
      delete curam.util.TabNavigation.tabLists[tabWidgetId];
      curam.util.TabNavigation.tabLists[tabWidgetId] = tabList;
    },
    
    /**
     * Correctly highlight the selected tab, as per the page loaded.
     * 
     * @param pageId The id of the page loaded in the content area.
     * @param tabWidgetId The id of the tab the content area is part of.
     */
    handleContentAreaUpdate: function(pageId, tabWidgetId, jsonPageToIdMap) {
      // Get the IDs of the relevant elements associated with the page id
      // If not found, the page is not associated with anything in the
      // tab and nothing is done
      var ids = jsonPageToIdMap[pageId];
      if (ids) {
        var dojoTabId = ids["dojoTabId"];
        var parentNavId = dojoTabId + "-parent-nav";
        var tabId = ids["tabId"];
        var childId = ids["childId"];

        // Get the widgets using the IDs
        var tabWidget = registry.byId(tabId);
        var navTabContainer = registry.byId(parentNavId);
        if (tabWidget) {
          if (navTabContainer.selectedChildWidget != tabWidget) {
            // Only set selected child if not already
            // curamDoNoReload indicates that the content area page should not be 
            // updated. See TabNavigation.onParentSelect for usage.
            tabWidget.setAttribute("curamDoNoReload", true);
            navTabContainer.selectChild(tabWidget);
          }

          // If there is a child Id defined, ensure it is selected and buttons
          // are displayed
          if (childId) {
            // Ensure the child menus are displayed
            var childStackId = tabId + "-Stack";
            var childStackContainerId = dojoTabId  + "-child-nav";   
            var childStackContainer = registry.byId(childStackContainerId);
            var childStack = registry.byId(childStackId);
            childStackContainer.selectChild(childStack);

            // Original query was not working consistently.
            // var childWidget = dojo.query('li#' + childId, childStack.domNode)[0];
            var liElements = dojo.query('li', childStack.domNode);
            for (var i = 0; i < liElements.length; i++) {
              var liElement = liElements[i];
              if (liElement.id == childId) {
                var childWidget = liElement;
              }
            }
            if (childWidget) {
              if (!domClass.contains(childWidget, "selected")) {
                // Reset current selected button
                var menuItems = childWidget.parentNode.childNodes;
                // Reset all to not selected
                for(var i=0; i < menuItems.length; i++) {
                  domClass.replace(menuItems[i], "not-selected", "selected");
                }
                // Set current one to selected
                domClass.replace(childWidget, "selected", "not-selected");
              }
            }
          }
        }
      }
    },
    
    /**
     * Works out the position at which a tab control button should be inserted
     * when it is being redisplayed.
     * 
     * @param tabWidgetId
     *    Id of the parent Object tab.
     * @param actualNavTabIds
     *    List of ids of the currently visible navigation tabs.
     * @param navTabId
     *    Id of the navigation tab the position is needed for.
     */
    getInsertIndex: function(tabWidgetId, actualNavTabIds, navTabId) {
      var tabList = curam.util.TabNavigation.tabLists[tabWidgetId];
      var initialIndex = dojo.indexOf(tabList, navTabId);
      var actualIndex = initialIndex;
      for (var i = initialIndex - 1; i >= 0; i--) {
        if (dojo.indexOf(actualNavTabIds, tabList[i]) < 0) {
          actualIndex--;
        }
      }
      return actualIndex;
    }
  });  
  layer.register("curam/util/TabNavigation", curam.util.TabNavigation);
  
  return curam.util.TabNavigation;
});

},
'dojo/store/Observable':function(){
define(["../_base/kernel", "../_base/lang", "../when", "../_base/array" /*=====, "./api/Store" =====*/
], function(kernel, lang, when, array /*=====, Store =====*/){

// module:
//		dojo/store/Observable

var Observable = function(/*Store*/ store){
	// summary:
	//		The Observable store wrapper takes a store and sets an observe method on query()
	//		results that can be used to monitor results for changes.
	//
	// description:
	//		Observable wraps an existing store so that notifications can be made when a query
	//		is performed.
	//
	// example:
	//		Create a Memory store that returns an observable query, and then log some
	//		information about that query.
	//
	//	|	var store = Observable(new Memory({
	//	|		data: [
	//	|			{id: 1, name: "one", prime: false},
	//	|			{id: 2, name: "two", even: true, prime: true},
	//	|			{id: 3, name: "three", prime: true},
	//	|			{id: 4, name: "four", even: true, prime: false},
	//	|			{id: 5, name: "five", prime: true}
	//	|		]
	//	|	}));
	//	|	var changes = [], results = store.query({ prime: true });
	//	|	var observer = results.observe(function(object, previousIndex, newIndex){
	//	|		changes.push({previousIndex:previousIndex, newIndex:newIndex, object:object});
	//	|	});
	//
	//		See the Observable tests for more information.

	var undef, queryUpdaters = [], revision = 0;
	// a Comet driven store could directly call notify to notify observers when data has
	// changed on the backend
	// create a new instance
	store = lang.delegate(store);
	
	store.notify = function(object, existingId){
		revision++;
		var updaters = queryUpdaters.slice();
		for(var i = 0, l = updaters.length; i < l; i++){
			updaters[i](object, existingId);
		}
	};
	var originalQuery = store.query;
	store.query = function(query, options){
		options = options || {};
		var results = originalQuery.apply(this, arguments);
		if(results && results.forEach){
			var nonPagedOptions = lang.mixin({}, options);
			delete nonPagedOptions.start;
			delete nonPagedOptions.count;

			var queryExecutor = store.queryEngine && store.queryEngine(query, nonPagedOptions);
			var queryRevision = revision;
			var listeners = [], queryUpdater;
			results.observe = function(listener, includeObjectUpdates){
				if(listeners.push(listener) == 1){
					// first listener was added, create the query checker and updater
					queryUpdaters.push(queryUpdater = function(changed, existingId){
						when(results, function(resultsArray){
							var atEnd = resultsArray.length != options.count;
							var i, l, listener;
							if(++queryRevision != revision){
								throw new Error("Query is out of date, you must observe() the query prior to any data modifications");
							}
							var removedObject, removedFrom = -1, insertedInto = -1;
							if(existingId !== undef){
								// remove the old one
								var filteredArray = [].concat(resultsArray);
								if(queryExecutor && !changed){
									filteredArray = queryExecutor(resultsArray);
								}
								for(i = 0, l = resultsArray.length; i < l; i++){
									var object = resultsArray[i];
									if(store.getIdentity(object) == existingId){
										if(filteredArray.indexOf(object)<0) continue;
										removedObject = object;
										removedFrom = i;
										if(queryExecutor || !changed){// if it was changed and we don't have a queryExecutor, we shouldn't remove it because updated objects would be eliminated
											resultsArray.splice(i, 1);
										}
										break;
									}
								}
							}
							if(queryExecutor){
								// add the new one
								if(changed &&
										// if a matches function exists, use that (probably more efficient)
										(queryExecutor.matches ? queryExecutor.matches(changed) : queryExecutor([changed]).length)){

									var firstInsertedInto = removedFrom > -1 ? 
										removedFrom : // put back in the original slot so it doesn't move unless it needs to (relying on a stable sort below)
										resultsArray.length;
									resultsArray.splice(firstInsertedInto, 0, changed); // add the new item
									insertedInto = array.indexOf(queryExecutor(resultsArray), changed); // sort it
									// we now need to push the change back into the original results array
									resultsArray.splice(firstInsertedInto, 1); // remove the inserted item from the previous index
									
									if((options.start && insertedInto == 0) ||
										(!atEnd && insertedInto == resultsArray.length)){
										// if it is at the end of the page, assume it goes into the prev or next page
										insertedInto = -1;
									}else{
										resultsArray.splice(insertedInto, 0, changed); // and insert into the results array with the correct index
									}
								}
							}else if(changed){
								// we don't have a queryEngine, so we can't provide any information
								// about where it was inserted or moved to. If it is an update, we leave it's position alone, other we at least indicate a new object
								if(existingId !== undef){
									// an update, keep the index the same
									insertedInto = removedFrom;
								}else if(!options.start){
									// a new object
									insertedInto = store.defaultIndex || 0;
									resultsArray.splice(insertedInto, 0, changed);
								}
							}
							if((removedFrom > -1 || insertedInto > -1) &&
									(includeObjectUpdates || !queryExecutor || (removedFrom != insertedInto))){
								var copyListeners = listeners.slice();
								for(i = 0;listener = copyListeners[i]; i++){
									listener(changed || removedObject, removedFrom, insertedInto);
								}
							}
						});
					});
				}
				var handle = {};
				// TODO: Remove cancel in 2.0.
				handle.remove = handle.cancel = function(){
					// remove this listener
					var index = array.indexOf(listeners, listener);
					if(index > -1){ // check to make sure we haven't already called cancel
						listeners.splice(index, 1);
						if(!listeners.length){
							// no more listeners, remove the query updater too
							queryUpdaters.splice(array.indexOf(queryUpdaters, queryUpdater), 1);
						}
					}
				};
				return handle;
			};
		}
		return results;
	};
	var inMethod;
	function whenFinished(method, action){
		var original = store[method];
		if(original){
			store[method] = function(value){
				var originalId;
				if(method === 'put'){
					originalId = store.getIdentity(value);
				}
				if(inMethod){
					// if one method calls another (like add() calling put()) we don't want two events
					return original.apply(this, arguments);
				}
				inMethod = true;
				try{
					var results = original.apply(this, arguments);
					when(results, function(results){
						action((typeof results == "object" && results) || value, originalId);
					});
					return results;
				}finally{
					inMethod = false;
				}
			};
		}
	}
	// monitor for updates by listening to these methods
	whenFinished("put", function(object, originalId){
		store.notify(object, originalId);
	});
	whenFinished("add", function(object){
		store.notify(object);
	});
	whenFinished("remove", function(id){
		store.notify(undefined, id);
	});

	return store;
};

lang.setObject("dojo.store.Observable", Observable);

return Observable;
});

},
'curam/pagination/ControlPanel':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 31-May-2022  FN [RTC261496] Fixing screen-reader issue for previous and next icons.
 * 28-Apr-2021  JD [RTC266247] Scroll browser viewport to top of list after new page
 * or page size is selected.
 * 23-Feb-2021  JD [RTC266247] Reset focus to list div container when new page is
 * selected or page size changes.
 * 08-Aug-2013  AW [CR00394139] Added date and time object to make unique identifier
 * for paginated list labels
 * 07-Jun-2013 NLH [CR00385557] Replace contrast images for Pagination item 
 * when high contrast mode is turned on.
 * 09-Oct-2012 BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012 MK [CR00323691] Use new Dojo AMD format.
 * 04-Apr-2012 MK [CR00316488] Replaced call to dojo.connect and 
 * dojo.disconnect to use the curam.util.connect and curam.util.disconnect.
 * 26-Sep-2011 NLH [CR00282407] Generate IMG tag for arrows which can be 
 * accessed by user.
 * 09-Jun-2011 MV [CR00269409] Stop event in click handlers to avoid side
 * effects.
 * 21-Jan-2011 DG [CR00243540] Changed "console.log" to "curam.debug.log".
 * 13-Dec-2010 MV [CR00237821] Miscellaneous bug fixes.
 * 29-Apr-2010 MV [CR00195109] Initialize variables properly per instance.
 * 13-Apr-2010 MV [CR00192550] Moved styling to a *.css file, externalized
 * localizable strings, added page size dropdown.
 * 10-Apr-2010 OK [CR00193314] Alterations to createLinkControl and createDropdownControl
 * functions to allow for a class name and title to be passed
 * 18-Mar-2010 MV [CR00136536] Initial version.
 */

/**
 * @name curam.pagination.ControlPanel
 * 
 * @namespace ControlPanel generates a GUI control panel for list pagination.
 */
define(["dijit/registry",
        "dojo/_base/declare",
        "dojo/dom-style",
        "dojo/dom-attr",
        "dojo/dom-class",
        "dojo/dom-construct",
        "dojo/sniff",
        "dojo/window",
        "curam/pagination", 
        "curam/debug", 
        "curam/util"
        ], function(registry, declare, domStyle, domAttr, domClass, domConstruct, has, winUtils) {

var ControlPanel = declare("curam.pagination.ControlPanel", null, 
/**
 * @lends uram.pagination.ControlPanel
 */    
{
  /** Control identifier constants. */
  first: "FIRST",
  last: "LAST",
  previous: "PREV",
  next: "NEXT",
  page: "GOTO_PAGE",
  pageSize: "PAGE_SIZE",
  rowInfo: "ROW_INFO",
  classFirst: "first",
  classLast: "last",
  classPrevious: "previous",
  classNext:"next",
  classPage:"page",
  classDisplayInfo:"display_info",
  

  /** The actual DOM nodes of the controls. Using object as an associative
   *  array, controls identified by the above identifiers.
   */
  _controls: undefined,
  
  currentPage: 0,
  
  lastPage: 9999,
  
  currentPageSize: 0,
  
  directLinkRangeWidth: 3,
  
  parentNode: undefined,
  
  handlers: undefined,
  
  directLinksDisconnects: undefined,

  constructor: function(parentNode) {
    this._controls = {};
    this.handlers = {};
    this.directLinksDisconnects = [];
    var loc = this._localize;
    
    // we need to create the HTML representation here so that after this function
    // finishes, the GUI can respond to state updates
    var ul = domConstruct.create("ul", null, parentNode);
    domClass.add(ul, "pagination-control-list");
    
    this._controls[this.pageSize] =
        this._createDropdownControl(this.pageSize, loc("pageSize_title"), ul);
    this._controls[this.rowInfo] =
        this._createDisplayControl(this.rowInfo, loc("pagination_info",
            ["$dummy$", "$dummy$", "$dummy$"]), ul,null,null);
    
    this._controls[this.first] = this._createLinkControl(this.first,
                loc("firstPage_btn"), ul, null, this.classFirst,loc("firstPage_title"));
    this._controls[this.previous] = this._createLinkControl(
        this.previous, loc("prevPage_btn"), ul, null, this.classPrevious,loc("prevPage_title"));

    this._controls[this.page] = [];
    this._controls[this.page].push(this._createLinkControl(this.page,
        "direct-page-links-section", ul, null, this.classPage,loc("page_title")));

    this._controls[this.next] = this._createLinkControl(this.next,
                loc("nextPage_btn"), ul, null, this.classNext,loc("nextPage_title"));
    this._controls[this.last] = this._createLinkControl(this.last,
                loc("lastPage_btn"), ul, null, this.classLast,loc("lastPage_title"));
    
    this.parentNode = parentNode;
    
    // display the control panel
    domStyle.set(parentNode, { "display":"" });
  },
  
  /**
   * Retrieves localized string for the given msgId and replaces any %s with
   * a corresponding value from the values array.
   */ 
  _localize: function(msgId, values) {
    var result = curam.pagination.localizedStrings[msgId];
    if (!values) {
      return result;
    }
    for (var i = 0; i < values.length; i++) {
      result = result.replace(/%s/i, values[i]);
    }
    return result;
  },
  
  _createLinkControl: function(identifier, text, refNode, position, cssName, title) {
    var cls = cssName != null ? cssName : "";
    var li = domConstruct.create("li", {
      "id": identifier,
      "class": cls
    }, refNode, position);
    domClass.add(li, "pagination-control-list-item enabled");
    
    var a = domConstruct.create("a", { "innerHTML": text, "href":"#", "title": title}, li);
    
    domClass.add(a, "pagination-link");
    
    // Generate a IMG element instead of a P element.This is done for accessibility reason.
    if (identifier == this.first || 
          identifier == this.last || 
          identifier == this.previous ||
          identifier == this.next ) {
            
     if(curam.util.highContrastModeType()){
        var imageName = "../CDEJ/themes/v6/images/high-contrast/" + identifier +"-contrast" + ".png";
        domConstruct.create("img", { "src": imageName, 
                                 "alt": title }, a);
      }else{      
        
        var imageName = "../CDEJ/themes/curam/images/" + identifier + ".svg";
        var hoverImageName = "../CDEJ/themes/curam/images/" + identifier + "_hover.svg";
        
        a.setAttribute("onfocus", "this.children[0].src = '" + hoverImageName + "';");
        a.setAttribute("onblur", "this.children[0].src = '" + imageName + "';");
        
        domConstruct.create("img", { "src": imageName, 
                                 "alt": title, 
                                 "onmouseover": "this.src = '" + hoverImageName + "';", 
                                 "onmouseout": "this.src = '" + imageName + "';", 
                                 "onmouseup": "this.src = '" + imageName + "';",
                                 "aria-hidden": "true" 
                                 }, a);
      }
      } else {
        var text = domConstruct.create("p", {"innerHTML": text}, li);
        domClass.add(text, "pagination-text");
      }

    return li;
  },

  _createDropdownControl: function(identifier, text, refNode, position) {
    var li = domConstruct.create("li", { "id": identifier }, refNode, position);
    domClass.add(li, "pagination-control-list-item");
    
    //Adding a date and time object that takes in the current date and time to make a unique id
    var selectIdentifier="page-size-select" + new Date().getTime();
    var label = domConstruct.create("label", { "innerHTML":text + ": ",
                                       "for":selectIdentifier}, li);
    domClass.add(label, "pagination-page-size-dropdown-label");
    var select = domConstruct.create("select", { "title":text,
                                       "id":selectIdentifier}, li);

    li._type = "dropdown";
    
    return li;
  },
  
  _createDisplayControl: function(identifier, text, refNode, position, cssName) {
    var cls = cssName != null ? cssName : "";
    var li = domConstruct.create("li", {
      "id": identifier,
      "class":cls
    }, refNode, position);
    domClass.add(li, "pagination-control-list-item");


    var text = domConstruct.create("p", { "innerHTML": "[" + text + "]" }, li);
    
    return li;
  },

  /*
   * state.pageSizeOptions :: Array of page size options to show
   * state.currentPageSize :: Number
   * state.first :: Boolean
   * state.previous :: Boolean
   * state.next :: Boolean
   * state.last :: Boolean
   * state.currentPage :: Number
   * state.lastPage :: Number
   * state.rowInfo :: Array (triple of Numbers) -> [rowFrom, rowTo, totalRows]
   * state.directLinkRangeWidth :: Number signifying the number of links to show
   *                                           on each side of the current page.
   */
  updateState: function(state) {
    curam.debug.log("curam.pagination.ControlPanel.updateState: ", state);
    if (typeof(state.first) != "undefined") {
      this._setEnabled(this._controls[this.first], state.first);
    }
    if (typeof(state.previous) != "undefined") {
      this._setEnabled(this._controls[this.previous], state.previous);
    }
    if (typeof(state.next) != "undefined") {
      this._setEnabled(this._controls[this.next], state.next);
    }
    if (typeof(state.last) != "undefined") {
      this._setEnabled(this._controls[this.last], state.last);
    }
    if (typeof(state.currentPage) != "undefined") {
      this.currentPage = state.currentPage;
    }
    if (typeof(state.lastPage) != "undefined") {
      this.lastPage = state.lastPage;
    }
    if (typeof(state.currentPageSize) != "undefined") {
      this.currentPageSize = state.currentPageSize;
    }
    if (typeof(state.directLinkRangeWidth) != "undefined") {
      this.directLinkRangeWidth = state.directLinkRangeWidth;
    }
    if (typeof(state.rowInfo) != "undefined") {
      var refNode = this._controls[this.rowInfo].previousSibling;
      domConstruct.destroy(this._controls[this.rowInfo]);
      var start = state.rowInfo[0];
      var end = state.rowInfo[1];
      var numRows = state.rowInfo[2];
      var infoText = this._localize("pagination_info", [start, end, numRows])
      this._controls[this.rowInfo] = this._createDisplayControl(this.rowInfo,
          infoText, refNode, "after",this.classDisplayInfo);
    }
    if (typeof(state.pageSizeOptions) != "undefined") {
      var select = dojo.query("select", this._controls[this.pageSize])[0];
      // remove all options
      dojo.forEach(select.childNodes, function(item) {
        domConstruct.destroy(item);
      });
      // add new ones based on new state
      for (var i = 0; i < state.pageSizeOptions.length; i++) {
        var optionValue = state.pageSizeOptions[i];
        var option = domConstruct.create("option",
            { "value":optionValue, "innerHTML":optionValue }, select);
        if (optionValue == this.currentPageSize) {
          domAttr.set(option, "selected", "selected");
        }
      }
    }
    this._updateDirectLinks();
    
    // Force Redraw of content area, due to no scroll bars appearing in IE
    var contentNode = registry.byId("content");
    if (contentNode) {
      contentNode.resize();
    }
  },

  /**
   * handlers.first = this.gotoFirst;
   * handlers.last = this.gotoLast;
   * handlers.previous = this.gotoPrevious;
   * handlers.next = this.gotoNext;
   * handlers.page = this.gotoPage;
   * handlers.pageSize = this.changePageSize;
   */
  setHandlers: function(handlers) {
    curam.debug.log("curam.pagination.ControlPanel.setHandlers: ", handlers);
    // save them for later use
    this.handlers = handlers;
    
    if (handlers.first) {
      this._connectSimpleHandler(this._controls[this.first], handlers.first);
    }
    if (handlers.previous) {
      this._connectSimpleHandler(this._controls[this.previous], handlers.previous);
    }
    if (handlers.next) {
      this._connectSimpleHandler(this._controls[this.next], handlers.next);
    }
    if (handlers.last) {
      this._connectSimpleHandler(this._controls[this.last], handlers.last);
    }
    if (handlers.page) {
      this._connectDirectLinkHandlers(handlers.page);
    }
    if (handlers.pageSize) {
      var select = dojo.query("select", this._controls[this.pageSize])[0];
      var _setFocusToListDivContainerAfterNewPageSelected = this._setFocusToListDivContainerAfterNewPageSelected;
      dojo.connect(select, "onchange",
          dojo.hitch(this, function(event) {
            var newPageSize = event.target.value
            this.currentPageSize = newPageSize;
            handlers.pageSize(this.currentPageSize);
                
            var listControlSelect = event.currentTarget;
            if (listControlSelect && 
                  domClass.contains(listControlSelect.parentElement, "pagination-control-list-item")) {
              
              var listControlSelectParent = listControlSelect.parentElement;
              _setFocusToListDivContainerAfterNewPageSelected(listControlSelectParent);
            }
            
            var options = dojo.query("option", select);
            options.forEach(function(option) {
              if (domAttr.get(option, "value") == newPageSize) {
                domAttr.set(option, "selected", "selected");
              } else {
                domAttr.remove(option, "selected");
              }
            });
          }));
    }
  },
  
  _connectSimpleHandler: function(control, handler) {
    var h = handler ? handler : control._handler;
    this._removeSimpleHandler(control);
    var _setFocusToListDivContainerAfterNewPageSelected = this._setFocusToListDivContainerAfterNewPageSelected;
    var disconnect = curam.util.connect(control, "onclick", function(event) {
      dojo.stopEvent(event);
      h();
      
      var paginationControlListItem = event.currentTarget;
      if (paginationControlListItem && 
          domClass.contains(paginationControlListItem, "pagination-control-list-item")) {
          
          var paginationControlListItemParent = paginationControlListItem.parentElement;
          _setFocusToListDivContainerAfterNewPageSelected(paginationControlListItemParent);
      }
      
    });
    control._handler = h;
    control._disconnect = disconnect;
  },
  
  _removeSimpleHandler: function(control) {
    if (control._disconnect) {
      curam.util.disconnect(control._disconnect);
    }
  },

  reset: function() {
    curam.debug.log("curam.pagination.ControlPanel.reset");
  },

  _getDirectLinkPageNumbers: function() {
    // We will show this.directLinkRangeWidth direct links on each side
    // of the current page.
    var numLinks = 2 * this.directLinkRangeWidth + 1; // +1 for the current page number in the middle
    var p = this.currentPage;
    var numbers = [];
    
    var num = p > this.directLinkRangeWidth ? p - this.directLinkRangeWidth : 1;
    for (var i = 0; i < numLinks; i++) {
      numbers[i] = num++;
      if (num > this.lastPage) {
        // break early if the last page was reached
        break;
      }
    }

    return numbers;
  },
  
  _updateDirectLinks: function() {
    curam.debug.log("curam.pagination.ControlPanel._updateDirectLinks");
    var loc = this._localize;
    var directLinks = this._controls[this.page];
    dojo.query("div.pagination-direct-links-dots").forEach(domConstruct.destroy);
    var referenceNode = directLinks[0].previousSibling;
    domStyle.set(this.parentNode, "display", "none");
    // remove all the links
    for (var i = 0; i < directLinks.length; i++) {
      if (directLinks._dots) {
        domConstruct.destroy(directLinks._dots);
      }
      domConstruct.destroy(directLinks[i]);
      directLinks[i] = undefined;
    }
      
    this._controls[this.page] = [];
    directLinks = this._controls[this.page];
    var pageNums = this._getDirectLinkPageNumbers();
    for (var i = 0; i < pageNums.length; i++) {
      var pageNum = pageNums[i];
      directLinks[i] = this._createLinkControl(
          this.page + "(" + pageNum + ")", pageNum, referenceNode, "after", null, loc("page_title") + " " + pageNum);
      domClass.add(directLinks[i], "pagination-direct-link");
      if (pageNum == this.currentPage) {
        domClass.add(directLinks[i], "selected");
      }
      referenceNode = directLinks[i];
      // set this for later use by the handler function
      directLinks[i]._pageNum = pageNum;
    }
    
    var firstDirectLink = directLinks[0];
    domClass.add(firstDirectLink, "firstDirectLink");
    if (pageNums[0] > 1) {
      domClass.add(firstDirectLink, "has-previous");
      var dots = domConstruct.create("div", { innerHTML:"..." }, firstDirectLink, "before");
      domClass.add(dots, "pagination-direct-links-dots");
    }
    var lastDirectLink = directLinks[directLinks.length - 1];
    domClass.add(lastDirectLink, "lastDirectLink");
    if (pageNums[pageNums.length - 1] < this.lastPage) {
      domClass.add(lastDirectLink, "has-next");
      var dots = domConstruct.create("div", { innerHTML:"..." }, lastDirectLink, "after");
      domClass.add(dots, "pagination-direct-links-dots");
    }
    
    if (this.handlers.page) {
      this._connectDirectLinkHandlers(this.handlers.page);
    }
    
    domStyle.set(this.parentNode, "display", "");
  },
  
  _connectDirectLinkHandlers: function(handler) {
    dojo.forEach(this.directLinksDisconnects, dojo.disconnect);
    this.directLinksDisconnects = [];
    
    var directPageLinks = this._controls[this.page];
    for (var i = 0; i < directPageLinks.length; i++) {
      var dLink = directPageLinks[i];
      // the following code is a trick to allow access to the page number
      // after the loop has finished
      var _setFocusToListDivContainerAfterNewPageSelected = this._setFocusToListDivContainerAfterNewPageSelected;
      var h = function(event) {
        dojo.stopEvent(event);
        
        var paginationControlListItem = event.currentTarget;
        var paginationControlListItemParent = paginationControlListItem.parentElement;

        // this._pageNum accesses the page number set by the code after this
        // function is created below
        handler(this._pageNum);
        
        if (paginationControlListItem && 
             domClass.contains(paginationControlListItem, "pagination-control-list-item")) {
            
            if (!domClass.contains(paginationControlListItem, "selected")) {
              _setFocusToListDivContainerAfterNewPageSelected(paginationControlListItemParent);
            } else {
                var paginationControlListItemID = paginationControlListItem.id;
                var paginationControlListItemChildAnchor = dojo.query("a.pagination-link", paginationControlListItemParent.children[paginationControlListItemID])[0];
                
                if (paginationControlListItemChildAnchor) {
                  paginationControlListItemChildAnchor.focus();
                }
            }
            
        }
      };
      // now set the page number to be accessed from within the function
      h._pageNum = dLink._pageNum;
      this.directLinksDisconnects.push(dojo.connect(dLink, "onclick", h));
    }
  },
  
  _setEnabled: function(control, enabled) {
    if (enabled) {
      this._connectSimpleHandler(control);
      domClass.replace(control, "enabled", "disabled");
    
    } else {
      this._removeSimpleHandler(control);
      domClass.replace(control, "disabled", "enabled");
    }
  },
  
  /**
   * Moves the focus back to the list div container after a new list page has been displayed.
   */
  _setFocusToListDivContainerAfterNewPageSelected: function(paginationControlNodeItemParent) {
  
    var listHeaderDiv = "";
      
    while (paginationControlNodeItemParent !== null) {
        
      if (domClass.contains(paginationControlNodeItemParent, "list")) {
        listHeaderDiv = paginationControlNodeItemParent;
        break;
      } else {
        paginationControlNodeItemParent = paginationControlNodeItemParent.parentElement
      }
    }
      
    if (listHeaderDiv != "") {
      listHeaderDiv.setAttribute("tabindex", "-1");
      listHeaderDiv.focus();
      // Scroll to the top of the list. Edge Chromium/Chrome requires the native
      // listHeaderDiv.scrollIntoView() whereas in IE11 the page becomes offset
      // using the native function, so Dojo's window.scrollIntoView(node) is used
      // which corrects the offset. Dojo's function does not work in Edge Chromium/Chrome.
      has("trident") ? winUtils.scrollIntoView(listHeaderDiv) : listHeaderDiv.scrollIntoView();
    }
  }

});

return ControlPanel;
});

},
'dijit/form/MappedTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("msapp")
	"dojo/dom-construct", // domConstruct.place
	"./ValidationTextBox"
], function(declare, has, domConstruct, ValidationTextBox){

	// module:
	//		dijit/form/MappedTextBox

	return declare("dijit.form.MappedTextBox", ValidationTextBox, {
		// summary:
		//		A dijit/form/ValidationTextBox subclass which provides a base class for widgets that have
		//		a visible formatted display value, and a serializable
		//		value in a hidden input field which is actually sent to the server.
		// description:
		//		The visible display may
		//		be locale-dependent and interactive.  The value sent to the server is stored in a hidden
		//		input field which uses the `name` attribute declared by the original widget.  That value sent
		//		to the server is defined by the dijit/form/MappedTextBox.serialize() method and is typically
		//		locale-neutral.
		// tags:
		//		protected

		postMixInProperties: function(){
			this.inherited(arguments);

			// We want the name attribute to go to the hidden <input>, not the displayed <input>,
			// so override _FormWidget.postMixInProperties() setting of nameAttrSetting for IE.
			this.nameAttrSetting = "";
		},

		// Remap name attribute to be mapped to hidden node created in buildRendering(), rather than this.focusNode
		_setNameAttr: "valueNode",

		serialize: function(val /*=====, options =====*/){
			// summary:
			//		Overridable function used to convert the get('value') result to a canonical
			//		(non-localized) string.  For example, will print dates in ISO format, and
			//		numbers the same way as they are represented in javascript.
			// val: anything
			// options: Object?
			// tags:
			//		protected extension
			return val.toString ? val.toString() : ""; // String
		},

		toString: function(){
			// summary:
			//		Returns widget as a printable string using the widget's value
			// tags:
			//		protected
			var val = this.filter(this.get('value')); // call filter in case value is nonstring and filter has been customized
			return val != null ? (typeof val == "string" ? val : this.serialize(val, this.constraints)) : ""; // String
		},

		validate: function(){
			// Overrides `dijit/form/TextBox.validate`
			this.valueNode.value = this.toString();
			return this.inherited(arguments);
		},

		buildRendering: function(){
			// Overrides `dijit/_TemplatedMixin/buildRendering`

			this.inherited(arguments);

			// Create a hidden <input> node with the serialized value used for submit
			// (as opposed to the displayed value).
			// Passing in name as markup rather than relying on _setNameAttr custom setter above
			// to make query(input[name=...]) work on IE. (see #8660).
			// But not doing that for Windows 8 Store apps because it causes a security exception (see #16452).
			this.valueNode = domConstruct.place("<input type='hidden'" +
				((this.name && !has("msapp")) ? ' name="' + this.name.replace(/"/g, "&quot;") + '"' : "") + "/>",
				this.textbox, "after");
		},

		reset: function(){
			// Overrides `dijit/form/ValidationTextBox.reset` to
			// reset the hidden textbox value to ''
			this.valueNode.value = '';
			this.inherited(arguments);
		}
	});
});

},
'dojox/layout/ContentPane':function(){
define([
	"dojo/_base/lang",
	"dojo/_base/xhr",
	"dijit/layout/ContentPane",
	"dojox/html/_base",
	"dojo/_base/declare"
], function (lang, xhrUtil, ContentPane, htmlUtil, declare) {

return declare("dojox.layout.ContentPane", ContentPane, {
	// summary:
	//		An extended version of dijit.layout.ContentPane.
	//		Supports infile scripts and external ones declared by `<script src=''...>`
	//		relative path adjustments (content fetched from a different folder)
	//		`<style>` and `<link rel='stylesheet' href='..'>` tags,
	//		css paths inside cssText is adjusted (if you set adjustPaths = true)
	//
	//		NOTE that dojo.require in script in the fetched file isn't recommended
	//		Many widgets need to be required at page load to work properly

	// adjustPaths: Boolean
	//		Adjust relative paths in html string content to point to this page.
	//		Only useful if you grab content from a another folder then the current one
	adjustPaths: false,

	// cleanContent: Boolean
	//		Cleans content to make it less likely to generate DOM/JS errors.
	//		Useful if you send ContentPane a complete page, instead of a html fragment
	//		scans for:
	//
	//		- title Node, remove
	//		- DOCTYPE tag, remove
	cleanContent: false,

	// renderStyles: Boolean
	//		trigger/load styles in the content
	renderStyles: false,

	// executeScripts: Boolean
	//		Execute (eval) scripts that is found in the content
	executeScripts: true,

	// scriptHasHooks: Boolean
	//		replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	//		NOTE this name might change in the near future
	scriptHasHooks: false,

	ioMethod: xhrUtil.get,

	ioArgs: {},

	onExecError: function(/*Event*/ e){
		// summary:
		//		event callback, called on script error or on java handler error
		//		override and return your own html string if you want a some text
		//		displayed within the ContentPane
	},

	_setContent: function(cont){
		// override dijit.layout.ContentPane._setContent, to enable path adjustments
		
		var setter = this._contentSetter;
		if(! (setter && setter instanceof htmlUtil._ContentSetter)) {
			setter = this._contentSetter = new htmlUtil._ContentSetter({
				node: this.containerNode,
				_onError: lang.hitch(this, this._onError),
				onContentError: lang.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		// stash the params for the contentSetter to allow inheritance to work for _setContent
		this._contentSetterParams = {
			adjustPaths: Boolean(this.adjustPaths && (this.href||this.referencePath)),
			referencePath: this.href || this.referencePath,
			renderStyles: this.renderStyles,
			executeScripts: this.executeScripts,
			scriptHasHooks: this.scriptHasHooks,
			scriptHookReplacement: "dijit.byId('"+this.id+"')"
		};

		return this.inherited("_setContent", arguments);
	},
	// could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles

	destroy: function () {
		var setter = this._contentSetter;
		if (setter) {
			setter.tearDown();
		}
		this.inherited(arguments);
	}
});
});

},
'curam/date/locale':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2014, 2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 13-Sep-2019 DR  [RTC251863]  Added parseDate() function.
   * 10-Jan-2014 SK  [CR00411875] Month names override implemented.
   * 08-Jan-2014 MV  [CR00411875] Initial version.
   */

define(['curam/define',
        'dojo/_base/lang',
        'dojo/date/locale'
        ], function(define, lang, dojoDateLib) {
  var origGetGregorianBundle = dojoDateLib._getGregorianBundle;
  function getCuramGregorianBundle(/*String*/ locale) {
    var origBundle = origGetGregorianBundle(locale);
    // override values
    if(LOCALIZED_MONTH_NAMES){
      origBundle["months-format-abbr"]=LOCALIZED_SHORT_MONTH_NAMES;
      origBundle["months-format-wide"]=LOCALIZED_MONTH_NAMES;
    }
    return origBundle;
  };
  
  define.singleton("curam.date.locale", {});
  // creating our own version of dojo/date/locale
  lang.mixin(curam.date.locale, dojoDateLib);
  
  curam.date.locale.format = function(/*Date*/ dateObject,
      /*__FormatOptions?*/ options) {
    dojoDateLib._getGregorianBundle = getCuramGregorianBundle;
    var result = dojoDateLib.format(dateObject, options);
    dojoDateLib._getGregorianBundle = origGetGregorianBundle;
    return result;
  };

  /**
   * @name curam.date.locale.parseDate
	* @description Converts a date string YYYY-MM-DD into a JavaScript date 
	* which will take the time zone into account so that 
	* when the JavaScript date is converted back into YYYY-DD-MM,
  * it displays the original dateString value. YYYY-MM-DD is the ISO Date Format.
  * @param dateString is the date to adjust with the Time Zones. It is in String format. 
	*/
	curam.date.locale.parseDate = function(dateString) {
    var localisedDate = new Date(dateString);
    return new Date(localisedDate.getTime() + localisedDate.getTimezoneOffset() * 60000);
};
  
  curam.date.locale.parse = function(/*String*/ value,
      /*__FormatOptions?*/ options) {
    dojoDateLib._getGregorianBundle = getCuramGregorianBundle;
    var result = dojoDateLib.parse(value, options);
    dojoDateLib._getGregorianBundle = origGetGregorianBundle;
    return result;
  };

  return curam.date.locale;
});

},
'curam/util/WordFileEdit':function(){
/*
 * Copyright 2009-2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/has",
        "dojo/dom",
        "dojo/dom-style",
        "dojo/dom-construct",
        "curam/define",
        "curam/debug",
        "dijit/DialogUnderlay"
        ], function(has, dom, domStyle, domConstruct, define, debug) {

/*
 * Modification History
 * --------------------
 * 22-Mar-2021 COF [RTC269312] Mark applet code as deprecated.
 * 22-Oct-2014  MV [CR00447541] Support IE11. 
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 12-Apr-2013  MV [CR00381021] Extend IE version detection to v10 and beyond
 *      for allowed URL handling.
 * 20-Feb-2013  MV [CR00367709] Extend IE version detection to v9 for allowed
 *      URL handling.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 15-Dec-2011  MV [CR00299726] Skip the plugin detection for Chrome.
 * 12-Jul-2011  MV [CR00269970] Add extra tracing to applet initialization.
 * 15-Dec-2010  MV [CR00238518] Add support for IE8, fix the way elements were
 *    being searched for in the document.
 * 26-Oct-2010  MV [CR00223441] JavaScript refactoring.
 * 06-Sep-2010  MV [CR00219321] Fixed problems with returning to the application
 *    after Word closes. Added overlay to stop user from clicking the parent
 *    window while Word is open. Renamed and moved to follow
 *    the JS code standards.
 */

    isIE8OrGreater = function() {
      // note IE < 7 is not supported!
      return has('ie') >= 8 || has('trident');
    };

/**
 * @namespace Contains the Word File Edit related code.
 */
  define.singleton("curam.util.WordFileEdit", {
  /**
   * Has the user finished the Word Edit?
   * @private
   */
  _clickedFinish: false,

  /**
   * Used to force the submit button to be clicked when finished editing.
   * @private
   */
  _buttonIdPart: "__o3btn.",

  /** The optional search window associated with a word integration session. */
  searchWindow: null,

  /** Holds a localizable error message. */
  cantLoadControlMsg: "$unlocalized$ cannot load Word integration control",

  /** Holds a localizable error message. */
  cantSubmitMsg: "$unlocalized$ cannot submit data",
  
  /** Holds a localizable window title prefix. */
  searchWindowTitlePrefix: "SEARCH",
  
  useApplet: (function() { return isIE8OrGreater(); })(),
  controlAttributes: {},
  controlParameters: {},

  /**
   * The Word document in a base64 string is passed back to IE.
   * Put the info in the textarea and submit the form to save.
   *
   * @param textareaName
   *                Name of textarea field in HTML document.
   * @param textareaValue
   *                Base64 encoded string to be put into textareaName.
   */
  submitSaveWordFileEdit: function(textareaName, textareaValue) {
    try {
      var parent = curam.util.WordFileEdit.getParentWindow();
      var input = curam.util.WordFileEdit._findTextArea(parent, textareaName);
      input.value = textareaValue;
      parent.document.forms[0].submit();

    } catch(e) {
      alert("Error saving: " +dojo.toJson(e));
    }

    return;
  },
  
  /**
   * Start the WordFileEdit ActiveX control.
   *
   * @param wfeId
   *          The unique ID generated each time the widget is run.
   * @param documentField
   *          The textarea field holding the encoded word document or template.
   * @param detailsField
   *          The encoded XML string containing the name/value pairs
   *          to be populated into the word template.
   */
  openWordFileEditWindow: function(wfeId, documentField, detailsField) {
    // Display the search window if an associated search URL has been defined.
    if (curam.util.WordFileEdit.getSearchPage().length>0) {
      curam.util.WordFileEdit.displaySearchWindow(
          wfeId, documentField, detailsField);

    } else {
      curam.util.WordFileEdit.doOpenWordFileEditWindow(
          wfeId,documentField,detailsField);
    }
  },
  
  /**
   * Launch the Word ActiveX control in a separate window.
   *
   * @param wfeId
   *          The unique ID generated each time the widget is run.
   * @param documentField
   *          The textarea field holding the encoded word document or template.
   * @param detailsField
   *          The encoded XML string containing the name/value pairs
   *          to be populated into the word template.
   */
  doOpenWordFileEditWindow: function(wfeId, documentField, detailsField) {
    var activeXWindowWidth = 100;  // width of ActiveX control window
    var activeXWindowHeight = 100; // height of ActiveX control window
    var activeXWindowLeft = Math.floor(
        (screen.width - activeXWindowWidth)/2);  // Find center of screen
    var activeXWindowTop = Math.floor(
        (screen.height - activeXWindowHeight)/2); // co-ords for new window
  
    window.open("../word-file-edit.jsp?id="
        + wfeId + "&document-field="
        + documentField + "&details-field="
        + detailsField, 
      new Date().valueOf(),
      "toolbar=no,menubar=no,location=no,scrollbars=no,"
        + "resizable=no,top=" 
        + activeXWindowTop 
        + ",left=" 
        + activeXWindowLeft 
        + ",width="
        + activeXWindowWidth 
        + ",height=" 
        + activeXWindowHeight);
  },
  
  /**
   * Launch the Curam Search window associated with the Word Document
   *
   * @param wfeId
   *          The unique ID generated each time the widget is run.
   * @param documentField
   *          The textarea field holding the encoded word document or template.
   * @param detailsField
   *          The encoded XML string containing the name/value pairs
   *          to be populated into the word template.
   * @param attempt
   *          The number of attempts made to relaunch the window.
   */
  displaySearchWindow: function(wfeId, documentField, detailsField, attempt) {
    if (!attempt) {
      attempt = 0;
    }
    if (attempt > 3 ) {
      return;
    }
    if (attempt == 0) {
      curam.util.WordFileEdit.searchWindow = window.open(
          "about:blank",
          'searchWindow',
          'left=40000,top=40000,scrollbars=yes');
    }
    var titleChanged = false;
    try {
      var searchWindowTitle = curam.util.WordFileEdit.searchWindow.document.title;
      if (searchWindowTitle.indexOf(searchWindowTitlePrefix + ":")==-1) {
        curam.util.WordFileEdit.searchWindow.document.title = 
                                    searchWindowTitlePrefix + ':' + wfeId;
      } else {
        titleChanged = true;
      }
      searchWindowTitle = curam.util.WordFileEdit.searchWindow.document.title;
      if (!titleChanged && 
            searchWindowTitle.indexOf(searchWindowTitlePrefix + ":")!=-1) {
        titleChanged = true;
      }
    } catch (e) {
    } // Cannot set title of new search window

    if (!titleChanged) {
      attempt++;
      window.setTimeout('displaySearchWindow(\'' + wfeId + '\',\''
          + documentField + '\',\'' + detailsField
          + '\',' + attempt + ')', 500);

    } else {
      curam.util.WordFileEdit.doOpenWordFileEditWindow(
          wfeId, documentField, detailsField);
    }
  },
  
  /**
   * Re-launch the Curam Search window associated with the Word Document
   *
   * @param wfeId
   *          The unique ID generated each time the widget is run.
   * @param attempt
   *          The number of attempts made to relaunch the window.
   */
  redisplaySearchWindow: function(wfeId, attempt) {
    if (!attempt) attempt = 0;
    if (attempt > 3 ) return;
    if (attempt == 0) {
      curam.util.WordFileEdit.searchWindow = window.open(
          "about:blank",'searchWindow','left=40000,top=40000');
    }
    var titleChanged = false;
    try {
      var searchWindowTitle = curam.util.WordFileEdit.searchWindow.document.title;
      if (searchWindowTitle.indexOf(searchWindowTitlePrefix + ":")==-1) {
        curam.util.WordFileEdit.searchWindow.document.title = 
                                searchWindowTitlePrefix + ':' + wfeId;
      } else {
        titleChanged = true;
      }
      searchWindowTitle = curam.util.WordFileEdit.searchWindow.document.title;
      if (!titleChanged && 
            searchWindowTitle.indexOf(searchWindowTitlePrefix + ":")!=-1) {
        titleChanged = true;
      }
    } catch (e) {
    } // Cannot set title of new search window
    if (!titleChanged) {
      attempt++;
      window.setTimeout('redisplaySearchWindow(\'' + wfeId + '\','
          + attempt + ')', 500);
    }
  },
  
  /**
   * Retreives the name of the search page associated with a Word
   * Integration session.
   *
   * @param isParent
   *            Indicates whether the parent window should contain the search
   *            page value.
   */
  getSearchPage: function(isParent) {
    var searchPage = "";
    try {
      if(!isParent) {
          searchPage = document.getElementById('searchPage').value;

        } else {
          var parentWin = curam.util.WordFileEdit.getParentWindow();
          searchPage = parentWin.document.getElementById('searchPage').value;
        }
    } catch (e) {} // Cannot retrieve search page value from HTML
    return searchPage;
  },
  
  /**
   * Initialize the integration component.
   * 
   * If using ActiveX control, then call its openDocument Sub.
   * If it can't be called, the control didn't install successfully.
   * 
   * If using applet, register handlers for the parent frame events.
   * 
   * @param wfeId
   *          The unique ID generated each time the widget is run.
   */
  initialize: function(wfeId) {
    var parentWindow = curam.util.WordFileEdit.getParentWindow();
    try {
      var integrationControl = dom.byId(wfeId);
      if (typeof integrationControl != "undefined") {
        curam.util.WordFileEdit._setOverlay(true);

        // Deprecated Since Curam 8.0.0.0 word-integ-applet. The Word Integration Applet solution is being
        // deprecated.
        if (curam.util.WordFileEdit.useApplet) {
          // Applet - it is started automatically, no need to call openDocument()
          // Connect required event handlers
          if (!isIE8OrGreater()) {
            var iframe = parentWindow.frameElement;
            curam.util.connect(iframe, "onload", function(evt) {
              dojo.fixEvent(evt, iframe);
              var url = iframe.contentWindow.location.href;
              try {
                integrationControl.mainApplicationPageLoaded(url);
    
              } catch (e) {
                alert("Error calling mainApplicationPageLoaded on applet: "
                    + e.message);
              }
            });
            
            parentWindow.top.dojo.addOnUnload(function() {
              integrationControl.mainApplicationPageUnloaded();
            });
          } // else for IE the event will be caught by the applet via COM
            // this is to get around the opener.frameElement not working in IE
          
        } else {
          integrationControl.openDocument();
        }
      
      } else {
        curam.util.WordFileEdit._setOverlay(false);
        curam.util.WordFileEdit.closeAppletWindow();
      }
    
    } catch(e) { // Cannot call method of activeX control
      curam.util.WordFileEdit._setOverlay(false);
      curam.util.WordFileEdit.closeAppletWindow();
      parentWindow.curam.util.WordFileEdit.cannotLoadControl(e);
    }
  },
  
  /**
   * Sets overlay on the main application window while the Word document
   * is being edited.
   * 
   * @param {Boolean} displayOverlay
   *                   Specifies whether the overlay should be shown or hidden.
   * 
   * @private
   */
  _setOverlay: function(displayOverlay) {
    debug.log(debug.getProperty("curam.util.WordFileEdit.version"),
        "6.0");
     /*try {
       var openerWin = curam.util.WordFileEdit.getParentWindow(); 
       var topWin = (openerWin != null)
           ? openerWin.curam.util.getTopmostWindow() : curam.util.getTopmostWindow();
       if (topWin != window) {
        topWin.require(["curam/util/WordFileEdit"], function(topWinWordFileEdit) {
          topWinWordFileEdit._setOverlay(displayOverlay);
           return;
         });
       }
       
       if (!curam.util.WordFileEdit._overlay) {
         curam.util.WordFileEdit._overlay = new dijit.DialogUnderlay({
             dialogId: "dummy", "class": "word-file-edit-overlay" });
       }
  
       var ovr = curam.util.WordFileEdit._overlay;
       if (displayOverlay) {
         domStyle.set(ovr.domNode, 'zIndex', 9999);
         ovr.show();
       
       } else {
         ovr.hide();
       }
     
     } catch(e) {
       alert("_setOverlay ERROR: " + e.message);
     }*/
  },
  
  /**
   * Either the user has declined to install the ActiveX control, or the
   * required dlls (contained within Word) aren't installed on the target
   * machine.  Dislay a message and return to the previous page.
   */
  cannotLoadControl: function(e) {
    var msg = isIE8OrGreater() && !curam.util.WordFileEdit.useApplet ?
        curam.util.WordFileEdit.cantLoadControlMsgIE
        : curam.util.WordFileEdit.cantLoadControlMsg;
    alert(msg + "\rERROR: " + e.message);
    history.go(-1);
  },
  
  /**
   * Change the text in the ActiveX window to let the user
   * know the status of the Control
   * (e.g. 'loading activex', 'launching word', etc).
   *
   * @param text
   *          The status text to be displayed.
   */
  setStatusTextWordFileEditWindow: function(text) {
    try {
      document.getElementById('statustext').innerHTML = text;
    } catch (e) {} // Cannot find statustext element
  },
  
  /**
   * Returns the base64 encoded string which has been loaded into
   * the textareaName textarea.
   *
   * @param textareaName
   *                The textarea holding the base 64 encoded string.
   */
  getWordFileEditParentTextareaValue: function(textareaName) {
    var returnValue = "";
    try {
      var parentWin = curam.util.WordFileEdit.getParentWindow();
      var input = curam.util.WordFileEdit._findTextArea(parentWin, textareaName);
      returnValue = input.value;
      
    } catch (e) {
      alert("getWordFileEditParentTextareaValue('"+ textareaName +"'): \r"
          + e.message);
    }
    
    return returnValue;
  },
  
  _findTextArea: function(context, textareaName, partial) {
    var result = null;
    if (!partial) {
      result = context.dojo.query(
          "input[name='" + textareaName + "']", context.dojo.body())[0];

    } else {
      result = context.dojo.query(
          "input[name$='" + textareaName + "']", context.dojo.body())[0];
    }
    
    return result;
  },
  
  /**
   * Called from ActiveX control when finished editing.
   * It only passes textareaName and textareaValue through where
   * the Word document needs to be saved whilst closing.
   *
   * @param returnText
   *          Text to be displayed to user while form is being submitted.
   * @param textareaName
   *          Name of textarea_field to pass in base64 string.
   * @param textareaValue
   *          The base64 encoded string to be submitted.
   */
  finishedWordFileEditWindow: function(returnText, textareaName, textareaValue) {
    if(!curam.util.WordFileEdit._clickedFinish) {
      // Ensure this function is only called once
      curam.util.WordFileEdit.doFinishWordFileEditWindow(returnText,
          textareaName, textareaValue);

      curam.util.WordFileEdit._clickedFinish = true;
    }
  },
  
  /**
   * Finds the submit button on the page and sends click command to it.
   * The click causes the widget to finish.
   * It only passes textareaName and textareaValue through where
   * the Word document needs to be saved whilst closing.
   *
   * @param returnText
   *          Text to be displayed to user while form is being submitted.
   * @param textareaName
   *          Name of textarea_field to pass in base64 string.
   * @param textareaValue
   *          The base64 encoded string to be submitted.
   */
  doFinishWordFileEditWindow: function(returnText, textareaName, textareaValue) {
    var foundSubmitButton = false;
  
    // Indicates whether the document is being saved as it is closed.
    var savingAndClosing = false;
  
    try {
      var parent = curam.util.WordFileEdit.getParentWindow();
      if (textareaName && textareaValue) {
        savingAndClosing = true;
        var input = curam.util.WordFileEdit._findTextArea(parent, textareaName);
        input.value = textareaValue;
      }
      var elements = parent.dojo.query("form input");
      for (var i = 0; i < elements.length && !foundSubmitButton; i++) {
        if (elements[i].id.substring(
            0, curam.util.WordFileEdit._buttonIdPart.length).toLowerCase() ==
            curam.util.WordFileEdit._buttonIdPart.toLowerCase()) {
          foundSubmitButton = true;
  
          // Check and see if the document has to be saved whilst closing.  If
          // not, add a new hidden form element to indicate that the document is
          // not to be saved, and also wipe the textarea encoded document.
  
          if (!savingAndClosing) {
            // Wipe the textarea encoded string, no need to save it back again.
            var input = curam.util.WordFileEdit._findTextArea(parent, textareaName);
            input.value = '';
  
            var foundWordIntegrationForm = false;
            var formElement;
            var element = elements[i];
            // Find the form associated with this word integration session.
            try {
              while (element.tagName.toUpperCase() != "BODY"
                  && !foundWordIntegrationForm) {
                
                if (element.tagName.toUpperCase() == "FORM") {
                  foundWordIntegrationForm = true;
                  formElement = element;
                
                } else {
                  element = element.parentElement;
                }
              }
            
            } catch (e) {
              // Could not find associated Form.
              alert("doFinishWordFileEditWindow: " + e.message);
            }
            if (foundWordIntegrationForm) {
              var newElement = '<input type="hidden" name="__o3NoSave" value="true"/>';
              formElement.innerHTML += newElement;
            }
          }
          parent.curam.util.clickButton(elements[i].id);
          if (returnText.length > 0) {
            parent.document.body.innerHTML = returnText;
          }
          curam.util.WordFileEdit._setOverlay(false);
          return;
        }
      }
      if (!foundSubmitButton) {
        alert(curam.util.WordFileEdit.cantSubmitMsg);
        try {
          curam.util.WordFileEdit._setOverlay(false);
          curam.util.WordFileEdit.closeAppletWindow();
        } catch (e) { } // Cannot close ActiveX control
      }
    
    } catch (e) {
      alert("doFinishWordFileEditWindow: " + e.message);
      curam.util.WordFileEdit._setOverlay(false);
      curam.util.WordFileEdit.closeAppletWindow(); // Cannot find base64 textarea
    }
  },
  
  /**
   * Send a JavaScript alert to the user from the ActiveX control.
   *
   * @param alertText
   *            Text to be displayed in alert.
   */
  screenAlertWordFileEditWindow: function(alertText) {
    try {
      curam.util.WordFileEdit.getParentWindow().alert(alertText);
    } catch (e) {} // Cannot Alert from parent window
  },

  /**
   * This function is used to hide submit buttons on pages with
   * word integration controls. gen-jsp.xsl adds a call to this
   * function on pages that contain a MS Word control.
   */
  hideSubmitButtons: function() {
    dojo.query("a.ac").forEach(function(item) {
      item.style.display = "none";
    });
  },

  /**
   * Returns the <code>window</code> object of the page that opened
   * the ActiveX window. For the tabbed UI it is usualy the content panel
   * iframe, but it can also be a modal window if ActiveX window was opened
   * from a modal.
   *
   * This function is expected to be called in the context of the ActiveX
   * window.
   */
  getParentWindow: function() {
    return window.opener;
  },
  
  /**
   * Returns two URLs required by the WordFileEdit ActiveX control.
   * This function is caled on the control startup ind is expected
   * to be called in the context of the ActiveX window.
   * 
   * @returns An array of Strings where first element represents urlPath
   *    and second element represents allowed URL.
   */
  getUrls: function() {
    try {
      var parentWin = curam.util.WordFileEdit.getParentWindow();
      var doc = parentWin.document;
      var fullUrl = doc.URL;
    
      var firstForm = parentWin.dojo.query("form", doc)[0];
      var action = firstForm.action;
      var urlpath = fullUrl.substr(0, fullUrl.lastIndexOf("/") + 1);
    
      // Write the values in the window object for the ActiveX control
      // to read from. This a workaround to the problem of the ActiveX not being
      // able to pick return values of some JavaScript functions.
      window.curam.util.WordFileEdit.urlPath_return_value = urlpath;
      var allowedUrl = isIE8OrGreater() ? action : urlpath + action;
      window.curam.util.WordFileEdit.allowedUrl_return_value = 
        // IE8+ returns the full URL in the form action
        allowedUrl;
      
      return [urlpath, allowedUrl];
     
     } catch (e) {
       alert("getUrls: " + dojo.toJson(e));
     }
  },

  /**
   * Returns the title of the topmost browser window that hat the tabbed
   * UI loaded in it.
   *
   * This function is expected to be called in the context of the ActiveX
   * window.
   */
  getTitle: function() {
    var title = curam.util.WordFileEdit.getParentWindow().top.document.title;
    
    // also write the title in the window object for the ActiveX control
    // to read from. This a workaround to the problem of the ActiveX not being
    // able to pick return values of some JavaScript functions.
    curam.util.WordFileEdit.title_return_value = title;
    // there is an also issue accesing the above qualified object variable
    // from ActiveX - temporarily using the following global variable.
    window.curam_wordIntegration_title_return_value = title;
    
    return title;
  },
  
  /**
   * Sets the title of the topmost browser window that hat the tabbed
   * UI loaded in it. The title is set to be the text passed as the title
   * function argument.
   *
   * @param title
   *          The text to be used as window title.
   *
   * This function is expected to be called in the context of the ActiveX
   * window.
   */
  setTitle: function(title) {
    curam.util.WordFileEdit.getParentWindow().top.document.title = title;
  },

  /**
   * Returns true if the parent window page contains an input control
   * with the name specified as inputName function argument.
   *
   * @param inputNameEnd
   *              The end part of name of the input element to search for,
   *              preceded with an asterisk.
   *
   * This function is expected to be called in the context of the ActiveX
   * window.
   */
  hasNamedInput: function(inputNameEnd) {
    var parent = curam.util.WordFileEdit.getParentWindow();
    // only the last part of the name is passed into this function
    // with an asterisk wildcard at the start - remove the asterisk
    // and do partial search
    var namePart = inputNameEnd.slice(1);
    var input = curam.util.WordFileEdit._findTextArea(parent, namePart, true);
    return input ? true : false;
  },
  
  /**
   * Closes the applet window.
   * 
   * @deprecated Since Curam 8.0.0.0 word-integ-applet. The Word Integration Applet solution is being
   * deprecated.
   */
  closeAppletWindow: function() {
    self.close();
  },
  
  /**
   * Outputs the applet code into page.
   * 
   * This function must be called BEFORE the page has finished loading,
   * otherwise the complete contents of the page will be overwritten with
   * the applet code.
   * 
   * @deprecated Since Curam 8.0.0.0 word-integ-applet. The Word Integration Applet solution is being
   * deprecated.
   */
  runApplet: function(id) {
    // some diagnostic output
    if (typeof deployJava != "undefined") {
      var plugin = deployJava.getPlugin();
      if (plugin) {
        debug.log(debug.getProperty("curam.util.WordFileEdit.version"),
            plugin.version);

      } else {
        debug
          .log(debug.getProperty("curam.util.WordFileEdit.no.plugin"));
      }

    } else {
      debug.log(debug.getProperty("curam.util.WordFileEdit.no.java"));
    }

    if (typeof deployJava == "undefined"
        // Skip the plugin check for Chrome as there is a bug:
        // http://code.google.com/p/chromium/issues/detail?id=76207
        || (!dojo.isChrome && !deployJava.isPlugin2())) {

      alert(curam.util.WordFileEdit.noJavaInstalled);

    } else { // carry on starting the applet
      dojo.mixin(curam.util.WordFileEdit.controlAttributes, {
        id: id
      });

      var hiddenDiv = domConstruct.create("div", {style:"display:none"});
      var appletTag = domConstruct.create("applet",
          curam.util.WordFileEdit.controlAttributes, hiddenDiv);
      
      var params = curam.util.WordFileEdit.controlParameters;
      for (property in params) {
        domConstruct.create("param", {name: property, value: params[property]},
            appletTag);
      }
      
      var appletHTML = hiddenDiv.innerHTML;
      domConstruct.destroy(hiddenDiv);
      
      // now put the applet in the page
      document.write(appletHTML);
    }
  }
  });
  
  return curam.util.WordFileEdit;
});

},
'dojo/dnd/Moveable':function(){
define([
	"../_base/array", "../_base/declare", "../_base/lang",
	"../dom", "../dom-class", "../Evented", "../on", "../topic", "../touch", "./common", "./Mover", "../_base/window"
], function(array, declare, lang, dom, domClass, Evented, on, topic, touch, dnd, Mover, win){

// module:
//		dojo/dnd/Moveable


var Moveable = declare("dojo.dnd.Moveable", [Evented], {
	// summary:
	//		an object, which makes a node movable

	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,

	constructor: function(node, params){
		// node: Node
		//		a node (or node's id) to be moved
		// params: Moveable.__MoveableArgs?
		//		optional parameters
		this.node = dom.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dom.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : Mover;
		this.events = [
			on(this.handle, touch.press, lang.hitch(this, "onMouseDown")),
			// cancel text selection and text dragging
			on(this.handle, "dragstart",   lang.hitch(this, "onSelectStart")),
			on(this.handle, "selectstart",   lang.hitch(this, "onSelectStart"))
		];
	},

	// markup methods
	markupFactory: function(params, node, Ctor){
		return new Ctor(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		array.forEach(this.events, function(handle){ handle.remove(); });
		this.events = this.node = this.handle = null;
	},

	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				on(this.handle, touch.move, lang.hitch(this, "onMouseMove")),
				on(this.handle, touch.release, lang.hitch(this, "onMouseUp"))
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			this.events.pop().remove();
		}
		e.stopPropagation();
		e.preventDefault();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dnd.isFormElement(e)){
			e.stopPropagation();
			e.preventDefault();
		}
	},

	// local events
	onDragDetected: function(/*Event*/ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/*Mover*/ mover){
		// summary:
		//		called before every move operation
		topic.publish("/dnd/move/start", mover);
		domClass.add(win.body(), "dojoMove");
		domClass.add(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/*Mover*/ mover){
		// summary:
		//		called after every move operation
		topic.publish("/dnd/move/stop", mover);
		domClass.remove(win.body(), "dojoMove");
		domClass.remove(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/*===== mover, e =====*/){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		// mover: Mover
		// e: Event

		// default implementation does nothing
	},
	onMove: function(mover, leftTop /*=====, e =====*/){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		// mover: Mover
		// leftTop: Object
		// e: Event
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/*===== mover, leftTop =====*/){
		// summary:
		//		called before every incremental move; can be overwritten.
		// mover: Mover
		// leftTop: Object

		// default implementation does nothing
	},
	onMoved: function(/*===== mover, leftTop =====*/){
		// summary:
		//		called after every incremental move; can be overwritten.
		// mover: Mover
		// leftTop: Object

		// default implementation does nothing
	}
});

/*=====
Moveable.__MoveableArgs = declare([], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dnd.Mover
});
=====*/

return Moveable;
});

},
'dojo/store/util/QueryResults':function(){
define(["../../_base/array", "../../_base/lang", "../../when"
], function(array, lang, when){

// module:
//		dojo/store/util/QueryResults

var QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	// results: Array|dojo/promise/Promise
	//		The result set as an array, or a promise for an array.
	// returns:
	//		An array-like object that can be used for iterating over.
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}

	var isPromise = !!results.then;
	// if it is a promise it may be frozen
	if(isPromise){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		// Always add the iterative methods so a QueryResults is
		// returned whether the environment is ES3 or ES5
		results[method] = function(){
			var args = arguments;
			var result = when(results, function(results){
				Array.prototype.unshift.call(args, results);
				return QueryResults(array[method].apply(array, args));
			});
			// forEach should only return the result of when()
			// when we're wrapping a promise
			if(method !== "forEach" || isPromise){
				return result;
			}
		};
	}

	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(results.total == null){
		results.total = when(results, function(results){
			return results.length;
		});
	}
	return results; // Object
};

lang.setObject("dojo.store.util.QueryResults", QueryResults);

return QueryResults;

});

},
'curam/util/ui/form/renderer/CTListEditRendererFormEventsAdapter':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022,2023.
 *
 */
define(["dojo/_base/declare", 'dojo/_base/unload', "curam/util/ui/form/renderer/GenericRendererFormEventsAdapter", "curam/util/Dropdown"], function(declare, baseUnload, GenericRendererFormEventsAdapter, Dropdown) {

	/*
	 * Modification History
	 * --------------------
	 * 19-Jan-2023  COC [SPM-126270] Renamed the CuramFormsAPI events.
	 * 23-Nov-2022  BD  [SPM16083] Updated method setFormElementValue.
	 * 09-Nov-2022  BD  [SPM125872] Initial version.
	 */

	/**
	 * @namespace Functions specific to the context panel.
	 */


	var CTListEditRendererFormEventsAdapter = declare("curam.util.ui.form.renderer.CTListEditRendererFormEventsAdapter", GenericRendererFormEventsAdapter,
     /** @lends curam.util.ui.form.renderer.CTListEditRendererFormEventsAdapter */ {

			_unsubscribes: [],

			/**
			 * Initializes the element id, path id and element attributes.
			 * Also, listen the topic comboxbox/initialValue to
			 * set the element value when the value is setted on SPM-components.
			 * 
			 * @param id  The ID of element on the page.
			 * @param pathID The path ID to the element on the page. 
			 */
			constructor: function(id, pathID) {
				this.elementID = id;
				this.pathID = pathID;
				var handle = dojo.subscribe("/curam/comboxbox/initialValue", this, function(value, inputID) {
					if (this.getFormElement().id === inputID) {
						this.getFormElement().value = value;

					}
					handle.remove();
				});
				baseUnload.addOnUnload(function() {
					this._unsubscribes && this._unsubscribes.forEach(function(hh) { hh.remove(); });
				});

			},

			/**
			 * Add change listener for the combobox on the element ID.
			 * The SPM-components renders the combobox and publish the
			 * topic when the combobox value changes. 
			 * 
			 * @param callbackForOnChangeEvent The function to be executed when the
			 * element changes on the page.
			 */
			addChangeListener: function(callbackForOnChangeEvent) {
				var listener = 'curam/util/CuramFormsAPI/formChange/combobox'.concat(this.getElementID());

				this._unsubscribes.push(dojo.subscribe(listener, this, function(comboboxChanged) {
					this.getFormElement().value = comboboxChanged.value;
					callbackForOnChangeEvent();
				}));
			},

			/**
			 * Set the form element value. The combobox values is set on the SPM-components.
			 * If the combobox is renderer on the page, set the value. Otherwise listener
			 * the topic published by SPM-components when the component is ready. 
			 * 
			 * @param value The new value for the element. 
			 */
			setFormElementValue: function(value) {
				var self = this;
				var handle = dojo.subscribe("curam/modal/component/ready", this,
					function() {
						var dropdown = new Dropdown();
						dropdown.setSelectedOnDropdownIDByCodevalue(self.getElementID(), value);
						this.getFormElement().value = value;
						handle.remove();
					});
			}

		});

	return CTListEditRendererFormEventsAdapter;

});
},
'curam/pagination/DefaultListModel':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*
 * Modification History
 * --------------------
 * 05-Jun-2019  SK [RTC248394] Accumulating output to increase performance
 *                 when unpacking
 * 28-May-2019  SK [RTC241554] Now emits event to update accessibility readings.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 22-Dec-2010  MV  [CR00239864] Handle the case when the associated list table
 *    is not found. 
 * 20-Dec-2010 MV  [CR00239063] Move common function to pagination.js
 * 13-Dec-2010 MV [CR00237821] Performance improvement - the list rows now
 *    come packed in script tags - unpack before using.
 * 11-May-2010 MV [CR00196066] Cleanup the code, name variables properly.
 * 26-Apr-2010 MV [CR00194538] Force Redraw of content area after showing rows.
 *                            Due to no scrollbars appearing in IE
 * 23-Apr-2010 MV [CR00194352] Fix an array-index-related bug in hideRange().
 * 10-Apr-2010 OK [CR00193314] Added check on last row of fragmented list,
 *                 to add correct rounded edges to bottom
 * 20-Apr-2010 MV [CR00193983] Make the model API's row indexes 1-based
 *                            as per the design.
 * 18-Mar-2010 MV [CR00136536] Initial version.
 * 
 */

/**
 * @name curam.pagination.DefaultListModel
 * 
 * @namespace DefaultListModel provides access to a list rendered as a HTML table.
 * The rendering is done in gen-jsp.xsl.
 *
 */
define(["dojo/_base/declare",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/query",
        "curam/debug",
        "curam/pagination"
        ], function(declare, domClass, domStyle, query, debug, pagination) {
  
var DefaultListModel = declare("curam.pagination.DefaultListModel", null, 

/**
 * @lends curam.pagination.DefaultListModel.prototype
 */    
{
  _rowCount: null,

  /**
   * Instantiate the model and intialize with the corresponding table node. 
   */
  constructor: function(tableId) {
    this.tableNode = query("table.paginated-list-id-" + tableId)[0];
    if (!this.tableNode) {
      throw "Table node for ID " + tableId + " not found - failing!";
    }
    debug.log("curam.pagination.DefaultListModel " 
      + debug.getProperty("curam.pagination.DefaultListModel"), 
      this.tableNode);
    this._id = tableId;
  },

  getId: function() {
    return this._id;
  },

  getRowCount: function() {
    if (this._rowCount == null) {
      this._rowCount = 0;
      // count the rows in script blocks
      var scripts = query("tbody > script.hidden-list-rows", this.tableNode),
        frag = document.createDocumentFragment();
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        var isLastScript = (i == scripts.length - 1);
        if (!isLastScript) {
          // for most script blocks, rely on the page size
          this._rowCount += pagination.getNumRowsInBlock(script);
        
        } else {
          // for the last page we must load the contents as it may contain smaller
          // number of rows than page size. These will be counted below.
          pagination.unpackRows(script, frag);
          script.innerHTML='';//blanking out to avoid additional evaluations.
                              // removing from the DOM or replacing creates huge overrhead
        }
      };
      this.tableNode.tBodies[0].appendChild(frag);
      // now count the row nodes
      var rowNodesCount = query("tbody > tr", this.tableNode).length;
      this._rowCount += rowNodesCount;
    }
    
    return this._rowCount;
  },

  hideRange: function(startIndex, endIndex) {
    var rows = this._getRowNodes(startIndex, endIndex);
    for (var i = startIndex; i <= endIndex; i++) {
      domStyle.set(rows[i - 1], {"display":"none"});
      domClass.remove(rows[i - 1],"even-last-row");
      domClass.remove(rows[i - 1],"odd-last-row");
    }
  },

  showRange: function(startIndex, endIndex) {
    var rows = this._getRowNodes(startIndex, endIndex);
   
    // set the proper CSS class for the last row
    var lastRowCssClass =
        (endIndex % 2 == 0) ? "even-last-row" : "odd-last-row";
    domClass.add(rows[endIndex - 1], lastRowCssClass);
    
    // show the required rows
    for (var i = startIndex; i <= endIndex; i++) {
      domStyle.set(rows[i - 1], {"display":""});
    }
    dojo.publish('curam/update/pagination/rows', [rows, this.getId()]);
  },

  _getRowNodes: function(startIndex, endIndex) {
    // read the list content - any rows and script blocks
    var listContent = pagination.readListContent(this.tableNode);

    // go through the required range and expand any script blocks in the way
    for(var i = 1; i <= endIndex && i <= listContent.length; i++) {
      var node = listContent[i - 1];
      if (node.tagName == "SCRIPT") {
        // at least part of the required row range is packed in a script tag
        // expand it now
        pagination.unpackRows(node);
        
        // re-read content
        listContent = pagination.readListContent(this.tableNode);
        // and skip the script block in the count
        i--;
      }
    }

    // now return all the existing row nodes
    return query("tbody > tr", this.tableNode);
  }
});

return DefaultListModel;
});

},
'dijit/form/DropDownButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // hitch
	"dojo/query", // query
	"../registry", // registry.byNode
	"../popup", // dijit.popup2.hide
	"./Button",
	"../_Container",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, lang, query, registry, popup, Button, _Container, _HasDropDown, template){

	// module:
	//		dijit/form/DropDownButton

	return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
		// summary:
		//		A button with a drop down
		//
		// example:
		// |	<button data-dojo-type="dijit/form/DropDownButton">
		// |		Hello world
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
		// |	win.body().appendChild(button1);
		//

		baseClass: "dijitDropDownButton",

		templateString: template,

		_fillContent: function(){
			// Overrides Button._fillContent().
			//
			// My inner HTML contains both the button contents and a drop down widget, like
			// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
			// The first node is assumed to be the button content. The widget is the popup.

			if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
				//FIXME: figure out how to filter out the widget and use all remaining nodes as button
				//	content, not just nodes[0]
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){
				return;
			}

			// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
			// make it invisible, and store a reference to pass to the popup code.
			if(!this.dropDown && this.dropDownContainer){
				var dropDownNode = query("[widgetId]", this.dropDownContainer)[0];
				if(dropDownNode){
					this.dropDown = registry.byNode(dropDownNode);
				}
				delete this.dropDownContainer;
			}
			if(this.dropDown){
				popup.hide(this.dropDown);
			}

			this.inherited(arguments);
		},

		isLoaded: function(){
			// Returns whether or not we are loaded - if our dropdown has an href,
			// then we want to check that.
			var dropDown = this.dropDown;
			return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
		},

		loadDropDown: function(/*Function*/ callback){
			// Default implementation assumes that drop down already exists,
			// but hasn't loaded it's data (ex: ContentPane w/href).
			// App must override if the drop down is lazy-created.
			var dropDown = this.dropDown;
			var handler = dropDown.on("load", lang.hitch(this, function(){
				handler.remove();
				callback();
			}));
			dropDown.refresh();		// tell it to load
		},

		isFocusable: function(){
			// Overridden so that focus is handled by the _HasDropDown mixin, not by
			// the _FormWidget mixin.
			return this.inherited(arguments) && !this._mouseDown;
		}
	});
});

},
'dojo/regexp':function(){
define(["./_base/kernel", "./_base/lang"], function(dojo, lang){

// module:
//		dojo/regexp

var regexp = {
	// summary:
	//		Regular expressions and Builder resources
};
lang.setObject("dojo.regexp", regexp);

regexp.escapeString = function(/*String*/str, /*String?*/except){
	// summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	// summary:
	//		Builds a regular expression that groups subexpressions
	// description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return regexp.group(b.join("|"), nonCapture); // String
};

regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return regexp;
});

},
'curam/layout/TabContainer':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.layout.TabContainer
 * @namespace Customized dijit.layout.TabContainer class in order to change the
 * behavior when a tab is closed.
 */
define(["dojo/_base/declare",
        "dijit/layout/TabContainer",
        "dojo/text!curam/layout/resources/TabContainer.html",
        "curam/inspection/Layer",
        "dojo/_base/connect",
        "curam/layout/ScrollingTabController",
        "dijit/layout/TabController"
        ], function(declare, TabContainer, template, layer, connect, CuramScrollingTabController,
                TabController) {
        
/*
 * Modification History
 * --------------------
 * 14-May-2019  JD  [RTC242058] Override postMixInProperties so 
 * 								CuramScrollingTabController can be used.
 * 23-Aug-2018  BD  [RTC229425] Overriden the method selectChild 
 *                              to publish to alert the tabwiget selected.
 * 25-Oct-2017  GB  [RTC177937] Adding a method to update tab 
 * 								title when changing tabs.
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Added publishing of
 * /curam/tab/closing event.)
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 24-Oct-2012  SK  [CR00346419] Now destroys the unnecessary references to avoid
 *                    holding memory.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format. 
 * 17-Dec-2010  DG  [CR00239200] Do not select tabs when destroying container.
 * 29-Sep-2010  MK  [CR00221781] Revised to change tab by responding to
 *                    the onRemoveChild event.
 * 03-Aug-2010  MK  [CR00211743] Initial Version.
 */
 
var CuramTabContainer = declare("curam.layout.TabContainer", dijit.layout.TabContainer,
  /**
   * @lends curam.layout.TabContainer
   */
{
  // The "dijitAlingTop" CSS class has been added to the "tablistSpacer" div in the template string.
  // The template string is actually defined in _TabContainerBase.js. No information on why this is needed
  // but it is obviously it was an alignment issue with the ootb Dojo widget. However, it "looks wrong".
  // If there was a bug with the ootb alignment (e.g. it didn't align to the center), then we should have fixed that
  // instaead of using "dijitAlignTop" to "push up" the contents to the center. It sounds to me like we are using
  // "align top" to make something "align center" !! Needs more investigation.  
  templateString: template,
  
  /**
   * The index of the currently selected tab.
   * @private
   */
  _theSelectedTabIndex: 0,

  /**
   * The page associated with the currently selected tab.
   * @private
   */
  _thePage: null,

  /**
   * The list of tabs.
   * @private
   */
  _theChildren: null,

  /**
   * Override of the superclass method in order to connect
   * the _changeTab function to the onRemoveChild event.
   */
	postCreate: function() {
		    this.inherited(arguments);
		    var tl = this.tablist;
		    this.connect(tl, 'onRemoveChild', '_changeTab');
		    this.connect(tl, 'onSelectChild', 'updateTabTitle');
		    layer.register("curam/layout/TabContainer", this);
	
	},

	selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
		this.inherited(arguments);
		dojo.publish("curam/tab/selected",[page.id]);
	},
	
	
  /**
   * Updates the tab title when changing tabs.
   */
  updateTabTitle: function() {
	  curam.util.setBrowserTabTitle();
  },

  /**
    * This method implements the Curam specific behavior to
    * be executed when a tab is closed.
    *
    * @private
    */
  _changeTab: function(){
    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._beingDestroyed) {
      this._thePage = null;
      this._theChildren = null;
      return;
    }
    if (this._theChildren == null) {
      return;
    }
    // if the tab currently being closed is not the one in display
    // then we don't want to change focus
    if (this._theChildren[this._theSelectedTabIndex] != this._thePage) {
      this.selectChild(this._theChildren[this._theSelectedTabIndex]);
      this._thePage = null;
      this._theChildren = null;
      return;
    }

    // display correct tab.
    if (this._theChildren.length < 1 ) { // no tabs open
      this._thePage = null;
      return;
    } else if (this._theChildren.length == 1 ) { // only one tab open
      this.selectChild(this._theChildren[this._theChildren.length-1]);
      this._thePage = null;
      this._theChildren = null;
    } else { // more than one tab open

      if (this._theSelectedTabIndex == (this._theChildren.length - 1)){
        // closing the right most tab
        this.selectChild(this._theChildren[this._theChildren.length-2]);

      } else if (this._theSelectedTabIndex == 0) {
        // closing the left most tab
       this.selectChild(this._theChildren[1]);

      } else {
        // closing a tab that is neither the left or right most tab
        // we can be guaranteed there is at least three tabs
        if (this._theChildren.length > 2) {
          this.selectChild(this._theChildren[this._theSelectedTabIndex + 1]);
        }
      }
      this._thePage = null;
      this._theChildren = null;
    }
  },

  /**
   * Override of the parent method.
   */
  removeChild: function(/*dijit._Widget*/ page){
    // Overrides dijit.layout.TabContainer.removeChild()

    // Do not do anything if the tab container is being destroyed. The tabs
    // will be removed one-by-one and we do not want to accidentally trigger
    // any unwanted selection events that might break tab session management.
    if (this._started && !this._beingDestroyed) {
      // find the index of the selected tab
      // need to find this before the call to inherited as the call to
      // inherited reset the selected tab.
      var children = this.getChildren();
      var i = 0;
      var selectedTabIndex = 0;
      for (i = 0; i < children.length; i++){
        if (children[i].get('selected')) {
          selectedTabIndex = i;
          break;
        }
      }

      // store the values so that they will be accessible by
      // _changeTab method when it responds to the firing.
      // of the onRemoveChild event
      this._theSelectedTabIndex = selectedTabIndex;
      this._thePage = page;
      this._theChildren = children;

      // Trigger any cleanup events associated with the closing tab
      var tabWidgetId = page.id;
      connect.publish("/curam/tab/closing", [tabWidgetId]);
    }

    // Call the superclass. It can handle destruction cleanly on its own.
    this.inherited(arguments);
  },
  
  postMixInProperties: function() {
	    // Scrolling controller only works for horizontal non-nested tabs
	    if(!this.controllerWidget){
	      this.controllerWidget =
	          (this.tabPosition == "top" || this.tabPosition == "bottom")
	          && !this.nested
	          ? CuramScrollingTabController : TabController;
	    }

	    this.inherited(arguments);
	  }
  
});


return CuramTabContainer;
});
},
'curam/ui/SectionShortcutsPanel':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.ui.SectionShortcutsPanel
 * 
 * @namespace Functions for the section shortcuts panel.
 */
define(["curam/inspection/Layer",
        "curam/define",
        "curam/tab",
        "curam/util",
        "curam/ui/UIController"], function(layer) {
/*
 * Modification History
 * --------------------
 * 30-Sep-2014  SL  [CR00445898] Added Inspection Layer integration.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 02-May-2012 MK [CR00323691] Use new Dojo AMD format.
 * 17-Nov-2010 MK [CR00230397] added additional function for handling non-dojo
 *                    links that simply use an anchor HTML element. 
 * 22-Nov-2010 MV [CR00231655] Added code to cleanup storage on page unload.
 * 27-Oct-2010 SK [CR00224193] changed function for opening
 *                    shortcut in modal dialog.
 * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
 *                    tab-app-controller.js and tab-app-common.js.
 * 20-Jul-2010  MV  [CR00211031] Initial version.
 */
var SectionShortcutsPanel = curam.define.singleton("curam.ui.SectionShortcutsPanel",
/**
  * @lends curam.ui.SectionShortcutsPanel.prototype
  */
{  
  handleClickOnAnchorElement: function(pageId, openInModal) {			    
    if (!openInModal) {
      curam.tab.getTabController().handleUIMPageID(pageId);

    } else {
      curam.ui.SectionShortcutsPanel.openInModal(pageId);
    }
  },
			  
  handleClick: function(sourceID, item) {
    var jsonStore = eval(sourceID + "JsonStore");
    var pageId = jsonStore.getValue(item, 'pageID');
    var openInModal = jsonStore.getValue(item, 'openInModal');

    if (!openInModal) {
      curam.tab.getTabController().handleUIMPageID(pageId);

    } else {
      curam.ui.SectionShortcutsPanel.openInModal(pageId);
    }
  },

  openInModal: function(pageId) {
    var baseUrl = pageId + "Page.do";
    var modalObject = {};
    curam.tab.getTabController().handleLinkClick(baseUrl, modalObject);
  },
  
  setupCleanupScript: function(sourceID) {
    dojo.ready(function() {
      var jsonStore = eval(sourceID + "JsonStore");
      dojo.addOnWindowUnload(function() {
        jsonStore.close();
      });
    });
  }
});
layer.register("curam/ui/SectionShortcutsPanel", this);

return SectionShortcutsPanel;
});

},
'curam/cdsl/_base/_StructBase':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 23-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 * 21-Jan-2014  MV  [CR00412812] Added mising support for handling
 *      of Date data type.
 */

define(['dojo/_base/declare',
        'dojo/_base/lang',
        'dojo/json',
        'curam/cdsl/types/FrequencyPattern'
        ], function(
            declare, lang, json, FrequencyPattern) {

  var DEFAULT_OPTIONS = {
    bareInput: false,
    fixups: null,
    metadataRegistry: null,
    dataAdapter: null
  };
  
  var processOptions = function(options) {
    var o = lang.clone(DEFAULT_OPTIONS);
    return lang.mixin(o, options);
  };
  
  var DEFAULT_DATA_ADAPTER = {
    onRequest: {
      onItem: function(path, data) { return data; },
      onStruct: function(structData) { },
    },
    
    onResponse: {
      onItem: function(path, data) { return data; },
      onStruct: function(structData) { },
    }
  };
  
  var concatToPath = function(frag, newPart) {
    if (frag) {
      return frag + "." + newPart;
    }
    
    return newPart;
  };
  

  /**
   * @name curam.cdsl._base._StructBase
   * @namespace Base class for Curam structs.
   *     This is provided so that the actual Struct class can inherit
   *     any methods and keep it's own object for storing the actual data
   *     properties. This is recommended by the dojo/store design:
   * http://dojotoolkit.org/reference-guide/1.9/dojo/store.html#returned-objects
   */
  var Struct = declare(null,
  /**
   * @lends curam._base._StructBase.prototype
   */
  {
    _data: null,
    
    _converter: null,
    
    _dataAdapter: null,

    /**
     * By default we just take the data parameter and this is meant
     * as the public interface for CDSL clients. In this mode we expect
     * to be getting data in typed form.
     * 
     * The other usages are governed by options, and these are for internal
     * CDSL usage.
     */
    constructor: function(data, opts) {
      if (!data) {
        throw new Error("Missing parameter.");
      }
      if (typeof data !== "object") {
        throw new Error("Wrong parameter type: " + typeof data);
      }
      
      var options = processOptions(opts);
      
      if (!options.bareInput) {
        this._data = this._typedToBare(data);

      } else {
        this.setDataAdapter(options.dataAdapter);

        this._data = this._bareToTyped(data);
        if (options.fixups) {
          this._applyFixUps(options.fixups, this._data,
              options.metadataRegistry);
        }
      }
    },
    
    _applyFixUps: function(fixups, data, metadataRegistry) {

      dojo.forEach(fixups, function(item, index) {
        var path = fixups[index].path;
        var type = fixups[index].type;
        
        this._processFixUp(data,
            path, this._getTransformFunction(type, metadataRegistry));            
       }, this);
    },
    
    _processFixUp: function(data, path, transform) {

      if(path.length == 1) {        
        data[path[0]] = transform(data[path[0]]);
        return;                 

      } else {
        if (lang.isArray(data[path[0]])) {
          dojo.forEach(data[path[0]], function(item, index){
            this._processFixUp(item, path.slice(1, path.length), transform);
          }, this);

        } else {
          this._processFixUp(data[path[0]], path.slice(1, path.length),
              transform);
        }
      }      
    },

    _getTransformFunction: function(type, metadataRegistry){
      
      // TODO add in other types, refactor out transform functions?
      // TODO cleaner with just a map of maps?
      if (type[0] === "frequencypattern") {
        return function(data) {
          return new FrequencyPattern(data.code, data.description);
        };

      } else if (type[0] === "datetime") {
        return function(data) {
          // TODO
          return new Date(data);
        };

      } else if (type[0] === "date") {
        return function(data) {
          // TODO
          return new Date(data);
        };

      } else if (type[0] === "time") {
        return function(data) {
          // TODO
          return new Date(data);
        };

      } else if (type[0] === "codetable") {
        
        if (type.length < 2) {
          throw new Error(
              "Missing codetable name, type specified is: " + type);
        }
        
        return function(data) {
          //TODO handle case where code does not exist
          var codetable = metadataRegistry.codetables()[type[1]];
          if (codetable){             
            return codetable.getItem(data);

          } else {
            throw new Error(
                "Codetable does not exist: codetable name=" + type[1]);
          }            
        };

      } else {
        throw new Error("Unsupported type: " + type);
      } 
    },    

    toJson: function() {
      return json.stringify(this.getData());
    },
    
    /**
     * Returns data in bare (untyped) form suitable for conversion to JSON.
     */
    getData: function() {
      // collect new data values - they might have been changed since
      // this instance was created
      for (var name in this._data) {
        this._data[name] = this[name];
      }
      
      return this._typedToBare(this._data);
    },

    /**
     * Takes data in the form adhering to the CDSL contract with regards
     * to JSON-serialized data types and converts them into the corresponding
     * JavaScript object representation.
     *
     * @param {Object} data Deserialized JSON data object.
     * @param {String} [path] Path to the data.
     * @returns JavaScript object ready to be used by this Struct API.
     */
    _bareToTyped: function(data, path) {
      if (lang.isObject(data)) {
        var retData = {};
        
        // apply client provided data transforms on a Struct level
        this._applyResponseStructAdapter(data);

        for (var prop in data) {
          if (lang.isArray(data[prop])) {
            retData[prop] = [];
            for (var i = 0; i < data[prop].length; i++) {
              retData[prop].push(this._bareToTyped(data[prop][i],
                  concatToPath(path, prop + "[" + i + "]")));
            }

          } else if (typeof data[prop] === 'object') {
            retData[prop] = this._bareToTyped(data[prop],
                concatToPath(path, prop));        

          } else {
            retData[prop] = data[prop];
          }
        
          // apply client provided data transforms on item level
          var fullPath = concatToPath(path, prop);
          retData[prop] = this._applyResponseDataAdapter(fullPath, retData[prop]);
        }
        
        return retData;
      }
      
      // apply client provided data transforms on item level
      return this._applyResponseDataAdapter(path, data);
    },

    /**
     * Converts typed (external) data into a form that conforms to the CDSL
     * contract with regards to JSON-serialized data types.
     *
     * @param {Object} data JavaScript objects representing the Struct data.
     * @param {String} [path] Path to the data.
     * @returns JavaScript object ready to be passed into JSON.stringify()
     *    and sent to CDSL servlet.
     */
    _typedToBare: function(data, path) {
      if (lang.isObject(data)) {
        var retData = {};
        for (var prop in data) {
          if (data.hasOwnProperty(prop)
              // strip out Dojo class related properties
              && '_data' !== prop
              && '_dataAdapter' !== prop
              && '_inherited' !== prop
              && '_converter' !== prop) {
            
            // handle arrays
            if (lang.isArray(data[prop])) {
              retData[prop] = [];
              for (var i = 0; i < data[prop].length; i++) {
                retData[prop].push(this._typedToBare(data[prop][i],
                    concatToPath(path, prop + "[" + i + "]")));
              }
            
            // handle codetables
            } else if (data[prop].getDescription && data[prop].getCode) {
              retData[prop] = data[prop].getCode();
              
            // handle Date
            } else if (data[prop].getTime) {
              retData[prop] = data[prop].getTime();

            } else if (typeof data[prop] === 'object') {
              retData[prop] = this._typedToBare(data[prop],
                  concatToPath(path, prop));        

            } else {
              retData[prop] = data[prop];
            }
            
            // apply client provided data transforms on item level
            var fullPath = concatToPath(path, prop);
            retData[prop] = this._applyRequestDataAdapter(fullPath, retData[prop]);
          }
        }

        this._applyRequestStructAdapter(retData);
        
        return retData;
      }
      
      // apply client provided data transforms on item level
      return this._applyRequestDataAdapter(path, data);
    },
    
    /**
     * Sets the data adapter to use for items of this struct.
     * 
     * @param {Object} adapter The adapter with appropriate callback functions.
     */
    setDataAdapter: function(adapter) {
      if (adapter) {
        var a = lang.clone(DEFAULT_DATA_ADAPTER);
        
        if (adapter.onRequest && adapter.onRequest.onItem) {
          a.onRequest.onItem = adapter.onRequest.onItem;
        }
        if (adapter.onRequest && adapter.onRequest.onStruct) {
          a.onRequest.onStruct = adapter.onRequest.onStruct;
        }
        if (adapter.onResponse && adapter.onResponse.onItem) {
          a.onResponse.onItem = adapter.onResponse.onItem;
        }
        if (adapter.onResponse && adapter.onResponse.onStruct) {
          a.onResponse.onStruct = adapter.onResponse.onStruct;
        }
        
        this._dataAdapter = a;
      
      } else {
        this._dataAdapter = null;
      }
    },
    
    _applyRequestDataAdapter: function(path, value) {
      if (this._dataAdapter) {
        return this._dataAdapter.onRequest.onItem(path, value);
      }
      
      return value;
    },

    _applyResponseDataAdapter: function(path, value) {
      if (this._dataAdapter) {
        return this._dataAdapter.onResponse.onItem(path, value);
      }
      
      return value;
    },
    
    _applyRequestStructAdapter: function(structData) {
      if (this._dataAdapter) {
        this._dataAdapter.onRequest.onStruct(structData);
      }
    },

    _applyResponseStructAdapter: function(structData) {
      if (this._dataAdapter) {
        this._dataAdapter.onResponse.onStruct(structData);
      }
    }
  });
  
  return Struct;
});

},
'dojo/debounce':function(){
define([], function(){
	// module:
	//		dojo/debounce
	// summary:
	//		This module provide a debouncer

	return function(cb, wait){
		// summary:
		//		Create a function that will only execute after `wait` milliseconds
		// description:
		//		Create a function that will only execute after `wait` milliseconds
		//		of repeated execution. Useful for delaying some event action slightly to allow
		//		for rapidly-firing events such as window.resize, node.mousemove and so on.
		// cb: Function
		//		A callback to fire. Like hitch() and partial(), arguments passed to the
		//		returned function curry along to the original callback.
		// wait: Integer
		//		Time to spend caching executions before actually executing.
		var timer;
		return function(){
			if(timer){
				clearTimeout(timer);
			}
			var self = this;
			var a = arguments;
			timer = setTimeout(function(){
				cb.apply(self, a);
			}, wait);
		};
	};
});

},
'dojox/widget/Standby':function(){
define(["dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/dom-geometry",
	"dojo/dom-style",
	"dojo/window",
	"dojo/_base/window",
	"dojo/_base/fx",
	"dojo/fx",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dijit/registry"],

function(kernel,
		declare,
		array,
		event,
		has,
		dom,
		attr,
		construct,
		geometry,
		domStyle,
		window,
		baseWindow,
		baseFx,
		fx,
		_Widget,
		_TemplatedMixin,
		registry) {

kernel.experimental("dojox.widget.Standby");

return declare("dojox.widget.Standby", [_Widget, _TemplatedMixin],{
	// summary:
	//		A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a
	//		particular DOM node is processing and cannot be clicked on at this time.
	//		This widget uses absolute positioning to apply the overlay and image.

	// image: String
	//		A URL to an image to center within the blocking overlay.
	//		The default is a basic spinner.
	image: require.toUrl("dojox/widget/Standby/images/loading.gif").toString(),

	// imageText: String
	//		Text to set on the ALT tag of the image.
	//		The default is 'Please wait...'
	imageText: "Please Wait...", // TODO: i18n

	// text: String
	//		Text/HTML to display in the center of the overlay
	//		This is used if image center is disabled.
	//		Defaults to 'Please Wait...'
	text: "Please wait...",

	// centerIndicator: String
	//		Property to define if the image and its alt text should be used, or
	//		a simple Text/HTML node should be used.  Allowable values are 'image'
	//		and 'text'.
	//		Default is 'image'.
	centerIndicator: "image",
	
	// target: DOMNode||DOMID(String)||WidgetID(String)
	//		The target to overlay when active.  Can be a widget id, a
	//		dom id, or a direct node reference.
	target: "",

	// color:	String
	//		The color to set the overlay.  Should be in #XXXXXX form.
	//		Default color for the translucent overlay is light gray.
	color: "#C0C0C0",

	// duration: Integer
	//		Integer defining how long the show and hide effects should take in milliseconds.
	//		Defaults to 500
	duration: 500,
	
	// zIndex: String
	//		Control that lets you specify if the zIndex for the overlay
	//		should be auto-computed based off parent zIndex, or should be set
	//		to a particular value.  This is useful when you want to overlay
	//		things in digit.Dialogs, you can specify a base zIndex to append from.
	zIndex: "auto",
	
	// opacity: float
	//		The opacity to make the overlay when it is displayed/faded in.
	//		The default is 0.75.  This does not affect the image opacity, only the
	//		overlay.
	opacity: 0.75,	
	
	// templateString: [protected] String
	//		The template string defining out the basics of the widget.  No need for an external
	//		file.
	templateString:
		"<div>" +
			"<div style=\"display: none; opacity: 0; z-index: 9999; " +
				"position: absolute; cursor:wait;\" dojoAttachPoint=\"_underlayNode\"></div>" +
			"<img src=\"${image}\" style=\"opacity: 0; display: none; z-index: -10000; " +
				"position: absolute; top: 0px; left: 0px; cursor:wait;\" "+
				"dojoAttachPoint=\"_imageNode\">" +
			"<div style=\"opacity: 0; display: none; z-index: -10000; position: absolute; " +
				"top: 0px;\" dojoAttachPoint=\"_textNode\"></div>" +
		"</div>",

	// _underlayNode: [private] DOMNode
	//		The node that is the translucent underlay for the
	//		image that blocks access to the target.
	_underlayNode: null,

	// _imageNode: [private] DOMNode
	//		The image node where we attach and define the image to display.
	_imageNode: null,

	// _textNode: [private] DOMNode
	//		The div to attach text/HTML in the overlay center item.
	_textNode: null,

	// _centerNode: [private] DOMNode
	//		Which node to use as the center node, the image or the text node.
	_centerNode: null,

	// _displayed: [private] Boolean
	//		Flag to indicate if the overlay is displayed or not.
	_displayed: false,

	// _resizeCheck: [private] Object
	//		Handle to interval function that checks the target for changes.
	_resizeCheck: null,

	// _started: [private] Boolean
	//		Trap flag to ensure startup only processes once.
	_started: false,

	// _parent: [private] DOMNode
	//		Wrapping div for the widget, also used for IE 7 in dealing with the
	//		zoom issue.
	_parent: null,

	startup: function(args){
		// summary:
		//		Over-ride of the basic widget startup function.
		//		Configures the target node and sets the image to use.
		if(!this._started){
			if(typeof this.target === "string"){
				var w = registry.byId(this.target);
				this.target = w ? w.domNode : dom.byId(this.target);
			}

			if(this.text){
				this._textNode.innerHTML = this.text;
			}
			if(this.centerIndicator === "image"){
				this._centerNode = this._imageNode;
				attr.set(this._imageNode, "src", this.image);
				attr.set(this._imageNode, "alt", this.imageText);
			}else{
				this._centerNode = this._textNode;
			}
			domStyle.set(this._underlayNode, {
				display: "none",
				backgroundColor: this.color
			});
			domStyle.set(this._centerNode, "display", "none");
			this.connect(this._underlayNode, "onclick", "_ignore");

			//Last thing to do is move the widgets parent, if any, to the current document body.
			//Avoids having to deal with parent relative/absolute mess.  Otherwise positioning
			//tends to go goofy.
			if(this.domNode.parentNode && this.domNode.parentNode != baseWindow.body()){
				baseWindow.body().appendChild(this.domNode);
			}

			//IE 7 has a horrible bug with zoom, so we have to create this node
			//to cross-check later.  Sigh.
			if(has("ie") == 7){
				this._ieFixNode = construct.create("div");
				domStyle.set(this._ieFixNode, {
					opacity: "0",
					zIndex: "-1000",
					position: "absolute",
					top: "-1000px"
				});
				baseWindow.body().appendChild(this._ieFixNode);
			}
			this.inherited(arguments);
		}		
	},

	show: function(){
		// summary:
		//		Function to display the blocking overlay and busy/status icon or text.
		if(!this._displayed){
			if(this._anim){
				this._anim.stop();
				delete this._anim;
			}
			this._displayed = true;
			this._size();
			this._disableOverflow();
			this._fadeIn();
		}
	},

	hide: function(){
		// summary:
		//		Function to hide the blocking overlay and status icon or text.
		if(this._displayed){
			// Ideally would come up with something better than try/catch,
			// but don't see another simple workaround for
			// https://bugs.dojotoolkit.org/ticket/18196 and
			// https://bugs.dojotoolkit.org/ticket/14984
			try{
				if(this._anim){
					this._anim.stop();
					delete this._anim;
				}
				this._size();
			}catch(e){
				console.error(e);
			}finally{
				this._fadeOut();
				this._displayed = false;
				if(this._resizeCheck !== null){
					clearInterval(this._resizeCheck);
					this._resizeCheck = null;
				}
			}
		}
	},

	isVisible: function(){
		// summary:
		//		Helper function so you can test if the widget is already visible or not.
		// returns:
		//		boolean indicating if the widget is in 'show' state or not.
		return this._displayed; // boolean
	},

	onShow: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	onHide: function(){
		// summary:
		//		Event that fires when the display of the Standby completes.
	},

	uninitialize: function(){
		// summary:
		//		Over-ride to hide the widget, which clears intervals, before cleanup.
		this._displayed = false;
		if(this._resizeCheck){
			clearInterval(this._resizeCheck);
		}
		domStyle.set(this._centerNode, "display", "none");
		domStyle.set(this._underlayNode, "display", "none");
		if(has("ie") == 7 && this._ieFixNode){
			baseWindow.body().removeChild(this._ieFixNode);
			delete this._ieFixNode;
		}
		if(this._anim){
			this._anim.stop();
			delete this._anim;
		}
		this.target = null;
		this._imageNode = null;
		this._textNode = null;
		this._centerNode = null;
		this.inherited(arguments);
	},

	_size: function(){
		// summary:
		//		Internal function that handles resizing the overlay and
		//		centering of the image on window resizing.
		// tags:
		//		private
		if(this._displayed){
			var dir = attr.get(baseWindow.body(), "dir");
			if(dir){dir = dir.toLowerCase();}
			var _ie7zoom;
			var scrollers = this._scrollerWidths();

			var target = this.target;

			//Show the image and make sure the zIndex is set high.
			var curStyle = domStyle.get(this._centerNode, "display");
			domStyle.set(this._centerNode, "display", "block");
			var box = geometry.position(target, true);
			if(target === baseWindow.body() || target === baseWindow.doc){
				// Target is the whole doc, so scale to viewport.
				box = window.getBox();
				box.x = box.l;
				box.y = box.t;
			}

			var cntrIndicator = geometry.getMarginBox(this._centerNode);
			domStyle.set(this._centerNode, "display", curStyle);

			//IE has a horrible zoom bug.  So, we have to try and account for
			//it and fix up the scaling.
			if(this._ieFixNode){
				_ie7zoom = -this._ieFixNode.offsetTop / 1000;
				box.x = Math.floor((box.x + 0.9) / _ie7zoom);
				box.y = Math.floor((box.y + 0.9) / _ie7zoom);
				box.w = Math.floor((box.w + 0.9) / _ie7zoom);
				box.h = Math.floor((box.h + 0.9) / _ie7zoom);
			}

			//Figure out how to zIndex this thing over the target.
			var zi = domStyle.get(target, "zIndex");
			var ziUl = zi;
			var ziIn = zi;

			if(this.zIndex === "auto"){
				if(zi != "auto"){
					ziUl = parseInt(ziUl, 10) + 1;
					ziIn = parseInt(ziIn, 10) + 2;
				}else{
					//We need to search up the chain to see if there
					//are any parent zIndexs to overlay.
					var cNode = target;
					if(cNode && cNode !== baseWindow.body() && cNode !== baseWindow.doc){
						cNode = target.parentNode;
						var oldZi = -100000;
						while(cNode && cNode !== baseWindow.body()){
							zi = domStyle.get(cNode, "zIndex");
							if(!zi || zi === "auto"){
								cNode = cNode.parentNode;
							}else{
								var newZi = parseInt(zi, 10);
								if(oldZi < newZi){
									oldZi = newZi;
									ziUl = newZi + 1;
									ziIn = newZi + 2;
								}
								// Keep looking until we run out, we want the highest zIndex.
								cNode = cNode.parentNode;
							}
						}
					}
				}
			}else{
				ziUl = parseInt(this.zIndex, 10) + 1;
				ziIn = parseInt(this.zIndex, 10) + 2;
			}

			domStyle.set(this._centerNode, "zIndex", ziIn);
			domStyle.set(this._underlayNode, "zIndex", ziUl);


			var pn = target.parentNode;
			if(pn && pn !== baseWindow.body() &&
				target !== baseWindow.body() &&
				target !== baseWindow.doc){
				
				// If the parent is the body tag itself,
				// we can avoid all this, the body takes
				// care of overflow for me.  Besides, browser
				// weirdness with height and width on body causes
				// problems with this sort of intersect testing
				// anyway.
				var obh = box.h;
				var obw = box.w;
				var pnBox = geometry.position(pn, true);

				//More IE zoom corrections.  Grr.
				if(this._ieFixNode){
					_ie7zoom = -this._ieFixNode.offsetTop / 1000;
					pnBox.x = Math.floor((pnBox.x + 0.9) / _ie7zoom);
					pnBox.y = Math.floor((pnBox.y + 0.9) / _ie7zoom);
					pnBox.w = Math.floor((pnBox.w + 0.9) / _ie7zoom);
					pnBox.h = Math.floor((pnBox.h + 0.9) / _ie7zoom);
				}
				
				//Shift the parent width/height a bit if scollers are present.
				pnBox.w -= pn.scrollHeight > pn.clientHeight &&
					pn.clientHeight > 0 ? scrollers.v: 0;
				pnBox.h -= pn.scrollWidth > pn.clientWidth &&
					pn.clientWidth > 0 ? scrollers.h: 0;

				//RTL requires a bit of massaging in some cases
				//(and differently depending on browser, ugh!)
				//WebKit and others still need work.
				if(dir === "rtl"){
					if(has("opera")){
						box.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(has("ie")){
						pnBox.x += pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0 ? scrollers.v: 0;
					}else if(has("webkit")){
						//TODO:  FIX THIS!
					}
				}

				//Figure out if we need to adjust the overlay to fit a viewable
				//area, then resize it, we saved the original height/width above.
				//This is causing issues on IE.  Argh!
				if(pnBox.w < box.w){
					//Scale down the width if necessary.
					box.w = box.w - pnBox.w;
				}
				if(pnBox.h < box.h){
					//Scale down the width if necessary.
					box.h = box.h - pnBox.h;
				}

				//Look at the y positions and see if we intersect with the
				//viewport borders.  Will have to do computations off it.
				var vpTop = pnBox.y;
				var vpBottom = pnBox.y + pnBox.h;
				var bTop = box.y;
				var bBottom = box.y + obh;
				var vpLeft = pnBox.x;
				var vpRight = pnBox.x + pnBox.w;
				var bLeft = box.x;
				var bRight = box.x + obw;
				var delta;
				//Adjust the height now
				if(bBottom > vpTop &&
					bTop < vpTop){
					box.y = pnBox.y;
					//intersecting top, need to do some shifting.
					delta = vpTop - bTop;
					var visHeight = obh - delta;
					//If the visible height < viewport height,
					//We need to shift it.
					if(visHeight < pnBox.h){
						box.h = visHeight;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.h -= 2*(pn.scrollWidth > pn.clientWidth &&
							pn.clientWidth > 0? scrollers.h: 0);
					}
				}else if(bTop < vpBottom && bBottom > vpBottom){
					//Intersecting bottom, just figure out how much
					//overlay to show.
					box.h = vpBottom - bTop;
				}else if(bBottom <= vpTop || bTop >= vpBottom){
					//Outside view, hide it.
					box.h = 0;
				}

				//adjust width
				if(bRight > vpLeft && bLeft < vpLeft){
					box.x = pnBox.x;
					//intersecting left, need to do some shifting.
					delta = vpLeft - bLeft;
					var visWidth = obw - delta;
					//If the visible width < viewport width,
					//We need to shift it.
					if(visWidth < pnBox.w){
						box.w = visWidth;
					}else{
						//Deal with horizontal scrollbars if necessary.
						box.w -= 2*(pn.scrollHeight > pn.clientHeight &&
							pn.clientHeight > 0? scrollers.w:0);
					}
				}else if(bLeft < vpRight && bRight > vpRight){
					//Intersecting right, just figure out how much
					//overlay to show.
					box.w = vpRight - bLeft;
				}else if(bRight <= vpLeft || bLeft >= vpRight){
					//Outside view, hide it.
					box.w = 0;
				}
			}

			if(box.h > 0 && box.w > 0){
				//Set position and size of the blocking div overlay.
				domStyle.set(this._underlayNode, {
					display: "block",
					width: box.w + "px",
					height: box.h + "px",
					top: box.y + "px",
					left: box.x + "px"
				});

				var styles = ["borderRadius", "borderTopLeftRadius",
					"borderTopRightRadius","borderBottomLeftRadius",
					"borderBottomRightRadius"];
				this._cloneStyles(styles);
				if(!has("ie")){
					//Browser specific styles to try and clone if non-IE.
					styles = ["MozBorderRadius", "MozBorderRadiusTopleft",
						"MozBorderRadiusTopright","MozBorderRadiusBottomleft",
						"MozBorderRadiusBottomright","WebkitBorderRadius",
						"WebkitBorderTopLeftRadius", "WebkitBorderTopRightRadius",
						"WebkitBorderBottomLeftRadius","WebkitBorderBottomRightRadius"
					];
					this._cloneStyles(styles, this);
				}
				var cntrIndicatorTop = (box.h/2) - (cntrIndicator.h/2);
				var cntrIndicatorLeft = (box.w/2) - (cntrIndicator.w/2);
				//Only show the image if there is height and width room.
				if(box.h >= cntrIndicator.h && box.w >= cntrIndicator.w){
					domStyle.set(this._centerNode, {
						top: (cntrIndicatorTop + box.y) + "px",
						left: (cntrIndicatorLeft + box.x) + "px",
						display: "block"
					});
				}else{
					domStyle.set(this._centerNode, "display", "none");
				}
			}else{
				//Target has no size, display nothing on it!
				domStyle.set(this._underlayNode, "display", "none");
				domStyle.set(this._centerNode, "display", "none");
			}
			if(this._resizeCheck === null){
				//Set an interval timer that checks the target size and scales as needed.
				//Checking every 10th of a second seems to generate a fairly smooth update.
				var self = this;
				this._resizeCheck = setInterval(function(){self._size();}, 100);
			}
		}
	},

	_cloneStyles: function(list){
		// summary:
		//		Internal function to clone a set of styles from the target to
		//		the underlay.
		// list: Array
		//		An array of style names to clone.
		//
		// tags:
		//		private
		array.forEach(list, function(s){
			domStyle.set(this._underlayNode, s, domStyle.get(this.target, s));
		}, this);
	},

	_fadeIn: function(){
		// summary:
		//		Internal function that does the opacity style fade in animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: 0, end: self.opacity}}
		});
		var imageAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 0, end: 1}},
			onEnd: function(){
				self.onShow();
				delete self._anim;
			}
		});
		this._anim = fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_fadeOut: function(){
		// summary:
		//		Internal function that does the opacity style fade out animation.
		// tags:
		//		private
		var self = this;
		var underlayNodeAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._underlayNode,
			properties: {opacity: {start: self.opacity, end: 0}},
			onEnd: function(){
				domStyle.set(this.node,{"display":"none", "zIndex": "-1000"});
			}
		});
		var imageAnim = baseFx.animateProperty({
			duration: self.duration,
			node: self._centerNode,
			properties: {opacity: {start: 1, end: 0}},
			onEnd: function(){
				domStyle.set(this.node,{"display":"none", "zIndex": "-1000"});
				self.onHide();
				self._enableOverflow();
				delete self._anim;
			}
		});
		this._anim = fx.combine([underlayNodeAnim,imageAnim]);
		this._anim.play();
	},

	_ignore: function(e){
		// summary:
		//		Function to ignore events that occur on the overlay.
		// event: Event
		//		The event to halt
		// tags:
		//		private
		if(e){
			event.stop(e);
		}
	},

	_scrollerWidths: function(){
		// summary:
		//		This function will calculate the size of the vertical and
		//		horizontaol scrollbars.
		// returns:
		//		Object of form: {v: Number, h: Number} where v is vertical scrollbar width
		//		and h is horizontal scrollbar width.
		// tags:
		//		private
		var div = construct.create("div");
		domStyle.set(div, {
			position: "absolute",
			opacity: 0,
			overflow: "hidden",
			width: "50px",
			height: "50px",
			zIndex: "-100",
			top: "-200px",
			padding: "0px",
			margin: "0px"
		});
		var iDiv = construct.create("div");
		domStyle.set(iDiv, {
			width: "200px",
			height: "10px"
		});
		div.appendChild(iDiv);
		baseWindow.body().appendChild(div);

		//Figure out content size before and after
		//scrollbars are there, then just subtract to
		//get width.
		var b = geometry.getContentBox(div);
		domStyle.set(div, "overflow", "scroll");
		var a = geometry.getContentBox(div);
		baseWindow.body().removeChild(div);
		return { v: b.w - a.w, h: b.h - a.h };
	},

	/* The following are functions that tie into _Widget.attr() */

	_setTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the text displayed in center
		//		if using text display.
		// text: String
		//		The text to set.
		this._textNode.innerHTML = text;
		this.text = text;
	},

	_setColorAttr: function(c){
		// summary:
		//		Function to allow widget.attr to set the color used for the translucent
		//		div overlay.
		// c: String
		//		The color to set the background underlay to in #XXXXXX format..
		domStyle.set(this._underlayNode, "backgroundColor", c);
		this.color = c;
	},

	_setImageTextAttr: function(text){
		// summary:
		//		Function to allow widget.attr to set the ALT text text displayed for
		//		the image (if using image center display).
		// text: String
		//		The text to set.
		attr.set(this._imageNode, "alt", text);
		this.imageText = text;
	},

	_setImageAttr: function(url){
		// summary:
		//		Function to allow widget.attr to set the url source for the center image
		// text: String
		//		The url to set for the image.
		attr.set(this._imageNode, "src", url);
		this.image = url;
	},

	_setCenterIndicatorAttr: function(indicator){
		// summary:
		//		Function to allow widget.attr to set the node used for the center indicator,
		//		either the image or the text.
		// indicator: String
		//		The indicator to use, either 'image' or 'text'.
		this.centerIndicator = indicator;
		if(indicator === "image"){
			this._centerNode = this._imageNode;
			domStyle.set(this._textNode, "display", "none");
		}else{
			this._centerNode = this._textNode;
			domStyle.set(this._imageNode, "display", "none");
		}
	},

	_disableOverflow: function(){
		 // summary:
		 //		Function to disable scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this.target === baseWindow.body() || this.target === baseWindow.doc){
			 // Store the overflow state we have to restore later.
			 // IE had issues, so have to check that it's defined.  Ugh.
			 this._overflowDisabled = true;
			 var body = baseWindow.body();
			 if(body.style && body.style.overflow){
				 this._oldOverflow = domStyle.get(body, "overflow");
			 }else{
				 this._oldOverflow = "";
			 }
			 if(has("ie") && !has("quirks")){
				 // IE will put scrollbars in anyway, html (parent of body)
				 // also controls them in standards mode, so we have to
				 // remove them, argh.
				 if(body.parentNode &&
					body.parentNode.style &&
					body.parentNode.style.overflow){
					 this._oldBodyParentOverflow = body.parentNode.style.overflow;
				 }else{
					 try{
						this._oldBodyParentOverflow = domStyle.get(body.parentNode, "overflow");
					 }catch(e){
						 this._oldBodyParentOverflow = "scroll";
					 }
				 }
				 domStyle.set(body.parentNode, "overflow", "hidden");
			 }
			 domStyle.set(body, "overflow", "hidden");
		 }
	},

	_enableOverflow: function(){
		 // summary:
		 //		Function to restore scrollbars on the body.  Only used if the overlay
		 //		targets the body or the document.
		 if(this._overflowDisabled){
			delete this._overflowDisabled;
			var body = baseWindow.body();
			// Restore all the overflow.
			if(has("ie") && !has("quirks")){
				body.parentNode.style.overflow = this._oldBodyParentOverflow;
				delete this._oldBodyParentOverflow;
			}
			domStyle.set(body, "overflow", this._oldOverflow);
			if(has("webkit")){
				//Gotta poke WebKit, or scrollers don't come back. :-(
				var div = construct.create("div", { style: {
						height: "2px"
					}
				});
				body.appendChild(div);
				setTimeout(function(){
					body.removeChild(div);
				}, 0);
			}
			delete this._oldOverflow;
		}
	}
});

});

},
'dojo/string':function(){
define([
	"./_base/kernel",	// kernel.global
	"./_base/lang"
], function(kernel, lang){

// module:
//		dojo/string
var ESCAPE_REGEXP = /[&<>'"\/]/g;
var ESCAPE_MAP = {
	'&': '&amp;',
	'<': '&lt;',
	'>': '&gt;',
	'"': '&quot;',
	"'": '&#x27;',
	'/': '&#x2F;'
};
var string = {
	// summary:
	//		String utilities for Dojo
};
lang.setObject("dojo.string", string);

string.escape = function(/*String*/str){
	// summary:
	//		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
	// str:
	//		the string to escape
	if(!str){ return ""; }
	return str.replace(ESCAPE_REGEXP, function(c) {
		return ESCAPE_MAP[c];
	});
};

string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || kernel.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

/*=====
 string.trim = function(str){
	 // summary:
	 //		Trims whitespace from both sides of the string
	 // str: String
	 //		String to be trimmed
	 // returns: String
	 //		Returns the trimmed string
	 // description:
	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	 return "";	// String
 };
 =====*/

	return string;
});

},
'dijit/_Contained':function(){
define([
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		// example:
		//	|	// make a basic custom widget that knows about its parents
		//	|	declare("my.customClass",[dijit._WidgetBase, dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//		Returns next or previous sibling
			// which:
			//		Either "next" or "previous"
			// tags:
			//		private
			var p = this.getParent();
			return (p && p._getSiblingOfChild && p._getSiblingOfChild(this, which == "previous" ? -1 : 1)) || null;	// dijit/_WidgetBase
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit/_WidgetBase
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit/_WidgetBase
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit/_Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'curam/util/UIMFragment':function(){
/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['curam/util/Request',
        "curam/define",
        "curam/debug",
        "curam/util/ScreenContext"],
       function(curamRequest) {
  /*
   * Modification History
   * --------------------
   * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
   * 23-Aug-2012  KW  [CR00339169] Initial Version
   */
  /**
   * @name curam.util.UIMFragment
   * @namespace Allows interaction with fragment UIMs.
   *
   * A "fragment UIM" is a special type of UIM which generates a HTML fragment
   * rather than a full page. It is defined by setting the UIM PAGE element's
   * COMPONENT_TYPE attribute to "PAGE_FRAGMENT". The UIM will then contain a
   * single FIELD which is mapped to a renderer. The output of this renderer will
   * be returned when the UIM is requested. No other HTML (e.g. html, head, body
   * elements) will be returned.
   * 
   * This API provides methods to interact with these types of UIMs.
   * 
   */
  
  curam.define.singleton("curam.util.UIMFragment", {

    /** 
     * Requests a fragment UIM.
     * 
     * @param (Object) args An object containing the following properties:
     * <ul>
     *   <li>pageID : The UIM page id. This is mandatory.</li>
     *   <li>params : A Object with name-value pairs specifying request
     *   parameters. This method will URL encode the parameter values before
     *   making the request. This is optional.</li>
     *   <li>contentPaneID : The ID of the dijit.layout.ContentPane to load the
     *   HTML fragment into. This is mandatory.</li>
     *   <li>onDownloadEnd : The function which will be invoked when the
     *   ContentPane is loaded. This is optional.</li>
     *   <li>onDownloadEnd : The function which will be invoked if there was an
     *   error retrieving the HTML fragment. This is optional.</li>  
     * </ul>
     */
    get: function(args) {

      var pageID = args && args.pageID;
      var url = args && args.url;
      var params = args && args.params;
      var onLoad = args && args.onLoad;
      var onDownloadError = args && args.onDownloadError;

      var targetID = args && args.targetID;


      if (targetID === "" || typeof targetID === "undefined") {
        throw "UIMFragment: targetID must be set.";
      }

      var requestPath = null;
      if (url) {
        //var locale = "en";
        //var topWindow = window.top;
        //if (topWindow.curam && topWindow.curam.config
        //    && topWindow.curam.config.locale) {
        //  locale = topWindow.curam.config.locale;
        //}
        requestPath = url;
      } else {
        // The "_addCDEJParameters()" method adds the "?" to the query string, and
        // the "_encodeParameters()" method assumes this. So, do not change the
        // order of the methods here.
        requestPath = curam.util.UIMFragment._constructPath(pageID)
                          + curam.util.UIMFragment._addCDEJParameters()
                          + curam.util.UIMFragment._encodeParameters(params);
      }
      curam.debug.log("UIMFragment: GET to " + requestPath);

      curam.util.UIMFragment._doService(requestPath, targetID, args,
                                  onLoad, onDownloadError);
    },
    
    /**
     * 
     * @param args
     */
    submitForm: function(onSubmitEvent) {
      var onSubmitEvent = dojo.fixEvent(onSubmitEvent);
      var theForm = onSubmitEvent.target;
      dojo.stopEvent(onSubmitEvent);
      
      // TODO: prevent multiple submits.....
      // if this form has already been submitted just return so the xhrPost
      // below isn't executed multiple times.
      //if (theForm._isSubmitted) {
      //  return false;
      //}
      // Set a flag to indicate this form has been submitted.
      //theForm._isSubmitted = true;
      
      var xhrPostArgs = {
          url: curam.util.UIMFragment._constructFormActionPath(theForm),
          form: theForm,
          load: function(data) 
            { 
              var cp = dijit.getEnclosingWidget(theForm);
              cp.set("content", data);
            },
          error: function(error){alert('form error: error!!')}
        };
        
      curamRequest.post(xhrPostArgs);
      
      console.log(onSubmitEvent + " " + theForm);
    },
    
    _constructFormActionPath: function(theForm) {
      var prefix = "";
      if (window === window.top) {
        // top level window so prefix locale:
        prefix = curam.config.locale + "/";
      }
      return prefix + theForm.getAttribute("action"); 
    },
    
    /**
     * 
     * @param pageID The UIM Page ID.
     */
    _initForm: function(contentPaneID) {
      var theForm = dojo.query("form", dijit.byId(contentPaneID).domNode)[0];
      if (theForm) {
        dojo.connect(theForm, "onsubmit", curam.util.UIMFragment.submitForm);
      }
    },

    /**
     * Construct the Url Path. If the function is called from the top most
     * window, we need to prefix the locale to the pathname.
     * 
     * @param {String} pageID The UIM page ID.
     * @Returns {String} Pathname used to create ajax request.
     */
    _constructPath: function(pageID) {
      var currentWindow = window;
      var topWindow = window.top;
      return curam.util.UIMFragment._constructPathValue(
          pageID, currentWindow, topWindow);
    },

    _constructPathValue: function(pageID, currentWindow, topWindow) {
      if (pageID === "" || typeof pageID === "undefined") {
        throw "UIMFragment: pageID must be set.";
      }
      var pathPrefix = "";
      // TODO: can we just use currentWindow === topWindow ?
      if (currentWindow.location.pathname === topWindow.location.pathname) {
        // it's the "top level" window so we need to add the locale to the Path.
        var locale = topWindow.curam && topWindow.curam.config
                                                && topWindow.curam.config.locale;
        // should always be set, but have included default case just to be safe.
        pathPrefix = (locale || "en") + "/";
      }
      return pathPrefix + pageID + "Page.do";
    },

    /** 
     * Encode the parameters and appended them to the request Path.
     * 
     * @param {Object} params
     *        Parameters to append to path,
     *        expected format: { name:"value", ... }.
     * @Returns {String}
     *        Encoded request parameters prefixed with question mark.
     */
    _encodeParameters: function(params) {

      if (typeof params === "undefined" || dojo.toJson(params) === "{}") {
        curam.debug.log("UIMFragment: No params included in request.");
        return "";
      }
   
      var result = [];
      for (var paramName in params) {
        result.push(paramName + "=" + encodeURIComponent(params[paramName]));
      }
      // This method assumes that _addCDEJParameters() as been called which
      // guarantees that a parameter has been already added. Therefore, this
      // string starts with an "&". 
      return "&" + result.join("&");
    },
    
    /**
     * Adds CDEJ parameters to the request string. This function assumes it is
     * called directly after _constructPath() so it always starts with a "?".
     * The screen context parameter is the only one required for "fragment"
     * requests.
     */
    _addCDEJParameters: function() {
      return "?" + jsScreenContext.toRequestString();
    },

    /**
     * Creates a Ajax post request using the dojo api. Any parameters to be sent
     * with the request are included as per a normal get|post request.
     *
     * @param {String} method
     *        The method of the request, either "GET" or "POST".
     * @param {String} path
     *        The path to invoke on the web-tier.
     * @param {Object} params
     *        The parameters to be included with the post.
     * @param {Function} onDownloadEnd
     *        The function to invoke for handling the returned data.
     * @param {Function} onDownloadError
     *        The function to invoke on failure of resolving the path.
     * @param {String} targetID
     *        Dictates what format the response will be in, e.g. Text or JSON.
     */
    _doService: function(url, targetID, args, onLoad, onDownloadError) {

      var cp = dijit.byId(targetID);
      
      //cp.onDownloadError = dojo.hitch(
      //    this, curam.util.UIMFragment._handleDownloadError, onDownloadError);
      
      //cp.onDownloadEnd = dojo.hitch(
      //    cp, curam.util.UIMFragment._handleDownloadSuccess, args, onDownloadEnd);

      // onLoad is called after either setHref or setContent.....
      cp.onLoad = dojo.hitch(
          cp, curam.util.UIMFragment._handleLoadSuccess, args, onLoad);
      
      // Set defaults if not defined
      //if (typeof onDownloadError === "undefined") {
        //onDownloadError = dojo.hitch(this, this._handleDownloadError);
        //cp.set("onDownloadError", this._handleDownloadError);
        //cp.onDownloadError = curam.util.UIMFragment._handleDownloadError;
      //} else {
        //cp.set("onDownloadError", onDownloadError);
        //cp.onDownloadError = onDownloadError;
      //}
      
      //if (typeof onDownloadEnd === "undefined" || onDownloadEnd == null) {
        //onDownloadEnd = dojo.hitch(this, this._handleDownloadSuccess);
        //cp.set("onDownloadEnd ", this._handleDownloadSuccess);
        //cp.onDownloadEnd = curam.util.UIMFragment._handleDownloadSuccess;
      //} else {
        //cp.onDownloadEnd = onDownloadEnd;
      //}
      
      cp.preventCache = true;
      cp.set("href", url);
    },


    /**
     * Generic handler for when the UIMFragment fails.
     *
     * @param {Object} error
     *        Containing all information on the error
     * @param {Object} ioargs
     *        Contains all arguments passed to the web tier in the call, for
     *        debugging purposes.
     */
    _handleDownloadError: function(error) {
      curam.debug.log("Error invoking the UIMFragment: " + error);  
      return "UIMFragment: Generic Error Handler";
    },

    /**
     * When content is loaded into a ContentPane by this class, a number of 
     * actions have to take place:
     * 1. Search the HTML fragment for a form and setup event handlers
     * 2. Invoke the developer specified callback if specified.  
     * 
     * This method will always be called in the scope of the ContentPane that has
     * just been loaded i.e. The "this" keyword will point to a ContentPane.
     *  
     * @param {Object} fragmentArgs The original arguments to the
     * "UIMFragment.get" call.
     * @param {Function} customCallback The developers specified call back.
     */
    _handleLoadSuccess: function(fragmentArgs, customCallback) {
      
      curam.util.UIMFragment._initForm(fragmentArgs.targetID);
      if (customCallback) {
        customCallback(this);
      }
      curam.debug.log("");  
      return "UIMFragment: Generic Success Handler";
    }
  });
  
  return curam.util.UIMFragment;
  
});
},
'curam/tab/TabDescriptor':function(){
/*
 *  IBM Confidential
 *  
 *  OCO Source Materials
 *  
 *  Copyright IBM Corporation 2022.
 *  
 *  The source code for this program is not published or otherwise divested
 *  of its trade secrets, irrespective of what has been deposited with the 
 *  US Copyright Office
 */

/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.tab.TabDescriptor
 * 
 * @namespace <p>
 * Information that provides a unique descriptor for an open tab. This may be
 * used to save and restore the state of the tab. A tab is identified by its
 * "signature" (see below) which makes it unique with respect to other open
 * tabs with the same tab ID.
 * </p>
 * <p>
 * A <code>TabDescriptor</code> may also maintain an object that provides more
 * information about the page contained within the tab. This "tabContent"
 * property is used when constructing URLs for the content, etc.
 * </p>
 * <p>
 * The tab descriptor also tracks the state of the tab. When a tab is created,
 * the descriptor must be saved to the tab session. However, it must first have
 * a tab name assigned and a signature set. If those are set, then the tab can
 * be saved. If a tab has been restored from the session, then it does not need
 * to be saved, as the session already records its presence.
 * </p>
 *
 */
define(["dojo/_base/declare",
        "curam/tab/TabSessionManager",
        "curam/debug"], function(declare, TabSessionManager, debug) {
/*
 * Modification History
 * --------------------
 * 26-Aug-2022  COC [SPM-125576] Auto recovery to include the foreground page details.
 * 18-Jul-2013  SB  [CR00388308] Added publish event for tab context.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 15-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 26-Jan-2011  MV  [CR00244801] Fixed check for DEBUG flag.
 * 14-Jan-2011  DG  [CR00242400] Improved support for updating tab content by
 *                    not removing the tab name if one is already set.
 * 17-Dec-2010  DG  [CR00239200] Option not to select tab on setting signature. 
 * 24-Oct-2010  DG  [CR00217921] Initial version.
 */
/**
 * Creating Resource Bundle Object to access localized resources.
 */

var TabDescriptor = declare("curam.tab.TabDescriptor", null, 
  /** @lends curam.tab.TabDescriptor.prototype */ {
  
  /**
   * Creates a new tab descriptor for the given section and tab configuration
   * ID. The tab signature will be set to null. Until the signature is set,
   * the singleton status of the tab cannot be determined.
   *
   * @param {String} sectionID The section ID for the tab.
   * @param {String} tabID     The configuration ID of the tab.
   */
  constructor: function(sectionID, tabID) {
    this.sectionID = sectionID ? sectionID : null;
    this.tabID = tabID ? tabID : null;
    this.tabSignature = null;
    this.tabContent = null;
    this.tabParamNames = null;
    // Home pages may not be closed. By default, other tabs can be closed.
    this.isHomePage = false;
    // Foreground content for Auto Recovery
    this.foregroundTabContent = null;
    this.restoreModalInd = false;
  },

  /**
   * Converts this tab content description to JSON form, suitable for saving
   * and restoring later.
   *
   * @return The JSON string form of this tab descriptor.
   */
  toJson: function() {
    // NOTE: Do not call "_log" from here, as it calls this function back!

    var value = {"sectionID": this.sectionID,
                 "tabID": this.tabID,
                 "tabSignature": this.tabSignature,
                 "tabParamNames" : this.tabParamNames,
                 "isHomePage": this.isHomePage};

    // This property is optional. Set it to null if it is missing.
    value.tabContent = this.tabContent ? this.tabContent : null;
    // Foreground content for Auto Recovery
    value.foregroundTabContent = this.foregroundTabContent ? this.foregroundTabContent : null;
    value.restoreModalInd = this.restoreModalInd ? this.restoreModalInd : false;   
    return dojo.toJson(value);
  },

  /**
   * Sets the tab content. This function should be used in preference to setting
   * properties of the tab content in an ad hoc manner, as it ensures that all
   * of the necessary values are set correctly. The tab name (title) may be set
   * independently, if required. If no tab name is given, then the tab name will
   * not be changed, unless it is not already set, in which case it will be
   * initialized to an empty string.
   *
   * @param {curam.ui.PageRequest} uimPageRequest The request detailing the
   *   content of the tab: its page ID, parameters, etc.
   * @param {String} tabName The name (title) of the tab.
   */
  setTabContent: function(uimPageRequest, tabName) {
    if (this.tabContent) {
      this._log(debug.getProperty("curam.tab.TabDescriptor.content.changed"));
    } else {
      this._log(debug.getProperty("curam.tab.TabDescriptor.content.set"));
    }

    // Blend the page parameters with the "system" parameters.
    var contentParameters = dojo.clone(uimPageRequest.parameters);
    dojo.mixin(contentParameters, uimPageRequest.cdejParameters);

    if (!this.tabContent) {
      // Create the content and populate it, or overwrite the existing content.
      this.tabContent = {};
    }
    this.tabContent.parameters = contentParameters;
    this.tabContent.pageID = uimPageRequest.pageID;

    if (tabName) {
      this.tabContent.tabName = tabName;
    } else if (!this.tabContent.tabName) {
      this.tabContent.tabName = "";
    }
    // else we leave the tab name unchanged, as no new name was given. This
    // can be the case when the content page is changed. We only get notified
    // of the new page request details, not the page title.

    this._save();
    dojo.publish("/curam/tab/labelUpdated");
  },

  /**
   * <p>
   * Sets the "signature" of the tab. The signature combines the tab ID with
   * the set of parameters and their values that uniquely identity an instance
   * of a tab. The signature is stored as a string, allowing quick and efficient
   * comparison. To ensure that signatures are comparable, the parameters are
   * added to the signature in the lexicographical order of their names. Once
   * set, signatures are never parsed, they are simply compared as strings.
   * </p>
   * <p>
   * Only the parameters in the page request that are named in the tab
   * configuration are used in the signature. All of the other parameters,
   * including the CDEJ "system" parameters are ignored. The full parameter
   * list is maintained as part of the tab content, not the signature.
   * </p>
   * <p>
   * If the tab requires no parameters, the signature will be just the tab ID.
   * It can then be treated as a "singleton" tab instance. If the signature has
   * not yet been set, it will be null. It is usually set by a call to the
   * UIController generated by the TabRenderer.
   * </p>
   *
   * @param {Array} tabParamNames The names of the tab parameters to be
   *   extracted from the request parameters. This may be empty, but not null.
   * @param {curam.ui.PageRequest} uimPageRequest The request containing all
   *   of the parameters and their values.
   * @param {Boolean} openInBackground "true" to avoid recording the tab as the
   *   currently selected tab in local storage, "false" (or undefined) is the
   *   more typical case for a newly created tab.
   */
  setTabSignature: function(tabParamNames, uimPageRequest, openInBackground) {
    // Note: the format for the tab signature is deliberately not JSON or a
    // URL. This is to discourage any inclination to parse it, as that would
    // suggest the developer has missed he point of the signature: it is just
    // a unique token.
    if (!this.tabSignature) {
      // The tab param names are saved to allow them to be used again when
      // trying to match this tab to another uimPageRequest. We simply generate
      // the signature from the new request and see if it matches this
      // signature. The "slice(0)" call makes a full copy of the array before
      // sorting to avoid any unwanted side effects.
      this.tabParamNames = tabParamNames.slice(0);
      this.tabParamNames.sort();
      this.tabSignature = this._generateSignature(
          this.tabID, this.tabParamNames, uimPageRequest);
      this._log(debug.getProperty("curam.tab.TabDescriptor.signature.set"));
      this._save();
      // When a new tab is created in the foreground, it is selected. However,
      // the tab signature is only set after the content page has loaded. Until
      // then, we cannot record the tab as selected, as the signature is not
      // complete and comparisons will fail. Therefore, when the signature is
      // set, we record the tab as the selected one unless instructed otherwise.
      if (!openInBackground) {
        this._select();
      }
    } else {
      // The signature can only be set once, as the identity of a tab must not
      // change, even if its content changes. The content is tracked separately.
      this._log(debug
        .getProperty("curam.tab.TabDescriptor.signature.not.set"));
    }
  },

  /**
   * Indicates if this tab descriptor matches a page request. As this tab
   * descriptor is associated with an open tab, a request to open a page must
   * be checked to see if that page is already open in a tab. This function
   * makes that match. This function should not be called before this tab's
   * signature has been set.
   *
   * @param {curam.ui.PageRequest} uimPageRequest The new page request that
   *   should be tested to see if it matches this tab.
   * @return {Boolean} true if the page request matches this tab.
   */
  matchesPageRequest: function(uimPageRequest) {
    return this.tabSignature
        && this.tabSignature == this._generateSignature(
               this.tabID, this.tabParamNames, uimPageRequest);
  },

  /**
   * Generates a "signature" for a tab. See above for details.
   *
   * @param {String} tabID The ID of the tab.
   * @param {Array} tabParamNames A sorted list of the names of the parameters
   *   to take from the request when generating the signature.
   * @param {curam.ui.PageRequest} uimPageRequest The request containing all
   *   of the parameters and their values.
   * @return {String} The tab signature string.
   *
   * @private
   */
  _generateSignature: function(tabID, tabParamNames, uimPageRequest) {
    // The tab ID is the base of the signature. The parameters are added if
    // they are available.
    var newSig = tabID;

    if (tabParamNames) {
      for (var i = 0; i < tabParamNames.length; i++) {
        var name = tabParamNames[i];
        if (uimPageRequest.parameters[name]) {
          newSig += "|" + name + "=" + uimPageRequest.parameters[name];
        }
      }
    }
    return newSig;
  },

  /**
   * Saves the tab to the tab session if the tab information is complete and if
   * it has not already been saved.
   *
   * @private
   */
  _save: function() {
    if (this.tabContent && this.tabSignature) {
      this._log(debug.getProperty("curam.tab.TabDescriptor.saving"));
      new TabSessionManager().tabUpdated(this);
    }
  },

  /**
   * <p>
   * Records the tab as the selected tab in the tab session. This is
   * complicated. After a tab loads for the first time, it communicates its
   * tab signature parameters in a call-back to the "UIController" and then
   * "TabDescriptor.setTabSignature" is called. It is only at this time that
   * the tab descriptor has enough information to allow it to be recorded as
   * the selected tab. Therefore, when the tab was opened, and before it
   * completed loading, the selection event had to be discarded. Only now can
   * the selection be saved, as we assume that we are being called back to set
   * the signature.
   * </p>
   * <p>
   * For the selection of already loaded tabs, this is not a problem and the
   * normal selection handler in the "TabSessionManager" is called in response
   * to that event.
   * </p>
   *
   * @private
   */
  _select: function() {
    // TODO: Probably need to add a check that this tab is still the selected
    // tab, as the selection may have changed while this tab was loading. -- DG
    if (this.tabSignature) {
      this._log(debug.getProperty("curam.tab.TabDescriptor.selecting"));
      new TabSessionManager().tabSelected(this);
    }
  },

  /**
   * Simplifies the production of consistent log messages for this class.
   *
   * @param {String} msg The message to be logged.
   * @private
   */
  _log: function(msg) {
    // If debug logging is turned off, then we do not want to keep the overhead
    // of converting objects to JSON form to create the log message, so we
    // check the DEBUG switch even before calling "curam.debug.log".
    if (curam.debug.enabled()) {
      curam.debug.log("TAB DESCRIPTOR: " + msg + " [" + this.toJson() + "]");
    }
  }
});

/*
 * Add a "static" method to the above class that can be used as a factory
 * method for creating tab descriptors from JSON strings. This avoids the
 * need to instantiate a TabDescriptor object before calling "fromJson".
 * This can be called as: <code>curam.tab.TabDescriptor.fromJson(String)</code>,
 * i.e., without any "new" keyword or parentheses after the class name.
 */
dojo.mixin(curam.tab.TabDescriptor, {
  /**
   * Creates a new tab descriptor from a previously serialized descriptor
   * represented as a JSON string. The JSON string must have been created
   * using the "toJson" method of this class.
   *
   * @param {String} jsonTabDescriptor The JSON tab descriptor string, if this
   *                                     is not set, null will be returned.
   * @return A tab descriptor parsed from the JSON string, or null.
   */
  fromJson: function(jsonTabDescriptor) {
    var result = null;

    if (jsonTabDescriptor) {
      var rawTD = dojo.fromJson(jsonTabDescriptor);
      var result = new curam.tab.TabDescriptor(rawTD.sectionID, rawTD.tabID);

      // Values are set if available, otherwise the default values assigned in
      // the constructor are preserved.
      if (rawTD.tabSignature) {
        result.tabSignature = rawTD.tabSignature;
      }
      if (rawTD.tabContent) {
        result.tabContent = rawTD.tabContent;
      }
      if (rawTD.tabParamNames) {
        result.tabParamNames = rawTD.tabParamNames;
      }
      if (rawTD.isHomePage) {
        result.isHomePage = rawTD.isHomePage;
      }
      if (rawTD.foregroundTabContent) {
        result.foregroundTabContent = rawTD.foregroundTabContent;
      }
      if (rawTD.restoreModalInd) {
        result.restoreModalInd = rawTD.restoreModalInd;
      }    
    }
    return result;
  }
});

return TabDescriptor;
});

},
'dijit/_Container':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"dojo/_base/kernel" // kernel.deprecated
], function(array, declare, domConstruct, kernel){

	// module:
	//		dijit/_Container

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain HTML and/or a set of widget children.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// All widgets with descendants must set containerNode.
				// NB: this code doesn't quite work right because for TabContainer it runs before
				// _TemplatedMixin::buildRendering(), and thus
				// sets this.containerNode to this.domNode, later to be overridden by the assignment in the template.
				this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			// I want to just call domConstruct.place(widget.domNode, this.containerNode, insertIndex), but the counting
			// is thrown off by text nodes and comment nodes that show up when constructed by markup.
			// In the future consider stripping those nodes on construction, either in the parser or this widget code.
			var refNode = this.containerNode;
			if(insertIndex > 0){
				// Old-school way to get nth child; dojo.query would be easier but _Container was weened from dojo.query
				// in #10087 to minimize download size.   Not sure if that's still and issue with new smaller dojo/query.
				refNode = refNode.firstChild;
				while(insertIndex > 0){
					if(refNode.nodeType == 1){ insertIndex--; }
					refNode = refNode.nextSibling;
				}
				if(refNode){
					insertIndex = "before";
				}else{
					// to support addChild(child, n-1) where there are n children (should add child at end)
					refNode = this.containerNode;
					insertIndex = "last";
				}
			}

			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove (ie, removeChild(5) removes the sixth widget).

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit/_WidgetBase*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//		private
			var children = this.getChildren(),
				idx = array.indexOf(children, child);	// int
			return children[idx + dir];
		},

		getIndexOfChild: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'curam/util/ui/form/renderer/CheckboxEditRendererFormEventsAdapter':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022
 *
 */
define(["dojo/_base/declare", "curam/util/ui/form/renderer/GenericRendererFormEventsAdapter"], function(declare, GenericRendererFormEventsAdapter) {

	/*
	 * Modification History
	 * --------------------
	 * 09-NOV-2022  BD [SPM-125872] Changed the superclass to GenericRendererFormEventsAdapter.
	 * 09-NOV-2022  BD [SPM-126066] Initial version.
	 */

	/**
	 * @namespace Functions to support Autorecovery
	 */


	var CheckboxEditRendererFormEventsAdapter = declare("curam.util.ui.form.renderer.CheckboxEditRendererFormEventsAdapter", GenericRendererFormEventsAdapter,
      /** @lends curam.util.ui.form.renderer.CheckboxEditRendererFormEventsAdapater */ {

			setFormElementValue: function(value) {
				this.element.checked = value;
			},

			getFormElementValue: function() {
				return this.getFormElement().checked;
			},

		});

	return CheckboxEditRendererFormEventsAdapter;
});
},
'dijit/layout/BorderContainer':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.style
	"dojo/keys",
	"dojo/_base/lang", // getObject() hitch() delegate()
	"dojo/on",
	"dojo/touch",
	"../_WidgetBase",
	"../_Widget",
	"../_TemplatedMixin",
	"./LayoutContainer",
	"./utils"        // layoutUtils.layoutChildren
], function(array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, keys, lang, on, touch,
			_WidgetBase, _Widget, _TemplatedMixin, LayoutContainer, layoutUtils){

	// module:
	//		dijit/layout/BorderContainer

	var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin ], {
		// summary:
		//		A draggable spacer between two items in a `dijit/layout/BorderContainer`.
		// description:
		//		This is instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create it directly.
		// tags:
		//		private

		/*=====
		 // container: [const] dijit/layout/BorderContainer
		 //		Pointer to the parent BorderContainer
		 container: null,

		 // child: [const] dijit/layout/_LayoutWidget
		 //		Pointer to the pane associated with this splitter
		 child: null,

		 // region: [const] String
		 //		Region of pane associated with this splitter.
		 //		"top", "bottom", "left", "right".
		 region: null,
		 =====*/

		// live: [const] Boolean
		//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
		//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
		live: true,

		/* CURAM-FIX removed role="separator" as it was causing splitter to be announced as a menu by screenreader */
		templateString: '<div class="dijitSplitter" data-dojo-attach-event="onkeydown:_onKeyDown,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0"><div class="dijitSplitterThumb"></div></div>',
		/* CURAM-FIX */
		
		constructor: function(){
			this._handlers = [];
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			this.horizontal = /top|bottom/.test(this.region);
			this._factor = /top|left/.test(this.region) ? 1 : -1;
			this._cookieName = this.container.id + "_" + this.region;
		},

		buildRendering: function(){
			this.inherited(arguments);

			domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

			if(this.container.persist){
				// restore old size
				var persistSize = cookie(this._cookieName);
				if(persistSize){
					this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
				}
			}
		},

		_computeMaxSize: function(){
			// summary:
			//		Return the maximum size that my corresponding pane can be set to

			var dim = this.horizontal ? 'h' : 'w',
				childSize = domGeometry.getMarginBox(this.child.domNode)[dim],
				center = array.filter(this.container.getChildren(), function(child){
					return child.region == "center";
				})[0];

			// Can expand until center is crushed.  But always leave room for center's padding + border,
			//  otherwise on the next call domGeometry methods start to lie about size.
			var spaceAvailable = domGeometry.getContentBox(center.domNode)[dim] - 10;

			return Math.min(this.child.maxSize, childSize + spaceAvailable);
		},

		_startDrag: function(e){
			if(!this.cover){
				this.cover = domConstruct.place("<div class=dijitSplitterCover></div>", this.child.domNode, "after");
			}
			domClass.add(this.cover, "dijitSplitterCoverActive");

			// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
			if(this.fake){
				domConstruct.destroy(this.fake);
			}
			if(!(this._resize = this.live)){ //TODO: disable live for IE6?
				// create fake splitter to display at old position while we drag
				(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
				domClass.add(this.domNode, "dijitSplitterShadow");
				domConstruct.place(this.fake, this.domNode, "after");
			}
			domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
			if(this.fake){
				domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
			}

			//Performance: load data info local vars for onmousevent function closure
			var factor = this._factor,
				isHorizontal = this.horizontal,
				axis = isHorizontal ? "pageY" : "pageX",
				pageStart = e[axis],
				splitterStyle = this.domNode.style,
				dim = isHorizontal ? 'h' : 'w',
				childCS = domStyle.getComputedStyle(this.child.domNode),
				childStart = domGeometry.getMarginBox(this.child.domNode, childCS)[dim],
				max = this._computeMaxSize(),
				min = Math.max(this.child.minSize, domGeometry.getPadBorderExtents(this.child.domNode, childCS)[dim] + 10),
				region = this.region,
				splitterAttr = region == "top" || region == "bottom" ? "top" : "left", // style attribute of splitter to adjust
				splitterStart = parseInt(splitterStyle[splitterAttr], 10),
				resize = this._resize,
				layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id),
				de = this.ownerDocument;

			this._handlers = this._handlers.concat([
				on(de, touch.move, this._drag = function(e, forceResize){
					var delta = e[axis] - pageStart,
						childSize = factor * delta + childStart,
						boundChildSize = Math.max(Math.min(childSize, max), min);

					if(resize || forceResize){
						layoutFunc(boundChildSize);
					}
					// TODO: setting style directly (usually) sets content box size, need to set margin box size
					splitterStyle[splitterAttr] = delta + splitterStart + factor * (boundChildSize - childSize) + "px";
				}),
				on(de, "dragstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(this.ownerDocumentBody, "selectstart", function(e){
					e.stopPropagation();
					e.preventDefault();
				}),
				on(de, touch.release, lang.hitch(this, "_stopDrag"))
			]);
			e.stopPropagation();
			e.preventDefault();
		},

		_onMouse: function(e){
			// summary:
			//		Handler for onmouseenter / onmouseleave events
			var o = (e.type == "mouseover" || e.type == "mouseenter");
			domClass.toggle(this.domNode, "dijitSplitterHover", o);
			domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
		},

		_stopDrag: function(e){
			try{
				if(this.cover){
					domClass.remove(this.cover, "dijitSplitterCoverActive");
				}
				if(this.fake){
					domConstruct.destroy(this.fake);
				}
				domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter"
					+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
				this._drag(e); //TODO: redundant with onmousemove?
				this._drag(e, true);
			}finally{
				this._cleanupHandlers();
				delete this._drag;
			}

			if(this.container.persist){
				cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires: 365});
			}
		},

		_cleanupHandlers: function(){
			var h;
			while(h = this._handlers.pop()){
				h.remove();
			}
		},

		_onKeyDown: function(/*Event*/ e){
			// should we apply typematic to this?
			this._resize = true;
			var horizontal = this.horizontal;
			var tick = 1;
			switch(e.keyCode){
				case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
					tick *= -1;
//				break;
				case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
					break;
				default:
//				this.inherited(arguments);
					return;
			}
			var childSize = domGeometry.getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
			this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
			e.stopPropagation();
			e.preventDefault();
		},

		destroy: function(){
			this._cleanupHandlers();
			delete this.child;
			delete this.container;
			delete this.cover;
			delete this.fake;
			this.inherited(arguments);
		}
	});

	var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin], {
		// summary:
		//		Just a spacer div to separate side pane from center pane.
		//		Basically a trick to lookup the gutter/splitter width from the theme.
		// description:
		//		Instantiated by `dijit/layout/BorderContainer`.  Users should not
		//		create directly.
		// tags:
		//		private

		templateString: '<div class="dijitGutter" role="presentation"></div>',

		postMixInProperties: function(){
			this.inherited(arguments);
			this.horizontal = /top|bottom/.test(this.region);
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
		}
	});

	var BorderContainer = declare("dijit.layout.BorderContainer", LayoutContainer, {
		// summary:
		//		A BorderContainer is a `dijit/LayoutContainer` that can have draggable splitters between the children,
		//		in order to adjust their sizes.
		//
		//		In addition, it automatically adds some space between the children even
		//		if they don't have a draggable splitter between them, and space between the edge of the BorderContainer
		//		and the children that are adjacent to the edge.  Note that the intended style is that all the children
		//		have borders, but (despite the name) the BorderContainer itself does not.
		//
		//		See `BorderContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `BorderContainer`.

		// gutters: [const] Boolean
		//		Give each pane a border and margin.
		//		Margin determined by domNode.paddingLeft.
		//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
		gutters: true,

		// liveSplitters: [const] Boolean
		//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
		liveSplitters: true,

		// persist: Boolean
		//		Save splitter positions in a cookie.
		persist: false,

		baseClass: "dijitBorderContainer",

		// _splitterClass: Function||String
		//		Optional hook to override the default Splitter widget used by BorderContainer
		_splitterClass: _Splitter,

		postMixInProperties: function(){
			// change class name to indicate that BorderContainer is being used purely for
			// layout (like LayoutContainer) rather than for pretty formatting.
			if(!this.gutters){
				this.baseClass += "NoGutter";
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override LayoutContainer._setupChild().

			this.inherited(arguments);

			var region = child.region, ltr = child.isLeftToRight();
			if(region == "leading"){
				region = ltr ? "left" : "right";
			}
			if(region == "trailing"){
				region = ltr ? "right" : "left";
			}

			if(region){
				// Create draggable splitter for resizing pane,
				// or alternately if splitter=false but BorderContainer.gutters=true then
				// insert dummy div just for spacing
				if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
					var _Splitter = child.splitter ? this._splitterClass : _Gutter;
					if(lang.isString(_Splitter)){
						_Splitter = lang.getObject(_Splitter);	// for back-compat, remove in 2.0
					}
					var splitter = new _Splitter({
						id: child.id + "_splitter",
						container: this,
						child: child,
						region: region,
						live: this.liveSplitters
					});
					splitter.isSplitter = true;
					child._splitterWidget = splitter;

					// Make the tab order match the visual layout by placing the splitter before or after the pane,
					// depending on where the splitter is visually compared to the pane.
					var before = region == "bottom" || region == (this.isLeftToRight() ? "right" : "left");
					domConstruct.place(splitter.domNode, child.domNode, before ? "before" : "after");

					// Splitters aren't added as Contained children, so we need to call startup explicitly
					splitter.startup();
				}
			}
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			this._layoutChildren();
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget.removeChild().

			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
				delete child._splitterWidget;
			}

			this.inherited(arguments);
		},

		getChildren: function(){
			// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
			return array.filter(this.inherited(arguments), function(widget){
				return !widget.isSplitter;
			});
		},

		// TODO: remove in 2.0
		getSplitter: function(/*String*/region){
			// summary:
			//		Returns the widget responsible for rendering the splitter associated with region
			// tags:
			//		deprecated
			return array.filter(this.getChildren(), function(child){
				return child.region == region;
			})[0]._splitterWidget;
		},

		resize: function(newSize, currentSize){
			// Overrides _LayoutWidget.resize().

			// resetting potential padding to 0px to provide support for 100% width/height + padding
			// TODO: this hack doesn't respect the box model and is a temporary fix
			if(!this.cs || !this.pe){
				var node = this.domNode;
				this.cs = domStyle.getComputedStyle(node);
				this.pe = domGeometry.getPadExtents(node, this.cs);
				this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
				this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);

				domStyle.set(node, "padding", "0px");
			}

			this.inherited(arguments);
		},

		_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
			// summary:
			//		This is the main routine for setting size/position of each child.
			// description:
			//		With no arguments, measures the height of top/bottom panes, the width
			//		of left/right panes, and then sizes all panes accordingly.
			//
			//		With changedRegion specified (as "left", "top", "bottom", or "right"),
			//		it changes that region's width/height to changedRegionSize and
			//		then resizes other regions that were affected.
			// changedChildId:
			//		Id of the child which should be resized because splitter was dragged.
			// changedChildSize:
			//		The new width/height (in pixels) to make specified child

			if(!this._borderBox || !this._borderBox.h){
				// We are currently hidden, or we haven't been sized by our parent yet.
				// Abort.   Someone will resize us later.
				return;
			}

			// Combining the externally specified children with splitters and gutters
			var childrenAndSplitters = [];
			array.forEach(this._getOrderedChildren(), function(pane){
				childrenAndSplitters.push(pane);
				if(pane._splitterWidget){
					childrenAndSplitters.push(pane._splitterWidget);
				}
			});

			// Compute the box in which to lay out my children
			var dim = {
				l: this.pe.l,
				t: this.pe.t,
				w: this._borderBox.w - this.pe.w,
				h: this._borderBox.h - this.pe.h
			};

			// Layout the children, possibly changing size due to a splitter drag
			layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters,
				changedChildId, changedChildSize);
		},

		destroyRecursive: function(){
			// Destroy splitters first, while getChildren() still works
			array.forEach(this.getChildren(), function(child){
				var splitter = child._splitterWidget;
				if(splitter){
					splitter.destroy();
				}
				delete child._splitterWidget;
			});

			// Then destroy the real children, and myself
			this.inherited(arguments);
		}
	});

	BorderContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a BorderContainer.

		// splitter: [const] Boolean
		//		Parameter for children where region != "center".
		//		If true, enables user to resize the widget by putting a draggable splitter between
		//		this widget and the region=center widget.
		splitter: false,

		// minSize: [const] Number
		//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
		minSize: 0,

		// maxSize: [const] Number
		//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
		maxSize: Infinity
	};
	lang.mixin(BorderContainer.ChildWidgetProperties, LayoutContainer.ChildWidgetProperties);

	// Since any widget can be specified as a BorderContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ BorderContainer.ChildWidgetProperties);

	// For monkey patching
	BorderContainer._Splitter = _Splitter;
	BorderContainer._Gutter = _Gutter;

	return BorderContainer;
});

},
'dojo/dnd/Mover':function(){
define([
	"../_base/array", "../_base/declare", "../_base/lang", "../sniff", "../_base/window",
	"../dom", "../dom-geometry", "../dom-style", "../Evented", "../on", "../touch", "./common", "./autoscroll"
], function(array, declare, lang, has, win, dom, domGeom, domStyle, Evented, on, touch, dnd, autoscroll){

// module:
//		dojo/dnd/Mover

return declare("dojo.dnd.Mover", [Evented], {
	// summary:
	//		an object which makes a node follow the mouse, or touch-drag on touch devices.
	//		Used as a default mover, and as a base class for custom movers.

	constructor: function(node, e, host){
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dom.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;

		function stopEvent(e){
			e.preventDefault();
			e.stopPropagation();
		}

		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following
			// listener is disconnected.
			on(d, touch.move, lang.hitch(this, "onFirstMove")),

			// These are called continually during the drag
			on(d, touch.move, lang.hitch(this, "onMouseMove")),

			// And these are called at the end of the drag
			on(d, touch.release,  lang.hitch(this, "onMouseUp")),

			// cancel text selection and text dragging
			on(d, "dragstart",   stopEvent),
			on(d.body, "selectstart", stopEvent)
		];

		// Tell autoscroll that a drag is starting
		autoscroll.autoScrollStart(d);

		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		autoscroll.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY}, e);
		e.preventDefault();
		e.stopPropagation();
	},
	onMouseUp: function(e){
		if(has("webkit") && has("mac") && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		e.preventDefault();
		e.stopPropagation();
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		//		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = domGeom.getMarginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing domGeom.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = win.doc.body;
				var bs = domStyle.getComputedStyle(b);
				var bm = domGeom.getMarginBox(b, bs);
				var bc = domGeom.getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}

		// Disconnect touch.move that call this function
		this.events.shift().remove();
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		array.forEach(this.events, function(handle){ handle.remove(); });
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

});

},
'dijit/form/ComboBoxMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/Deferred",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin
	"dojo/store/util/QueryResults",
	"./_AutoCompleterMixin",
	"./_ComboBoxMenu",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template){


	// module:
	//		dijit/form/ComboBoxMixin

	return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {
		// summary:
		//		Provides main functionality of ComboBox widget

		// dropDownClass: [protected extension] Function String
		//		Dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: _ComboBoxMenu,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: template,

		baseClass: "dijitTextBox dijitComboBox",

		/*=====
		// store: [const] dojo/store/api/Store|dojo/data/api/Read
		//		Reference to data provider object used by this ComboBox.
		//
		//		Should be dojo/store/api/Store, but dojo/data/api/Read supported
		//		for backwards compatibility.
		store: null,
		=====*/

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		_setHasDownArrowAttr: function(/*Boolean*/ val){
			this._set("hasDownArrow", val);
			this._buttonNode.style.display = val ? "" : "none";
		},

		_showResultList: function(){
			// hide the tooltip
			this.displayMessage("");
			this.inherited(arguments);
		},

		_setStoreAttr: function(store){
			// For backwards-compatibility, accept dojo.data store in addition to dojo/store/api/Store.  Remove in 2.0.
			if(!store.get){
				lang.mixin(store, {
					_oldAPI: true,
					get: function(id){
						// summary:
						//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
						//		Like dojo/store/DataStore.get() except returns native item.
						var deferred = new Deferred();
						this.fetchItemByIdentity({
							identity: id,
							onItem: function(object){
								deferred.resolve(object);
							},
							onError: function(error){
								deferred.reject(error);
							}
						});
						return deferred.promise;
					},
					query: function(query, options){
						// summary:
						//		Queries the store for objects.   Like dojo/store/DataStore.query()
						//		except returned Deferred contains array of native items.
						var deferred = new Deferred(function(){ fetchHandle.abort && fetchHandle.abort(); });
						deferred.total = new Deferred();
						var fetchHandle = this.fetch(lang.mixin({
							query: query,
							onBegin: function(count){
								deferred.total.resolve(count);
							},
							onComplete: function(results){
								deferred.resolve(results);
							},
							onError: function(error){
								deferred.reject(error);
							}
						}, options));
						return QueryResults(deferred);
					}
				});
			}
			this._set("store", store);
		},

		postMixInProperties: function(){
			// Since _setValueAttr() depends on this.store, _setStoreAttr() needs to execute first.
			// Unfortunately, without special code, it ends up executing second.
			var store = this.params.store || this.store;
			if(store){
				this._setStoreAttr(store);
			}

			this.inherited(arguments);

			// User may try to access this.store.getValue() etc.  in a custom labelFunc() function.
			// It's not available with the new data store for handling inline <option> tags, so add it.
			if(!this.params.store && this.store && !this.store._oldAPI){
				var clazz = this.declaredClass;
				lang.mixin(this.store, {
					getValue: function(item, attr){
						kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
						return item[attr];
					},
					getLabel: function(item){
						kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
						return item.name;
					},
					fetch: function(args){
						kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
						var shim = ["dojo/data/ObjectStore"];	// indirection so it doesn't get rolled into a build
						require(shim, lang.hitch(this, function(ObjectStore){
							new ObjectStore({objectStore: this}).fetch(args);
						}));
					}
				});
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this.focusNode.setAttribute("aria-autocomplete", this.autoComplete ? "both" : "list");
		}
	});
});

},
'dijit/form/Select':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox
	"dojo/i18n", // i18n.getLocalization
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie")
	"./_FormSelectWidget",
	"../_HasDropDown",
	"../DropDownMenu",
	"../MenuItem",
	"../MenuSeparator",
	"../Tooltip",
	"../_KeyNavMixin",
	"../registry", // registry.byNode
	"dojo/text!./templates/Select.html",
	"dojo/i18n!./nls/validate"
], function(array, declare, domAttr, domClass, domGeometry, i18n, keys, lang, on, has,
			_FormSelectWidget, _HasDropDown, DropDownMenu, MenuItem, MenuSeparator, Tooltip, _KeyNavMixin, registry, template){

	// module:
	//		dijit/form/Select

	var _SelectMenu = declare("dijit.form._SelectMenu", DropDownMenu, {
		// summary:
		//		An internally-used menu for dropdown that allows us a vertical scrollbar

		// Override Menu.autoFocus setting so that opening a Select highlights the current value.
		autoFocus: true,

		buildRendering: function(){
			this.inherited(arguments);

			this.domNode.setAttribute("role", "listbox");
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));
		},

		focus: function(){
			// summary:
			//		Overridden so that the previously selected value will be focused instead of only the first item
			var found = false,
				val = this.parentWidget.value;
			if(lang.isArray(val)){
				val = val[val.length - 1];
			}
			if(val){ // if focus selected
				array.forEach(this.parentWidget._getChildren(), function(child){
					if(child.option && (val === child.option.value)){ // find menu item widget with this value
						found = true;
						this.focusChild(child, false); // focus previous selection
					}
				}, this);
			}
			if(!found){
				this.inherited(arguments); // focus first item by default
			}
		}
	});

	var Select = declare("dijit.form.Select" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormSelectWidget, _HasDropDown, _KeyNavMixin], {
		// summary:
		//		This is a "styleable" select box - it is basically a DropDownButton which
		//		can take a `<select>` as its input.

		baseClass: "dijitSelect dijitValidationTextBox",

		templateString: template,

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		// required: Boolean
		//		Can be true or false, default is false.
		required: false,

		// state: [readonly] String
		//		"Incomplete" if this select is required but unset (i.e. blank value), "" otherwise
		state: "",

		// message: String
		//		Currently displayed error/prompt message
		message: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		// emptyLabel: string
		//		What to display in an "empty" dropdown
		emptyLabel: "&#160;", // &nbsp;

		// _isLoaded: Boolean
		//		Whether or not we have been loaded
		_isLoaded: false,

		// _childrenLoaded: Boolean
		//		Whether or not our children have been loaded
		_childrenLoaded: false,

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "html",

		_fillContent: function(){
			// summary:
			//		Set the value to be the first, or the selected index
			this.inherited(arguments);
			// set value from selected option
			if(this.options.length && !this.value && this.srcNodeRef){
				var si = this.srcNodeRef.selectedIndex || 0; // || 0 needed for when srcNodeRef is not a SELECT
				this._set("value", this.options[si >= 0 ? si : 0].value);
			}
			// Create the dropDown widget
			this.dropDown = new _SelectMenu({ id: this.id + "_menu", parentWidget: this });
			domClass.add(this.dropDown.domNode, this.baseClass.replace(/\s+|$/g, "Menu "));
		},

		_getMenuItemForOption: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, return the menu item that should be
			//		used to display it.  This can be overridden as needed
			if(!option.value && !option.label){
				// We are a separator (no label set for it)
				return new MenuSeparator({ownerDocument: this.ownerDocument});
			}else{
				// Just a regular menu option
				var click = lang.hitch(this, "_setValueAttr", option);
				var item = new MenuItem({
					option: option,
					label: (this.labelType === 'text' ? (option.label || '').toString()
						.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
						option.label) || this.emptyLabel,
					onClick: click,
					ownerDocument: this.ownerDocument,
					dir: this.dir,
					textDir: this.textDir,
					disabled: option.disabled || false
				});
				item.focusNode.setAttribute("role", "option");
				return item;
			}
		},

		_addOptionItem: function(/*_FormSelectWidget.__SelectOption*/ option){
			// summary:
			//		For the given option, add an option to our dropdown.
			//		If the option doesn't have a value, then a separator is added
			//		in that place.
			if(this.dropDown){
				this.dropDown.addChild(this._getMenuItemForOption(option));
			}
		},

		_getChildren: function(){
			if(!this.dropDown){
				return [];
			}
			return this.dropDown.getChildren();
		},

		focus: function(){
			// Override _KeyNavMixin::focus(), which calls focusFirstChild().
			// We just want the standard form widget behavior.
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
					/*squelch errors from hidden nodes*/
				}
			}
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Sets the value to the given option, used during search by letter.
			// widget:
			//		Reference to option's widget
			// tags:
			//		protected
			if(widget){
				this.set('value', widget.option);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last child widget.
			// tags:
			//		abstract extension
			var children = this._getChildren();
			return children.length ? children[children.length-1] : null;
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this.dropDown;
		},

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_loadChildren: function(/*Boolean*/ loadMenuItems){
			// summary:
			//		Resets the menu and the length attribute of the button - and
			//		ensures that the label is appropriately set.
			// loadMenuItems: Boolean
			//		actually loads the child menu items - we only do this when we are
			//		populating for showing the dropdown.

			if(loadMenuItems === true){
				// this.inherited destroys this.dropDown's child widgets (MenuItems).
				// Avoid this.dropDown (Menu widget) having a pointer to a destroyed widget (which will cause
				// issues later in _setSelected). (see #10296)
				if(this.dropDown){
					delete this.dropDown.focusedChild;
					this.focusedChild = null;
				}
				if(this.options.length){
					this.inherited(arguments);
				}else{
					// Drop down menu is blank but add one blank entry just so something appears on the screen
					// to let users know that they are no choices (mimicing native select behavior)
					array.forEach(this._getChildren(), function(child){
						child.destroyRecursive();
					});
					var item = new MenuItem({
						ownerDocument: this.ownerDocument,
						label: this.emptyLabel
					});
					this.dropDown.addChild(item);
				}
			}else{
				this._updateSelection();
			}

			this._isLoaded = false;
			this._childrenLoaded = true;

			if(!this._loadingStore){
				// Don't call this if we are loading - since we will handle it later
				this._setValueAttr(this.value, false);
			}
		},

		_refreshState: function(){
			if(this._started){
				this.validate(this.focused);
			}
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setValueAttr: function(value){
			this.inherited(arguments);
			domAttr.set(this.valueNode, "value", this.get("value"));
			this._refreshState();	// to update this.state
		},

		_setNameAttr: "valueNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);
			this._refreshState();	// to update this.state
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();	// to update this.state
		},

		_setOptionsAttr: function(/*Array*/ options){
			this._isLoaded = false;
			this._set('options', options);
		},

		_setDisplay: function(/*String*/ newDisplay){
			// summary:
			//		sets the display for the given value (or values)

			var lbl = (this.labelType === 'text' ? (newDisplay || '')
					.replace(/&/g, '&amp;').replace(/</g, '&lt;') :
					newDisplay) || this.emptyLabel;
			this.containerNode.innerHTML = '<span role="option" aria-selected="true" class="dijitReset dijitInline ' + this.baseClass.replace(/\s+|$/g, "Label ") + '">' + lbl + '</span>';
		},

		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress, and whenever required/disabled state changes
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			//		Used when a select is initially set to no value and the user is required to
			//		set the value.

			var isValid = this.disabled || this.isValid(isFocused);
			this._set("state", isValid ? "" : (this._hasBeenBlurred ? "Error" : "Incomplete"));
			this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");
			var message = isValid ? "" : this._missingMsg;
			if(message && this.focused && this._hasBeenBlurred){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
			this._set("message", message);
			return isValid;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Whether or not this is a valid value.  The only way a Select
			//		can be invalid is when it's required but nothing is selected.
			return (!this.required || this.value === 0 || !(/^\s*$/.test(this.value || ""))); // handle value is null or undefined
		},

		reset: function(){
			// summary:
			//		Overridden so that the state will be cleared.
			this.inherited(arguments);
			Tooltip.hide(this.domNode);
			this._refreshState();	// to update this.state
		},

		postMixInProperties: function(){
			// summary:
			//		set the missing message
			this.inherited(arguments);
			this._missingMsg = i18n.getLocalization("dijit.form", "validate", this.lang).missingMessage;
		},

		postCreate: function(){
			this.inherited(arguments);

			// stop mousemove from selecting text on IE to be consistent with other browsers
			this.own(on(this.domNode, "selectstart", function(evt){
				evt.preventDefault();
				evt.stopPropagation();
			}));

			this.domNode.setAttribute("aria-expanded", "false");

			// Prevent _KeyNavMixin from calling stopPropagation() on left and right arrow keys, thus breaking
			// navigation when Select inside Toolbar.
			var keyNavCodes = this._keyNavCodes;
			delete keyNavCodes[keys.LEFT_ARROW];
			delete keyNavCodes[keys.RIGHT_ARROW];
		},

		_setStyleAttr: function(/*String||Object*/ value){
			this.inherited(arguments);
			domClass.toggle(this.domNode, this.baseClass.replace(/\s+|$/g, "FixedWidth "), !!this.domNode.style.width);
		},

		isLoaded: function(){
			return this._isLoaded;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		populates the menu
			this._loadChildren(true);
			this._isLoaded = true;
			loadCallback();
		},

		destroy: function(preserveDom){
			if(this.dropDown && !this.dropDown._destroyed){
				this.dropDown.destroyRecursive(preserveDom);
				delete this.dropDown;
			}
			Tooltip.hide(this.domNode);	// in case Select (or enclosing Dialog) destroyed while tooltip shown
			this.inherited(arguments);
		},

		_onFocus: function(){
			this.validate(true);	// show tooltip if second focus of required tooltip, but no selection
			// Note: not calling superclass _onFocus() to avoid _KeyNavMixin::_onFocus() setting tabIndex --> -1
		},

		_onBlur: function(){
			Tooltip.hide(this.domNode);
			this.inherited(arguments);
			this.validate(false);
		}
	});

	if(has("dojo-bidi")){
		Select = declare("dijit.form.Select", Select, {
			_setDisplay: function(/*String*/ newDisplay){
				this.inherited(arguments);
				this.applyTextDir(this.containerNode);
			}
		});
	}

	Select._Menu = _SelectMenu;	// for monkey patching

	// generic event helper to ensure the dropdown items are loaded before the real event handler is called
	function _onEventAfterLoad(method){
		return function(evt){
			if(!this._isLoaded){
				this.loadDropDown(lang.hitch(this, method, evt));
			}else{
				this.inherited(method, arguments);
			}
		};
	}
	Select.prototype._onContainerKeydown = _onEventAfterLoad("_onContainerKeydown");
	Select.prototype._onContainerKeypress = _onEventAfterLoad("_onContainerKeypress");

	return Select;
});

},
'dijit/_base/manager':function(){
define([
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"dojo/_base/lang",
	"../registry",
	"../main"	// for setting exports to dijit namespace
], function(array, config, lang, registry, dijit){

	// module:
	//		dijit/_base/manager

	var exports = {
		// summary:
		//		Deprecated.  Shim to methods on registry, plus a few other declarations.
		//		New code should access dijit/registry directly when possible.
	};

	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		exports[name] = registry[name];
	});

	 lang.mixin(exports, {
		 // defaultDuration: Integer
		 //		The default fx.animation speed (in ms) to use for all Dijit
		 //		transitional fx.animations, unless otherwise specified
		 //		on a per-instance basis. Defaults to 200, overrided by
		 //		`djConfig.defaultDuration`
		 defaultDuration: config["defaultDuration"] || 200
	 });

	lang.mixin(dijit, exports);

	/*===== return exports; =====*/
	return dijit;	// for back compat :-(
});

},
'curam/util/ui/form/CuramFormsAPI':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022,2023
 *
 */
define(["curam/define", "curam/debug"], function(define, debug) {

	/*
	 * Modification History
	 * --------------------
	 * 19-Jan-2023  COC [SPM-126270] Renaming of functions and file name from FormsEventsAPI to CuramFormsAPI.
	 * 13-Dec-2022  AT  [SPM-126320] Component registration only if CuramFormsAPI is enabled.
	 * 12-Dec-2022  AT  [SPM-126340] Pass the frameID as part of the form-change event.
	 * 09-Dec-2002  COC [SPM-126340] Updated _handleComponentChanges to include href in event.
	 * 08-Dec-2022  AT  [SPM-126340] loadStoredFormData wait on component registration to complete.
	 * 30-Nov-2022  AT  [SPM-126293] Publish message when all form components have registered.
	 * 17-Nov-2022  COC [SPM-125684] Updates based on changes for the multiple tab flows.
	 * 19-Oct-2022  BD  [SPM125820] Re-designed the FormEventAPI.
	 * 14-Sep-2022  BOS [JIRA XXX] Initial version.
	 */

	/**
	 * @namespace Functions specific to the context panel.
	 */
	curam.define.singleton("curam.util.ui.form.CuramFormsAPI", {

		/** Name of the attribute on content iframe that holds the URL of the frame
		 *  content. */
		pageID: "",

		_PATH: "path",

		_VALUE: "value",

		_formComponentMap: {},

		_expectedComponentCount : 0,
		
		_ready : false,

		/**
		 *  Returns true if CuramFormsAPI is enabled, false otherwise.
		 *  
		 *  Where this returns false, the CuramFormsAPI will not register components
		 *  and as a result does not load or notify of change.
		 */
		isEnabled : function() {
			return curam.util.getTopmostWindow().CURAM_FORMS_API_ENABLED === 'true';
		},

		/**
		 *  Increments the counter to inform the CuramFormsAPI that a component will register.
		 *  This function is added by the renderers when adding the code to call registerComponent.
		 *  This is necessary so that CuramFormsAPI can publish a message when all components have  registered
		 *  so that it is safe to start using the CuramFormsAPI to load and save.
		 */
		incrementExpectedComponentsCount : function(adapter, pathID, elementID) {
			this._expectedComponentCount += 1;			
			curam.debug.log("curam.util.CuramFormsAPI: "
					+ debug.getProperty("curam.util.CuramFormsAPI.expectedComponent"), 
					[this._expectedComponentCount, pathID]);
		},

		/**
		 * Returns the count of the number of components.
		 * 
		 * Note, this should not be used as a count of the number of components
		 * that have registered, but a count of those that will register. The
		 * two are guaranteed to be the same only once isReady() returns true.
		 */
		getComponentCount : function() {
			return this._expectedComponentCount;
		},

		/** Returns true when the CuramFormsAPI is read for use, that is, once
		 * all components have finished registering. Alternatively subscribe
		 * to curam/util/CuramFormsAPI/ready. */
		isReady : function() {
			return this._ready;
		},

		/**
		 * Register the component on the form component Map.
		 * The map id is the pathID for each component, and the
		 * value is the component object.
		 * @param component object that represents each renderer.
		*/
		registerComponent: function(component) {
			
			if (!this.isEnabled()) { 
				return;
			}
			
			if (!this._formComponentMap[component.pathID]) {
				this._formComponentMap[component.pathID] = component;
			}
			if (component.addChangeListener && component.addChangeListener instanceof Function) {
				component.addChangeListener(this._handleComponentChanges.bind(this));
			}
			
			var registeredComponentCount = Object.keys(this._formComponentMap).length;
			
			curam.debug.log("curam.util.CuramFormsAPI: "
					+ debug.getProperty("curam.util.CuramFormsAPI.registerComponent"), 
					[registeredComponentCount, component.pathID]);
			if (registeredComponentCount === this._expectedComponentCount) {
				this._ready = true;
				curam.util.getTopmostWindow().dojo.publish("curam/util/CuramFormsAPI/ready");
			}
		},

		/**
		 * Replaces the default form data received via the DISPLAY_PHASE with the values 
		 * passed via the formData parameter.
		 * 
		 * This function takes care of whether all fields have completed registration with the 
		 * CuramFormsAPI and will defer the setting part until it is required.
		 *
		 * @param formPageID The auto recovery page identifier.
		 * @param formData The auto recovery form data.
		 *
		 */
		 setFormFields: function(formPageID, formData) {
			
			if (!this.isEnabled()) { 
				return;
			}

			if (this.isReady()) {
				this._setFormFieldsInternal(formPageID, formData);
			} else {
				this._formPageID = formPageID;
				this._formData = formData;
				var handle = curam.util.getTopmostWindow().dojo.subscribe("curam/util/CuramFormsAPI/ready", this, function() {
					this._setFormFieldsInternal(this._formPageID, this._formData);
					curam.util.getTopmostWindow().dojo.unsubscribe(handle);
				});
			}
		},

		/**
		 * Does the actual load of the stored data as described in setFormFields.
		 * 
		 * The code to do the actual load is refactored here to allow for the two load paths,
		 * one where it can be performed immediately, and one where it must be deferred until
		 * all of the form components have registered.
		 *
		 * @param storedData The auto recovery data stored for the user.
		 *
		 */
		_setFormFieldsInternal: function(formPageID, formData) {
			
			var savedDataForComponents = formData.data;

			for (var key in this._formComponentMap) {
				var component = this._formComponentMap[key];
				if (this._formComponentMap.hasOwnProperty(key) && component) {
					var path = key;
					var dataStoredForComponent = savedDataForComponents.find(function(fgPageData) {
						return path === fgPageData._PATH && fgPageData._VALUE !== ''
					});
					dataStoredForComponent && this._updateComponentWithStoredData(dataStoredForComponent, component);
				}
			}
		},

		/**
		 * Update the Page Component with the data stored for the component with the auto recovery.
		 * @param {*} dataStoredForComponent The auto recovery data stored for the user.
		 * @param {*} component The component object from the page.
		 */
		_updateComponentWithStoredData: function(dataStoredForComponent, component) {
			component.setFormElementValue(dataStoredForComponent._VALUE);
		},

		/**
		 * Handler to dispatch the custom event 'form-change' sending the 
		 * form component map as JSON.  
		 * @param {event} event object.
		 */
		_handleComponentChanges: function(event) {
			var formComponentDataAsJSON = this.getFormComponentDataAsJSON(event);
			var href = location.href;
			var frameID = window.frameElement.id.replace('iframe-', '');
			curam.util.getTopmostWindow().dojo.publish(
				"curam/util/CuramFormsAPI/formChange", [{ data: formComponentDataAsJSON, 'href': href, 'frameID':frameID }]);
		},

		/**
		 * Get the form component data map as JSON.  
		 * @returns array with JSON format with path and value for each component.
		 */
		getFormComponentDataAsJSON: function() {
			var formComponentData = [];
			for (var key in this._formComponentMap) {
				var component = this._formComponentMap[key];
				if (this._formComponentMap.hasOwnProperty(key) && component) {
					var pathID = key;
					formComponentData.push({
						_PATH: pathID,
						_VALUE: component.getFormElementValue()
					});
				}
			}
			var formComponentDataAsJSON = JSON.stringify({
				data: formComponentData
			});
			return formComponentDataAsJSON;
		},

		/**
		 * Get the form component map.
		 * @returns object that contains all the components registered to the FormEvent.
		 */
		getFormComponentMap: function() {
			return this._formComponentMap;
		},

	});
	return curam.util.ui.form.CuramFormsAPI;
});
},
'dojo/data/ItemFileReadStore':function(){
define(["../_base/kernel", "../_base/lang", "../_base/declare", "../_base/array", "../_base/xhr",
	"../Evented", "./util/filter", "./util/simpleFetch", "../date/stamp"
], function(kernel, lang, declare, array, xhr, Evented, filterUtil, simpleFetch, dateStamp){

// module:
//		dojo/data/ItemFileReadStore

var ItemFileReadStore = declare("dojo.data.ItemFileReadStore", [Evented],{
	// summary:
	//		The ItemFileReadStore implements the dojo/data/api/Read API and reads
	//		data from JSON files that have contents in this format --
	// |	{ items: [
	// |		{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	// |		{ name:'Fozzie Bear', wears:['hat', 'tie']},
	// |		{ name:'Miss Piggy', pets:'Foo-Foo'}
	// |	]}
	//		Note that it can also contain an 'identifier' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.

	constructor: function(/* Object */ keywordParameters){
		// summary:
		//		constructor
		// keywordParameters:
		//		{url: String} {data: jsonObject} {typeMap: object}
		//		The structure of the typeMap object is as follows:
		// |	{
		// |		type0: function || object,
		// |		type1: function || object,
		// |		...
		// |		typeN: function || object
		// |	}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		// |	{
		// |		type: function, //constructor.
		// |		deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		// |	}

		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo/date/stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
				type: Date,
				deserialize: function(value){
					return dateStamp.fromISOString(value);
				}
			};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},

	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.

	// clearOnClose: Boolean
	//		Parameter to allow users to specify if a close call should force a reload or not.
	//		By default, it retains the old behavior of not clearing if close is called.  But
	//		if set true, the store will be reset to default state.  Note that by doing this,
	//		all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	// urlPreventCache: Boolean
	//		Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//		Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//		Added for tracker: #6072
	urlPreventCache: false,

	// failOk: Boolean
	//		Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	// hierarchical: Boolean
	//		Parameter to indicate to process data from the url as hierarchical
	//		(data items can contain other data items in js form).  Default is true
	//		for backwards compatibility.  False means only root items are processed
	//		as items, all child objects outside of type-mapped objects and those in
	//		specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* dojo/data/api/Item */ item){
		// summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		// item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error(this.declaredClass + ": Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		// summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		// attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error(this.declaredClass + ": Invalid attribute argument.");
		}
	},

	getValue: function(	/* dojo/data/api/Item */ item,
						   /* attribute-name-string */ attribute,
						   /* value? */ defaultValue){
		// summary:
		//		See dojo/data/api/Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* dojo/data/api/Item */ item,
						/* attribute-name-string */ attribute){
		// summary:
		//		See dojo/data/api/Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		// Clone it before returning.  refs: #10474
		return (item[attribute] || []).slice(0); // Array
	},

	getAttributes: function(/* dojo/data/api/Item */ item){
		// summary:
		//		See dojo/data/api/Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* dojo/data/api/Item */ item,
							   /* attribute-name-string */ attribute){
		// summary:
		//		See dojo/data/api/Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* dojo/data/api/Item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		// summary:
		//		See dojo/data/api/Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = filterUtil.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* dojo/data/api/Item */ item,
								 /* attribute-name-string */ attribute,
								 /* anything */ value,
								 /* RegExp?*/ regexp){
		// summary:
		//		Internal function for looking at the values contained by the item.
		// description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		// item:
		//		The data item to examine for attribute values.
		// attribute:
		//		The attribute to inspect.
		// value:
		//		The value to match.
		// regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return array.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !lang.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		// summary:
		//		See dojo/data/api/Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		// summary:
		//		See dojo/data/api/Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		// summary:
		//		See dojo/data/api/Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		// summary:
		//		See dojo/data/api/Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* dojo/data/api/Item */ item){
		// summary:
		//		See dojo/data/api/Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* dojo/data/api/Item */ item){
		// summary:
		//		See dojo/data/api/Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	filter: function(/* Object */ requestArgs, /* item[] */ arrayOfItems, /* Function */ findCallback){
		// summary:
		//		This method handles the basic filtering needs for ItemFile* based stores.
		var items = [],
			i, key;

		if(requestArgs.query){
			var value,
				ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

			//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
			//same value for each item examined.  Much more efficient.
			var regexpList = {};
			for(key in requestArgs.query){
				value = requestArgs.query[key];
				if(typeof value === "string"){
					regexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);
				}else if(value instanceof RegExp){
					regexpList[key] = value;
				}
			}
			for(i = 0; i < arrayOfItems.length; ++i){
				var match = true;
				var candidateItem = arrayOfItems[i];
				if(candidateItem === null){
					match = false;
				}else{
					for(key in requestArgs.query){
						value = requestArgs.query[key];
						if(!this._containsValue(candidateItem, key, value, regexpList[key])){
							match = false;
						}
					}
				}
				if(match){
					items.push(candidateItem);
				}
			}
			findCallback(items, requestArgs);
		}else{
			// We want a copy to pass back in case the parent wishes to sort the array.
			// We shouldn't allow resort of the internal list, so that multiple callers
			// can get lists and sort without affecting each other.  We also need to
			// filter out any null values that have been left as a result of deleteItem()
			// calls in ItemFileWriteStore.
			for(i = 0; i < arrayOfItems.length; ++i){
				var item = arrayOfItems[i];
				if(item !== null){
					items.push(item);
				}
			}
			findCallback(items, requestArgs);
		}
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							  /* Function */ findCallback,
							  /* Function */ errorCallback){
		// summary:
		//		See dojo/data/util.simpleFetch.fetch()
		var self = this;

		if(this._loadFinished){
			this.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated(this.declaredClass + ": ",
					"To change the url, set the url property of the store," +
						" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: lang.hitch(self, "filter"), findCallback: lang.hitch(self, findCallback)});
				}else{
					this._loadInProgress = true;
					var getArgs = {
						url: self._jsonFileUrl,
						handleAs: "json-comment-optional",
						preventCache: this.urlPreventCache,
						failOk: this.failOk
					};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;

							self.filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions), findCallback);
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					self.filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions), findCallback);
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error(this.declaredClass + ": No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		// summary:
		//		Internal function to execute delayed request in the store.
		
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i],
					delayedQuery = fData.args,
					delayedFilter = fData.filter,
					delayedFindCallback = fData.findCallback;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions), delayedFindCallback);
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		// summary:
		//		Internal function to determine which list of items to search over.
		// queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo/data/api/Request|Object?*/ request){
		// summary:
		//		See dojo/data/api/Read.close()
		if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			//Reset all internalsback to default state.  This will force a reload
			//on next fetch.  This also checks that the data or url param was set
			//so that the store knows it can get data.  Without one of those being set,
			//the next fetch will trigger an error.

			if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				(this.url == "" || this.url == null)
				) && this.data == null){
				console.debug(this.declaredClass + ": WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			}
			this._arrayOfAllItems = [];
			this._arrayOfTopLevelItems = [];
			this._loadFinished = false;
			this._itemsByIdentity = null;
			this._loadInProgress = false;
			this._queuedFetches = [];
		}
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		// summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		// description:
		//		Function to parse the loaded data into item format and build the internal items array.
		// dataObject:
		//		The JS data object containing the raw data to convery into item format.
		// returns: Array
		//		Array of items in store item format.

		// First, we define a couple little utility functions...
		var addingArrays = false,
			self = this;

		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'1802-05-14'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			return (aValue !== null) &&
				(typeof aValue === "object") &&
				(!lang.isArray(aValue) || addingArrays) &&
				(!lang.isFunction(aValue)) &&
				(aValue.constructor == Object || lang.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical;
		}

		function addItemAndSubItemsToArrayOfAllItems(/* dojo/data/api/Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(lang.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i,
			item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(lang.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {},
			key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!lang.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error(this.declaredClass + ":  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error(this.declaredClass + ":  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date(1918, 6, 18)) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(lang.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(lang.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!lang.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k],
										found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		// summary:
		//		Method to add an reference map entry for an item and attribute.
		// description:
		//		Method to add an reference map entry for an item and attribute.
		// refItem:
		//		The item that is referenced.
		// parentItem:
		//		The item that holds the new reference to refItem.
		// attribute:
		//		The attribute on parentItem that contains the new reference.

		//Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* dojo/data/api/Item */ item){
		// summary:
		//		See dojo/data/api/Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object|String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		// summary:
		//		See dojo/data/api/Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item,
			scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated(this.declaredClass + ": ",
					"To change the url, set the url property of the store," +
						" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
						url: self._jsonFileUrl,
						handleAs: "json-comment-optional",
						preventCache: this.urlPreventCache,
						failOk: this.failOk
					};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:kernel.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:kernel.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:kernel.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:kernel.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		// summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			// If this map is defined, we need to just try to get it.  If it fails
			// the item does not exist.
			if(Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
				item = this._itemsByIdentity[identity];
			}
		}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* dojo/data/api/Item */ item){
		// summary:
		//		See dojo/data/api/Identity.getIdentityAttributes()

		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo/data/api/Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},

	_forceLoad: function(){
		// summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			kernel.deprecated(this.declaredClass + ": ",
				"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
			var getArgs = {
				url: this._jsonFileUrl,
				handleAs: "json-comment-optional",
				preventCache: this.urlPreventCache,
				failOk: this.failOk,
				sync: true
			};
			var getHandler = xhr.get(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error(this.declaredClass + ":  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
lang.extend(ItemFileReadStore,simpleFetch);

return ItemFileReadStore;

});

},
'curam/validation/calendar':function(){
define(["curam/define"
        ], function() {
  
  curam.define.singleton("curam.validation.calendar", {
    /* This will be initialized with a localized message by the generated code. */
    invalidGotoDateEntered: null
  });
  
  return curam.validation.calendar;
});

},
'curam/widget/_TabButton':function(){
/*
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * Copyright IBM Corporation 2022.
 *
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the US
 * Copyright Office.
 */

/**
 * @name curam.widget._TabButton
 * @namespace Customized dijit.layout._TabButton class.
 *
 * This code has been taken from Dojo 1.4.0 source and small improvements
 * have been made to it. There are number of TODOs in the code, but they
 * belong to Dojo people and there's no need for us to worry about them.
 *
 */
define(["dojo/_base/declare",
        "dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/has",
        "dojo/i18n",
        "dojo/_base/lang",
        "dojo/text!curam/widget/templates/_TabButton.html",
        "dijit/registry",
        "dojo/_base/connect",
        "curam/inspection/Layer",
        "dijit/layout/StackController", // to load the base class dijit.layout._StackButton
        "dijit/Menu",
        "dijit/MenuItem",
        "curam/widget/MenuItem",
        "curam/tab"], function(declare, dom, domAttr, domClass, domStyle, has, i18n, lang, 
            template, registry, connect, layer) {       
 
/*
 * Modification History
 * --------------------
 * 07-Mar-2022  FN  [RTC254434] Removed code for enabled/disabled tab context render.
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Moved publishing of
 * /curam/tab/closing event to TabContainer.removeChild function.)
 * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 30-Jan-2014  MV  [CR00412899] Refactor tab context info handler for better
 *      performance.
 * 22-Jan-2014  MV  [CR00412812] Fix tab context info handler.
 * 30-Sep-2013  MK  [CR00390932] Upgrade to Dojo 1.9 
 * 04-Aug-2013  NLH  [CR00388987] Toggle button on context panel disappears.
 * 18-Jul-2013  SB  [CR00388308] Added tab context event handler.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 06-Feb-2013  SB  [CR00368739] Updated id of the focusNode.
 * 14-Aug-2012  MV  [CR00338135] Remove dependency on full Dojo API.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 16-Mar-2012  BOS [TEC-9823]   Localizing the tooltip for closing a tab
 * 30-Nov-2011  SB  [CR00293890] Updated span tag inner text for close tab.
 * 03-Dec-2010  MV [CR00232963] Add ability to disable and hide the button.
 */

  /**
   * Updates tab context strings of all tabs, e.g 'Tab 1 of 4'.
   * This is only ever registered once, as the module is loaded.
   */
  connect.subscribe("/curam/tab/labelUpdated", function() {
    var tabs;  
    var tabLists = dojo.query(".dijitTabContainerTop-tabs");
    
    tabLists.forEach(function(tabList){
       tabs = dojo.query('.tabLabel', tabList);
      
       tabs.forEach(function(tab, index){
         var label = tabs[index].innerHTML;
         tab.setAttribute("title", label);
         
         //Add the tab name to the close button title.
         var nextSibling = tab.nextSibling;
         while(nextSibling){
        	 if(domClass.contains(nextSibling, "dijitTabCloseButton")){
        		 var title = nextSibling.getAttribute("title");  
        		 if(title && title.indexOf(label) < 0){
        			 nextSibling.setAttribute("title", title + " - " + label);
        		 } 
        		 break;
        	 }
        	 nextSibling = nextSibling.nextSibling; 
         }
       }); 
    }); 
  });
  
  var _TabButton = declare("curam.widget._TabButton", dijit.layout._StackButton,
 
/**
 * A tab (the thing you click to select a pane).
 * Contains the title of the pane, and optionally a close-button to destroy
 * the pane. This is an internal widget and should not be instantiated
 * directly.
 *
 * @private
 *
 * @lends curam.widget._TabButton.prototype
 */
{
  //>>> Override the templateString to add the class 'dijitTab' to the
  //>>> outer div of each tab button
  templateString: template,

  // Button superclass maps name to a this.valueNode, but we don't have a this.valueNode attach point
  _setNameAttr: "focusNode",

  // Override _FormWidget.scrollOnFocus.
  // Don't scroll the whole tab container into view when the button is focused.
  scrollOnFocus: false,

  curamDisabled: false,
  curamVisible: true,

  // baseClass: String
  //    The CSS class applied to the domNode.
  baseClass: "dijitTab",

  postMixInProperties: function(){
    // Override blank iconClass from Button to do tab height adjustment on IE6,
    // to make sure that tabs with and w/out close icons are same height
    if(!this.iconClass){
      this.iconClass = "dijitTabButtonIcon";
    }
  },

  postCreate: function() {
    this.inherited(arguments);
    dom.setSelectable(this.containerNode, false);

    // If a custom icon class has not been set for the
    // tab icon, set its width to one pixel. This ensures
    // that the height styling of the tab is maintained,
    // as it is based on the height of the icon.
    // TODO: I still think we can just set dijitTabButtonIcon to 1px in CSS <Bill>
    if(this.iconNode.className == "dijitTabButtonIcon"){
      domStyle.set(this.iconNode, "width", "1px");
    }
    
    domAttr.set(this.focusNode, "id", this.id );
    layer.register("curam/widget/_TabButton", this);
  },

  startup: function(){
    dijit.layout._StackButton.prototype.startup.apply(this, arguments);
  },

  _setCloseButtonAttr: function(/*Boolean*/ disp) {
    this._set("closeButton", disp);
    domClass.toggle(this.domNode, "dijitClosable", disp);
    this.closeNode.style.display = disp ? "" : "none";
    if(disp){
      var _nlsResources = i18n.getLocalization("dijit", "common");
      if(this.closeNode){
        domAttr.set(this.closeNode, "title", _nlsResources.itemClose);
      }
    }else{
        //>>> addition next line only
      domClass.add(this.titleNode,"hasNoCloseButton");
      if(this._closeMenu){
        this._closeMenu.destroyRecursive();
        delete this._closeMenu;
      }
    }
  },
  /**
   * Hook for attr('disabled', ...) to work.
   * Enable or disable this button.
   */
  _setCuramDisabledAttr: function(/*Boolean*/ value) {
    this.curamDisabled = value;
    this._swapState(this.domNode, this.curamDisabled, "disabled", "enabled");
  },
  
  /**
   * Hook for attr('visible', ...) to work.
   * Show or hide this button.
   */
  _setCuramVisibleAttr: function(/*Boolean*/ value) {
    this.curamVisible = value;
    this._swapState(this.domNode, this.curamVisible, "visible", "hidden");
  },
  
  /**
   * Given a DOM node, boolean state and class names for true and false
   * alternatives, the function sets the appropriate classes on the node.
   */
  _swapState: function(node, state, classTrue, classFalse) {
    if (state) {
      domClass.replace(node, classTrue, classFalse);
    } else {
      domClass.replace(node, classFalse, classTrue);
    }
  },
  
  destroy: function() {
    // removing button, need to update all other tabs
    connect.publish("/curam/tab/labelUpdated");
    if (this._closeMenu) {
      this._closeMenu.destroyRecursive();
      delete this._closeMenu;
    }
    this.inherited(arguments);
  }
  });
  
  return _TabButton;
});

},
'dijit/form/ComboButton':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"../focus", // focus.focus()
	"./DropDownButton",
	"dojo/text!./templates/ComboButton.html",
	"../a11yclick"	// template uses ondijitclick
], function(declare, keys, focus, DropDownButton, template){

	// module:
	//		dijit/form/ComboButton

	return declare("dijit.form.ComboButton", DropDownButton, {
		// summary:
		//		A combination button and drop-down button.
		//		Users can click one side to "press" the button, or click an arrow
		//		icon to display the drop down.
		//
		// example:
		// |	<button data-dojo-type="dijit/form/ComboButton" onClick="...">
		// |		<span>Hello world</span>
		// |		<div data-dojo-type="dijit/Menu">...</div>
		// |	</button>
		//
		// example:
		// |	var button1 = new ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
		// |	dojo.body().appendChild(button1.domNode);
		//

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setIdAttr: "", // override _FormWidgetMixin which puts id on the focusNode
		_setTabIndexAttr: ["focusNode", "titleNode"],
		_setTitleAttr: "titleNode",

		// optionsTitle: String
		//		Text that describes the options menu (accessibility)
		optionsTitle: "",

		baseClass: "dijitComboButton",

		// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
		// mouse action over specified node
		cssStateNodes: {
			"buttonNode": "dijitButtonNode",
			"titleNode": "dijitButtonContents",
			"_popupStateNode": "dijitDownArrowButton"
		},

		_focusedNode: null,

		_onButtonKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for right arrow key when focus is on left part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
				focus.focus(this._popupStateNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		_onArrowKeyDown: function(/*Event*/ evt){
			// summary:
			//		Handler for left arrow key when focus is on right part of button
			if(evt.keyCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
				focus.focus(this.titleNode);
				evt.stopPropagation();
				evt.preventDefault();
			}
		},

		focus: function(/*String*/ position){
			// summary:
			//		Focuses this widget to according to position, if specified,
			//		otherwise on arrow node
			// position:
			//		"start" or "end"
			if(!this.disabled){
				focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
			}
		}
	});
});

},
'curam/pagination/ExpandableListModel':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*
 * Modification History
 * --------------------
 * 05-Jun-2019  SK [RTC248394] Accumulating output to increase performance
 *                 when unpacking
 * 28-May-2019  SK [RTC241554] Now emits event to update accessibility readings.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 05-Jun-2012  MV  [CR00327652] Remove incorrect colon after dependency list.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 23-Dec-2010  MV  [CR00239961] Fix the row counting function.
 * 22-Dec-2010 MV  [CR00239864] Handle the case when the associated list table
 *    is not found. 
 * 20-Dec-2010  MV  [CR00239063] Move common function to pagination.js
 * 13-Dec-2010  MV  [CR00237821] Performance improvement - the list rows now
 *    come packed in script tags - unpack before using.
 * 26-Oct-2010  MV  [CR00223441] JavaScript refactoring.
 * 11-May-2010 MV [CR00196066] Cleanup the code, name variables properly.
 * 26-Mar-2010 MV [CR.....] Initial version.
 * 
 */


/**
 * @name curam.pagination.ExpandableListModel
 * 
 * @namespace ExpandableListModel provides access to expandable lists rendered as a HTML
 * table with each logical row being represented by multiple actual rows in DOM. 
 * The rendering is done in gen-jsp.xsl.
 *
 */
define(["dojo/_base/declare",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/query",
        "curam/debug",
        "curam/util/ExpandableLists",
        "curam/pagination"
        ], function(declare, domClass, domStyle, query, debug, ExpLists, pagination) {


var ExpandableListModel = declare("curam.pagination.ExpandableListModel", null, 
/** @lends curam.pagination.ExpandableListModel.prototype */    
{
  _rowCount: null,
  
  /**
   * Instantiate the model and intialize with the corresponding table node. 
   */
  constructor: function(tableId) {
    this.tableNode = query("table.paginated-list-id-" + tableId)[0];
    if (!this.tableNode) {
      throw "Table node for ID " + tableId + " not found - failing!";
    }
    debug.log("curam.pagination.ExpandableListModel " 
      + debug.getProperty("curam.pagination.ExpandableListModel"), 
      this.tableNode);
    this._id = tableId;
  },

  getId: function() {
    return this._id;
  },
  
  getRowCount: function() {
    if (this._rowCount == null) {
	  this._rowCount = 0;
	  
	  // count the rows in script blocks
	  var scripts = dojo.query("tbody > script.hidden-list-rows", this.tableNode), 
	        frag = document.createDocumentFragment();
	  for (var i = 0; i < scripts.length; i++) {
	    var script = scripts[i];
	    var isLastScript = (i == scripts.length - 1);
	    if (!isLastScript) {
	      // for most script blocks, rely on the page size
	      // multiply by 2 as every logical row is represented by 2 TRs
	      this._rowCount += (pagination.getNumRowsInBlock(script) * 2);  
	    } else {
	      // for the last page we must load the contents as it may contain smaller
	      // number of rows than page size. These will be counted below.
	      pagination.unpackRows(script, frag);
	      script.innerHTML='';//blanking out to avoid additional evaluations.
	                          // removing from the DOM or replacing creates huge overrhead
	    }
	  };
	  this.tableNode.tBodies[0].appendChild(frag);
	  // now count the row nodes
	  var rowNodesCount = dojo.query("tbody > tr", this.tableNode).length;
	  this._rowCount += rowNodesCount;
	}
    if (this._rowCount <= 1) {
	  // gen-jsp.xsl always adds a single dummy row for empty lists.
	  return 1;
	} else {
	  // divide by 2 as every logical row is represented by 2 TRs
	  return this._rowCount / 2;
    }
  },

  hideRange: function(startIndex, endIndex) {
    var rows = this._getRowNodes(startIndex, endIndex);
    
    for (var i = startIndex; i <= endIndex; i++) {
      var realRowIndex = (2 * i) - 2;
      var detailRowIndex = (2 * i) - 1;
      
      domStyle.set(rows[realRowIndex], "display", "none");
      domClass.remove(rows[realRowIndex],"even-last-row");
      domClass.remove(rows[realRowIndex],"odd-last-row");
      if (rows.length > detailRowIndex) {
        var detailsRow = rows[detailRowIndex];
        if (detailsRow) {
          detailsRow._curam_pagination_expanded =
              curam.util.ExpandableLists.isDetailsRowExpanded(detailsRow);
          curam.util.ExpandableLists.setDetailsRowExpandedState(
            rows[realRowIndex], detailsRow, false);
        }
      }
    }
  },

  showRange: function(startIndex, endIndex) {
    var rows = this._getRowNodes(startIndex, endIndex);
    // set the proper CSS class for the last row
    var lastRowCssClass =
        (endIndex % 2 == 0) ? "even-last-row" : "odd-last-row";
    // Multiplying by 2 as expanded list takes into account 
    // the detail row, subtract 2 to get the last displayed row.
    domClass.add(rows[(endIndex * 2) - 2], lastRowCssClass);
    
    for (var i = startIndex; i <= endIndex; i++) {
      var realRowIndex = (2 * i) - 2;
      var detailRowIndex = (2 * i) - 1;
      domStyle.set(rows[realRowIndex], "display", "");
      if (rows.length > detailRowIndex) {
        var detailsRow = rows[detailRowIndex];
        if (detailsRow) {
          curam.util.ExpandableLists.setDetailsRowExpandedState(
              rows[realRowIndex], detailsRow,
              detailsRow._curam_pagination_expanded);
        }
      }
    }
    dojo.publish('curam/update/pagination/rows', [rows, this.getId()]);
  },

  _getRowNodes: function(startIndex, endIndex) {
    // read the list content - any rows and script blocks
    var listContent = curam.pagination.readListContent(this.tableNode);

    // go through the required range and expand any script blocks in the way
    for(var i = 1; i <= (endIndex * 2) && i <= listContent.length; i++) {
      var node = listContent[i - 1];
      if (node.tagName == "SCRIPT") {
        // at least part of the required row range is packed in a script tag
        // expand it now
        curam.pagination.unpackRows(node);
        
        // re-read content
        listContent = curam.pagination.readListContent(this.tableNode);
        // and skip the script block in the count
        i--;
      }
    }
    
    return dojo.query("tbody > tr", this.tableNode);
  }
});

return ExpandableListModel;
});

},
'curam/widget/SearchTextBox':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2012,2016. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Copyright 2012 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.widget.SearchTextBox
 * @namespace Customized dijit.form.TextBox class in order to add extra
 *            functionality.
 */
define(
		[ "dojo/query", "dojo/dom-style", "dojo/dom-construct", "dojo/on",
				"dojo/dom-geometry", "dojo/dom-class", "curam/util",
				"dojo/dom-attr", "dojo/_base/fx", "dojo/_base/lang",
				"dijit/form/TextBox", "dojo/_base/declare",
				"dojo/text!curam/widget/templates/SearchTextBox.html" ],
		function(query, domStyle, domConstruct, on, domGeom, domClass, util,
				domAttr, fx, lang, TextBox, declare, template) {

			/*
			 * Modification History -------------------- 10-Jun-2016 GB []
			 * Initial Version.
			 */

			var CuramSearchTextBox = declare(
					"curam.widget.SearchTextBox",
					TextBox,
					/**
					 * @lends curam.widget.SearchTextBox
					 */
					{
						templateString : template,
						backgroundColor : null,
						searchTextDiv : null,
						searchIconDiv : null,
						searchIcon : null,
						searchInputField : null,
						searchInputImg : null,
						placeholderText : null,
						applicationSearchDiv : null,
						searchControlsDiv : null,
						placeholderText : null,
						closedHeight : null,
						searchOptionsDiv : null,
						searchOptionsDivOpenedColor: null,
						originalInputColor : null,
						menuOpenedHeight : 60,

						__populateValues : function() {
							if (this.searchControlsDiv == null) {
								this.searchControlsDiv = query(".search-input-controls");
							}
							if (this.searchIconDiv == null) {
								this.searchIconDiv = query(".application-search-anchor-div");
							}
							if (this.searchIcon == null) {
								this.searchIcon = query(".application-search-anchor");
							}
							if (this.searchInputField == null) {
								this.searchInputField = query(".search-input-controls div.dijitInputField input")[0];
							}
							if (this.applicationSearchDiv == null) {
								this.applicationSearchDiv = query(".application-search");
							}
							if (this.searchOptionsDiv == null) {
								this.searchOptionsDiv = query(".search-options.no-dropdown");
							}
							if (this.searchOptionsDiv.length > 0 && this.searchOptionsDivOpenedColor == null) {
								this.searchOptionsDivOpenedColor = domStyle.get(this.searchOptionsDiv[0], "color");
							}
							if (this.searchInputImg == null) {
								this.searchInputImg = query('.application-search-anchor img');
							}
						},
						
						postCreate: function () {
							this.__populateValues();
						},
						
						__hideElements : function() {
							if (this.__isSearchInputFieldPopulated()) {
								domStyle.set(this.searchInputField,
										"color", domStyle.get(this.applicationSearchDiv[0], "color"));
							} else {
								domStyle.set(this.searchInputField, this.originalInputColor);
							}
							
							domClass.remove(this.searchInputField, 'input-placeholder-opened');
							domClass.add(this.searchInputField, 'input-placeholder-closed');
							
							if (this.searchTextDiv != null && domStyle.get(this.searchTextDiv[0],
							'background-color') != this.backgroundColor) {
								fx.animateProperty({
									node : this.searchTextDiv[0],
									properties : {
										backgroundColor : {
											start : this.searchOptionsDivOpenedColor,
											end : this.backgroundColor
										}
									}
								}).play();
	
								fx.animateProperty({
									node : this.searchControlsDiv[0],
									properties : {
										backgroundColor : {
											start : this.searchOptionsDivOpenedColor,
											end : this.backgroundColor
										}
									}
								}).play();
	
								fx.animateProperty({
									node : this.searchIconDiv[0],
									properties : {
										backgroundColor : {
											start : this.searchOptionsDivOpenedColor,
											end : this.backgroundColor
										}
									}
								}).play();
	
								this.searchInputImg[0].src = jsBaseURL
										+ '/themes/curam/images/search--20-on-dark.svg';
	
								if (this.searchOptionsDiv.length > 0) {
									domClass.remove(
											this.applicationSearchDiv[0],
											'application-search-upfront-popup');
									domStyle.set(this.searchOptionsDiv[0],
											"display", "none");
	
									fx.animateProperty({
										node : this.applicationSearchDiv[0],
										properties : {
											height : {
												start : this.menuOpenedHeight,
												end : this.closedHeight
											}
										}
									}).play();
	
									this.applicationSearchDiv.style({
										left : "0px"
									});
								}
							}
						},
						
						__recursive : function (target) {
							if (target.parentElement != null) {
								if (domClass.contains(target, "application-search")) {
									return true;
								} else {
									return this.__recursive(target.parentElement);
								}
							}
							return false;
						},
						
						__checkBlur : function(evt) {
							var _self = this;
							setTimeout( function() {
								var element = document.activeElement;
								if (!(domClass.contains(element, 'searchTextBox') || 
									domClass.contains(element, 'application-search-anchor') ||
									domClass.contains(element, 'curam') ||
									(element.parentElement != null && domClass.contains(element.parentElement, 'search-options')) ||
									domClass.contains(element, 'search-options'))) {
									_self.__hideElements();
								}
							}, 1);
						},

						_setPlaceHolderAttr : function(v) {
							this.__populateValues();
							var _self = this;
							on(query("body.curam"), "click", function(evt) {
								var result = _self.__recursive(evt.target);
								if (!result) {
									_self.__hideElements();
								}
							});
							on(query("body.curam"), "touchstart", function(evt) {
								var result = _self.__recursive(evt.target);
								if (!result) {
									_self.__hideElements();
								}
							});
							on(this.searchIcon, "blur", function(evt) {
								_self.__checkBlur(evt);
							});
							if (this.searchOptionsDiv.length > 0) {
								on(this.searchOptionsDiv[0].firstChild, "blur", function(evt) {
									_self.__checkBlur(evt);
								});
							}
							placeholderText = v;
							this.searchInputField = this.domNode.firstChild.firstChild;
							domAttr.set(this.searchInputField, 'placeholder',
									placeholderText);
						},

						__isSearchInputFieldPopulated : function() {
							if (this.searchInputField.value.length > 0) {
								return true;
							}
							return false;
						},
						
						__onKeyUp : function(evt) {
                                                        var enable = this.__isSearchInputFieldPopulated();
                                                        this.__enableOrDisableSearchLink(evt, enable);
                                                },
                                                
                                                __onPaste : function(evt) {
                                                        var clipboardData = evt.clipboardData || window.clipboardData;
                                                        var pastedData = clipboardData.getData('Text');
                                                        var enable = 
                                                          (pastedData && pastedData.length > 0) || 
                                                           this.__isSearchInputFieldPopulated();
                                                        
                                                        this.__enableOrDisableSearchLink(evt, enable);
                                                },
                                                
                                                __enableOrDisableSearchLink : function(evt, enable) {
                                                        if (enable && enable === true) {
								domClass.remove(this.searchIcon[0], "dijitDisabled");
								if (evt.keyCode == 13) {
									curam.util.search('__o3.appsearch.searchText', '__o3.appsearch.searchType');
								}
							} else {
								domClass.add(this.searchIcon[0], "dijitDisabled");
							}
						},

						/**
						 * New function that may be called by the onClick event,
						 * in order to close all tabs.
						 */
						__onClick : function(evt) {
								this.__populateValues();
								if (this.searchTextDiv == null) {
									this.searchTextDiv = query(".search-input-controls div.dijitInputField");
								}
								
								if (this.originalInputColor == null) {
									this.originalInputColor = domStyle.get(this.searchInputField, "color"); 
								}
	
								domStyle.set(this.searchInputField, "color", this.originalInputColor); 
								domClass.remove(this.searchInputField, 'input-placeholder-closed');
								domClass.add(this.searchInputField, 'input-placeholder-opened');
								
								if (this.searchOptionsDiv.length > 0) {
	
									var currentPosition = domGeom
											.position(this.searchInputField).x - 11;
									var rtlMode = util.isRtlMode();
									if (rtlMode != null) {
										currentPosition = domGeom
												.position(this.applicationSearchDiv[0]).x - 20;
									}
	
									if (this.closedHeight == null) {
										this.closedHeight = domStyle.get(
												this.applicationSearchDiv[0],
												'height');
									}
	
									this.applicationSearchDiv.style({
										left : currentPosition + "px"
									});
	
									domClass.add(this.applicationSearchDiv[0],
											'application-search-upfront-popup');
	
									if (domStyle.get(this.applicationSearchDiv[0],
											'height') != 60) {
	
										domStyle.set(this.searchOptionsDiv[0],
												"display", "block");
										domStyle.set(this.searchOptionsDiv[0],
												"opacity", "0");
										var fadeArgs = {
											node : this.searchOptionsDiv[0]
										};
	
										fx.animateProperty({
											node : this.applicationSearchDiv[0],
											properties : {
												height : {
													start : this.closedHeight,
													end : this.menuOpenedHeight
												}
											}
										}).play();
	
										fx.fadeIn(fadeArgs).play();
									}
								}
	
								if (this.backgroundColor == null) {
									this.backgroundColor = domStyle.get(
											this.searchTextDiv[0],
											'background-color');
								}
								
								if (this.searchTextDiv != null && domStyle.get(this.searchTextDiv[0],
								'background-color') != this.searchOptionsDivOpenedColor) {
	
									fx.animateProperty({
										node : this.searchTextDiv[0],
										properties : {
											backgroundColor : {
												start : this.backgroundColor,
												end : this.searchOptionsDivOpenedColor
											}
										}
									}).play();
	
									fx.animateProperty({
										node : this.searchControlsDiv[0],
										properties : {
											backgroundColor : {
												start : this.backgroundColor,
												end : this.searchOptionsDivOpenedColor
											}
										}
									}).play();
	
									fx.animateProperty({
										node : this.searchIconDiv[0],
										properties : {
											backgroundColor : {
												start : this.backgroundColor,
												end : this.searchOptionsDivOpenedColor
											}
										}
									}).play();
	
									this.searchInputImg[0].src = jsBaseURL
											+ '/themes/curam/images/search--20-enabled.svg';
								}
							},
	
							__onBlur : function(evt) {
								this.__populateValues();
	
								if (!this.__isSearchInputFieldPopulated()) {
									this.searchInputField.value = "";
									domAttr.set(this.searchInputField,
											'placeholder', placeholderText);
	
								}
								
								this.__checkBlur(evt);
							}

					});

			return CuramSearchTextBox;
		});
},
'dojo/touch':function(){
define(["./_base/kernel", "./aspect", "./dom", "./dom-class", "./_base/lang", "./on", "./has", "./mouse", "./domReady", "./_base/window"],
function(dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win){

	// module:
	//		dojo/touch

	var ios4 = has("ios") < 5;

	// Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
	var hasPointer = has("pointer-events") || has("MSPointer"),
		pointer = (function () {
			var pointer = {};
			for (var type in { down: 1, move: 1, up: 1, cancel: 1, over: 1, out: 1 }) {
				pointer[type] = has("MSPointer") ?
					"MSPointer" + type.charAt(0).toUpperCase() + type.slice(1) :
					"pointer" + type;
			}
			return pointer;
		})();

	// Detect if platform supports the webkit touchstart/touchend/... events
	var hasTouch = has("touch-events");

	// Click generation variables
	var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;

	// Time of most recent touchstart, touchmove, or touchend event
	var lastTouch;

	function dualEvent(mouseType, touchType, pointerType){
		// Returns synthetic event that listens for both the specified mouse event and specified touch event.
		// But ignore fake mouse events that were generated due to the user touching the screen.
		if(hasPointer && pointerType){
			// IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
			// so just use that regardless of hasTouch.
			return function(node, listener){
				return on(node, pointerType, listener);
			};
		}else if(hasTouch){
			return function(node, listener){
				var handle1 = on(node, touchType, function(evt){
						listener.call(this, evt);

						// On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
						// a handler for a touch event may take >1s to run.  That time shouldn't
						// be included in the calculation for lastTouch.
						lastTouch = (new Date()).getTime();
					}),
					handle2 = on(node, mouseType, function(evt){
						if(!lastTouch || (new Date()).getTime() > lastTouch + 1000){
							listener.call(this, evt);
						}
					});
				return {
					remove: function(){
						handle1.remove();
						handle2.remove();
					}
				};
			};
		}else{
			// Avoid creating listeners for touch events on performance sensitive older browsers like IE6
			return function(node, listener){
				return on(node, mouseType, listener);
			};
		}
	}

	function marked(/*DOMNode*/ node){
		// Search for node ancestor has been marked with the dojoClick property to indicate special processing.
		// Returns marked ancestor.
		do{
			if(node.dojoClick !== undefined){ return node; }
		}while(node = node.parentNode);
	}

	function doClicks(e, moveType, endType){
		// summary:
		//		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
		//		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
		//		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
		//		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
		//      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
		//      to falsy.

		if(mouse.isRight(e)){
			return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
		}

		var markedNode = marked(e.target);
		clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
		if(clickTracker){
			useTarget = (clickTracker == "useTarget");
			clickTarget = (useTarget?markedNode:e.target);
			if(useTarget){
				// We expect a click, so prevent any other
				// default action on "touchpress"
				e.preventDefault();
			}
			clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
			clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
			clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
			clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;

			// add move/end handlers only the first time a node with dojoClick is seen,
			// so we don't add too much overhead when dojoClick is never set.
			if(!clicksInited){
				clicksInited = true;

				function updateClickTracker(e){
					if(useTarget){
						clickTracker = dom.isDescendant(
							win.doc.elementFromPoint(
								(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
								(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
							clickTarget);
					}else{
						clickTracker = clickTracker &&
							(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
							Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
					}
				}

				win.doc.addEventListener(moveType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(useTarget){
						// prevent native scroll event and ensure touchend is
						// fire after touch moves between press and release.
						e.preventDefault();
					}
				}, true);

				win.doc.addEventListener(endType, function(e){
					if(mouse.isRight(e)){
						return;		// avoid spurious dojoclick event on IE10+; right click is just for context menu
					}
					updateClickTracker(e);
					if(clickTracker){
						clickTime = (new Date()).getTime();
						var target = (useTarget?clickTarget:e.target);
						if(target.tagName === "LABEL"){
							// when clicking on a label, forward click to its associated input if any
							target = dom.byId(target.getAttribute("for")) || target;
						}
						//some attributes can be on the Touch object, not on the Event:
						//http://www.w3.org/TR/touch-events/#touch-interface
						var src = (e.changedTouches) ? e.changedTouches[0] : e;
						function createMouseEvent(type){
							//create the synthetic event.
							//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
							var evt = document.createEvent("MouseEvents");
							evt._dojo_click = true;
							evt.initMouseEvent(type,
								true, //bubbles
								true, //cancelable
								e.view,
								e.detail,
								src.screenX,
								src.screenY,
								src.clientX,
								src.clientY,
								e.ctrlKey,
								e.altKey,
								e.shiftKey,
								e.metaKey,
								0, //button
								null //related target
							);
							return evt;
						}
						var mouseDownEvt = createMouseEvent("mousedown");
						var mouseUpEvt = createMouseEvent("mouseup");
						var clickEvt = createMouseEvent("click");

						setTimeout(function(){
							on.emit(target, "mousedown", mouseDownEvt);
							on.emit(target, "mouseup", mouseUpEvt);
							on.emit(target, "click", clickEvt);

							// refresh clickTime in case app-defined click handler took a long time to run
							clickTime = (new Date()).getTime();
						}, 0);
					}
				}, true);

				function stopNativeEvents(type){
					win.doc.addEventListener(type, function(e){
						// Stop native events when we emitted our own click event.  Note that the native click may occur
						// on a different node than the synthetic click event was generated on.  For example,
						// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
						// sends a click event to the node that was *underneath* the menu.  So stop all native events
						// sent shortly after ours, similar to what is done in dualEvent.
						// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
						// we call click() explicitly, we don't want to stop this event.
						if(clickTracker && !e._dojo_click &&
								(new Date()).getTime() <= clickTime + 1000 &&
								!(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))){
							e.stopPropagation();
							e.stopImmediatePropagation && e.stopImmediatePropagation();
							if(type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox")
								&& e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO"){
								 // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
								 // but it is still needed for checkboxes and radio buttons, otherwise in some cases
								 // the checked state becomes inconsistent with the widget's state
								e.preventDefault();
							}
						}
					}, true);
				}

				stopNativeEvents("click");

				// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
				// which can confuse some dijit widgets.
				stopNativeEvents("mousedown");
				stopNativeEvents("mouseup");
			}
		}
	}

	var hoveredNode;

	if(has("touch")){
		if(hasPointer){
			// MSPointer (IE10+) already has support for over and out, so we just need to init click support
			domReady(function(){
				win.doc.addEventListener(pointer.down, function(evt){
					doClicks(evt, pointer.move, pointer.up);
				}, true);
			});
		}else{
			domReady(function(){
				// Keep track of currently hovered node
				hoveredNode = win.body();	// currently hovered node

				win.doc.addEventListener("touchstart", function(evt){
						lastTouch = (new Date()).getTime();

					// Precede touchstart event with touch.over event.  DnD depends on this.
					// Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
					// and to ensure this code runs even if the listener on the node does event.stop().
					var oldNode = hoveredNode;
					hoveredNode = evt.target;
					on.emit(oldNode, "dojotouchout", {
						relatedTarget: hoveredNode,
						bubbles: true
					});
					on.emit(hoveredNode, "dojotouchover", {
						relatedTarget: oldNode,
						bubbles: true
					});

					doClicks(evt, "touchmove", "touchend"); // init click generation
				}, true);

				function copyEventProps(evt){
					// Make copy of event object and also set bubbles:true.  Used when calling on.emit().
					var props = lang.delegate(evt, {
						bubbles: true
					});

					if(has("ios") >= 6){
						// On iOS6 "touches" became a non-enumerable property, which
						// is not hit by for...in.  Ditto for the other properties below.
						props.touches = evt.touches;
						props.altKey = evt.altKey;
						props.changedTouches = evt.changedTouches;
						props.ctrlKey = evt.ctrlKey;
						props.metaKey = evt.metaKey;
						props.shiftKey = evt.shiftKey;
						props.targetTouches = evt.targetTouches;
					}

					return props;
				}

				on(win.doc, "touchmove", function(evt){
					lastTouch = (new Date()).getTime();

					var newNode = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					);

					if(newNode){
						// Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
						if(hoveredNode !== newNode){
							// touch out on the old node
							on.emit(hoveredNode, "dojotouchout", {
								relatedTarget: newNode,
								bubbles: true
							});

							// touchover on the new node
							on.emit(newNode, "dojotouchover", {
								relatedTarget: hoveredNode,
								bubbles: true
							});

							hoveredNode = newNode;
						}

						// Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
						// drags over the specified node, regardless of which node the touch started on.
						if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
							// emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
							// default behavior of the underlying native event "touchmove".
							evt.preventDefault();
						}
					}
				});

				// Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
				// This is different than the native touchend, which fires on the node where the drag started.
				on(win.doc, "touchend", function(evt){
						lastTouch = (new Date()).getTime();
					var node = win.doc.elementFromPoint(
						evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
						evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
					) || win.body(); // if out of the screen

					on.emit(node, "dojotouchend", copyEventProps(evt));
				});
			});
		}
	}

	//device neutral events - touch.press|move|release|cancel/over/out
	var touch = {
		press: dualEvent("mousedown", "touchstart", pointer.down),
		move: dualEvent("mousemove", "dojotouchmove", pointer.move),
		release: dualEvent("mouseup", "dojotouchend", pointer.up),
		cancel: dualEvent(mouse.leave, "touchcancel", hasPointer ? pointer.cancel : null),
		over: dualEvent("mouseover", "dojotouchover", pointer.over),
		out: dualEvent("mouseout", "dojotouchout", pointer.out),
		enter: mouse._eventHandler(dualEvent("mouseover","dojotouchover", pointer.over)),
		leave: mouse._eventHandler(dualEvent("mouseout", "dojotouchout", pointer.out))
	};

	/*=====
	touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
		//      click events immediately for this node and its descendants (except for descendants that
		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
		//
		// example:
		//		Used with dojo/on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		// example:
		//		Used with touch.* directly
		//		|	touch.press(node, function(e){});
		//		|	touch.move(node, function(e){});
		//		|	touch.release(node, function(e){});
		//		|	touch.cancel(node, function(e){});
		// example:
		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
		//		|	node.dojoClick = true;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
		//		|	node.dojoClick = 10;
		// example:
		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
		//		|	node.dojoClick = {x:50, y:5};
		// example:
		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
		//		|  node.dojoClick = false;

		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to releasing the mouse button while the cursor is over the given node
			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		over: function(node, listener){
			// summary:
			//		Register a listener to 'mouseover' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		out: function(node, listener){
			// summary:
			//		Register a listener to 'mouseout' or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		enter: function(node, listener){
			// summary:
			//		Register a listener to mouse.enter or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		leave: function(node, listener){
			// summary:
			//		Register a listener to mouse.leave or touch equivalent for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
	=====*/

	 1  && (dojo.touch = touch);

	return touch;
});

},
'dojo/cache':function(){
define(["./_base/kernel", "./text"], function(dojo){
	// module:
	//		dojo/cache

	// dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'dijit/DialogUnderlay':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch
	"dojo/aspect", // aspect.after
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/on",
	"dojo/window", // winUtils.getBox, winUtils.get
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"./Viewport",
	"./main" // for back-compat, exporting dijit._underlay (remove in 2.0)
], function(declare, lang, aspect, domAttr, domStyle, on,
			winUtils, _Widget, _TemplatedMixin, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/DialogUnderlay

	var DialogUnderlay = declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {
		// summary:
		//		A component used to block input behind a `dijit/Dialog`.
		//
		//		Normally this class should not be instantiated directly, but rather shown and hidden via
		//		DialogUnderlay.show() and DialogUnderlay.hide().  And usually the module is not accessed directly
		//		at all, since the underlay is shown and hidden by Dialog.DialogLevelManager.
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' tabIndex='-1' data-dojo-attach-point='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		// This will get overwritten as soon as show() is call, but leave an empty array in case hide() or destroy()
		// is called first.   The array is shared between instances but that's OK because we never write into it.
		_modalConnects: [],

		_setDialogIdAttr: function(id){
			domAttr.set(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// Append the underlay to the body
			this.ownerDocumentBody.appendChild(this.domNode);

			this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown")));

			this.inherited(arguments);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = winUtils.getBox(this.ownerDocument);
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.open = true;
			this.layout();
			this.bgIframe = new BackgroundIframe(this.domNode);

			var win = winUtils.get(this.ownerDocument);
			this._modalConnects = [
				Viewport.on("resize", lang.hitch(this, "layout")),
				on(win, "scroll", lang.hitch(this, "layout"))
			];

		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay

			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.open = false;
		},

		destroy: function(){
			while(this._modalConnects.length){ (this._modalConnects.pop()).remove(); }
			this.inherited(arguments);
		},

		_onKeyDown: function(){
			// summary:
			//		Extension point so Dialog can monitor keyboard events on the underlay.
		}
	});

	DialogUnderlay.show = function(/*Object*/ attrs, /*Number*/ zIndex){
		// summary:
		//		Display the underlay with the given attributes set.  If the underlay is already displayed,
		//		then adjust it's attributes as specified.
		// attrs:
		//		The parameters to create DialogUnderlay with.
		// zIndex:
		//		zIndex of the underlay

		var underlay = DialogUnderlay._singleton;
		if(!underlay || underlay._destroyed){
			underlay = dijit._underlay = DialogUnderlay._singleton = new DialogUnderlay(attrs);
		}else{
			if(attrs){ underlay.set(attrs); }
		}
		domStyle.set(underlay.domNode, 'zIndex', zIndex);
		if(!underlay.open){
			underlay.show();
		}
	};

	DialogUnderlay.hide = function(){
		// summary:
		//		Hide the underlay.

		// Guard code in case the underlay widget has already been destroyed
		// because we are being called during page unload (when all widgets are destroyed)
		var underlay = DialogUnderlay._singleton;
		if(underlay && !underlay._destroyed){
			underlay.hide();
		}
	};

	return DialogUnderlay;
});

},
'dijit/form/_ToggleButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

	// module:
	//		dijit/form/_ToggleButtonMixin

	return declare("dijit.form._ToggleButtonMixin", null, {
		// summary:
		//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

		// checked: Boolean
		//		Corresponds to the native HTML `<input>` element's attribute.
		//		In markup, specified as "checked='checked'" or just "checked".
		//		True if the button is depressed, or the checkbox is checked,
		//		or the radio button is selected, etc.
		checked: false,

		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-pressed",

		_onClick: function(/*Event*/ evt){
			var original = this.checked;
			this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
			var ret = this.inherited(arguments); // the user could reset the value here
			this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
			return ret;
		},

		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this._set("checked", value);
			var node = this.focusNode || this.domNode;
			if(this._created){ // IE is not ready to handle checked attribute (affects tab order)
				// needlessly setting "checked" upsets IE's tab order
				if(domAttr.get(node, "checked") != !!value){
					domAttr.set(node, "checked", !!value); // "mixed" -> true
				}
			}
			node.setAttribute(this._aria_attr, String(value)); // aria values should be strings
			this._handleOnChange(value, priorityChange);
		},

		postCreate: function(){ // use postCreate instead of startup so users forgetting to call startup are OK
			this.inherited(arguments);
			var node = this.focusNode || this.domNode;
			if(this.checked){
				// need this here instead of on the template so IE8 tab order works
				node.setAttribute('checked', 'checked');
			}

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.checked;
			}
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time

			this._hasBeenBlurred = false;

			// set checked state to original setting
			this.set('checked', this.params.checked || false);
		}
	});
});

},
'curam/layout/CuramStackController':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2020,2021. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define([
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/_base/array",
  "dojo/dom-attr",
  "dijit/form/ToggleButton",
  "dojo/text!curam/layout/resources/CuramStackButton.html",
  "dijit/layout/StackController"
],
  function(declare, lang, array, attr, ToggleButton, template, StackController){

	/*
	 * Modification History
	 * --------------------
	 * 22-Jul-2020  FN [RTC254390] CuramStackController.js initial version overriding dojo widget API 
	 *                             in dijit/layout/StackController.js in order to update image details attributes ("alt" and "src")
	 *                             for each button as defined in CuramStackButton.html to
	 *                             render list view and photo view icons for the buttons.
	 */

    var CuramStackButton = declare("curam.layout._StackButton", ToggleButton, {

      tabIndex: "0",
      templateString: template,
      imageDefaultSrc: "", // New variable added for new html image tag
      imageHoverSrc: "",  // New variable added for new html image tag
      imageAltText: "",  // New variable added for new html image tag
      closeButton: false,
      _aria_attr: "aria-selected",

      buildRendering: function(/*Event*/ evt) {
        this.inherited(arguments);
        (this.focusNode || this.domNode).setAttribute("role", "tab");
      }
    });

    var CuramStackController = declare("curam.layout.CuramStackController", StackController, {

      baseClass: "curamStackController",
      // Overriding Button.html
      buttonWidget: CuramStackButton,

      buttonWidgetCloseClass: "dijitStackCloseButton",

      // Overridden method in order to add details for both images defined in CuramStackButton.html template for the default and hover 
      // image to display for the photo and list view buttons respectively. Each variable value defined below for the photo and list views is
      // updated in the button variable below using the CuramStackButton.html template.
      onAddChild: function(/*dijit/_WidgetBase*/ page, /*Integer?*/ insertIndex) {

        var photoImageDefaultSrc = "../Images/avatar--20-enabled.svg";
        var photoImageHoverSrc = "../Images/avatar--20-enabled.svg";
        var listImageDefaultSrc = "../Images/list--20-enabled.svg";
        var listImageHoverSrc = "../Images/list--20-enabled.svg";

        var isStackContainerPhoto = page.get("class").indexOf("stack-container-photo") != -1 ? true : false;
        var imageDefaultSource = isStackContainerPhoto ? photoImageDefaultSrc : listImageDefaultSrc;
        var imageHoverSource = isStackContainerPhoto ? photoImageHoverSrc : listImageHoverSrc;

        var Cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
        var button = new Cls({
          id: this.id + "_" + page.id,
          name: this.id + "_" + page.id, // note: must match id used in pane2button()
          disabled: page.disabled,
          ownerDocument: this.ownerDocument,
          dir: page.dir,
          lang: page.lang,
          textDir: page.textDir || this.textDir,
          showLabel: page.showTitle,
          imageDefaultSrc: imageDefaultSource, // New property and variable added to update button image
          imageHoverSrc: imageHoverSource, // New property and variable added to update button image
          imageAltText: page.title, // New property added to update button image
          iconClass: page.iconClass,
          closeButton: page.closable,
          title: page.tooltip,
          page: page
        });

        this.addChild(button, insertIndex);
        page.controlButton = button;	// this value might be overwritten if two tabs point to same container
        if(!this._currentChild){
          // If this is the first child then StackContainer will soon publish that it's selected,
          // but before that StackContainer calls layout(), and before layout() is called the
          // StackController needs to have the proper height... which means that the button needs
          // to be marked as selected now.   See test_TabContainer_CSS.html for test.
          this.onSelectChild(page);
        }

        // Update class name for the participant(s) CCV link when list view is selected. Part of defect RTC254152.
        var widgetidOfTheListViewButton = attr.get(button.domNode, "widgetid");
        // Widget ids are either value of "controller_stackCon-fourimages_title_1" or "controller_stackCon-fourimages_title_2"
        // mapped to each of the two buttons, the first being for the photo view and the latter for the list view.
        // We need to find the list view button in order to append the new class name onto the CCV icon link for each of the
        // participants in the list.
        if (typeof(widgetidOfTheListViewButton) != "undefined"){
          widgetidOfTheListViewButton.split("_");
          var listViewButtonFound = widgetidOfTheListViewButton.indexOf("2") != -1 ? true : false;
          if (listViewButtonFound){
            var ccvIconLinkInListViewMode = dojo.query("table.list-body >tbody>tr>td.field.body-first-cell>a.ac", this.ownerDocument);
            if (ccvIconLinkInListViewMode){
              array.forEach(ccvIconLinkInListViewMode, function(ccvIconLinkInListViewMode){ 
                attr.set(ccvIconLinkInListViewMode, "class", ccvIconLinkInListViewMode.className.concat("list-view"));
                });
            }
          }
        }

        // Add this StackController button to the list of things that labels that StackContainer pane.
        // Also, if there's an aria-labelledby parameter for the pane, then the aria-label parameter is unneeded.
        var labelledby = page._wrapper.getAttribute("aria-labelledby") ?
          page._wrapper.getAttribute("aria-labelledby") + " " + button.id : button.id;
          page._wrapper.removeAttribute("aria-label");
          page._wrapper.setAttribute("aria-labelledby", labelledby);
      }
    });

    CuramStackController.StackButton = CuramStackButton;	// for monkey patching

    return CuramStackController;
});
},
'curam/cdsl/types/FrequencyPattern':function(){
define(["dojo/_base/declare",
        "dojo/_base/lang"
        ], function(
            declare) {

  /**
   * @name curam.cdsl.types.FrequencyPattern
   * @namespace Represents a Curam Frequency Pattern.
   */
  var FrequencyPattern = declare(null,
  /**
   * TODO
   */
  {
    _code: null,
    _description: null,
    
    constructor: function(code, description) {
      this._code = code;
      this._description = description;
    },
    
    getCode: function(){
      return this._code;
    },
    
    getDescription: function(){
      return this._description;
    }
  });
  
  return FrequencyPattern;
});

},
'dojo/store/util/SimpleQueryEngine':function(){
define(["../../_base/array" /*=====, "../api/Store" =====*/], function(arrayUtil /*=====, Store =====*/){

// module:
//		dojo/store/util/SimpleQueryEngine

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	//		used to match strings by more complex expressions
	//		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo/store/api/Store.QueryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						// an object can provide a test method, which makes it work with regex
						if(!required.test(object[key], object)){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		var sortSet = options && options.sort;
		if(sortSet){
			results.sort(typeof sortSet == "function" ? sortSet : function(a, b){
				for(var sort, i=0; sort = sortSet[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					// valueOf enables proper comparison of dates
					aValue = aValue != null ? aValue.valueOf() : aValue;
					bValue = bValue != null ? bValue.valueOf() : bValue;
					if (aValue != bValue){
						return !!sort.descending == (aValue == null || aValue > bValue) ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};

});

},
'dijit/_TemplatedMixin':function(){
define([
	"dojo/cache",	// dojo.cache
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/sniff", // has("ie")
	"dojo/string", // string.substitute string.trim
	"./_AttachMixin"
], function(cache, declare, domConstruct, lang, on, has, string, _AttachMixin){

	// module:
	//		dijit/_TemplatedMixin

	var _TemplatedMixin = declare("dijit._TemplatedMixin", _AttachMixin, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

/*=====
		// _rendered: Boolean
		//		Not normally use, but this flag can be set by the app if the server has already rendered the template,
		//		i.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to
		//		just function like _AttachMixin.
		_rendered: false,
=====*/

		// Set _AttachMixin.searchContainerNode to true for back-compat for widgets that have data-dojo-attach-point's
		// and events inside this.containerNode.   Remove for 2.0.
		searchContainerNode: true,

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value : this._escapeValue("" + value);
			}, this);
		},

		_escapeValue: function(/*String*/ val){
			// summary:
			//		Escape a value to be inserted into the template, either into an attribute value
			//		(ex: foo="${bar}") or as inner text of an element (ex: <span>${foo}</span>)

			// Safer substitution, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			// and also https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet#RULE_.231_-_HTML_Escape_Before_Inserting_Untrusted_Data_into_HTML_Element_Content
			return val.replace(/["'<>&]/g, function(val){
				return {
					"&": "&amp;",
					"<": "&lt;",
					">": "&gt;",
					"\"": "&quot;",
					"'": "&#x27;"
				}[val];
			});
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this._rendered){
				if(!this.templateString){
					this.templateString = cache(this.templatePath, {sanitize: true});
				}

				// Lookup cached version of template, and download to cache if it
				// isn't there already.  Returns either a DomNode or a string, depending on
				// whether or not the template contains ${foo} replacement parameters.
				var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache, this.ownerDocument);

				var node;
				if(lang.isString(cached)){
					node = domConstruct.toDom(this._stringRepl(cached), this.ownerDocument);
					if(node.nodeType != 1){
						// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
						throw new Error("Invalid template: " + cached);
					}
				}else{
					// if it's a node, all we have to do is clone it
					node = cached.cloneNode(true);
				}

				this.domNode = node;
			}

			// Call down to _WidgetBase.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			if(!this._rendered){
				this._fillContent(this.srcNodeRef);
			}

			this._rendered = true;
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		}

	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString, doc){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// doc: Document?
		//		The target document.   Defaults to document global if unspecified.
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the
				// current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == (doc || document)){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString, doc);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		on(window, "unload", function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	return _TemplatedMixin;
});

},
'curam/util/ui/refresh/RefreshEvent':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/declare"], function(declare) {
  
  /*
   * Modification History
   * --------------------
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * @name curam.util.ui.refresh.RefreshEvent
   * @namespace Represents a UI element refresh event.
   * 
   */
  var RefreshEvent = declare("curam.util.ui.refresh.RefreshEvent", null,
  /**
   * @lends curam.util.ui.refresh.RefreshEvent.prototype
   */
  {
    /** Event type constant. */
    TYPE_ONLOAD: "onload",
    
    /** Event type constant. */
    TYPE_ONSUBMIT: "onsubmit",
    
    /** Event context constant. */
    SOURCE_CONTEXT_MAIN: "main-content",
    
    /** Event context constant. */
    SOURCE_CONTEXT_DIALOG: "dialog",
    
    /** Event context constant. */
    SOURCE_CONTEXT_INLINE: "inline",

    /** Holds the type of the event. */
    _type: null,
    
    /** Holds the context of the event. */
    _context: null,
    
    /**
     * Creates an instance of the refresh event.
     * 
     * @param {String}
     *                type The event type. Only accepted values will be the ones
     *                provided as constants in this class.
     * @param {String}
     *                context The event context. Only accepted values will be the
     *                ones provided as constants in this class.
     */
    constructor: function(type, context) {
      if (!type || !context) {
        throw "Required parameters missing.";
      }
      if (!(type == this.TYPE_ONLOAD || type == this.TYPE_ONSUBMIT)) {
        throw "Unknown type: " + type;
      }
      if (!(context == this.SOURCE_CONTEXT_DIALOG
          || context == this.SOURCE_CONTEXT_INLINE
          || context == this.SOURCE_CONTEXT_MAIN)) {
        throw "Unknown context: " + context;
      }

      this._type = type;
      this._context = context;
    },
    
    /**
     * Determines if the specified event is the same as this one.
     * 
     * @param other
     *                The event to check.
     * @returns {Boolean} True if the other event is the same, otherwise false.
     */
    equals: function(other) {
      // check for undefined, null and variable types other than object
      if (typeof other != "object") {
        return false;
      }
      
      // check for Dojo class name
      if (other.declaredClass != this.declaredClass) {
        return false;
      }
      
      return this._type === other._type
          && this._context === other._context;
    }
  });
  
  return RefreshEvent;
});

},
'curam/ui/UIMPageAdaptor':function(){
/*
 * Copyright 2009-2020 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-class",
        "dojo/query",
        "curam/tab",
        "curam/define",
        "curam/debug",
        "curam/util",
        "curam/ui/PageRequest"
        ], function(dom, domAttr, domClass, query, tab, define, debug) {
  
  /*
   * Modification History
   * --------------------
   * 15-Jan-2020  GG  [RTC255718] Updated isLinkValidForTabProcessing to exclude 
   * javascript calls from tab processing.
   * 10-May-2016  SK  [CR00479312] Replace outdated in-house code with Dojo
   * method invocations.
   * 28-Oct-2014  KW  [CR00448502] If a page links to itself, then set
   * forceLoad.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 16-Jan-2011  DG  [CR00242400] Changed order of tab title and name value in
   *                    event to match event name, function name, etc.
   * 18-Nov-2010 MV [CR00231387] Connect to DOM event with a function that will
   *    automatically disconnect on page unload.
   * 18-Nov-2010 SJ [CR00228391]Fixed the issue with OPEN_NEW attribute on link.
   * 24-Nov-2010  PK  [TEC-XXXX] Added NESTED_UIM context.
   * 08-Sep-2010  MV  [CR00219540] Move the click handler for the list actions menu
   *                    items to curam.util.
   * 29-Jul-2010  PK  [CR00211736] Moved tab-app-adaptor.js to
   *                    curam.ui.UIMPageAdaptor.
   * 27-Jul-2010  PK  [CR00211464] Fixed issue when accessing the "tab controller".
   * 27-Jul-2010  MV  [CR00211474] Publish generic iframe-loaded event on top ofcuram
   *                    the page-specific one.
   * 26-Jun-2010  MV  [CR00204069] Moved getPageHeight() function to util.js
   * 23-Jun-2010  AF  [CR00202526] Removed content panel references in page height
   *                    method.
   * 22-Apr-2010  AF  [CR00194043] Modified height of a frame that contains
   *                    in-page navigation. This removes unnecessary extra space
   *                    appearing at the bottom of the in-page navigation
   *                    container.
   * 02-Apr-2010  PK  [CR00192620] Added listRowFrameLoaded method to handle
   *                    auto-height calculation for an expanded list row.
   * 25-Mar-2010  PA  [CR00187654] Changes required to implement the List Action
   *                    Menu.
   * 24-Feb-2010  BD  [CR00189322] Add onload functionality to publish an event.
   *                    The published event contains the height of the page which
   *                    can be used for sizing.
   * 23-Dec-2009  MV  [CR00181822] Code cleanup in setTabTitleAndName() function.
   */
  
  /**
   * Adapts "normal" pages to function in the v6 tabbed user interface. Pages
   * are opened up embedded in an iframe. We have to handle clicks which open
   * up new tabs etc.
   */
  define.singleton("curam.ui.UIMPageAdaptor", {
    /**
     * This function must be called from the onload event of the UIM page that
     * has to be "adapted". gen-jsp.xsl will generate the call to this script.
     */
    initialize: function() {
      if (jsScreenContext.hasContextBits("MODAL")) {
        // UIM pages opened in modals should not be "adapted". The modal
        // infrastructure has it's on event management, click handlers etc.
        return;
      }
      curam.util.connect(
          dojo.body(), "onclick", curam.ui.UIMPageAdaptor.clickHandler);

      var dojoInstance = null;
      var channel = null;
      if (!jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")) {
        dojoInstance = curam.util.getTopmostWindow().dojo;
        channel = "/iframe-loaded/" + window.jsPageID;
        debug.log(debug.getProperty("curam.ui.UIMPageAdaptor.event")
            + channel);
        dojoInstance.publish(channel);
      }
    },
    
    /**
     * Initialize function output only for external style client.s
     */
    externalInitialize:function() {
      if (jsScreenContext.hasContextBits("MODAL")) {
        // UIM pages opened in modals should not be "adapted". The modal
        // infrastructure has it's on event management, click handlers etc.
        return;
      }
      curam.util.connect(
        dojo.body(), "onclick", curam.ui.UIMPageAdaptor.clickHandler);
    },
    
    /**
     * Handler for clicks for external style applications.
     * @param event The event.
     * @param anchor The anchor value.
     */
    externalClickHandler:function(event, anchor) {
      
      // Click handling for external applications
      var uimPageRequest = new curam.ui.PageRequest(anchor.href);
      var externalApp = window.top.dijit.byId("curam-app");
      if (externalApp != null) {

        // Convert the parameters into expected array. 
        // TODO: Consider changing the format of the parameters, but
        // this will have impact on HCR and NPG.
        var params = [];
        var i = 0;
        for (param in uimPageRequest.parameters) {
          params[i] = {paramKey: param, paramValue: 
            uimPageRequest.parameters[param]};
          i = i + 1;
        }
        
        var args = {pageID: uimPageRequest.pageID, param: params};
        
        if (externalApp._isNavBarItem(uimPageRequest.pageID)) {
          // If the page is in a navigation bar, open using displayContent
          // This is to ensure navigation item is displayed
          dojo.stopEvent(event || window.event);
          window.top.displayContent(args);        
        } else if (externalApp._isUIMFragment(uimPageRequest.pageID)) {
          // If the page is a fragment, open using displayContent
          // This is to ensure styling is correct
          dojo.stopEvent(event || window.event);
          window.top.displayContent(args);
        }
        // Otherwise, let normal click handling commence - event not stopped
      }
    },

    clickHandler:function(event) {
      // TODO: Also, *some* of the code in this method is duplicated
      // in the "clickHandlerForListActionMenu" method of "util.js". AS LONG AS
      // THESE METHODS ARE SEPARATE, ANY UPDATES TO THE LOGIC BELOW MUST BE
      // ANALYZED TO SEE IF THEY NEED TO BE APPLIED IN THE "util.js" ALSO.
      var anchor = null;
      if (event.target.nodeName == "A") {
        if (curam.ui.UIMPageAdaptor.allowLinkToContinue(event.target)) {
          // allow the event to continue by just returning.
          return;
        }
        anchor = event.target;
      } else if ((event.target.nodeName == "IMG" && !domClass.contains(event.target.parentNode, "file-download")) ||
          (event.target.nodeName == "SPAN" && (event.target.className == "middle" || event.target.className == "bidi"))) {
        // TODO: check html schema, what inline elements are allowed in an
        // anchor element....can they be nested etc. this check probably needs
        // search for an ancestor anchor element rather than parent.
		anchor = query(event.target).closest("A")[0];
      }
      
      // if we have an anchor, stop the click event and perform standard tab
      // processing (i.e. should it open in a new tab etc.)
      if (anchor != null) {
        if (!anchor.href || anchor.href.length == 0) {
          dojo.stopEvent(event || window.event);
          // the event has been stopped, just return if it has no href.
          // any onclick handlers attached to the link will have executed by now.
          return;
        }
        
        if (jsScreenContext.hasContextBits("EXTAPP")) {
          curam.ui.UIMPageAdaptor.externalClickHandler(event, anchor);
        } else {
          // Internal handling
          dojo.stopEvent(event || window.event);
          if (curam.ui.UIMPageAdaptor.shouldLinkOpenInNewWindow(anchor)) {
            window.open(anchor.href);
          } else if (curam.ui.UIMPageAdaptor.isLinkValidForTabProcessing(
              anchor)) {
  
            var uimPageRequest = new curam.ui.PageRequest(anchor.href);
            if (jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
                || jsScreenContext.hasContextBits("NESTED_UIM")) {
              uimPageRequest.pageHolder = window;
            }
            // If the requested page ID is same as the currently loaded Page ID
            // The page is linked to itself and we assume a reload is wanted.
            if ( window.jsPageID === uimPageRequest.pageID ) {
              uimPageRequest.forceLoad = true;
            }
            curam.tab.getTabController().handlePageRequest(uimPageRequest);
          }
        }
      }
      // Otherwise we let the event continue uninterrupted.
    },

    /**
     * leave submit buttons alone....they are embedded in an iframe....
     * leave file download alone. It should be processed as a normal link.
     * leave mailto links to be processed as normal
     * leave named anchors alone. TODO: the named anchor test for a '#' is copied
     * from the modal dialog click handler in dialog.js. Can the test be more
     * specific than just testing for that character?
     */
    allowLinkToContinue: function(anchor) {
      if (anchor && anchor._submitButton) {
        // don't care about the value of the _submitButton property, if it exists
        // return true.
        return true;
      }
      if (anchor && anchor.href) {
        return (anchor.href.indexOf("/servlet/FileDownload") != -1
            || anchor.href.indexOf("#") != -1
            || anchor.href.substr(0, 7) == "mailto:");
      } else {
        // if the href doesn't exist just return false.
        return false;
      }
    },

    /**
     * Popup links should not trigger tab processing. The OpenPopupTag adds this
     * class to each of the links.
     * Links which toggle the display of list details rows should not trigger tab
     * processing.
     * Javascript links should not trigger tab processing.
     */
      isLinkValidForTabProcessing: function(anchor) {
        if (!anchor || (domClass.contains(anchor, "popup-action")
                    || domClass.contains(anchor, "list-details-row-toggle"))
            || anchor.protocol == "javascript:") {
          return false;
        }
        return true;
      },	

    /**
     * This method will return true only if the link is external.
     * target attribute is set to the links which are external.
     */
    shouldLinkOpenInNewWindow: function(anchor) {
      //At the time of writing this comment,In TabTest Application, only
      //external links are allowed to open in new window.
      //target attribute is set to links only if they are external.
      // return domAttr.has(anchor, "target");
      return domAttr.has(anchor, "target")
             && !curam.util.isInternal(anchor.href);
    },

    /**
     * Publish an event to the parent window detailing the tab name and tab title
     * that are to be set.
     * Event to subscribe to: tab.title.name.set
     * Parameters of event: iframe element, tab title and tab name.
     */
    setTabTitleAndName: function() {
      var newTabTitle = dom.byId("tab-title").innerHTML;
      var newTabName = dom.byId("tab-name").innerHTML;

      window.parent.dojo.publish("tab.title.name.set",
          [window.frameElement, newTabTitle, newTabName]);
    }
  });
  
  return curam.ui.UIMPageAdaptor;
});

},
'curam/ModalDialog':function(){
/*
 *  IBM Confidential
 *  
 *  OCO Source Materials
 *  
 *  Copyright IBM Corporation 2009,2021.
 *  
 *  The source code for this program is not published or otherwise divested
 *  of its trade secrets, irrespective of what has been deposited with the 
 *  US Copyright Office
 */

/**
 * @name curam.ModalDialog
 * @namespace Implements a Curam dialog based on Dojo.
 */
define(["dojo/text!curam/layout/resources/CuramBaseModal.html",
        "dojo/_base/declare",
        "dojo/dom",
        "curam/modal/CuramBaseModal",
        "dijit/Dialog"], function(template, declare, dom,
          curamBaseModal) {

/*
 * Modification History
 * --------------------
 * 19-Apr-2021 FN   [RTC265093] Amended setTitle to fix issue with Jaws on modals when error messages are present.
 * 19-Feb-2021 BOS  [RTC268393] Refactoring for tabbing backwards and forwards.
 * 01-Dec-20202 BOS [RTC266982] Re-factored so that this is the modal for external application and for modal preceding V8 in internal
 *                              application.
 * 20-May-2020  JD  [RTC259879] Adjusted timeouts when setting focus in IE11, refactored _setFocusHandler() and updated styling when
 *                              revealing modal and added flag to be able to suppress timeouts.
 * 29-Apr-2020  FN  [RTC260435] Update _setFocusHandler to render the aria-label velue of the focused field when field is a list-box.
 * 15-Apr-2020  FN  [RTC259809] Update _setFocusHandler to render the aria-label value of the focused field when field is a component.
 * 27-Jan-2020  FN  [RTC254720] Update setTitle to add required aria tags onto the title for screen reader to fire up
 *                              an alert message to the user when error message(s) is present on the screen.
 * 08-Jan-2020  SH  [RTC255274] More updates to _setFocusHandler for focusing on CKEditor fields.
 * 11-Dec-2019  CM  [RTC255571] Update _setFocusHandler to add a check to see if 'curamDefaultActionId' 
 *                              session storage exists but input with this id doesn't exist. 
 * 03-Dec-2019  SH  [RTC255274] Prevent focus being moved in _setFocusHandler if the user has already 
 *                              focused on a form element manually.
 * 11-Nov-2019  FN  [RTC251147] Added new property LOCALISED_MODAL_HELP_TITLE to be rendered in the span
 *                              element of the help icon on registration modals.
 *  20-Sep-2019  AA [RTC250096] Updated function _setFocusHandler to set the focus on the search
 *                              button when the property curamDefaultActionId is defined.
 * 30-Apr-2019  CM  [RTC243249] Add image tags for close button and help button on modal for 
 *                              accessibility reasons when high contrast OS mode is enabled.
 * 23-Oct-2018   SK [RTC237984] Changed focus handler to do have all
 *                  the focusing logic in one place and merged with RTC225885.
 * 17-Sept-2018 CM  [RTC230524] Removed tabIndex="0" from iframe.
 * 10-Set-2018  BD  [RTC227106] Moved methods _createSpanContainingInformationOnCurrentWizardTab 
 *                              and _screenReaderAnnounceCurrentTabOnWizard to dialog.js.
 * 10-Aug-2018  SK  [RTC234604] The back-button functionality
 *                  related changes.
 * 28-Jun-2018  CMC [RTC227106]  Made current wizard tab accessible.
 * 25-Oct-2017  GB  [RTC186372]  Changed _createhelpicon event from keypress to keydown.
 * 22-Jun-2017  BD  [RTC-198658] Changed method  topic _onHideHandler
 * adding the topic /curam/dialog/close/appExitConfirmation.
 * 07-Oct-2016  SK  [174874] Progress spinner added to the wrapper. 
 * 24-Aug-2015  AB  [CR00465809] Dynamic browser tab titles.
 * 24-Feb-2015  AZ  [CR00458302] Fix tabbing order
 * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
 * 03-Feb-2015  AB  [CR00457610] Modal error handler can potentially cause
                  closed modal dialogs to re-appear on screen
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 05-Sep-2014  MV  [CR00444294] Allow for Dialog.js maxRatio value.
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.
 * 30-Sep-2013  MK  [CR00390932] Upgrade to Dojo 1.9  
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 28-Mar-2013  NLH [CR00377306] Modal close and help button label 
 *                jaws12 and 13 fix
 * 11-Mar-2013  MV  [CR00373738] Only destroy iframe when dialog itself
 *      is destroyed.
 * 20-Feb-2013  MV  [CR00367727] Prevent opening multiple dialogs at once
 *      by clicking on link in quick succession.
 * 18-Jan-2013  PK  [CR00361872] For external applications using the One UI
 *                    theme, the maximum height is adjusted. 
 * 18-Jan-2013  SB  [CR00359465] Add tabindex to close button when help
 *                               is absent.
 * 16-Jan-2013  SB  [CR00359326] Added onkeypress event to help button.
 * 11-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 09-Aug-2012  MV  [CR00337714] Load HTML template using the new mechanism. 
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 26-Apr-2012  MV  [CR00318809] Preload template string directly with the class
 *       to avoid an extra AJAX call when opening dialog for the first time.
 * 20-Apr-2012  MK  [CR00318172] Extracted numerical values for minimum space
 *                               required around a modal to variables.
 * 20-Apr-2012  PK  [CR00315682] On a mobile user agent, ensure disalogs are 
 *                    only positioned once.
 * 29-Feb-2012  MK  [CR00267592] Dojo 1.7.1 upgrade. 
 * 07-Oct-2011  PK  [CR00289859] Dojo 1.6.1 upgrade and IE9+ support. 
 * 30-Sep-2011  MK  [CR00289373] Fixed bug. Incorrect reference to local variable. 
 * 15-Aug-2011  AF  [CR00278493] Added new dialog template with customisations
 *                               to improve accessibility.
 * 12-Jul-2011  KW  [CR00275353] Refactored _initParentWindowRef().
 * 11-May-2011  MV  [CR00265902] Fix URL parsing code.
 * 28-Apr-2011  AF  [CR00264788] Added title to modal dialog frame and help
 *                               icon.
 * 17-Feb-2011  MV  [CR00253193] Fix errors on dialog close when x icon used.
 * 08-Feb-2011  SD  [CR00251223] Resolved iFrame consuming drag event.
 * 28-Jan-2011  MV  [CR00245381] Take help settings from the page context.
 * 28-Jan-2011  SD  [CR00245428] Update setTitle() to handle hiding the
 *     appended message test.
 * 26-Jan-2011  MV  [CR00244801] Strip o3rpu from RPU value.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 17-Jan-2010  MV  [CR00242255] Performance improvements.
 * 07-Dec-2010  MV  [CR00233442] Set the dialog size properly when
 *     the UIM controller is resized.
 * 06-Dec-2010  KW  [CR00233277] Modal title uses context width
 * 29-Nov-2010  KW  [CR00232834] Modal title width set in all cases
 * 28-Nov-2010  MV  [CR00232623] Set initial width and height properly.
 *    Hide iframe on unload and show again on load to avoid flicker.
 * 25-Nov-2010  MV  [CR00232063] Publish display event also on subsequent
 *   page load. Further performance improvements.
 * 22-Nov-2010  KW  [CR00231903] Added function to set a long title for a modal
 * 18-Nov-2010  MV  [CR00231655] Decrease the timeout on modal display timer.
 *    Publish the dialog size with the display event.
 * 16-Nov-2010  MV  [CR00231317] Change the way the dialog content is wiped
 *    on close. This is to avoid focus problems in the parent page after
 *    the dialog closes.
 * 09-Nov-2010  MV  [CR00230346] Display dialog in correct size on page load
 *    error.
 * 03-Nov-2010  MV  [CR00229566] Performance improvements.
 * 01-Nov-2010  SD  [CR00225331] UimDialog API related updates.
 * 26-Oct-2010  SK  [CR00224193] Handles the situation where the parent window
 *                               is not provided (opening from menu/shortcut).
 * 29-Sep-2010  MV  [CR00221605] Check for existence of dijit in a target
 *        context before accesing it. Determine max size per dialog instance.
 * 21-Sep-2010 MV [CR00220649] Reposition dialog after height change.
 * 10-Sep-2010 MV [CR00219824] Set initial focus correctly for dialogs with no
 *                        editable fields. Fix issue with dialog not closing
 *                        properly when new page has been loaded in it.
 * 27-Aug-2010 MV [CR00217499] Added full support for non-UIM pages
 *                  by integrating with the new external Dialog API.
 * 27-Jul-2010 MK [CR00211743] Add parameter to allow the displaying of a help
 *                  icon to be optional.
 * 21-Jul-2010 MV [CR00211225] If modal is closing, skip resizing and updating
 *                  the title.
 * 15-Jul-2010 MV [CR00210541] Handle focus on modal open.
 * 07-Jul-2010 JY [CR00209267] Add help icon to the modal dialog title bar.
 * 05-Jul-2010 BD [CR00204119] Introduced use of UIMController in place of
 *                             iframe to cater for In Page Navigation tabs.
 * 26-Jun-2010 MV [CR00204069] Remove unused default height variable. Use Curam
 *                DebugHelper.
 * 22-Jun-2010 MV [CR00204076] Fix handling of event when a page fails to load.
 * 24-Jun-2010 MV [CR00203864] Fix modal close handler.
 * 10-Jun-2010 MV [CR00202971] Refactor to use the new UIM onLoad event mechanism.
 * 08-Jun-2010 MV [CR00202412] Update the autosizing algorithm to handle pages
 *                              that don't have Dijit content panel.
 * 31-May-2010 MV [CR00202062] Ensure complete cleanup is done after the modal
 *                                is closed.
 * 25-May-2010 MV [CR00201591] URL parameters are now stripped when getting the
 *                  base URL.
 * 14-May-2010 MV [CR00189738] Remove the parent window from the dialog
 *                  hierarchy on exit.
 * 12-Mar-2010 RS [CR00186979] Added Minimum configurable modal height.
 * 23-Feb-2010 MV [CR00190348] Added function call that removes the parent
 *                             window's reference from the dialog hierarchy on
 *                             a dialog close.
 * 23-Feb-2010 AF [CR00189289] Added set title method to set the title of a
 *                  modal dialog.
 * 12-Feb-2010 AF [CR00183263] Added frame border setting to iframe in modal.
 * 10-Feb-2010 MV [CR00188844] Implement sizing enhancements.
 * 04-Feb-2010 MV [CR00184341] Test for dojo existence when detecting page
 *                             load error.
 * 04-Feb-2010 MV [CR00184333] Hide dialog immediately when closing.
 *                              Enable auto sizing.
 * 20-Jan-2010 MV [CR00183192] Fixed detection code for cases when the target
 *                                 page fails to load.
 * 16-Dec-2009 MV [CR00173949] Implemented opening modal even if the target
 *                              page does not exist. Also rewritten to work
 *                              properly with dijit.Dialog superclass.
 * 26-Nov-2009 MV [CR00176044] Mark the currently active dialog with a specific
 *                              CSS class. Also add delay to the modalDisplayed
 *                              event so that it fires after the dialog is really
 *                              displayed on the screen.
 * 08-Dec-2009 MV [CR00181267] Fix the behaviour when closing the dialog so that
 *                              underlay is properly maintained.
 * 25-Nov-2009 MV [CR00175955] Publish /curam/dialog/displayed event after
 *                           the modal is displayed..
 */
  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  //dojo.requireLocalization("curam.application", "Debug");
  //var bundle = new curam.util.ResourceBundle("Debug"),
  tabbingBackwards = null,
   
  handleTitlebarIconKeydown = function(e) {};
  
  var ModalDialog = declare("curam.ModalDialog", [dijit.Dialog, curamBaseModal], {
	  constructor: function() {
 	    this.inherited(arguments);
 	  },
 	  
 	  postCreate: function() {
 	    this.inherited(arguments);
 	  },
 	  
 	  handleFocusAtEnd: function(event, targetNode) {
 	    this.handleTabbingForwards(event, targetNode);
 	  }
  });
  
  /**
   * When using tab navigation the focus should go from the end of modal
   * to the help or close icon in the title bar at the top, whichever is first
   * This is called from a onfocus event at the end of modal.
   */
  ModalDialog.handleFocusAtEnd = function(event) {
    var targetIconNode = dojo.query("#"+this.id+" .dijitDialogHelpIcon")[0];
    curam.ModalDialog.prototype.handleFocusAtEnd(event, targetIconNode);
  };

  
  return ModalDialog;
});
},
'curam/widget/OptimalBrowserMessage':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013-2016. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 06-Jul-2016  SK  Updated to support MS Edge as part of Dojo upgrade.
   * 07-Nov-2014  BOS [CR00448707] Updated to detect IE11 because dojo has 
   * changed how it detects IE11.
   * 12-Sep-2014  MV  [CR00444603] Replace dojox/storage with HTML5 local storage.  
   * 17-Sep-2013  BOS [CR00396844] Changed the format of stored date to UTC as
   *                    the default was ISO and was causing an issue.
   * 22-Aug-2013  BOS [CR00394807] Refactored for unit tests.
   * 02-Aug-2013  BOS [CR00393492] Initial version.
   */
define([ "dojo/_base/declare",
         "dojo/_base/lang",
         "dojo/dom",
         "dojo/dom-class",
         "curam/util",
         "curam/util/UIMFragment",
         "curam/ui/ClientDataAccessor",
         "dijit/_Widget",
         "dijit/_TemplatedMixin",
         "dijit/_WidgetsInTemplateMixin",
         "dijit/layout/BorderContainer",
         "dijit/layout/ContentPane",
         "dijit/form/Button",
         "dojo/has",
         "dojo/text!curam/widget/templates/OptimalBrowserMessage.html",
         "dojo/dom-attr"],
  function(declare,
    lang,
    dom,
    domClass,
    util,
    UIMFragment, 
    ClientDataAccessor,
    _Widget,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    BorderContainer,
    ContentPane,
    Button,
    has,
    template,
    domAttr
    ){
  return declare("curam.widget.OptimalBrowserMessage",[_Widget,_TemplatedMixin,_WidgetsInTemplateMixin], 
    {
    OPTIMAL_BROWSER_MSG: "optimal-browser-msg",
    
    isExternalApp: null,
    
    optimalBrowserMsgPaddingCSS: "optimal-browser-banner", 
    
    optimalBrowserNode: null,
    
    appSectionsNode: null,
    
    appBannerHeaderNode: null,
    
    intApp: "internal",
    
    extApp: "external",
    
    /** Template String */
    
    templateString: template,

    widgetsInTemplate: true,
    
    baseClass: "",
    
    optimalBrowserNodeID: "_optimalMessage",
    
    _appConfig: null,
    


    /**
     * Overridden to mixin the override resources if provided.
     * @function
     * @public
     */
    postMixInProperties: function() {
      this.inherited(arguments);
    },
    
    /**
     * Override to force startup/layout on BorderContainer.
     */
    startup: function() {
      this.inherited(arguments);
      this._init();
      // load the nodes we are concerned with for optimal browser banner.
      this._loadNodes(this._optimalMessage.id);


    },

    /**
     * Initializes the widget by loading the JSON data before rendering the
     * optimal browser message.
     */
    _init: function() {
      da = new ClientDataAccessor();
      da.getRaw("/config/tablayout/settings[" + curam.config.appID + "]",
          lang.hitch(this, function(data) {
            console.log("External App config data:" + data);
            this._appConfig = data;
            this._getAppConfig();
            this._updateOptimalBrowserNode();
          }),
          function(error, args) {
            console.log("External App config data load error:" + error);
          },
          null);


    },
    
    /**
     * Initializes the widget by getting the JSON data before rendering the
     * optimal browser message.
     */
    _getAppConfig: function() {
      var optimalBrowserMsgEnabled = this._appConfig.optimalBrowserMessageEnabled;
      var optimalMsgKey = this._createStorageKey(this.OPTIMAL_BROWSER_MSG);
      var thisObj = this;
      



      // if the feature is enabled we start doing the checking of the current
      // browser version against the browser configuration...
      if (optimalBrowserMsgEnabled == "true" | optimalBrowserMsgEnabled == "TRUE") {
        return thisObj._isOptimalBrowserCheckDue(optimalMsgKey, thisObj);
      }
      
      return false;    
    },
    _updateOptimalBrowserNode: function() {
      this.optimalBrowserNode = dom.byId(this._optimalMessage.id);
      domAttr.set(optimalBrowserNode, "aria-label", this._appConfig.optimalMessageDivLabel);
    },
    
    /**
     * Determines if a an optimal browser check is due. This is determined if
     * the fetaure is on and the check has never been run before or the number days 
     * until the next browser check has elapsed.
     */
    _isOptimalBrowserCheckDue: function(optimalMsgKey, thisObj) {
      var dateForNextCheck = localStorage[optimalMsgKey];

        // If the application has been accessed before then we get the date
        // that was set for the key and determine if that date is not in the
        // past. If the date for the check was in the past then we need to do
        // check
        if(dateForNextCheck && dateForNextCheck != "") {
          // if the current date is greater (allowing for format) than 
          // date set persistently marking that we have shown this message to 
          // user before then we need to do the check again. ie. the check 
          // happen every 60 days (can be configured though for other value)..
          if (new Date(thisObj._getTargetDate()) 
              > new Date(dateForNextCheck)) {
          thisObj._executeBrowserVersionCheck();
            return true;
          }
        // if key never set in storage then the application must not have been 
        // accessed before.
        } else {
        thisObj._executeBrowserVersionCheck();
          return true;
        }
        return false;
    },
    
    /**
     * Execute the browser check. The current browser i.e 
     * (IE, FF, Chrome, Safari) is checked against the configured browser 
     * version for that browser.
     */
    _executeBrowserVersionCheck: function() {
      var ieMinVersion = this._appConfig.ieMinVersion;
      var ieMaxVersion = this._appConfig.ieMaxVersion;
      var ffMinVersion = this._appConfig.ffMinVersion;
      var ffMaxVersion = this._appConfig.ffMaxVersion;
      var chromeMinVersion = this._appConfig.chromeMinVersion;
      var chromeMaxVersion = this._appConfig.chromeMaxVersion;
      var safariMinVersion = this._appConfig.safariMinVersion;
      var safariMaxVersion = this._appConfig.safariMaxVersion;
    
      // up to IE 10 trident layout engine was V6.0.
      var ieV6TridentBrowserVersion = dojo.isIE;
      // from IE 11 onwards the trident layout engine V7 is being used and dojo.iE
      // is not supported for IE11.
      var ieV7TridentBrowserVersion = has('trident') || has('edge');
      var ffBrowserVersion = dojo.isFF;
      var chromeBrowserVersion = dojo.isChrome;
      var safariBrowserVersion = dojo.isSafari;
      
      // IE non trident check (up to IE 10) browser check
      if (ieV6TridentBrowserVersion != undefined && this.isExternalApp) {
        return this._isCurrentBrowserVerSupported(
          ieV6TridentBrowserVersion, ieMinVersion, ieMaxVersion);
        // IE trident check (IE 11 onwards) browser check
      }  else if (ieV7TridentBrowserVersion > 6 && this.isExternalApp) {
         // TODO: For IE12 onwards we need to update investigate how trident versions
         // map to IE versions but below is how they should be mapped provided they stay
        // with current mapping e.g. trident 4 versions behind IE verion
        // Trident 5.0 = IE9.0, Trident 6.0 = IE10.0, Trident 7.0 = IE11
        // Perhaps dojo will have new convenience function i.e dojo.isTrident ??
         var tridentMinVersion = ieMinVersion - 4;
         var tridentMaxVersion = ieMaxVersion - 4;
         return this._isCurrentBrowserVerSupported(
             ieV7TridentBrowserVersion, tridentMinVersion, tridentMaxVersion);
      } else if (ffBrowserVersion != undefined && this.isExternalApp) {
        return this._isCurrentBrowserVerSupported(
          ffBrowserVersion, ffMinVersion, ffMaxVersion);
      } else if (chromeBrowserVersion != undefined) {
        return this._isCurrentBrowserVerSupported(
          chromeBrowserVersion, chromeMinVersion, chromeMaxVersion);
      } else if (safariBrowserVersion != undefined && this.isExternalApp) {
        return this._isCurrentBrowserVerSupported(
          safariBrowserVersion, safariMinVersion, safariMaxVersion);
      }
      return false;
    },
    
    /**
     * Indicates if the browser version being used is supported. If the minimum
     * version is set to greater than the current version then display
     * the optimal browser message. Additionally if the current version is set
     * greater to that of the maximum version than display the message.
     */
    _isCurrentBrowserVerSupported: function(currentBrowserVersion, 
        minSupportedBrowserVersion, maxSupportedBrowserVersion) {
      var messageEnabled = false;
      if (minSupportedBrowserVersion > 0.0) {
        if (currentBrowserVersion < minSupportedBrowserVersion) {
          messageEnabled = true;
          this._displayOptimalBrowserMsg();
          return true;
        }
      }
      // if we have not enabled the message already (because we have just 
      // detected that minimum version not supported) and maximum version set 
      // then check maximum browser version. 
      if (maxSupportedBrowserVersion > 0.0 && !messageEnabled) {
        if (currentBrowserVersion > maxSupportedBrowserVersion) {
          this._displayOptimalBrowserMsg();
          return true;
        }
      }
      return false;
    },
    
    /**
     * Display the optimal browser message in the banner of the application, by
     * invoking a renderer. Some post rendering tasks are then executed.
     */
    _displayOptimalBrowserMsg: function() {
      this._addOrRemoveCssForInternalApp(true, 
        this.optimalBrowserMsgPaddingCSS);
      // Invoke the renderer where the message content will be rendered
      // and added to the root fragment
      UIMFragment.get({
        url: "optimal-browser-msg-fragment.jspx",
        targetID: this._optimalMessage.id

      });
      
      this._postRenderingTasks();
    },
    
    /**
     * Post rendering tasks.
     */
    _postRenderingTasks: function() {
      // BOTH INTERNAL AND EXTERNAL APP
      // (1) Remove the 'hidden' CSS class because we want display the root
      //     HTML fragment for the optimal browser message
      var nodeId = this._optimalMessage.id;
      dojo.addOnLoad(function(){
        var optimalBrowserNode = dom.byId(nodeId);
        domClass.remove(optimalBrowserNode, optimalBrowserNode.className);
      });
    
      // Set the number of days (in the storage facility) until when we should
      // do the next check...
      localStorage[this._createStorageKey(this.OPTIMAL_BROWSER_MSG)] =
          this._getTargetDate(this._appConfig.nextBrowserCheck);
    },
    
    /**
     * Load the nodes of interest for the optimal browser configuration.
     */
    _loadNodes: function(optimalMsgID) {
      dojo.addOnLoad(function() {
        this.optimalBrowserNode = dom.byId(optimalMsgID);
        this.appSectionsNode = dom.byId("app-sections-container-dc");
        this.appBannerHeaderNode = dom.byId("app-header-container-dc");
      });
    },
    
    /**
     * Creates a key for storing a token that will be used to determine the 
     * next time that the optimal browser check should be done.
     */
    _createStorageKey: function (initialKey) {
      // this.OPTIMAL_BROWSER_MSG
      if (this.isExternalApp) {
        initialKey = initialKey + "_" + this.extApp; 
      } else {
        initialKey = initialKey + "_" + this.intApp; 
      }
      return initialKey;
    },
    
    /**
     * Add or remove the relevant CSS class name for the optimal browser banner.
     * We need to adjust the height for internal application depending on
     * whether we have a banner header or sections.
     */
    _addOrRemoveCssForInternalApp: function(addClass, newCSS) {
      var isExternalApp = this.isExternalApp;
      dojo.addOnLoad(function() {
        // FOR INTERNAL APP ONLY
        // With current look and feel of optimal browser banner, lots more hacking
        // of the styling needs to be done... Timeouts e.t.c Tere is currently some
        // interference with the loading mask for tabs in UIController.
        if (!isExternalApp) {
          if (addClass) {
            domClass.add(this.appSectionsNode, newCSS);
            if (this.appBannerHeaderNode) {
              domClass.add(this.appSectionsNode.children.item(1), newCSS);
              domClass.add(this.appSectionsNode.children.item(2), newCSS);     
            }   
          } else {
            domClass.remove(this.appSectionsNode, newCSS);
            if (this.appBannerHeaderNode) {
              domClass.remove(this.appSectionsNode.children.item(1), newCSS);
              domClass.remove(this.appSectionsNode.children.item(2), newCSS);     
            }   
          }
        } 
      });     
    },
    
    /**
     * Gets a target date. The target date will be set a number of days into the
     * future if an input value has been specified.
     */
    _getTargetDate: function (daysIntoTheFuture) {
      var targetDate = new Date();
      if (daysIntoTheFuture == undefined) {
        targetDate.setDate(targetDate.getDate());
      } else {
        targetDate.setDate(targetDate.getDate() + daysIntoTheFuture);
      }
      return targetDate.toUTCString();
    },
    
    /**
     * Removes the optimal browser banner message from the application by 
     * removing the relevant node.
     */
    exitOptimalBrowserMessageBox: function() {
      var optimalBrowserNode = dom.byId(this._optimalMessage.id);
      if(optimalBrowserNode){
        optimalBrowserNode.parentNode.removeChild(optimalBrowserNode);
      }
      // remove the CSS class names added for the optimal browser afterwards so
      // that the height adjustments are rolled back to what they were
      // previously
      this._addOrRemoveCssForInternalApp(false, 
        this.optimalBrowserMsgPaddingCSS);
    }
    });
});  


},
'dijit/_KeyNavMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.END keys.HOME, keys.LEFT_ARROW etc.
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dijit/registry",
	"dijit/_FocusMixin"        // to make _onBlur() work
], function(array, declare, domAttr, keys, lang, on, registry, _FocusMixin){

	// module:
	//		dijit/_KeyNavMixin

	return declare("dijit._KeyNavMixin", _FocusMixin, {
		// summary:
		//		A mixin to allow arrow key and letter key navigation of child or descendant widgets.
		//		It can be used by dijit/_Container based widgets with a flat list of children,
		//		or more complex widgets like dijit/Tree.
		//
		//		To use this mixin, the subclass must:
		//
		//			- Implement  _getNext(), _getFirst(), _getLast(), _onLeftArrow(), _onRightArrow()
		//			  _onDownArrow(), _onUpArrow() methods to handle home/end/left/right/up/down keystrokes.
		//			  Next and previous in this context refer to a linear ordering of the descendants used
		//			  by letter key search.
		//			- Set all descendants' initial tabIndex to "-1"; both initial descendants and any
		//			  descendants added later, by for example addChild()
		//			- Define childSelector to a function or string that identifies focusable descendant widgets
		//
		//		Also, child widgets must implement a focus() method.

		/*=====
		 // focusedChild: [protected readonly] Widget
		 //		The currently focused child widget, or null if there isn't one
		 focusedChild: null,

		 // _keyNavCodes: Object
		 //		Hash mapping key code (arrow keys and home/end key) to functions to handle those keys.
		 //		Usually not used directly, as subclasses can instead override _onLeftArrow() etc.
		 _keyNavCodes: {},
		 =====*/

		// tabIndex: String
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		// childSelector: [protected abstract] Function||String
		//		Selector (passed to on.selector()) used to identify what to treat as a child widget.   Used to monitor
		//		focus events and set this.focusedChild.   Must be set by implementing class.   If this is a string
		//		(ex: "> *") then the implementing class must require dojo/query.
		childSelector: null,

		postCreate: function(){
			this.inherited(arguments);

			// Set tabIndex on this.domNode.  Will be automatic after #7381 is fixed.
			domAttr.set(this.domNode, "tabIndex", this.tabIndex);

			if(!this._keyNavCodes){
				var keyCodes = this._keyNavCodes = {};
				keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
				keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
				keyCodes[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW] = lang.hitch(this, "_onLeftArrow");
				keyCodes[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW] = lang.hitch(this, "_onRightArrow");
				keyCodes[keys.UP_ARROW] = lang.hitch(this, "_onUpArrow");
				keyCodes[keys.DOWN_ARROW] = lang.hitch(this, "_onDownArrow");
			}

			var self = this,
				childSelector = typeof this.childSelector == "string"
					? this.childSelector
					: lang.hitch(this, "childSelector");
			this.own(
				on(this.domNode, "keypress", lang.hitch(this, "_onContainerKeypress")),
				on(this.domNode, "keydown", lang.hitch(this, "_onContainerKeydown")),
				on(this.domNode, "focus", lang.hitch(this, "_onContainerFocus")),
				on(this.containerNode, on.selector(childSelector, "focusin"), function(evt){
					self._onChildFocus(registry.getEnclosingWidget(this), evt);
				})
			);
		},

		_onLeftArrow: function(){
			// summary:
			//		Called on left arrow key, or right arrow key if widget is in RTL mode.
			//		Should go back to the previous child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onRightArrow: function(){
			// summary:
			//		Called on right arrow key, or left arrow key if widget is in RTL mode.
			//		Should go to the next child in horizontal container widgets like Toolbar.
			// tags:
			//		extension
		},

		_onUpArrow: function(){
			// summary:
			//		Called on up arrow key. Should go to the previous child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		_onDownArrow: function(){
			// summary:
			//		Called on down arrow key. Should go to the next child in vertical container widgets like Menu.
			// tags:
			//		extension
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, 1);	// dijit/_WidgetBase
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused.

			// Leverage _getNextFocusableChild() to skip disabled children
			return this._getNextFocusableChild(null, -1);	// dijit/_WidgetBase
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected

			this.focusChild(this._getLastFocusableChild());
		},

		focusChild: function(/*dijit/_WidgetBase*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){
				return;
			}

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used to be used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focus
			widget.focus(last ? "end" : "start");

			// Don't set focusedChild here, because the focus event should trigger a call to _onChildFocus(), which will
			// set it.   More importantly, _onChildFocus(), which may be executed asynchronously (after this function
			// returns) needs to know the old focusedChild to set its tabIndex to -1.
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container itself gets focus.
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child.
			//
			//		TODO for 2.0 (or earlier): Instead of having the container tabbable, always maintain a single child
			//		widget as tabbable, Requires code in startup(), addChild(), and removeChild().
			//		That would avoid various issues like #17347.
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively).
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){
				return;
			}

			this.focus();
		},

		_onFocus: function(){
			// When the container gets focus by being tabbed into, or a descendant gets focus by being clicked,
			// set the container's tabIndex to -1 (don't remove as that breaks Safari 4) so that tab or shift-tab
			// will go to the fields after/before the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");

			this.inherited(arguments);
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)

			// TODO: for 2.0 consider changing this to blur whenever the container blurs, to be truthful that there is
			// no focused child at that time.

			domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			if(this.focusedChild){
				this.focusedChild.set("tabIndex", "-1");
				this.lastFocusedChild = this.focusedChild;
				this._set("focusedChild", null);
			}
			this.inherited(arguments);
		},

		_onChildFocus: function(/*dijit/_WidgetBase*/ child){
			// summary:
			//		Called when a child widget gets focus, either by user clicking
			//		it, or programatically by arrow key handling code.
			// description:
			//		It marks that the current node is the selected one, and the previously
			//		selected node no longer is.

			if(child && child != this.focusedChild){
				if(this.focusedChild && !this.focusedChild._destroyed){
					// mark that the previously focusable node is no longer focusable
					this.focusedChild.set("tabIndex", "-1");
				}

				// mark that the new node is the currently selected one
				child.set("tabIndex", this.tabIndex);
				this.lastFocused = child;		// back-compat for Tree, remove for 2.0
				this._set("focusedChild", child);
			}
		},

		_searchString: "",
		// multiCharSearchDuration: Number
		//		If multiple characters are typed where each keystroke happens within
		//		multiCharSearchDuration of the previous keystroke,
		//		search for nodes matching all the keystrokes.
		//
		//		For example, typing "ab" will search for entries starting with
		//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
		multiCharSearchDuration: 1000,

		onKeyboardSearch: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		When a key is pressed that matches a child item,
			//		this method is called so that a widget can take appropriate action is necessary.
			// tags:
			//		protected
			if(item){
				this.focusChild(item);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//
			//			* -1: a high priority match  and stop searching
			//		 	* 0: not a match
			//		 	* 1: a match but keep looking for a higher priority match
			// tags:
			//		private

			var element = item.domNode,
				text = item.label || (element.focusNode ? element.focusNode.label : '') || element.innerText || element.textContent || "",
				currentString = text.replace(/^\s+/, '').substr(0, searchString.length).toLowerCase();

			return (!!searchString.length && currentString == searchString) ? -1 : 0; // stop searching after first match by default
		},

		_onContainerKeydown: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then it's handled here.
			// tags:
			//		private

			var func = this._keyNavCodes[evt.keyCode];
			if(func){
				func(evt, this.focusedChild);
				evt.stopPropagation();
				evt.preventDefault();
				this._searchString = ''; // so a DOWN_ARROW b doesn't search for ab
			}else if(evt.keyCode == keys.SPACE && this._searchTimer && !(evt.ctrlKey || evt.altKey || evt.metaKey)){
				evt.stopImmediatePropagation(); // stop a11yclick and _HasDropdown from seeing SPACE if we're doing keyboard searching
				evt.preventDefault(); // stop IE from scrolling, and most browsers (except FF) from sending keypress
				this._keyboardSearch(evt, ' ');
			}
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a printable key is pressed, it's handled here, searching by letter.
			// tags:
			//		private

			// Ignore:
			// 		- duplicate events on firefox (ex: arrow key that will be handled by keydown handler)
			//		- control sequences like CMD-Q.
			//		- the SPACE key (only occurs on FF)
			//
			// Note: if there's no search in progress, then SPACE should be ignored.   If there is a search
			// in progress, then SPACE is handled in _onContainerKeyDown.
			if(evt.charCode <= keys.SPACE || evt.ctrlKey || evt.altKey || evt.metaKey){
				return;
			}

			evt.preventDefault();
			evt.stopPropagation();

			this._keyboardSearch(evt, String.fromCharCode(evt.charCode).toLowerCase());
		},

		_keyboardSearch: function(/*Event*/ evt, /*String*/ keyChar){
			// summary:
			//		Perform a search of the widget's options based on the user's keyboard activity
			// description:
			//		Called on keypress (and sometimes keydown), searches through this widget's children
			//		looking for items that match the user's typed search string.  Multiple characters
			//		typed within 1 sec of each other are combined for multicharacter searching.
			// tags:
			//		private
			var
				matchedItem = null,
				searchString,
				numMatches = 0,
				search = lang.hitch(this, function(){
					if(this._searchTimer){
						this._searchTimer.remove();
					}
					this._searchString += keyChar;
					var allSameLetter = /^(.)\1*$/.test(this._searchString);
					var searchLen = allSameLetter ? 1 : this._searchString.length;
					searchString = this._searchString.substr(0, searchLen);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//this._searchTimer = this.defer(function(){ // this is the "failure" timeout
					//	this._typingSlowly = true; // if the search fails, then treat as a full timeout
					//	this._searchTimer = this.defer(function(){ // this is the "success" timeout
					//		this._searchTimer = null;
					//		this._searchString = '';
					//	}, this.multiCharSearchDuration >> 1);
					//}, this.multiCharSearchDuration >> 1);
					this._searchTimer = this.defer(function(){ // this is the "success" timeout
						this._searchTimer = null;
						this._searchString = '';
					}, this.multiCharSearchDuration);
					var currentItem = this.focusedChild || null;
					if(searchLen == 1 || !currentItem){
						currentItem = this._getNextFocusableChild(currentItem, 1); // skip current
						if(!currentItem){
							return;
						} // no items
					}
					var stop = currentItem;
					do{
						var rc = this._keyboardSearchCompare(currentItem, searchString);
						if(!!rc && numMatches++ == 0){
							matchedItem = currentItem;
						}
						if(rc == -1){ // priority match
							numMatches = -1;
							break;
						}
						currentItem = this._getNextFocusableChild(currentItem, 1);
					}while(currentItem && currentItem != stop);
					// commented out code block to search again if the multichar search fails after a smaller timeout
					//if(!numMatches && (this._typingSlowly || searchLen == 1)){
					//	this._searchString = '';
					//	if(searchLen > 1){
					//		// if no matches and they're typing slowly, then go back to first letter searching
					//		search();
					//	}
					//}
				});

			search();
			// commented out code block to search again if the multichar search fails after a smaller timeout
			//this._typingSlowly = false;
			this.onKeyboardSearch(matchedItem, evt, searchString, numMatches);
		},

		_onChildBlur: function(/*dijit/_WidgetBase*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used to be used by MenuBase.js (remove for 2.0)
			// tags:
			//		protected
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable descendant, compared to "child".
			//		Implements and extends _KeyNavMixin._getNextFocusableChild() for a _Container.
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			var wrappedValue = child;
			do{
				if(!child){
					child = this[dir > 0 ? "_getFirst" : "_getLast"]();
					if(!child){ break; }
				}else{
					child = this._getNext(child, dir);
				}
				if(child != null && child != wrappedValue && child.isFocusable()){
					return child;	// dijit/_WidgetBase
				}
			}while(child != wrappedValue);
			// no focusable child found
			return null;	// dijit/_WidgetBase
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension

			return null;	// dijit/_WidgetBase
		},

		_getNext: function(child, dir){
			// summary:
			//		Returns the next descendant, compared to "child".
			// child: Widget
			//		The current widget
			// dir: Integer
			//		- 1 = after
			//		- -1 = before
			// tags:
			//		abstract extension

			if(child){
				child = child.domNode;
				while(child){
					child = child[dir < 0 ? "previousSibling" : "nextSibling"];
					if(child  && "getAttribute" in child){
						var w = registry.byNode(child);
						if(w){
							return w; // dijit/_WidgetBase
						}
					}
				}
			}
			return null;	// dijit/_WidgetBase
		}
	});
});

},
'curam/util/EditableList':function(){
/*
 * Copyright 2011-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 11-Oct-2011  JY  [CR00290450] Refactor the toggle function to make it 
 *                  easier to be tested.
 * 23-Sep-2011  JY  [CR00288523] Added a new class to the text input field 
 *                  when it is disabled.
 * 30-Aug-2011  JY  [TEC-7796]  Initial Version.
 */

define(["dojo/dom-class",
        "dojo/dom-attr",
        "curam/debug",
        "curam/define",
        "dojo/query",
        "dojo/NodeList-traverse"
        ], function(domClass, domAttr, debug) {
  
  curam.define.singleton("curam.util.EditableList", {

    /**
     * Method to enable/disable the fields in Editable Lists when
     * the page is being loaded.
     * 
     * @returns {String} For test purposes
     */
  onload: function(titleText){

    // Get all checkbox in the editable list
      var checkboxNodes = dojo.query(
          "div.list table tbody td input[type = 'checkbox']");

      if (checkboxNodes[0] == null) {
        return "Outside List";
      }
      
      checkboxNodes.forEach(function(node) {
      curam.debug.log("curam.util.EditableList onload()");

        curam.util.EditableList._doToggling(node, titleText);
    });

      return "In List";
    },

    /**
     * Method to receive an event in order to toggle fields
     *  in Editable Fields.
     * 
     * @param event JavaScript Event
     * @returns {String} For test purposes
     */
  toggle: function(event, titleText){
      curam.debug.log(
          "curam.util.EditableList: " 
            + debug.getProperty("curam.util.EditableList.toggle"));
      
    event = dojo.fixEvent(event);

      if (!event.target) {
        return "Improper Event";
      }
      
      var checkBoxNode = event.target;
      
      //Toggling the editable list
      curam.util.EditableList._doToggling(checkBoxNode, titleText);
      
      return "Event Processed";
    },
    
    /**
     * Method to toggle fields in Editable Lists.
     * 
     * @param checkBoxNode Checkbox node
     * @returns {String} For test purposes
     */
    _doToggling: function(checkBoxNode, titleText) {
      
      // Find the editable list node that contains the checkbox.
    var searchNode = checkBoxNode;
    while(searchNode && !domClass.contains(searchNode, "list")){
      searchNode = searchNode.parentNode;
    }

    // Stop here if the list node is not found.
    if(searchNode == null){
        return "Outside List";
    }
    
    // Find the TR node that contains the checkbox
    var trNode = dojo.query(checkBoxNode).closest('TR')[0];
    
    // update accessibility for boolean checkbox field when unchecked
    if (titleText) {
      curam.util.EditableList._updateCheckboxAccessibility(trNode,titleText);
    }
    


    if(checkBoxNode.checked == true){
      isChecked = true;
      curam.debug.log(debug.getProperty("curam.util.EditableList.ticking"));

    }else{
      isChecked = false;
      curam.debug.log(debug.getProperty("curam.util.EditableList.unticking"));
      }
    // Check if the "TR" node is found or not
      if (trNode == null) {
        throw new Error("Exception: The TR node is not found");
      }

      // Process editable fields in the list row associated with the checkbox
    dojo.query("td > *", trNode).forEach(function(node){
      if(domClass.contains(node, "text")){
        // Enable/Disable the input field
        if(isChecked){
          domAttr.remove(node, "disabled");
          domClass.remove(node, "disabled");
          curam.debug.log(debug
            .getProperty("curam.util.EditableList.enable.field"));

        }else{
          domAttr.set(node, "disabled", "disable");
          domClass.add(node, "disabled");
          curam.debug.log(
            debug.getProperty("curam.util.EditableList.disable.field"));
        }

      }else if(domClass.contains(node, "codetable")){
        // Enable/Disable the codetable
        var widgetId = domAttr.get(node, "widgetid");

        var selectWidget = dijit.byId(widgetId);
        if(isChecked){
          selectWidget.set("disabled", false);
          curam.debug.log(debug
            .getProperty("curam.util.EditableList.enable.ct"));

        }else{
          selectWidget.set("disabled", true);
          curam.debug.log(debug
              .getProperty("curam.util.EditableList.disable.ct"));
        }
      }
      });
      
      return "Toggled";
    },
    
    _updateCheckboxAccessibility: function(tr, titleText) {
      var tdNodes = dojo.query("td",tr);
      var table = tdNodes.parents("table");
      // checkbox td node
      var checkboxChild = tdNodes[0];
      // sibling of checkbox td element
      var checkboxSibling = tdNodes[1];
      var checkboxSiblingText = "";
      var updatedTitleText = "";

      if (checkboxChild && checkboxChild.firstElementChild) {
        // validate that the first td node has input node with type 'checkbox'
        if (checkboxChild.firstElementChild.nodeName == "INPUT" && checkboxChild.firstElementChild.getAttribute("type") == "checkbox") {
          // ensure sibling td node present
          if (checkboxSibling.firstChild) {
            // if the first child of sibling is text node then get that text
            // as updated accessibility text
            if (checkboxSibling.firstChild.nodeType == 3) {
              checkboxSiblingText =  checkboxSibling.firstChild.textContent;
              // otherwise get accessibility text from child input element of
              // sibling td
            } else if (checkboxChild.firstElementChild.nodeName == "INPUT") {
              checkboxSiblingText =  checkboxSibling.firstElementChild.getAttribute("value");
            }
          }
          // if text is valid (have text and not empty) the accessibility text
          // is the initital title text (passes in) plus the text we got from
          // sibling td node
          if (checkboxSiblingText && checkboxSiblingText.length > 0) {
            updatedTitleText = titleText + " - " + checkboxSiblingText;
          } else {
            updatedTitleText = titleText;
          }
          
          if (table[0] && table[0].getAttribute("summary")) {
            updatedTitleText 
              = table[0].getAttribute("summary") + " - " + updatedTitleText;
          }
          
          checkboxChild.firstElementChild.setAttribute("aria-label", updatedTitleText);
          checkboxChild.firstElementChild.title = updatedTitleText;
        }
     }
      // return checkbox node to test
     return checkboxChild;
   }
  });
  
  return curam.util.EditableList;
});

},
'dijit/form/_TextBoxMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/sniff",	// has("ie"), has("dojo-bidi")
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	"dojo/on", // on
	"../main"    // for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, has, keys, lang, on, dijit){

	// module:
	//		dijit/form/_TextBoxMixin

	var _TextBoxMixin = declare("dijit.form._TextBoxMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin for textbox form input widgets

		// trim: Boolean
		//		Removes leading and trailing whitespace if true.  Default is false.
		trim: false,

		// uppercase: Boolean
		//		Converts all characters to uppercase if true.  Default is false.
		uppercase: false,

		// lowercase: Boolean
		//		Converts all characters to lowercase if true.  Default is false.
		lowercase: false,

		// propercase: Boolean
		//		Converts the first character of each word to uppercase if true.
		propercase: false,

		// maxLength: String
		//		HTML INPUT tag maxLength declaration.
		maxLength: "",

		// selectOnClick: [const] Boolean
		//		If true, all text will be selected when focused with mouse
		selectOnClick: false,

		// placeHolder: String
		//		Defines a hint to help users fill out the input field (as defined in HTML 5).
		//		This should only contain plain text (no html markup).
		placeHolder: "",

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works as we like.
			// description:
			//		For `dijit/form/TextBox` this basically returns the value of the `<input>`.
			//
			//		For `dijit/form/MappedTextBox` subclasses, which have both
			//		a "displayed value" and a separate "submit value",
			//		This treats the "displayed value" as the master value, computing the
			//		submit value from it via this.parse().
			return this.parse(this.get('displayedValue'), this.constraints);
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			//
			// description:
			//		Sets the value of the widget to "value" which can be of
			//		any type as determined by the widget.
			//
			// value:
			//		The visual element value is also set to a corresponding,
			//		but not necessarily the same, value.
			//
			// formattedValue:
			//		If specified, used to set the visual element value,
			//		otherwise a computed visual value is used.
			//
			// priorityChange:
			//		If true, an onChange event is fired immediately instead of
			//		waiting for the next blur event.

			var filteredValue;
			if(value !== undefined){
				// TODO: this is calling filter() on both the display value and the actual value.
				// I added a comment to the filter() definition about this, but it should be changed.
				filteredValue = this.filter(value);
				if(typeof formattedValue != "string"){
					if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
						formattedValue = this.filter(this.format(filteredValue, this.constraints));
					}else{
						formattedValue = '';
					}
					// Ensure the filtered value does not change after being formatted. See track #17955.
					//
					// This check is only applied when the formatted value is not specified by the caller in order to allow the 
					// behavior to be overriden. This is needed whenever value synonyms cannot be determined using parse/compare. For
					// example, dijit/form/FilteringSelect determines the formatted value asynchronously and applies it using a 
					// callback to this method.
					//
					// TODO: Should developers be warned that they broke the round trip on format?
					if (this.compare(filteredValue, this.filter(this.parse(formattedValue, this.constraints))) != 0){
						formattedValue = null;
					}
				}
			}
			if(formattedValue != null /* and !undefined */ && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
				this.textbox.value = formattedValue;
				this._set("displayedValue", this.get("displayedValue"));
			}

			this.inherited(arguments, [filteredValue, priorityChange]);
		},

		// displayedValue: String
		//		For subclasses like ComboBox where the displayed value
		//		(ex: Kentucky) and the serialized value (ex: KY) are different,
		//		this represents the displayed value.
		//
		//		Setting 'displayedValue' through set('displayedValue', ...)
		//		updates 'value', and vice-versa.  Otherwise 'value' is updated
		//		from 'displayedValue' periodically, like onBlur etc.
		//
		//		TODO: move declaration to MappedTextBox?
		//		Problem is that ComboBox references displayedValue,
		//		for benefit of FilteringSelect.
		displayedValue: "",

		_getDisplayedValueAttr: function(){
			// summary:
			//		Hook so get('displayedValue') works.
			// description:
			//		Returns the displayed value (what the user sees on the screen),
			//		after filtering (ie, trimming spaces etc.).
			//
			//		For some subclasses of TextBox (like ComboBox), the displayed value
			//		is different from the serialized value that's actually
			//		sent to the server (see `dijit/form/ValidationTextBox.serialize()`)

			// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
			// this method
			// TODO: this isn't really the displayed value when the user is typing
			return this.filter(this.textbox.value);
		},

		_setDisplayedValueAttr: function(/*String*/ value){
			// summary:
			//		Hook so set('displayedValue', ...) works.
			// description:
			//		Sets the value of the visual element to the string "value".
			//		The widget value is also set to a corresponding,
			//		but not necessarily the same, value.

			if(value == null /* or undefined */){
				value = ''
			}
			else if(typeof value != "string"){
				value = String(value)
			}

			this.textbox.value = value;

			// sets the serialized value to something corresponding to specified displayedValue
			// (if possible), and also updates the textbox.value, for example converting "123"
			// to "123.00"
			this._setValueAttr(this.get('value'), undefined);

			this._set("displayedValue", this.get('displayedValue'));
		},

		format: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a value to a properly formatted string.
			// value: String
			// constraints: Object
			// tags:
			//		protected extension
			return value == null /* or undefined */ ? "" : (value.toString ? value.toString() : value);
		},

		parse: function(value /*=====, constraints =====*/){
			// summary:
			//		Replaceable function to convert a formatted string to a value
			// value: String
			// constraints: Object
			// tags:
			//		protected extension

			return value;	// String
		},

		_refreshState: function(){
			// summary:
			//		After the user types some characters, etc., this method is
			//		called to check the field for validity etc.  The base method
			//		in `dijit/form/TextBox` does nothing, but subclasses override.
			// tags:
			//		protected
		},

		 onInput: function(/*Event*/ /*===== evt =====*/){
			 // summary:
			 //		Connect to this function to receive notifications of various user data-input events.
			 //		Return false to cancel the event and prevent it from being processed.
			 //		Note that although for historical reasons this method is called `onInput()`, it doesn't
			 //		correspond to the standard DOM "input" event, because it occurs before the input has been processed.
			 // event:
			 //		keydown | keypress | cut | paste | compositionend
			 // tags:
			 //		callback
		 },

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened and this.textbox.value has new value.

			this._lastInputEventValue = this.textbox.value;

			// For Combobox, this needs to be called w/the keydown/keypress event that was passed to onInput().
			// As a backup, use the "input" event itself.
			this._processInput(this._lastInputProducingEvent || evt);
			delete this._lastInputProducingEvent;

			if(this.intermediateChanges){
				this._handleOnChange(this.get('value'), false);
			}
		},

		_processInput: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		Default action handler for user input events.
			//		Called after the "input" event (i.e. after this.textbox.value has been updated),
			//		but `evt` is the keydown/keypress/etc. event that triggered the "input" event.
			// tags:
			//		protected

			this._refreshState();

			// In case someone is watch()'ing for changes to displayedValue
			this._set("displayedValue", this.get("displayedValue"));
		},

		postCreate: function(){
			// setting the value here is needed since value="" in the template causes "undefined"
			// and setting in the DOM (instead of the JS object) helps with form reset actions
			this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

			this.inherited(arguments);

			// normalize input events to reduce spurious event processing
			//	keydown: do not forward modifier keys
			//		       set charOrCode to numeric keycode
			//	keypress: do not forward numeric charOrCode keys (already sent through onkeydown)
			//	paste, cut, compositionend: set charOrCode to 229 (IME)
			function handleEvent(e){
				var charOrCode;

				// Filter out keydown events that will be followed by keypress events.  Note that chrome/android
				// w/word suggestion has keydown/229 events on typing with no corresponding keypress events.
				if(e.type == "keydown" && e.keyCode != 229){
					charOrCode = e.keyCode;
					switch(charOrCode){ // ignore state keys
						case keys.SHIFT:
						case keys.ALT:
						case keys.CTRL:
						case keys.META:
						case keys.CAPS_LOCK:
						case keys.NUM_LOCK:
						case keys.SCROLL_LOCK:
							return;
					}
					if(!e.ctrlKey && !e.metaKey && !e.altKey){ // no modifiers
						switch(charOrCode){ // ignore location keys
							case keys.NUMPAD_0:
							case keys.NUMPAD_1:
							case keys.NUMPAD_2:
							case keys.NUMPAD_3:
							case keys.NUMPAD_4:
							case keys.NUMPAD_5:
							case keys.NUMPAD_6:
							case keys.NUMPAD_7:
							case keys.NUMPAD_8:
							case keys.NUMPAD_9:
							case keys.NUMPAD_MULTIPLY:
							case keys.NUMPAD_PLUS:
							case keys.NUMPAD_ENTER:
							case keys.NUMPAD_MINUS:
							case keys.NUMPAD_PERIOD:
							case keys.NUMPAD_DIVIDE:
								return;
						}
						if((charOrCode >= 65 && charOrCode <= 90) || (charOrCode >= 48 && charOrCode <= 57) || charOrCode == keys.SPACE){
							return; // keypress will handle simple non-modified printable keys
						}
						var named = false;
						for(var i in keys){
							if(keys[i] === e.keyCode){
								named = true;
								break;
							}
						}
						if(!named){
							return;
						} // only allow named ones through
					}
				}

				charOrCode = e.charCode >= 32 ? String.fromCharCode(e.charCode) : e.charCode;
				if(!charOrCode){
					charOrCode = (e.keyCode >= 65 && e.keyCode <= 90) || (e.keyCode >= 48 && e.keyCode <= 57) || e.keyCode == keys.SPACE ? String.fromCharCode(e.keyCode) : e.keyCode;
				}
				if(!charOrCode){
					charOrCode = 229; // IME
				}
				if(e.type == "keypress"){
					if(typeof charOrCode != "string"){
						return;
					}
					if((charOrCode >= 'a' && charOrCode <= 'z') || (charOrCode >= 'A' && charOrCode <= 'Z') || (charOrCode >= '0' && charOrCode <= '9') || (charOrCode === ' ')){
						if(e.ctrlKey || e.metaKey || e.altKey){
							return;
						} // can only be stopped reliably in keydown
					}
				}

				// create fake event to set charOrCode and to know if preventDefault() was called
				var faux = { faux: true }, attr;
				for(attr in e){
					if(!/^(layer[XY]|returnValue|keyLocation)$/.test(attr)){ // prevent WebKit warnings
						var v = e[attr];
						if(typeof v != "function" && typeof v != "undefined"){
							faux[attr] = v;
						}
					}
				}
				lang.mixin(faux, {
					charOrCode: charOrCode,
					_wasConsumed: false,
					preventDefault: function(){
						faux._wasConsumed = true;
						e.preventDefault();
					},
					stopPropagation: function(){
						e.stopPropagation();
					}
				});

				this._lastInputProducingEvent = faux;

				// Give web page author a chance to consume the event.  Note that onInput() may be called multiple times
				// for same keystroke: once for keypress event and once for input event.
				//console.log(faux.type + ', charOrCode = (' + (typeof charOrCode) + ') ' + charOrCode + ', ctrl ' + !!faux.ctrlKey + ', alt ' + !!faux.altKey + ', meta ' + !!faux.metaKey + ', shift ' + !!faux.shiftKey);
				if(this.onInput(faux) === false){ // return false means stop
					faux.preventDefault();
					faux.stopPropagation();
				}
				if(faux._wasConsumed){
					return;
				} // if preventDefault was called

				// IE8 doesn't emit the "input" event at all, and IE9 doesn't emit it for backspace, delete, cut, etc.
				// Since the code below (and perhaps user code) depends on that event, emit it synthetically.
				// See http://benalpert.com/2013/06/18/a-near-perfect-oninput-shim-for-ie-8-and-9.html.
				if(has("ie") <= 9){
					switch(e.keyCode){
					case keys.TAB:
					case keys.ESCAPE:
					case keys.DOWN_ARROW:
					case keys.UP_ARROW:
					case keys.LEFT_ARROW:
					case keys.RIGHT_ARROW:
						// These keys may alter the <input>'s value indirectly, but we don't want to emit an "input"
						// event.  For example, the up/down arrows in TimeTextBox or ComboBox will cause the next
						// dropdown item's value to be copied to the <input>.
						break;
					default:
						if(e.keyCode == keys.ENTER && this.textbox.tagName.toLowerCase() != "textarea"){
							break;
						}
						this.defer(function(){
							if(this.textbox.value !== this._lastInputEventValue){
								on.emit(this.textbox, "input", {bubbles: true});
							}
						});
					}
				}
			}
			this.own(
				on(this.textbox, "keydown, keypress, paste, cut, compositionend", lang.hitch(this, handleEvent)),
				on(this.textbox, "input", lang.hitch(this, "_onInput")),

				// Allow keypress to bubble to this.domNode, so that TextBox.on("keypress", ...) works,
				// but prevent it from further propagating, so that typing into a TextBox inside a Toolbar doesn't
				// trigger the Toolbar's letter key navigation.
				on(this.domNode, "keypress", function(e){ e.stopPropagation(); })
			);
		},

		_blankValue: '', // if the textbox is blank, what value should be reported
		filter: function(val){
			// summary:
			//		Auto-corrections (such as trimming) that are applied to textbox
			//		value on blur or form submit.
			// description:
			//		For MappedTextBox subclasses, this is called twice
			//
			//		- once with the display value
			//		- once the value as set/returned by set('value', ...)
			//
			//		and get('value'), ex: a Number for NumberTextBox.
			//
			//		In the latter case it does corrections like converting null to NaN.  In
			//		the former case the NumberTextBox.filter() method calls this.inherited()
			//		to execute standard trimming code in TextBox.filter().
			//
			//		TODO: break this into two methods in 2.0
			//
			// tags:
			//		protected extension
			if(val === null){
				return this._blankValue;
			}
			if(typeof val != "string"){
				return val;
			}
			if(this.trim){
				val = lang.trim(val);
			}
			if(this.uppercase){
				val = val.toUpperCase();
			}
			if(this.lowercase){
				val = val.toLowerCase();
			}
			if(this.propercase){
				val = val.replace(/[^\s]+/g, function(word){
					return word.substring(0, 1).toUpperCase() + word.substring(1);
				});
			}
			return val;
		},

		_setBlurValue: function(){
			// Format the displayed value, for example (for NumberTextBox) convert 1.4 to 1.400,
			// or (for CurrencyTextBox) 2.50 to $2.50

			this._setValueAttr(this.get('value'), true);
		},

		_onBlur: function(e){
			if(this.disabled){
				return;
			}
			this._setBlurValue();
			this.inherited(arguments);
		},

		_isTextSelected: function(){
			return this.textbox.selectionStart != this.textbox.selectionEnd;
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){
				return;
			}

			// Select all text on focus via click if nothing already selected.
			// Since mouse-up will clear the selection, need to defer selection until after mouse-up.
			// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
			if(this.selectOnClick && by == "mouse"){
				// Use on.once() to only select all text on first click only; otherwise users would have no way to clear
				// the selection.
				this._selectOnClickHandle = on.once(this.domNode, "mouseup, touchend", lang.hitch(this, function(evt){
					// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
					// and if not, then select all the text
					if(!this._isTextSelected()){
						_TextBoxMixin.selectInputText(this.textbox);
					}
				}));
				this.own(this._selectOnClickHandle);

				// in case the mouseup never comes
				this.defer(function(){
					if(this._selectOnClickHandle){
						this._selectOnClickHandle.remove();
						this._selectOnClickHandle = null;
					}
				}, 500); // if mouseup not received soon, then treat it as some gesture
			}
			// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
			// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
			this.inherited(arguments);

			this._refreshState();
		},

		reset: function(){
			// Overrides `dijit/_FormWidget/reset()`.
			// Additionally resets the displayed textbox value to ''
			this.textbox.value = '';
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		_TextBoxMixin = declare("dijit.form._TextBoxMixin", _TextBoxMixin, {
			_setValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_setDisplayedValueAttr: function(){
				this.inherited(arguments);
				this.applyTextDir(this.focusNode);
			},
			_onInput: function(){
				this.applyTextDir(this.focusNode);
				this.inherited(arguments);
			}
		});
	}

	_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		if(element.setSelectionRange){
			element.setSelectionRange(start, stop);
		}
	};

	_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
		// summary:
		//		Select text in the input element argument, from start (default 0), to stop (default end).

		// TODO: use functions in _editor/selection.js?
		element = dom.byId(element);
		if(isNaN(start)){
			start = 0;
		}
		if(isNaN(stop)){
			stop = element.value ? element.value.length : 0;
		}
		try{
			element.focus();
			_TextBoxMixin._setSelectionRange(element, start, stop);
		}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */
		}
	};

	return _TextBoxMixin;
});

},
'dijit/a11y':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // domStyle.style
	"dojo/_base/lang", // lang.mixin()
	"dojo/sniff", // has("ie")  1 
	"./main"	// for exporting methods to dijit namespace
], function(array, dom, domAttr, domStyle, lang, has, dijit){

	// module:
	//		dijit/a11y

	var undefined;

	var a11y = {
		// summary:
		//		Accessibility utility functions (keyboard, tab stops, etc.)

		_isElementShown: function(/*Element*/ elem){
			var s = domStyle.get(elem);
			return (s.visibility != "hidden")
				&& (s.visibility != "collapsed")
				&& (s.display != "none")
				&& (domAttr.get(elem, "type") != "hidden");
		},

		hasDefaultTabStop: function(/*Element*/ elem){
			// summary:
			//		Tests if element is tab-navigable even without an explicit tabIndex setting

			// No explicit tabIndex setting, need to investigate node type
			switch(elem.nodeName.toLowerCase()){
				case "a":
					// An <a> w/out a tabindex is only navigable if it has an href
					return domAttr.has(elem, "href");
				case "area":
				case "button":
				case "input":
				case "object":
				case "select":
				case "textarea":
					// These are navigable by default
					return true;
				case "iframe":
					// If it's an editor <iframe> then it's tab navigable.
					var body;
					try{
						// non-IE
						var contentDocument = elem.contentDocument;
						if("designMode" in contentDocument && contentDocument.designMode == "on"){
							return true;
						}
						body = contentDocument.body;
					}catch(e1){
						// contentWindow.document isn't accessible within IE7/8
						// if the iframe.src points to a foreign url and this
						// page contains an element, that could get focus
						try{
							body = elem.contentWindow.document.body;
						}catch(e2){
							return false;
						}
					}
					return body && (body.contentEditable == 'true' ||
						(body.firstChild && body.firstChild.contentEditable == 'true'));
				default:
					return elem.contentEditable == 'true';
			}
		},

		effectiveTabIndex: function(/*Element*/ elem){
			// summary:
			//		Returns effective tabIndex of an element, either a number, or undefined if element isn't focusable.

			if(domAttr.get(elem, "disabled")){
				return undefined;
			}else if(domAttr.has(elem, "tabIndex")){
				// Explicit tab index setting
				return +domAttr.get(elem, "tabIndex");// + to convert string --> number
			}else{
				// No explicit tabIndex setting, so depends on node type
				return a11y.hasDefaultTabStop(elem) ? 0 : undefined;
			}
		},

		isTabNavigable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is tab-navigable

			return a11y.effectiveTabIndex(elem) >= 0;
		},

		isFocusable: function(/*Element*/ elem){
			// summary:
			//		Tests if an element is focusable by tabbing to it, or clicking it with the mouse.

			return a11y.effectiveTabIndex(elem) >= -1;
		},

		_getTabNavigable: function(/*DOMNode*/ root){
			// summary:
			//		Finds descendants of the specified root node.
			// description:
			//		Finds the following descendants of the specified root node:
			//
			//		- the first tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the last tab-navigable element in document order
			//		  without a tabIndex or with tabIndex="0"
			//		- the first element in document order with the lowest
			//		  positive tabIndex value
			//		- the last element in document order with the highest
			//		  positive tabIndex value
			var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

			function radioName(node){
				// If this element is part of a radio button group, return the name for that group.
				return node && node.tagName.toLowerCase() == "input" &&
					node.type && node.type.toLowerCase() == "radio" &&
					node.name && node.name.toLowerCase();
			}

			var shown = a11y._isElementShown, effectiveTabIndex = a11y.effectiveTabIndex;
			var walkTree = function(/*DOMNode*/ parent){
				for(var child = parent.firstChild; child; child = child.nextSibling){
					// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
					// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
					if(child.nodeType != 1 || (has("ie") <= 9 && child.scopeName !== "HTML") || !shown(child)){
						continue;
					}

					var tabindex = effectiveTabIndex(child);
					if(tabindex >= 0){
						if(tabindex == 0){
							if(!first){
								first = child;
							}
							last = child;
						}else if(tabindex > 0){
							if(!lowest || tabindex < lowestTabindex){
								lowestTabindex = tabindex;
								lowest = child;
							}
							if(!highest || tabindex >= highestTabindex){
								highestTabindex = tabindex;
								highest = child;
							}
						}
						var rn = radioName(child);
						if(domAttr.get(child, "checked") && rn){
							radioSelected[rn] = child;
						}
					}
					if(child.nodeName.toUpperCase() != 'SELECT'){
						walkTree(child);
					}
				}
			};
			if(shown(root)){
				walkTree(root);
			}
			function rs(node){
				// substitute checked radio button for unchecked one, if there is a checked one with the same name.
				return radioSelected[radioName(node)] || node;
			}

			return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
		},

		getFirstInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is first in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.lowest ? elems.lowest : elems.first; // DomNode
		},

		getLastInTabbingOrder: function(/*String|DOMNode*/ root, /*Document?*/ doc){
			// summary:
			//		Finds the descendant of the specified root node
			//		that is last in the tabbing order
			var elems = a11y._getTabNavigable(dom.byId(root, doc));
			return elems.last ? elems.last : elems.highest; // DomNode
		}
	};

	 1  && lang.mixin(dijit, a11y);

	return a11y;
});

},
'dijit/form/TextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/sniff", // has("ie") has("mozilla")
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	"../main"	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, on, has,
			_FormValueWidget, _TextBoxMixin, template, dijit){

	// module:
	//		dijit/form/TextBox

	var TextBox = declare("dijit.form.TextBox" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie") < 9){
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the defer gives IE a chance to render the TextBox and to deal with font inheritance
				this.defer(function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
					 shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				});
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				this._phspan = domConstruct.create('span', {
					// dijitInputField class gives placeHolder same padding as the input field
					// parent node already has dijitInputField class but it doesn't affect this <span>
					// since it's position: absolute.
					className: 'dijitPlaceHolder dijitInputField'
				}, this.textbox, 'after');
				this.own(
					on(this._phspan, "mousedown", function(evt){ evt.preventDefault(); }),
					on(this._phspan, "touchend, pointerup, MSPointerUp", lang.hitch(this, function(){
						// If the user clicks placeholder rather than the <input>, need programmatic focus.  Normally this
						// is done in _FormWidgetMixin._onFocus() but after [30663] it's done on a delay, which is ineffective.
						this.focus();
					}))
				);
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(this._phspan.ownerDocument.createTextNode(v));
			this._updatePlaceHolder();
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Called AFTER the input event has happened
			//		See if the placeHolder text should be removed or added while editing.
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display = (this.placeHolder && !this.textbox.value) ? "" : "none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use get('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();

			if(has("mozilla")){
				if(this.selectOnClick){
					// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie") < 9){
		TextBox.prototype._isTextSelected = function(){
			var range = this.ownerDocument.selection.createRange();
			var parent = range.parentElement();
			return parent == this.textbox && range.text.length > 0;
		};

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}

	if(has("dojo-bidi")){
		TextBox = declare("dijit.form.TextBox", TextBox, {
			_setPlaceHolderAttr: function(v){
				this.inherited(arguments);
				this.applyTextDir(this._phspan);
			}
		});
	}

	return TextBox;
});

},
'dijit/layout/StackContainer':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.some
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct",
	"dojo/has", //  1 
	"dojo/_base/lang", // lang.extend
	"dojo/on",
	"dojo/ready",
	"dojo/topic", // publish
	"dojo/when",
	"../registry", // registry.byId
	"../_WidgetBase",
	"./_LayoutWidget"
], function(array, cookie, declare, domClass, domConstruct, has, lang, on, ready, topic, when, registry, _WidgetBase, _LayoutWidget){

	// module:
	//		dijit/layout/StackContainer

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/layout/StackController"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var StackContainer = declare("dijit.layout.StackContainer", _LayoutWidget, {
		// summary:
		//		A container that has multiple children, but shows only
		//		one child at a time
		//
		// description:
		//		A container for widgets (ContentPanes, for example) That displays
		//		only one Widget at a time.
		//
		//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
		//
		//		Can be base class for container, Wizard, Show, etc.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `StackContainer`.

		// doLayout: Boolean
		//		If true, change the size of my currently displayed child to match my size
		doLayout: true,

		// persist: Boolean
		//		Remembers the selected child across sessions
		persist: false,

		baseClass: "dijitStackContainer",

		/*=====
		// selectedChildWidget: [readonly] dijit._Widget
		//		References the currently selected child widget, if any.
		//		Adjust selected child with selectChild() method.
		selectedChildWidget: null,
		=====*/

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitLayoutContainer");
		},

		postCreate: function(){
			this.inherited(arguments);
			this.own(
				on(this.domNode, "keydown", lang.hitch(this, "_onKeyDown"))
			);
		},

		startup: function(){
			if(this._started){
				return;
			}

			var children = this.getChildren();

			// Setup each page panel to be initially hidden
			array.forEach(children, this._setupChild, this);

			// Figure out which child to initially display, defaulting to first one
			if(this.persist){
				this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
			}else{
				array.some(children, function(child){
					if(child.selected){
						this.selectedChildWidget = child;
					}
					return child.selected;
				}, this);
			}
			var selected = this.selectedChildWidget;
			if(!selected && children[0]){
				selected = this.selectedChildWidget = children[0];
				selected.selected = true;
			}

			// Publish information about myself so any StackControllers can initialize.
			// This needs to happen before this.inherited(arguments) so that for
			// TabContainer, this._contentBox doesn't include the space for the tab labels.
			topic.publish(this.id + "-startup", {children: children, selected: selected, textDir: this.textDir});

			// Startup each child widget, and do initial layout like setting this._contentBox,
			// then calls this.resize() which does the initial sizing on the selected child.
			this.inherited(arguments);
		},

		resize: function(){
			// Overrides _LayoutWidget.resize()
			// Resize is called when we are first made visible (it's called from startup()
			// if we are initially visible). If this is the first time we've been made
			// visible then show our first child.
			if(!this._hasBeenShown){
				this._hasBeenShown = true;
				var selected = this.selectedChildWidget;
				if(selected){
					this._showChild(selected);
				}
			}
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _LayoutWidget._setupChild()
			
			var childNode = child.domNode,
				wrapper = domConstruct.place(
					"<div role='tabpanel' class='" + this.baseClass + "ChildWrapper dijitHidden'>",
					child.domNode,
					"replace"),
				label = child["aria-label"] || child.title || child.label;			 

                        /* CURAM-FIX rtc231858 fix for rtc -203938 */
                        var tabPanelWrapper = wrapper.parentElement;
                        if(tabPanelWrapper && tabPanelWrapper.parentElement)
                        {
                            var tablistId = tabPanelWrapper.parentElement.id + "_tablist";
                            var tablist = dojo.byId(tablistId);
                            if (tablist && tablist.style.height.trim() == "0px"){
                                wrapper.removeAttribute("role");
                            }
                        } 
                        /* CURAM-FIX rtc231858 fix for rtc -203938 */
			if(label){
				// setAttribute() escapes special chars, and if() statement avoids setting aria-label="undefined"
				wrapper.setAttribute("aria-label", label);
			}
			domConstruct.place(childNode, wrapper);
			child._wrapper = wrapper;	// to set the aria-labelledby in StackController

			this.inherited(arguments);

			// child may have style="display: none" (at least our test cases do), so remove that
			if(childNode.style.display == "none"){
				childNode.style.display = "block";
			}

			// remove the title attribute so it doesn't show up when i hover over a node
			child.domNode.removeAttribute("title");
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to do layout and publish events

			this.inherited(arguments);

			if(this._started){
				topic.publish(this.id + "-addChild", child, insertIndex);	// publish

				// in case the tab titles have overflowed from one line to two lines
				// (or, if this if first child, from zero lines to one line)
				// TODO: w/ScrollingTabController this is no longer necessary, although
				// ScrollTabController.resize() does need to get called to show/hide
				// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild().
				// If this is updated to not layout [except for initial child added / last child removed], update
				// "childless startup" test in StackContainer.html to check for no resize event after second addChild()
				this.layout();

				// if this is the first child, then select it
				if(!this.selectedChildWidget){
					this.selectChild(child);
				}
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ page){
			// Overrides _Container.removeChild() to do layout and publish events

			var idx = array.indexOf(this.getChildren(), page);

			this.inherited(arguments);

			// Remove the child widget wrapper we use to set aria roles.  This won't affect the page itself since it's
			// already been detached from page._wrapper via the this.inherited(arguments) call above.
			domConstruct.destroy(page._wrapper);
			delete page._wrapper;

			if(this._started){
				// This will notify any tablists to remove a button; do this first because it may affect sizing.
				topic.publish(this.id + "-removeChild", page);
			}

			// If all our children are being destroyed than don't run the code below (to select another page),
			// because we are deleting every page one by one
			if(this._descendantsBeingDestroyed){
				return;
			}

			// Select new page to display, also updating TabController to show the respective tab.
			// Do this before layout call because it can affect the height of the TabController.
			if(this.selectedChildWidget === page){
				this.selectedChildWidget = undefined;
				if(this._started){
					var children = this.getChildren();
					if(children.length){
						this.selectChild(children[Math.max(idx - 1, 0)]);
					}
				}
			}

			if(this._started){
				// In case the tab titles now take up one line instead of two lines
				// (note though that ScrollingTabController never overflows to multiple lines),
				// or the height has changed slightly because of addition/removal of tab which close icon
				this.layout();
			}
		},

		selectChild: function(/*dijit/_WidgetBase|String*/ page, /*Boolean*/ animate){
			// summary:
			//		Show the given widget (which must be one of my children)
			// page:
			//		Reference to child widget or id of child widget

			var d;

			page = registry.byId(page);

			if(this.selectedChildWidget != page){
				// Deselect old page and select new one
				d = this._transition(page, this.selectedChildWidget, animate);
				this._set("selectedChildWidget", page);
				topic.publish(this.id + "-selectChild", page, this._focused);	// publish

				if(this.persist){
					cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
				}
			 }else if(this._focused  && true == page.closable){
			    //Publish topic to update tab browser title. Condition is used when the last in page navigation is closed 
				//and it is closable.
				topic.publish(this.id + "-selectChild", page, this._focused);	// publish
			}

			// d may be null, or a scalar like true.  Return a promise in all cases
			return when(d || true);		// Promise
		},

		_transition: function(newWidget, oldWidget /*===== ,  animate =====*/){
			// summary:
			//		Hide the old widget and display the new widget.
			//		Subclasses should override this.
			// newWidget: dijit/_WidgetBase
			//		The newly selected widget.
			// oldWidget: dijit/_WidgetBase
			//		The previously selected widget.
			// animate: Boolean
			//		Used by AccordionContainer to turn on/off slide effect.
			// tags:
			//		protected extension
			if(oldWidget){
				this._hideChild(oldWidget);
			}
			var d = this._showChild(newWidget);

			// Size the new widget, in case this is the first time it's being shown,
			// or I have been resized since the last time it was shown.
			// Note that page must be visible for resizing to work.
			if(newWidget.resize){
				if(this.doLayout){
					newWidget.resize(this._containerContentBox || this._contentBox);
				}else{
					// the child should pick it's own size but we still need to call resize()
					// (with no arguments) to let the widget lay itself out
					newWidget.resize();
				}
			}

			return d;	// If child has an href, promise that fires when the child's href finishes loading
		},

		_adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Gets the next/previous child widget in this container from the current selection.

			// TODO: remove for 2.0 if this isn't being used.   Otherwise, fix to skip disabled tabs.

			var children = this.getChildren();
			var index = array.indexOf(children, this.selectedChildWidget);
			index += forward ? 1 : children.length - 1;
			return children[ index % children.length ]; // dijit/_WidgetBase
		},

		forward: function(){
			// summary:
			//		Advance to next page.
			return this.selectChild(this._adjacent(true), true);
		},

		back: function(){
			// summary:
			//		Go back to previous page.
			return this.selectChild(this._adjacent(false), true);
		},

		_onKeyDown: function(e){
			topic.publish(this.id + "-containerKeyDown", { e: e, page: this});	// publish
		},

		layout: function(){
			// Implement _LayoutWidget.layout() virtual method.
			var child = this.selectedChildWidget;
			if(child && child.resize){
				if(this.doLayout){
					child.resize(this._containerContentBox || this._contentBox);
				}else{
					child.resize();
				}
			}
		},

		_showChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
			//		it can do any updates it needs regarding loading href's etc.
			// returns:
			//		Promise that fires when page has finished showing, or true if there's no href
			var children = this.getChildren();
			page.isFirstChild = (page == children[0]);
			page.isLastChild = (page == children[children.length - 1]);
			page._set("selected", true);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitVisible", "dijitHidden");
			}

			return (page._onShow && page._onShow()) || true;
		},

		_hideChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Hide the specified child by changing it's CSS, and call _onHide() so
			//		it's notified.
			page._set("selected", false);

			if(page._wrapper){	// false if not started yet
				domClass.replace(page._wrapper, "dijitHidden", "dijitVisible");
			}

			page.onHide && page.onHide();
		},

		closeChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Callback when user clicks the [X] to remove a page.
			//		If onClose() returns true then remove and destroy the child.
			// tags:
			//		private
			var remove = page.onClose && page.onClose(this, page);
			if(remove){
				this.removeChild(page);
				// makes sure we can clean up executeScripts in ContentPane onUnLoad
				page.destroyRecursive();
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			this._descendantsBeingDestroyed = true;
			this.selectedChildWidget = undefined;
			array.forEach(this.getChildren(), function(child){
				if(!preserveDom){
					this.removeChild(child);
				}
				child.destroyRecursive(preserveDom);
			}, this);
			this._descendantsBeingDestroyed = false;
		}
	});

	StackContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a StackContainer.

		// selected: Boolean
		//		Specifies that this widget should be the initially displayed pane.
		//		Note: to change the selected child use `dijit/layout/StackContainer.selectChild`
		selected: false,

		// disabled: Boolean
		//		Specifies that the button to select this pane should be disabled.
		//		Doesn't affect programmatic selection of the pane, nor does it deselect the pane if it is currently selected.
		disabled: false,

		// closable: Boolean
		//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
		closable: false,

		// iconClass: String
		//		CSS Class specifying icon to use in label associated with this pane.
		iconClass: "dijitNoIcon",

		// showTitle: Boolean
		//		When true, display title of this widget as tab label etc., rather than just using
		//		icon specified in iconClass
		showTitle: true
	};

	// Since any widget can be specified as a StackContainer child, mix them
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ StackContainer.ChildWidgetProperties);

	return StackContainer;
});

},
'curam/util/external':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

  /*
   * Modification History
   * --------------------
   * 25-Mar-2014 MV  [CR00423311] Initial version.  
   */
define(['curam/util'
        ], function(util) {
  
  /**
   * @name curam.util.external
   * @namespace Contains functions of general use for the external application
   *    container.
   */
  curam.define.singleton("curam.util.external",
  /**
   * @lends curam.util.external.prototype
   */
  {
    /**
     * Determines whether we are running within an external application
     * container or not.
     * 
     * @return True if we are in external app container, otherwise false.
     */
    inExternalApp: function() {
      return jsScreenContext.hasContextBits("EXTAPP");
    },
    
    /**
     * Determines the iframe to be used as parent for a UIM modal dialog.
     * 
     * @returns iframe or null.
     */
    getUimParentWindow: function() {
      if (util.getTopmostWindow() === dojo.global) {
        return null;

      } else {
        return dojo.global;
      }
    }
  });

  return curam.util.external;
});

},
'curam/modal/CuramBaseModal':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2020, 2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 11-Nov-2022 BD [SPM125872] Adding publish to setfocusHandler. 
   * 30-May-2021 LS [RTC278070] Edge-Chromium: Initial focus not setting properly in dialogs
   * 12-May-2022 BOS [RTC277988] Unmask correct value for date picker on error in modal.
   * 15-Oct-2021 SO [RTC274016] Fix for Unnecessary scrollbars in dialogs(removed inline height)
   * 14-Oct-2021 LS  [RTC274151] Focus doesn't start in right place when modal in modal
   * 10-Sep-2021 TD  [RTC273411] Reverse underscore name change to methods
   * 02-Sep-2021 SK  [RTC273131] corrected the _displaySpinner method because of the Progress Widget internal
   *                 naming changes (to satisfy the Intern tests).
   * 11-Aug-2011 SK  [RTC272800] Progress Spinner related changes.
   * 15-Jun-2021 SK  Minor changes in logging to prevent memory picture distortion
   * by the DevTools (direct object dumps).
   * 18-May-2021 FN  [RTC265093] Fixed issue in IE11 where error messages content would not be
   *                             announced when tabbing to error messages list. Updated also _setFocusHandler.
   * 19-Feb-2021 BOS  [RTC268393] Refactoring for tabbing backwards and forwards.
   * 29-Jan-2021 BOS  [RTC267873] Dismiss modal in separate function.
   * 02-Dec-2020 BOS  [RTC266982] Initial version. Re-factored code from ModalDialog.js
   */
define(["dojo/text!curam/layout/resources/CuramBaseModal.html",
		"dojo/_base/declare",
        "dojo/dom-geometry",
        "dojo/Deferred", // Deferred
        "dojo/on",
        "dojo/query",
        "dojo/_base/lang", // lang.mixin lang.hitch
        "dojo/_base/fx", // fx.fadeIn fx.fadeOut
        "dojo/window",
        "dojo/sniff",
        "dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-construct",
        "dojo/aspect",
        "dijit/Dialog",
        "curam/inspection/Layer",
        "curam/util/external",
        "curam/dialog",
        "curam/tab",
        "curam/debug",
        "curam/ModalUIMController",
        "curam/widget/ProgressSpinner",
        "curam/util/RuntimeContext"], function(template, declare, domGeom, Deferred, on, query, lang, fx,
          winUtils, has, dom, domAttr, domStyle, domClass, domConstruct, asp, Dialog, layer, external,
          dialog, tab, debug, modalUIMController, progressWidget) {
	
	var CuramBaseModal = declare("curam.modal.CuramBaseModal", null,
			 
			  
		  /** @lends curam.modal.CuramBaseModal.prototype */ {

		  templateString: template,

		  /**
		   * Disable setting focus to the first editable field - it will never work
		   * as we have all the content within an iframe.
		   */
		  autofocus: false,

		  /**
		   * Do not refocus the item focused before the dialog was opened.
		   */
		  refocus: false,

		  iframeHref: "",
		  iframe: undefined,
		  width: undefined,
		  height: undefined,
		  defaultWidth: 800,

		  /**
		   * This text is hidden, but is picked up by a screen reader.
		   */
		  closeModalText: LOCALISED_MODAL_CLOSE_BUTTON,
		  
		  /**
		   * This text contains the image source path of the default close image.
		   */
		  buttonCloseIcon: MODAL_CLOSE_BUTTON_ICON,

		  /**
		   * This text contains the image source path of the hover close image.
		   */
		  buttonCloseIconHover: MODAL_CLOSE_BUTTON_ICON_HOVER,
		  
		  /**
		    * Adding hidden text to prompt screen reader user regarding usage of
		    * the modal dialog: "Press the TAB key to activate the modal". Note the
		    * full stops have been added to the text to force screen reader to pause
		    * before giving the instruction.
		    */
		  modalPromptText: ". " + LOCALISED_MODAL_SCREEN_READER_PROMPT + " .",

		  /**
		   * Max width based on the available space minus some margin
		   * for dialog border, etc.
		   * @private
		   */
		  maximumWidth: null,

		  /**
		   * Max height based on the available space minus some margin
		   * for dialog title, border, etc.
		   * @private
		   */
		  maximumHeight: null,
		  // modalMinimumHeight is read from
		  // ApplicationConfiguration.properties

		  /**
		   * The calculated width.
		   * @private
		   */
		  _determinedWidth: null,

		  /**
		   * The calculated height.
		   * @private
		   */
		  _determinedHeight: null,

		  /**
		   * Horizontal space value used to prevent large modal dialogs to fill up the 
		   * whole application viewport.
		   *
		   * @private
		   */
		  _horizontalModalSpace: 100,
		  
		  /**
		   * Vertical space value used to prevent large modal dialogs to fill up the 
		   * whole application viewport.
		   *
		   * @private
		   */
		  _verticalModalSpace: 100,
		  
		  duration: 5,
		  parentWindow: undefined,
		  isRegisteredForClosing: false,
		  unsubscribes: undefined,
		  modalconnects: undefined,
		  onIframeLoadHandler: undefined,
		  initialized: false,
		  initDone: false,
		  initUnsubToken: null,
		  uimController: null,
		  _helpIcon: null,
		  _title:null,

		  /**
		   * Indicates if the modal dialog is being accessed from a mobile device. It is
		   * used in conjunction with the _isMobileUADialogPositioned variable below to
		   * control mobile specific behaviour. 
		   *
		   * @private
		   */
		  _isMobileUA: false,
		  
		  /**
		   * Indicates if this dialog has already been positioned. On mobile devices the
		   * dialog will be positioned (in the center of the screen) only once.
		   * Otherwise, if the user uses the "zoom and pan" capibilities of a tablet,
		   * the dialog keeps re-positioning to the "center" of the document and you can
		   * not pan around the dialog contents.
		   *
		   * @private.
		   */
		  _isMobileUADialogPositioned: false,

		  /**
		   * The uim token is only used in conjunction with the UimDialg API. It is
		   * used to return the dialogId for the open dialog.
		   */
		  uimToken: undefined,
		  
		  postCreate: function() {
		    this.initModal(arguments);
		  },
		  

		  initModal: function(arguments) {
		    curam.debug.log("curam.modal.CuramBaseModal.postCreate(): w=%s; h=%s",
		        this.width?this.width:"not given", this.height?this.height:"not given");

		    // destroy any old modals
		    this._destroyOldModals();

		    // AppController.jspx sets this variable on the "top" window.
		    // Cache it locally to prevent getTopmostWindow being called every time
		    // _position() is called.
		    var topmost = curam.util.getTopmostWindow();
		    if (topmost.curam.config) {
		      this._isMobileUA =
		        topmost.curam.config.mobileUserAgent;  
		    }

		    // Set _verticalModalSpace to 100 if internal app or 50 if external app. Needs 100 for internal app due to curam styling.
		    if(topmost && topmost.jsScreenContext) {
		      this._verticalModalSpace = 100;
		      if(topmost.jsScreenContext.hasContextBits("EXTAPP")) {
		        this._verticalModalSpace = 50;
		        curam.debug.log("curam.modal.CuramBaseModal.postCreate(): Detected external app, setting _verticalModalSpace to "
		            + this._verticalModalSpace);
		      }
		    }

		    if (typeof(this._isMobileUA) != 'boolean') {
		      // An additional safety check in case something goes wrong in
		      // AppController.jspx. Want to make sure this defaults to a boolean and
		      // not "undefined".
		      this._isMobileUA = false;
		    }
		    
		    // Disable dragging on mobile devices.
		    this.draggable = !this._isMobileUA; 
		    
		    // Dojo 1.8 introduced a maxRatio value into the Dialog.js.
		    // This value ensures a Dialog window is never bigger than 90% of the available
		    // viewport, adding a scroll bar if it is.
		    // This throws off our dimension calculations, causing double scroll bars to
		    // appear. So rather than subclass the Dialog.js, have adjusted our spacings here.
		    var maxRatio = 0.9;

		    // get these values anew for each dialog instance
		    this.maximumWidth = (dijit.getViewport().w * maxRatio) - this._horizontalModalSpace;
		    this.maximumHeight = (dijit.getViewport().h * maxRatio) - this._verticalModalSpace;
		    if (jsScreenContext.hasContextBits("EXTAPP")) {
		      // OneUI dialogs in the external app need an additional buffer on top
		      // of "_verticalModalSpace" as they have larger title bars etc. then our
		      // internal dialogs.
		      this.maximumHeight -= this._verticalModalSpace;
		    }
		    
		    this.inherited(arguments);
		    this.unsubscribes = [];
		    this.modalconnects = [];
		    
		    // All infrastructure modals (e.g. date picker) are stored in this location.
		    // This flag is then used in various conditions in this class. 
		    this._isCDEJModal =
		      (this.iframeHref.indexOf("CDEJ/popups") > -1
		       || this.iframeHref.indexOf("frequency-editor.jsp") > -1);

		    // set the dialog to be hidden initially
		    if (jsScreenContext.hasContextBits("EXTAPP")) {
	    	  domStyle.set(this.domNode, "top", "1px");
			  domStyle.set(this.domNode, "display", "");
			  domStyle.set(this.domNode, "opacity", "0");

			  domClass.add(this.domNode, "modalDialog");
		   }
		  
		    this._initParentWindowRef();
		    if (this.parentWindow) {
		      curam.dialog.pushOntoDialogHierarchy(this.parentWindow);
		    } else {
		      curam.dialog.pushOntoDialogHierarchy(curam.util.getTopmostWindow());
		    }

		    this.unsubscribes.push(this.subscribe("/dnd/move/start",
		        dojo.hitch(this, this._startDrag)));

		    // remove 'overlay' element once dragging event ends
		    this.unsubscribes.push(this.subscribe("/dnd/move/stop", function() {
		      var ovr = dojo.query(".overlay-iframe")[0];
		      if (ovr) {
		        domConstruct.destroy(ovr);
		      }
		    }));

		    this._registerInitListener();

		    // Handle removing this window from the dialog hierarchy when the page
		    // is unloaded.
		    var subscribeTokenUnload = dojo.subscribe("/curam/dialog/iframeUnloaded", this, function(dialogId, targetWin) {
		        if (this.id == dialogId) {
		          curam.debug
		            .log(debug.getProperty("curam.ModalDialog.unload"), dialogId);
		          curam.dialog.removeFromDialogHierarchy(targetWin);

		          // make sure the init event from the next page will be heard
		          this.initDone = false;
		          this._registerInitListener();
		        }
		      });
		    this.unsubscribes.push(subscribeTokenUnload);

		    // subscribe for onLoad events on the iframe
		    var onLoadInitHandler = dojo.hitch(this, function(iframeId, context) {
		      curam.debug.log(debug.getProperty("curam.ModalDialog.load.init"), iframeId);

		      // remove the no longer needed handler
		      curam.util.onLoad.removeSubscriber(
		          this._getEventIdentifier(), onLoadInitHandler);

		      curam.dialog.pushOntoDialogHierarchy(this.iframe.contentWindow);

		      this._determineSize(context);
		   
		      if (!this.isRegisteredForClosing) {
		        var topmostWindow = curam.util.getTopmostWindow();
		        this.unsubscribes.push(topmostWindow.dojo.subscribe(
		            "/curam/dialog/close", this, function(dialogId) {
		              if (this.id == dialogId) {
		                curam.debug.log("/curam/dialog/close " 
		                  + debug.getProperty("curam.ModalDialog.event.for"), 
		                    dialogId);
		                this.hide();
		              }
		            }));

		        this.isRegisteredForClosing = true;
		      }

		      this.doShow(context);
		      this._notifyModalDisplayed();
		    });
		    curam.util.onLoad.addSubscriber(this._getEventIdentifier(), onLoadInitHandler);
		    // these modals will frequently open on the top of other modals and might
		    // have focusing issues, hence forcing the focus.
		    if (this._isCDEJModal) {
		      curam.util.onLoad.addSubscriber(this._getEventIdentifier(), function(iframeId, context){
		        var iframe = dom.byId(iframeId);
		        if (iframe) {
		          iframe.focus();
		          iframe.contentWindow.focusFirst && iframe.contentWindow.focusFirst();
		      }
		      });
		    }
		    
		    var isFirstLoad = true;
		    this.onLoadSubsequentHandler = dojo.hitch(this, function(iframeId, context) {
		      if (isFirstLoad) {
		        // skip the first load as it is being handled by the above handler
		        isFirstLoad = false;

		      } else {
		        curam.debug.log(debug.getProperty("curam.ModalDialog.load"), iframeId);
		        if (!context.modalClosing) {
		          curam.dialog.pushOntoDialogHierarchy(this.iframe.contentWindow);

		          this._determineSize(context);
		          // Set position anew - the original y coordinate was calculated from
		          // the previous height, which may have changed, causing the bottom
		          // of the dialog off the viewport.
		          this._position(true);
		          this.doShow(context);
		          this._notifyModalDisplayed();

		        } else {
		          curam.debug.log(debug.getProperty("curam.ModalDialog.close"));
		        }
		      }

		      var iframe = dom.byId(iframeId);
		      var pageTitle = iframe.contentWindow.document.title;
		      iframe.setAttribute("title", LOCALISED_MODAL_FRAME_TITLE + " - " + pageTitle);
		    });
		    curam.util.onLoad.addSubscriber(this._getEventIdentifier(), this.onLoadSubsequentHandler);

		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/iframeFailedToLoad", this,
		      function(dialogId) {
		        if (this.id == dialogId) {
		          curam.util.onLoad.removeSubscriber(
		              this._getEventIdentifier(), onLoadInitHandler);
		          this._determineSize({ height: 450, title: 'Error!' });
		          this.doShow();
		          this._notifyModalDisplayed();
		        }
		    }));

		    // set focus on modal displayed
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/displayed", this, this._setFocusHandler));

		    // notify external API on modal displayed
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/displayed", this, function(dialogId) {
		          if (dialogId == this.id) {
		            curam.util.getTopmostWindow().dojo.publish(
		                "/curam/dialog/AfterDisplay", [ dialogId ]);
		          }
		        }));

		    // Only allow opening further modals once we are fully displayed.
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/displayed", this, function() {
		          curam.util._setModalCurrentlyOpening(false);
		        }));

		    var isAbsoluteUrl = function(inputUrl) {
		      return inputUrl.indexOf(":") > 0;
		    };
		    var fullUrl = isAbsoluteUrl(this.iframeHref) ? this.iframeHref
		        : this._getBaseUrl(curam.util.getTopmostWindow().location.href) + jsL
		          + "/" + this.iframeHref;

		    this.uimController = new modalUIMController({
		      uid:this.id,
		      url: fullUrl,
		      loadFrameOnCreate: false,
		      inDialog: true,
		      iframeId:this._getEventIdentifier(),
		      width: this._calculateWidth(this.width) + "px",
		      height: this.maximumHeight + "px"
		    });
		    layer.register("curam/modal/CuramBaseModal", this);
		    

		    // TODO: can all references to this.iframe simply be updated to be
		    // "this.uimController.getIFrame()"
		    curam.debug.log("DEBUG: ModalDialog.js:postCreate(): uimController: "
		        + this.uimController);
		    this.iframe = this.uimController.getIFrame();
		    curam.debug.log("DEBUG: ModalDialog.js:postCreate(): uimController.domNode: "
		        + this.uimController.domNode);

		    this.modalconnects.push(
		          dojo.connect(this, "onHide", this, this._onHideHandler));

		    this.set("content", this.uimController.domNode);

		    // mark the iframe node with a specific class to later identify events
		    // coming from it
		    domClass.add(this.iframe, this._getEventIdentifier());

		    // The following code makes sure that the active dialog has a specific class
		    // in its iframe element so that it can be recognized by automated tools.
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/displayed", this, this._modalDisplayedHandler));
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		        "/curam/dialog/closed", this, this._modalClosedHandler));
		    
		    // spinner request listener
		    this.unsubscribes.push(curam.util.getTopmostWindow().dojo.subscribe(
		            "/curam/dialog/spinner", this._displaySpinner(this)));

		    // report an event when the page fails to load
		    this._registerOnIframeLoad(dojo.hitch(this, this._loadErrorHandler));
		    
		    // now start loading the content
		    this.uimController.loadPage();
		  },

		  _displaySpinner: function(canvas) {
			var a1 = asp.before(this, "_loadErrorHandler", function() {
	          curam.util.getTopmostWindow().dojo.publish('curam/progress/unload');
	          a1.remove();
            });
			var a2 = asp.after(progressWidget, "dismissSpinner", function() {
              a1 && a1.remove();
              a2 && a2.remove();
            });
			curam.util.getTopmostWindow().dojo.publish('/curam/progress/display', [canvas.containerNode, 100]);
	      },
		  
		  
		  /* COPY_PASTE_CUSTOMIZATION
		   * Override the hide method to comment out the call to this:
		   *    
		   *    this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));
		   * 
		   * as this asynchronous task was never finishing and thus the method
		   * being hitched to was never called. So we just make the call to
		   * lang.hitch(this, 'onHide') directly.
		   */
		  hide: function(){
		    // summary:
		    //              Hide the dialog
		    // returns: dojo/promise/Promise
		    //    Promise object that resolves when the display animation is complete
		    // If we haven't been initialized yet then we aren't showing and we can just return.
		    // Likewise if we are already hidden, or are currently fading out.
		  if(!this._alreadyInitialized || !this.open) {
		      return;
		    }
		    if(this._fadeInDeferred){
		      this._fadeInDeferred.cancel();
		    }

		    // fade-in Animation object, setup below
		    var fadeOut = dojo.fadeOut({
		      node: this.domNode,
		      duration: this.duration,
		      onEnd: dojo.hitch(this, function() {                    
		            this.domNode.style.display = "none";
		            dijit.Dialog._DialogLevelManager.hide(this);
		            this._fadeOutDeferred.resolve(true);
		            delete this._fadeOutDeferred;
		          })
		    });
		    
		    this._fadeOutDeferred = new Deferred(dojo.hitch(this, function() {
		      fadeOut.stop();
		      delete this._fadeOutDeferred;            
		    }));

		    // If delay is 0, code above will delete this._fadeOutDeferred instantly, so grab promise while we can.
		    var promise = this._fadeOutDeferred.promise;

		    // fire onHide when the promise resolves.
		    //>>> comment out.
		    //this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));  
		    //>>> end comment out.
		    
		    //>>> addition.
		    dojo.hitch(this, 'onHide')();
		    //>>> end addition.

		    fadeOut.play();
		       
		    if(this._scrollConnected){
		      this._scrollConnected = false;
		    }
		    var h;
		    while(h = this._modalconnects.pop()){
		      h.remove();
		    }

		    if(this._relativePosition){
		      delete this._relativePosition;
		    }

		    this._set("open", false);

		    return promise;
		},

		  /**
		   * Returns the URL striped of the last path element and the query string.
		   */
		  _getBaseUrl: function(inputUrl) {
		    var queryIndex = inputUrl.indexOf('?');
		    inputUrl = (queryIndex > -1) ? inputUrl.substring(0, queryIndex) : inputUrl;
		    var lastSlashIdx = inputUrl.lastIndexOf("/");
		    return inputUrl.substring(0, lastSlashIdx + 1);
		  },

		  /**
		   * Adds the help icon to the modal dialog title bar.
		   *
		   * @param context
		   *    The UIM page context object.
		   */
		  _setupHelpIcon: function(context) {
		    // In some scenarios the context will not be passed at all.
		    // The code below handles this case.
		    var enable = typeof context != "undefined"
		        ? context.helpEnabled : false,
		      extension = enable ? context.helpExtension : "",
		      pageId = enable ? context.pageID : "",
		      // closeIcon is queried with the modal's ID to avoid misplacement of HelpIcon
		      closeIcon = dojo.query(".modalDialog#"+this.id+" .dijitDialogCloseIcon");
		    for (var i=0; i<closeIcon.length; i++) {
		      if (enable && !this._helpIcon) {
		        this._helpIcon = this._createHelpIcon(
		            "dijitDialogHelpIcon", "dijitDialogHelpIcon-hover",
		            extension, closeIcon[i]);

		        
		        this._helpIcon.setAttribute("role", "button");
		        // Set to be hidden initially so a screenreader doesn't announce it before it's revealed.
		        this._helpIcon.setAttribute("style", "visibility: hidden;");
		        this._setTabIndex(this._helpIcon, "0");
		        // this._helpIcon.setAttribute("onKeyDown", "curam.util.isShiftTab(event)");
		        // use this.connect() so that the handler is removed when dialog closes
		        this.connect(this._helpIcon, "onkeydown", function(event) {
		          this.handleTabbingBackwards(dojo.fixEvent(event));
		        });
		        
		        this._helpIcon._enabled = false;
		      }
		      this._setTabIndex(closeIcon[i], "0");
		    }

		    if (enable && this._helpIcon) {
		      this._helpIcon._pageID = pageId;
		    }

		    // avoid unnecessary styling
		    if ((enable && this._helpIcon && this._helpIcon._enabled)
		        || (!enable || !this._helpIcon || !this._helpIcon._enabled)) {
		      return;
		    }

		    domStyle.set(this._helpIcon, "display", enable ? "" : "none");
		    this._helpIcon._enabled = enable;
		  },

		  /**
		   * Creates the help icon in the dialog title bar.
		   *
		   * @param refNode
		   *    The node before which the help icon should be placed.
		   */
		  _createHelpIcon: function(clazz, hoverClazz, extension, refNode) {
		    var icon = domConstruct.create("span", {
		        "class": clazz,
		        "waiRole": "presentation",
		        "title": LOCALISED_MODAL_HELP_TITLE
		    });

		    domConstruct.place(icon, refNode, "before");

		    this.connect(icon, "onclick", function() {
		      var locale=curam.config?curam.config.locale:jsL;
		      var url;
		      //Construct the help URL for Modal window
		      url = "./help.jsp?pageID=" + this._helpIcon._pageID;     
		      window.open(url);
		    });
		    
		    this.connect(icon, "onkeydown", function() {
		      if(curam.util.enterKeyPress(event)){
		        var locale=curam.config?curam.config.locale:jsL;
		        var url;
		        //Construct the help URL for Modal window
		        url = "./help.jsp?pageID=" + this._helpIcon._pageID;     
		        window.open(url);
		      }
		    });

		    if (hoverClazz) {
		      this.connect(icon, "onmouseover", function() {
		        domClass.add(icon, hoverClazz);
		      });

		      this.connect(icon, "onmouseout", function() {
		        domClass.remove(icon, hoverClazz);
		      });
		    }
		   
		    //create images for help icon
		    var helpIcon = domConstruct.create("img", {
		      "src": MODAL_HELP_BUTTON_ICON,
		      "alt": LOCALISED_MODAL_HELP_ALT,
		      "class": "button-help-icon-default"
		    });

		    var helpHoverIcon = domConstruct.create("img", {
		      "src": MODAL_HELP_BUTTON_ICON_HOVER,
		      "alt": LOCALISED_MODAL_HELP_ALT,
		      "class": "button-help-icon-hover"
		    });

		    domConstruct.place(helpIcon, icon);
		    domConstruct.place(helpHoverIcon, icon);
		  
		    return icon;
		  },

		  _registerInitListener: function() {
		    if (!this.initUnsubToken) {
		      this.initUnsubToken = dojo.subscribe("/curam/dialog/init", this,
		        function() {
		          // notify the external API of the dialog ID
		          dojo.publish("/curam/dialog/SetId", [ this.id ]);
		          this.initDone = true;

		          // also notify the external UimDialog API passing back the dialogID
		          if(this.uimToken) {
		            dojo.publish("/curam/dialog/uim/opened/" + this.uimToken, [ this.id ]);
		          }
		          dojo.unsubscribe(this.initUnsubToken);
		          this.initUnsubToken = false;
		        });
		    }
		  },

		  _getEventIdentifier: function() {
		    return "iframe-" + this.id;
		  },

		  _registerOnIframeLoad: function(handler) {
		    if (dojo.isIE && dojo.isIE < 9) {
		      this.onIframeLoadHandler = dojo.hitch(this, function() {
		        if (typeof this.iframe != "undefined"
		            && typeof this.iframe.readyState != "undefined"
		            && this.iframe.readyState == "complete") {
		          handler();
		        }
		      });
		      this.iframe.attachEvent('onreadystatechange', this.onIframeLoadHandler);

		    } else {
		      this.modalconnects.push(
		          dojo.connect(this.iframe, "onload", this, handler));
		    }
		  },

		  /**
		   * Called before dragging the Dialog.
		   * @private
		   */
		  _startDrag: function(mover) {
		    if (!this.iframe) {
		      return;
		    }
		    if(mover && mover.node && mover.node === this.domNode){

		      // add an 'overlay' element on top of iframe to prevent iframe from
		      // interfering with drag event
		      var overLayDiv = domConstruct.create("div", {"class": "overlay-iframe"});
		      overLayDiv.innerHTML = "";
		      domConstruct.place(overLayDiv, this.iframe, "before");

		      var size = domGeom.getContentBox(this.containerNode, 
		          domStyle.getComputedStyle(this.containerNode));

		      domStyle.set(overLayDiv, {
		        width: size.w + "px",
		        height: size.h + "px"
		      });

		      var windowSize = domGeom.getMarginBoxSimple(dijit._underlay.domNode);

		      var limits = {
		        l: windowSize.w - size.w - 10,
		        t: windowSize.h - size.h - 30
		      };

		      // Override the onMove function on the _moveable object
		      // to limit the position of the dialog to within the
		      // browser frame, and not go outside the window.
		      this._moveable.onMove = function(mover, leftTop, e){
		        leftTop.l = Math.max(5, Math.min(leftTop.l, limits.l));
		        leftTop.t = Math.max(5, Math.min(leftTop.t, limits.t));

		        dojo.dnd.Moveable.prototype.onMove.apply(this, [mover, leftTop, e]);
		    };
		  }
		  },

		  _loadErrorHandler: function() {
			  curam.debug
		      .log(debug.getProperty("curam.ModalDialog.onload.notify") + this.iframe.id);
		    if (!this.initDone) {
		      dojo.unsubscribe(this.initUnsubToken);
		      curam.debug.log(debug.getProperty("curam.ModalDialog.firing") 
		          + " /curam/dialog/iframeFailedToLoad " 
		          + debug.getProperty("curam.ModalDialog.for"), this.id);
		      curam.util.getTopmostWindow().dojo.publish(
		          "/curam/dialog/iframeFailedToLoad", [this.id]);

		    } else {
		      curam.debug.log("UIM " 
		        + debug.getProperty("curam.ModalDialog.onload.success"));
		    }

		    // Set browser tab title
		    if(this.iframe
		        && this.iframe.contentWindow
		        && this.iframe.contentWindow.document
		        && this.iframe.contentWindow.document.title) {
		      curam.debug.log("curam.modal.CuramBaseModal._loadErrorHandler calling curam.util.setBrowserTabTitle");
		      curam.util.setBrowserTabTitle(this.iframe.contentWindow.document.title);
		    }
		  },

		  /**
		   * Called on the dialog display time, sets the initial focus appropriately.
		   * @private
		   */
		  _setFocusHandler: function(dialogId) {
		    if (dialogId == this.id && this.initDone) {
		      curam.debug.log("curam.modal.CuramBaseModal_setFocusHandler(): " 
		        + debug.getProperty("curam.ModalDialog.execute"), dialogId);
		      var frameWin = this.iframe.contentWindow;
              var that=this;
              var setFocusTimeout;
		   		
  			 if(frameWin.document.getElementsByClassName("skeleton").length>0){			   
              setFocusTimeout=setTimeout(function (){that._setFocusHandler(dialogId);},300);            
			}else{
			  frameWin.dojo.publish("curam/modal/component/ready");
			  if(setFocusTimeout){
				clearTimeout(setFocusTimeout);
			  }
             if (typeof frameWin.dijit == "object"
		          && typeof frameWin.dijit.focus == "function") {
		        frameWin.dijit.focus(this.iframe);
		      } else {
		        this.iframe.focus();
		      }
		      
		      var errorMessage;
		      dojo.withDoc(this.iframe.contentWindow.document, function() {
		        errorMessage = dojo.byId('error-messages');
		          
		        // NOTE: This is only necessary when dates incorrectly entered manually
		        // If correctly formatted this unmasking is not needed as error won't occur
	            // unmask the correct date picker values on error message
                var topWindow = window.curam.util.getTopmostWindow();
                if (errorMessage && topWindow.curam.__datePickerIds) {
                  var datePickerIds = topWindow.curam.__datePickerIds;
		          for (var i = 0; i < datePickerIds.length; i++) {
		            var datePickerId = datePickerIds[i];
		            var datePicker = dojo.byId(datePickerId);
		            if (datePicker) {
		              datePicker.nextElementSibling.focus();
		              datePicker.focus();  
		            }    
		          }
		          topWindow.curam.__datePickerIds = undefined;     
		        }
		      });
		      
		      var curamDefaultActionId = sessionStorage.getItem('curamDefaultActionId');
		      var focusField = null;
		      if (!errorMessage && curamDefaultActionId) {
		        sessionStorage.removeItem('curamDefaultActionId');
		        dojo.withDoc(this.iframe.contentWindow.document, function() {
		          if (dojo.byId(curamDefaultActionId)) {
		            focusField = dojo.byId(curamDefaultActionId).previousSibling;
		          } else {
		            focusField = frameWin.curam.util.doSetFocus();
		          }
		        });
		        
		      } else {
		        focusField = frameWin.curam.util.doSetFocus();
		        // if no focus field and there is a function to check for primary button 
		        // on view modal available,  then do so
		        if (!focusField && this.checkPrimaryButtonOnViewModal && typeof this.checkPrimaryButtonOnViewModal === "function") {
		          focusField = this.checkPrimaryButtonOnViewModal();
		        }
		      }
		      
		      if (focusField) {
          
					if (has('trident') || window.navigator.userAgent.indexOf("Edg/") > -1 || has('ie')) {
							// Creating a visually hidden input and focussing on that initially before focussing on the
							// actual focusField helps the screenreader switch to forms mode for the appropriate fields in IE11.
							// This is destroyed as soon as focus leaves the field.
							var mainForm = focusField.ownerDocument.forms['mainForm'];
							// IE and Edge specific flag where the timeouts can be suppressed.
							var suppressFocusTimeout = false;
							if(sessionStorage.getItem("suppressCuramModalFocusTimeout") && sessionStorage.getItem("suppressCuramModalFocusTimeout") === "true") {
									suppressFocusTimeout = true;
							}
						
							// Only create the hidden input for fields that require forms mode to be automatically switched on.
							if (mainForm && (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && domAttr.get(focusField, "type") === "text"))) {
								// Visually hide the input field.
								var hiddenInput = domConstruct.create("input", 
																	{"class": "hidden-focus-input", 
																	 "style": "position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap;", 
																	 "type": "text", 
																	 "aria-hidden": "true", 
																	 "tabindex": "-1"});
								domConstruct.place(hiddenInput, mainForm, "before");
								hiddenInput.focus();
								on(hiddenInput, 'blur', function(){domConstruct.destroy(hiddenInput)});
							}
							
							var fnFocus = function(ff){
								return function() {
		
									var currentNode = ff.ownerDocument.activeElement;
									// do nothing if already focused on a form element
									if (currentNode.tagName === 'INPUT' && !currentNode.classList.contains('hidden-focus-input') 
											|| currentNode.tagName === 'TEXTAREA'
											|| (currentNode.tagName === 'LABEL' && currentNode.className == 'fileUploadButton')
											|| (currentNode.tagName === 'A' && currentNode.className == 'popup-action')
											|| (currentNode.tagName === 'IFRAME' && currentNode.classList.contains('cke_wysiwyg_frame'))) {
										return;
									} else {
										ff.focus();
									}
								
								} 
							};
							var ownAria = domAttr.get(focusField, 'aria-label');
							var localizedTitle = "";
							// Cases for combo boxes where a subcomponent value is dependent on its main component's (component) selected value.
							// Both components have ojbid attributes respectively set as "component" and "subComponent".
							// Added case for stand-alone combo box.
							var componentObjId = domAttr.get(focusField,"objid");
							if (componentObjId && componentObjId.indexOf("component") == 0
									|| domClass.contains(focusField,"dijitReset dijitInputInner")){
								localizedTitle = focusField.title;
							} else {
								localizedTitle = LOCALISED_MODAL_FRAME_TITLE
																	 || 'Modal Dialog';
							}

                            // Prevent aria-label with localizedTitle from being added to error-messages as it prevents the screen reader
                            //from announcing the contents of the error messages list.
                            if (focusField && focusField.id !== "container-messages-ul") {
                              domAttr.set(focusField, 'aria-label', localizedTitle);
                            }

							var restorer = function(oldAria) {
								return function(e) {
									query('input|select[aria-label=' + localizedTitle + ']')
										.forEach(function(entry) {
										oldAria && domAttr.set(entry, 'aria-label', oldAria);
										!oldAria && domAttr.remove(entry, 'aria-label');
										});
								}
							}
							on(focusField, 'blur', restorer(ownAria));
							
							// Only fields that require user interaction need a delay in focus.
							// E.g text input fields, textareas, comboboxes.
							if (!suppressFocusTimeout && focusField.tagName === 'TEXTAREA'){
								setTimeout(fnFocus(focusField), 1000);
							} else if (!suppressFocusTimeout && (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && domAttr.get(focusField, "type") === "text"))) {
								setTimeout(fnFocus(focusField), 200);
							} else {
								focusField.focus();
							}
						} else {
							focusField.focus();
						}
						// Putting this outside of IE/Edge specific block as this flag can be set
						// in custom JS scripts for individual UIMs and can be set regardless of 
						// what browser is being used.
						if(sessionStorage.getItem("suppressCuramModalFocusTimeout")){
							sessionStorage.removeItem("suppressCuramModalFocusTimeout")
						}
					} /* else there are no editable fields
							 - leave focus on the dialog body */
		   }
           }
		  },

		  _modalDisplayedHandler: function(dialogId) {
		    if (dialogId == this.id) {
		      // this dialog is open, mark as active
		      curam.debug.log(debug.getProperty("curam.ModalDialog.dialog.open.1") 
		          + "("  + this.id + ")" 
		          + debug.getProperty("curam.ModalDialog.dialog.open.2"));
		      this._markAsActiveDialog(true);

		    } else {
		      // some other dialog has opened, deactivate this one if it hasn't
		      // been done before
		      if (!this.deactivatedBy) {
		        curam.debug.log(
		          debug.getProperty("curam.ModalDialog.dialog.deactivating.1") 
		           + "("  + this.id + ")," 
		           + debug.getProperty("curam.ModalDialog.dialog.deactivating.2"), 
		             dialogId);
		        this._markAsActiveDialog(false);
		        // only remember the first dialog that de-activated us -
		        // that gives the immediate child and will correctly activate
		        // this dialog when that child closes
		        this.deactivatedBy = dialogId;
		      }
		    }
		  },

		  _modalClosedHandler: function(dialogId) { 
		    if (this.deactivatedBy == dialogId) {
		      curam.debug.log(
		          debug.getProperty("curam.ModalDialog.dialog.activating.1") 
		           + "("  + this.id + ")," 
		           + debug.getProperty("curam.ModalDialog.dialog.activating.2"), 
		             dialogId);
		      this._markAsActiveDialog(true);
		      delete this.deactivatedBy;
		    }

		    // Set appropriate browser tab title based on the now-visible page
		    curam.debug.log("curam.modal.CuramBaseModal._modalClosedHandler calling curam.util.setBrowserTabTitle");
		    curam.util.setBrowserTabTitle();
		  },

		  _destroyOldModals: function() {
		    
		    if (!curam.dialog.oldModalsToDestroy) {
		      curam.dialog.oldModalsToDestroy = [];
		    }
		    dojo.forEach(curam.dialog.oldModalsToDestroy, function(oldModal) {
		      oldModal._cleanupIframe();
		      oldModal.destroyRecursive();
		    });
		    curam.dialog.oldModalsToDestroy = [];
		  },

		  _initParentWindowRef: function() {
		    if (!this.parentWindow) {
		      var parent = null;
		      if (curam.tab.inTabbedUI()) {
		        // we are in tabbed UI, use the active tab content iframe
		        parent = curam.tab.getContentPanelIframe();

		      } else if (external.inExternalApp()) {
		        // we are in the external application, try to get parent UIM iframe
		        parent = external.getUimParentWindow();
		      }
		      // else - unable to get, this is valid for example in ext app fragment
		      // scenarios

		      // if the parentWindow is not provided, the modal is being opened
		      // from the menu bar or shortcut panel. The parent will be the content
		      // panel iframe, if that is loaded, or null
		      if (parent) {
		        this.parentWindow = parent.contentWindow;

		      }

		    } else {
		      // Check if the parent window is the details panel
		      if (domClass.contains(this.parentWindow.frameElement, "detailsPanelFrame")) {
		        // use the main content panel URL as RPU
		        var contentPanel = curam.tab.getContentPanelIframe();
		        var rpuUrl = curam.util.getLastPathSegmentWithQueryString(
		            contentPanel.src);
		        // strip the __o3rpu parameter form the RPU value
		        rpuUrl = curam.util.removeUrlParam(rpuUrl, "__o3rpu");
		        curam.debug.log("o3rpu " 
		          + debug.getProperty("curam.ModalDialog.property"), 
		            encodeURIComponent(rpuUrl));

		        // Change the o3rpu to be the content panel href
		        this.iframeHref = curam.util.replaceUrlParam(this.iframeHref, "__o3rpu",
		            encodeURIComponent(rpuUrl));

		        // Change parent window to be the content panel
		        this.parentWindow = contentPanel.contentWindow;
		      }
		    }
		  },

		  _notifyModalDisplayed: function() {
		    curam.debug.log(debug.getProperty("curam.ModalDialog.publishing") 
		      + " /curam/dialog/displayed " 
		      + debug.getProperty("curam.ModalDialog.for"), this.id);
		    curam.util.getTopmostWindow().dojo.publish(
		        "/curam/dialog/displayed",
		        [ this.id, { width: this._determinedWidth,
		                     height: this._determinedHeight } ]);
		  },

		  _markAsActiveDialog: function(active) {
		    var activeDialogClassName = "curam-active-modal";
		    if (active) {
		      domClass.add(this.iframe, activeDialogClassName);
		      curam.debug.log(debug
		        .getProperty("curam.ModalDialog.add.class"), 
		          [this.id, this.iframeHref]);

		    } else {
		      domClass.remove(this.iframe, activeDialogClassName);
		      curam.debug.log(debug
		        .getProperty("curam.ModalDialog.remove.class"), 
		          [this.id, this.iframe.src]);
		    }
		    
		  },

		  _setHrefAttr:function(href) {
		    curam.debug.log("setHrefAttr");
		    this.iframeHref = href;

		    this.inherited(arguments);
		  },

		  _setTabIndex:function(iframe, tabIndex) {
		    iframe.setAttribute("tabIndex", tabIndex);
		  },

		  _position: function(force) {
		    curam.debug.log(debug.getProperty("curam.ModalDialog.position"));
		    if (this._isMobileUADialogPositioned == false && (this.open || force)) {
		      this.inherited(arguments);
		      if(this._isMobileUA == true) {
		        // Pn mobile devices, this flag prevents further positioning.
		        this._isMobileUADialogPositioned = true; 
		      }
		    } else {
		      curam.debug.log(debug.getProperty("curam.ModalDialog.ignoring") 
		        + " curam.ModalDialog_position");
		    }
		  },
		  
		  /**
		   * Gets the units for height or width of modal.
		   */
		  _getUnits: function() {
		     return 'px';
		  },

		  /**
		   * Applies default width if no value is specified and max width in case
		   * there is not enough space.
		   */
		  _calculateWidth: function(specifiedWidth) {
		    if (specifiedWidth) {
		      // convert, in case it is a string
		      specifiedWidth = new Number(specifiedWidth);
		      // G11N_MODAL_DIALOG_ADJUSTMENT_FACTOR is conditionally generated by
		      // JavaScriptUserPreferencesTag.java when dialog width needs to be
		      // automatically adjusted.
		      if (!this._isCDEJModal
		          && typeof(G11N_MODAL_DIALOG_ADJUSTMENT_FACTOR) != "undefined") {
		        specifiedWidth *= G11N_MODAL_DIALOG_ADJUSTMENT_FACTOR;
		      }
		      if (specifiedWidth > this.maximumWidth) {
		        curam.debug.log(debug
		          .getProperty("curam.ModalDialog.specified.width.over"), 
		            this.maximumWidth);
		        return this.maximumWidth;

		      } else {
		        // using "floor" incase the calculation above produces a floating
		        // point number.
		        return Math.floor(specifiedWidth);
		      }

		    } else {
		      // store this in a local varaible because we may have to make an
		      // adjustment, which we do not want to "persist" on the class.
		      var localDefaultWidth = this.defaultWidth;
		      if (!this._isCDEJModal
		          && typeof(G11N_MODAL_DIALOG_ADJUSTMENT_FACTOR) != "undefined") {
		        localDefaultWidth *= G11N_MODAL_DIALOG_ADJUSTMENT_FACTOR;
		      }
		      curam.debug.log(debug.getProperty("curam.ModalDialog.default.width"), 
		                      localDefaultWidth);
		      if (localDefaultWidth > this.maximumWidth) {
		        curam.debug.log(debug
		          .getProperty("curam.ModalDialog.default.width.over"), 
		            this.maximumWidth);
		        return this.maximumWidth;

		      } else {
		        // using "floor" incase the calculation above produces a floating
		        // point number.
		        return Math.floor(localDefaultWidth);
		      }
		    }
		  },

		  /**
		   * Applies calculated height if no value is specified. Also observes
		   * maximum allowed height in case there is not enough space.
		   */
		  _calculateHeight: function(specifiedHeight, calculatedHeight) {
		    if (specifiedHeight) {
		      specifiedHeight = isNaN(specifiedHeight) ? new Number(specifiedHeight)
		                                  : specifiedHeight; // convert, in case it is a string
		      if (specifiedHeight > this.maximumHeight) {
		        curam.debug.log("specified height exceeds available space, "
		            + "overriding with max available height of ", this.maximumHeight);
		        return this.maximumHeight;
		      } else if (specifiedHeight < this.modalMinimumHeight) {
		         curam.debug.log(debug
		           .getProperty("curam.ModalDialog.specified.height.over.1"), 
		           this.modalMinimumHeight);
		         return this.modalMinimumHeight;
		      } else {
		        return specifiedHeight;
		      }
		    } else {
		      curam.debug.log(debug
		        .getProperty("curam.ModalDialog.no.height"), calculatedHeight);
		      if (calculatedHeight > this.maximumHeight) {
		        curam.debug.log(debug
		          .getProperty("curam.ModalDialog.calculated.height.over.1"), 
		            this.maximumHeight);
		        return this.maximumHeight;

		      }else if (calculatedHeight < this.modalMinimumHeight) {
		         curam.debug.log(debug
		           .getProperty("curam.ModalDialog.calculated.height.over.2"), 
		           this.modalMinimumHeight);
		         return this.modalMinimumHeight;
		      } else {
		        return calculatedHeight;
		      }
		    }
		  },

		  _determineSize: function (context) {
		    var calculatedHeight = context.height;
		    var pageLevelOptions = context.windowOptions;
		    curam.debug.log(debug.getProperty("curam.ModalDialog.size"));
		    try {
		      // TODO: use calculatedHeight from event only if no fixed size, etc.

		      // first read the link-level window options
			  var w = this._calculateWidth(this.width);
		      var h = this._calculateHeight(this.height, calculatedHeight);

		      // now try to read the page-level window options
		      if (pageLevelOptions) {
		        // if any page level options are specified, use the page-level only,
		        // overriding link-level completely
		        if (pageLevelOptions["width"] || pageLevelOptions["height"]) {
		          curam.debug.log(debug.getProperty("curam.ModalDialog.options"));
		          w = this._calculateWidth(pageLevelOptions["width"]);
		          h = this._calculateHeight(pageLevelOptions["height"], calculatedHeight);
		        }
		      }
		      w = w + this._getUnits();
	          h = h + this._getUnits();
		      curam.debug.log("curam.ModalDialog:_determineSize() %s x %s", w, h);

		      // resize the UIM controller
		      if (jsScreenContext.hasContextBits("EXTAPP")) {
		          this.uimController.setDimensionsForModalDialog(w, h, context);
		      }
		      // set the actual size values for later use by event handlers
		      this._determinedWidth = w;
		      this._determinedHeight = h;

		      this.setTitle(context, w);

		    } catch(e) {
		      curam.debug.log("curam.ModalDialog:_determineSize() : " 
		        + debug.getProperty("curam.ModalDialog.error") + dojo.toJson(e));
		    }
		  },

		  setTitle: function (context, titleBarLength) {

		    // local title related variables
		    var title = context.title;
		    if (!title) {
		      curam.debug.log("curam.ModalDialog.setTitle() - " 
		        + debug.getProperty("curam.ModalDialog.no.title"));
		      title = "";
		    }
		    var appendedErrorText = context.messageTitleAppend;

		    curam.debug.log("curam.ModalDialog.setTitle('%s')", title);

		    // search for appended error text
		    var textFound = title.indexOf(appendedErrorText);

		    // if the appended error text is found, hide the text from the user using
		    // CSS (to allow it to remain visible to screen readers)
		    if(textFound != -1) {
		      var messageSpan =
		        domConstruct.create("span",
		          { innerHTML: appendedErrorText, "class": "messagesPresent" });

		      // update title string to encorporate span element
		      title =
		        title.split(appendedErrorText).join(
		          "<span class=\"messagesPresent\" aria-owns=\"error-messages-container-wrapper\" role=\"alert\"></span>");
		    }

		    this.titleNode.innerHTML = title;
		    domStyle.set(this.titleBar,{width: titleBarLength+"px", height: 21+"px"});
		    domStyle.set(this.titleNode,"width",Math.ceil(titleBarLength * .85)+"px");
		  },

		  doShow: function(context) {
		    curam.debug.log("curam.ModalDialog.doShow(): " 
		      + debug.getProperty("curam.ModalDialog.show"));

		    if(!this.initialized) {
		      this.initialized = true;
		    }

		    this._setupHelpIcon(context);

		    this.show();
		    
		    //dismiss any potential spinners still! ongoing
		    this.dismissModalSpinner();
		    
		    if (jsScreenContext.hasContextBits("EXTAPP")) {
		      var closeIcon = dojo.query(".modalDialog#"+this.id+" .dijitDialogCloseIcon");
		      domStyle.set(closeIcon[0], "visibility", "visible");
		      domStyle.set(dom.byId("end-"+this.id), "visibility", "visible");
		      domStyle.set(this.iframe, "visibility", "visible");
		      domStyle.set(this.domNode, "visibility", "visible");
		      if(this._helpIcon){
		        domStyle.set(this._helpIcon, "visibility", "visible");
		      }
		    }
		    
			},
			
		  /**
		   * Dismiss spinner.
		   */
		  dismissModalSpinner: function() {
            dojo.publish('/curam/progress/unload');
		  },

		  /**
		   * Performs the necessary cleanup on dialog close.
		   */
		  _onHideHandler: function() {
		    curam.util.getTopmostWindow().dojo.publish(
		        "/curam/dialog/BeforeClose", [ this.id ]);

		    // hide immediately to avoid flicker
		    domStyle.set(this.domNode, {
		      visibility: "hidden",
		      display: "block"
		    });

		    
		    curam.dialog.removeFromDialogHierarchy(this.iframe.contentWindow);
		    curam.dialog.removeFromDialogHierarchy(this.parentWindow);

		    var topmostWin = curam.util.getTopmostWindow();
		    topmostWin.dojo.publish("/curam/dialog/closed", [this.id]);

		    dojo.unsubscribe(this.initUnsubToken);
		    dojo.forEach(this.unsubscribes, topmostWin.dojo.unsubscribe);
		    this.unsubscribes = [];

		    dojo.forEach(this.modalconnects, dojo.disconnect);
		    this.modalconnects = [];

		    if (dojo.isIE && dojo.isIE < 9) {
		      this.iframe.detachEvent('onreadystatechange', this.onIframeLoadHandler);
		    }

		    curam.util.onLoad.removeSubscriber(
		        this._getEventIdentifier(), this.onLoadSubsequentHandler);

		    if (this._explodeNode && this._explodeNode.parentNode) {
		      this._explodeNode.parentNode.removeChild(this._explodeNode);
		    }
		    curam.debug
		      .log(debug.getProperty("curam.ModalDialog.deactivating", [this.id]));
		    
		    topmostWin.dojo.publish(
		              "/curam/dialog/close/appExitConfirmation", [this.id]);
		      
		    this._markAsActiveDialog(false);

		    // give focus back to iframe for device independence.
		    if (typeof this.parentWindow != "undefined" && this.parentWindow != null) {
		      this.parentWindow.focus();
		    }

		    // cleanup window references
		    delete this.parentWindow;

		    // make sure we release iframe content - avoid memory leaks
		    domAttr.set(this.iframe, "src", "");
		    
		    // Remove an objects stored in session storage for that modal
		    sessionStorage.removeItem("firstPageHitAfterModalOpened");

		    // Postpone destroying the modal to later, because doing so now would also
		    // remove the underlay. That is a problem in cases when multiple modals
		    // are open, you close the top one and you end up with the parent modal
		    // still open, but the rest of the viewport is now accessible
		    // (not grayed-out).
		    curam.dialog.oldModalsToDestroy.push(this);
		  },
		  
		  /**
           * When using tab navigation the focus should go from the end of modal
           * to the help or close icon in the title bar at the top, whichever is first
           * This is called from a onfocus event at the end of modal.
           */
		  handleTabbingForwards: function(e, targetNode) {
		      if (!tabbingBackwards) {
                if (targetNode) {
                  setTimeout(function() { targetNode.focus(); }, 1);
                } 
		      }
		      tabbingBackwards = null;
		    },
		    
		   /**
            * Catches SHIFT + TAB keyboard event on modal help and close icon.
            * When tabbing backward, once visible button is encountered in the 
            * modal title bar the focus is looped back to the last button in 
            * the modal button bar.
            */  
		    handleTabbingBackwards: function(e, helpIconID, endOfModalID) {
		      if(e.shiftKey && e.keyCode == 9) {
                var elem,
                evt = e ? e : window.event;
                if (evt.srcElement) {
                  elem = evt.srcElement;
                } else if (evt.target){
                  elem = evt.target;
       
                } else {
                  throw new Error("handleTabbingBackwards(): No target element found.");
                }
                
                var carbonHelpIconEnabled = helpIconID && (elem.previousElementSibling.id == helpIconID) && this.helpIconEnabled;
                   
                if (elem.previousSibling.className == "dijitDialogHelpIcon" || carbonHelpIconEnabled) {
                 return false;
       
                } else {
                  var modalID = endOfModalID ? endOfModalID : elem.parentElement.parentElement.id;
                  var endModal = document.getElementById(modalID);
                  if (endModal) {
                     tabbingBackwards = true;
                     endModal.focus();
                  }
                }
              }
		    },
		  
		  /**
		   * This will be called when dialog itself is destroyed.
		   * We used to do it in the _onHideHandler() function, but postponing to later
		   * prevents IE9 from garbage collecting iframe prematurely and throwing
		   * errors.
		   */
		  _cleanupIframe: function() {
		    // get rid of the the iframe
		    // remove from the modal
		    delete this.content;
		    delete this.uimController;
		    var ifrm = this.iframe;
		    // clear the iframe contents
		    ifrm.src = "";
		    // clear the iframe reference
		    delete this.iframe;
		    // destroy the node itself
		    domConstruct.destroy(ifrm);
		  }
		  });
	return CuramBaseModal;
	  });
},
'curam/util/Navigation':function(){
/**
 * @name curam.util.Navigation
 * @namespace Provides the ability to navigate pages in Curam application.
 */
define(["curam/util",
        "curam/tab",
        "curam/define"
        ], function() {
  
/*
 * Modification History
 * --------------------
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 */
 
curam.define.singleton("curam.util.Navigation",
/**
 * @lends curam.util.Navigation.prototype
 */
{
  /**
   * Navigates to the specified page.
   *
   * @param {String} pageId ID of the required UIM page.
   * @param {Object} pageParameters Page parameters to be used when loading
   *                      the required page. The following format is expected:
   *                      <code>{ param1Name:"value", param2Name:248 }</code>
   *                      The infrastructure handles URL-encoding the values
   *                      so do NOT encode them yourself.
   */
  goToPage: function(pageId, pageParameters) {
    var url = pageId + "Page.do"
        + curam.util.makeQueryString(pageParameters);

    curam.util.Navigation.goToUrl(url);
  },
  
  /**
   * Navigates to a page in Curam application based on the specified URL.
   * 
   * @param {String} fullUrl URL of the required page, excluding the locale
   *    prefix. Sample: <code>Person_homePage.do?id=101</code>
   */
  goToUrl: function(fullUrl) {
    curam.tab.getTabController().processURL(fullUrl);
  }
});

return curam.util.Navigation;
});

},
'curam/util/RuntimeContext':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare'
        ], function(declare) {

/*
 * Modification History
 * --------------------
 * 02-Aug-2011  MV  [CR00283023] Added the contextObject() function.
 * 21-Jun-2011  KW  [CR00275353] Initial version.
 */

/**
 * @name curam.util.RuntimeContext
 * @namespace Provides access to the browser Window object.
 * 
   */
  var RuntimeContext = declare("curam.util.RuntimeContext", null, {

  /**
   * @private
   */
  _window: null,

  /**
   * comments to follow
   *
   * @constructor
   * @private
   */
  constructor: function(window) {
    this._window = window;
  },
  
  /**
   * Comments to follow
   * 
   */
  getHref: function(){
    return this._window.location.href;
  },
  
  /**
   * Returns the path name of the url from the window's location object.
   * @Returns {String} Url path name.
   */
  getPathName: function() {
    return this._window.location.pathName;
  },

  /**
   * Returns the underlying context object of this runtime context.
   * @returns The underlying context object of this runtime context.
   */
  contextObject: function() {
    return this._window;
  }
  });
  
  return RuntimeContext;
});

},
'curam/util/ui/form/renderer/GenericRendererFormEventsAdapter':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022
 *
 */
define(["dojo/_base/declare", "curam/define"], function(declare) {

	/*
	 * Modification History
	 * --------------------
	 * 14-oct-2022  BD [SPM125943] Initial version.
	 */

	/**
	 * 
	 */


	var GenericRendererFormEventsAdapter = declare("curam.util.ui.form.renderer.GenericRendererFormEventsAdapter", null,
      /** @lends curam.util.ui.form.renderer.GenericRendererFormEventsAdapter */ {

			elementID: "",

			pathID: "",

			element: "",

			constructor: function(id, pathID) {
				this.elementID = id;
				this.pathID = pathID;
				this.element = document.getElementById(id);
			},

			addChangeListener: function(callbackForOnChangeEvent) {
				this.element.addEventListener('change', callbackForOnChangeEvent, this.getFormElement());
			},

			getElementID: function() {
				return this.elementID;
			},

			getFormElement: function() {
				return this.element;
			},

			setFormElementValue: function(value) {
				this.element.value = value;
			},

			getFormElementValue: function() {
				return this.getFormElement().value;
			},

		});

	return GenericRendererFormEventsAdapter;
});
},
'dijit/form/_FormWidgetMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/sniff", // has("webkit")
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"    // a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, on, has, winUtils, a11y){

	// module:
	//		dijit/form/_FormWidgetMixin

	return declare("dijit.form._FormWidgetMixin", null, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		// name: [const] String
		//		Name used when submitting form; same as "name" attribute or plain HTML elements
		name: "",

		// alt: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		alt: "",

		// value: String
		//		Corresponds to the native HTML `<input>` element's attribute.
		value: "",

		// type: [const] String
		//		Corresponds to the native HTML `<input>` element's attribute.
		type: "text",

		// type: String
		//		Apply aria-label in markup to the widget's focusNode
		"aria-label": "focusNode",

		// tabIndex: String
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		_setTabIndexAttr: "focusNode", // force copy even when tabIndex default value, needed since Button is <span>

		// disabled: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "disabled='disabled'", or just "disabled".
		disabled: false,

		// intermediateChanges: Boolean
		//		Fires onChange for each value change or only on demand
		intermediateChanges: false,

		// scrollOnFocus: Boolean
		//		On focus, should this widget scroll into view?
		scrollOnFocus: true,

		// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
		// works with screen reader
		_setIdAttr: "focusNode",

		_setDisabledAttr: function(/*Boolean*/ value){
			this._set("disabled", value);

			// Set disabled property if focusNode is an <input>, but aria-disabled attribute if focusNode is a <span>.
			// Can't use "disabled" in this.focusNode as a test because on IE, that's true for all nodes.
			if(/^(button|input|select|textarea|optgroup|option|fieldset)$/i.test(this.focusNode.tagName)){
				domAttr.set(this.focusNode, 'disabled', value);
			}else{
				this.focusNode.setAttribute("aria-disabled", value ? "true" : "false");
			}

			// And also set disabled on the hidden <input> node
			if(this.valueNode){
				domAttr.set(this.valueNode, 'disabled', value);
			}

			if(value){
				// reset these, because after the domNode is disabled, we can no longer receive
				// mouse related events, see #4200
				this._set("hovering", false);
				this._set("active", false);

				// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
				var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
					("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
				array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
					var node = this[attachPointName];
					// complex code because tabIndex=-1 on a <div> doesn't work on FF
					if(has("webkit") || a11y.hasDefaultTabStop(node)){    // see #11064 about webkit bug
						node.setAttribute('tabIndex', "-1");
					}else{
						node.removeAttribute('tabIndex');
					}
				}, this);
			}else{
				if(this.tabIndex != ""){
					this.set('tabIndex', this.tabIndex);
				}
			}
		},

		_onFocus: function(/*String*/ by){
			// If user clicks on the widget, even if the mouse is released outside of it,
			// this widget's focusNode should get focus (to mimic native browser behavior).
			// Browsers often need help to make sure the focus via mouse actually gets to the focusNode.
			// TODO: consider removing all of this for 2.0 or sooner, see #16622 etc.
			if(by == "mouse" && this.isFocusable()){
				// IE exhibits strange scrolling behavior when refocusing a node so only do it when !focused.
				var focusHandle = this.own(on(this.focusNode, "focus", function(){
					mouseUpHandle.remove();
					focusHandle.remove();
				}))[0];
				// Set a global event to handle mouseup, so it fires properly
				// even if the cursor leaves this.domNode before the mouse up event.
				var event = has("pointer-events") ? "pointerup" : has("MSPointer") ? "MSPointerUp" :
					has("touch-events") ? "touchend, mouseup" :		// seems like overkill but see #16622, #16725
					"mouseup";
				var mouseUpHandle = this.own(on(this.ownerDocumentBody, event, lang.hitch(this, function(evt){
					mouseUpHandle.remove();
					focusHandle.remove();
					// if here, then the mousedown did not focus the focusNode as the default action
					if(this.focused){
						if(evt.type == "touchend"){
							this.defer("focus"); // native focus hasn't occurred yet
						}else{
							this.focus(); // native focus already occurred on mousedown
						}
					}
				})))[0];
			}
			if(this.scrollOnFocus){
				this.defer(function(){
					winUtils.scrollIntoView(this.domNode);
				}); // without defer, the input caret position can change on mouse click
			}
			this.inherited(arguments);
		},

		isFocusable: function(){
			// summary:
			//		Tells if this widget is focusable or not.  Used internally by dijit.
			// tags:
			//		protected
			return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
		},

		focus: function(){
			// summary:
			//		Put focus on this widget
			if(!this.disabled && this.focusNode.focus){
				try{
					this.focusNode.focus();
				}catch(e){
				}
				/*squelch errors from hidden nodes*/
			}
		},

		compare: function(/*anything*/ val1, /*anything*/ val2){
			// summary:
			//		Compare 2 values (as returned by get('value') for this widget).
			// tags:
			//		protected
			if(typeof val1 == "number" && typeof val2 == "number"){
				return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
			}else if(val1 > val2){
				return 1;
			}else if(val1 < val2){
				return -1;
			}else{
				return 0;
			}
		},

		onChange: function(/*===== newValue =====*/){
			// summary:
			//		Callback when this widget's value is changed.
			// tags:
			//		callback
		},

		// _onChangeActive: [private] Boolean
		//		Indicates that changes to the value should call onChange() callback.
		//		This is false during widget initialization, to avoid calling onChange()
		//		when the initial value is set.
		_onChangeActive: false,

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget is set.  Calls onChange() if appropriate
			// newValue:
			//		the new value
			// priorityChange:
			//		For a slider, for example, dragging the slider is priorityChange==false,
			//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
			//		onChange is only called form priorityChange=true events.
			// tags:
			//		private
			if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
				// this block executes not for a change, but during initialization,
				// and is used to store away the original value (or for ToggleButton, the original checked state)
				this._resetValue = this._lastValueReported = newValue;
			}
			this._pendingOnChange = this._pendingOnChange
				|| (typeof newValue != typeof this._lastValueReported)
				|| (this.compare(newValue, this._lastValueReported) != 0);
			if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
				this._lastValueReported = newValue;
				this._pendingOnChange = false;
				if(this._onChangeActive){
					if(this._onChangeHandle){
						this._onChangeHandle.remove();
					}
					// defer allows hidden value processing to run and
					// also the onChange handler can safely adjust focus, etc
					this._onChangeHandle = this.defer(
						function(){
							this._onChangeHandle = null;
							this.onChange(newValue);
						}); // try to collapse multiple onChange's fired faster than can be processed
				}
			}
		},

		create: function(){
			// Overrides _Widget.create()
			this.inherited(arguments);
			this._onChangeActive = true;
		},

		destroy: function(){
			if(this._onChangeHandle){ // destroy called before last onChange has fired
				this._onChangeHandle.remove();
				this.onChange(this._lastValueReported);
			}
			this.inherited(arguments);
		}
	});
});

},
'curam/util/ContextPanel':function(){
/*
 * Copyright 2010-2015 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dijit/registry",
        "dojo/dom-attr",
        "curam/inspection/Layer",

        "curam/debug",
        "curam/util/onLoad",
        "curam/util",

        "curam/tab",
        "curam/define"], function(registry, domAttr, layer, debug, onLoad) {

/*
 * Modification History
 * --------------------
 * 08-Aug-2015  AB  [CR00465340] Avoid IE memory leaks (Adding debug statement.)
 * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
 * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 21-Oct-2012  SK  [CR00346419] Correctly unsubscribes from the onload registry
 *                               when a tab is closed.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 10-Sep-2012  MV  [CR00344216] Only subscribe one listener to tab ready event.
 * 31-Jul-2012  MV  [CR00336202] Refactor to also work in IE7.
 * 17-Jul-2012  MV  [CR00329547] Load context panel only after tab is ready.
 * 15-Dec-2011  MV [CR00299726] Synchronize initial load of panel with
 *                              subsequent refreshes. 
 * 26-Aug-2011  JK [TEC-7914]   Added title to context panel.
 * 29-Jul-2011  MV [CR00269970] Added refresh() function.
 * 20-Jan-2011  MV [CR00244126] Initial version.
 */






  
/**
 * @namespace Functions specific to the context panel.
 */
  curam.define.singleton("curam.util.ContextPanel", {
    
    /** Name of the attribute on content iframe that holds the URL of the frame
     * content. */
    CONTENT_URL_ATTRIB: "data-content-url",
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     */
    setupLoadEventPublisher: function(eventName, tabWidgetId, iframeId) {
      curam.util.ContextPanel._doSetup(eventName, tabWidgetId, iframeId,
          function(tabWidgetId) { return registry.byId(tabWidgetId); });
    },
  
    /**
     * Setup the page load handler to drive further actions after context panel
     * loads.
     *
     * @param eventName Name of the page event to listen to.
     * @param tabWidgetId Id of the tab widget.
     * @param iframeId Id of the context panel iframe.
     * @param getTab A function to get tab widget based on ID.
     */
    _doSetup: function(eventName, tabWidgetId, iframeId, getTab) {
    var unsToken = curam.util.getTopmostWindow().dojo.subscribe(
          eventName, function() {
            var tab = getTab(tabWidgetId);
            var iframe = curam.util.ContextPanel._getIframe(tab);
            
            if (iframe) {
              curam.tab.executeOnTabClose(function() {
                // make sure we release iframe content - avoid memory leaks
                var src = domAttr.get(iframe, "src");
                domAttr.set(iframe, "src", "");
                curam.debug.log("curam.util.ContextPanel: Released iframe content for " + src);
              }, tabWidgetId);

            //publish when the detailsPanel is fully loaded
              debug
                .log(debug.getProperty("curam.util.ContextPanel.loaded"));
              curam.util.getTopmostWindow().dojo.publish(
                  '/curam/frame/detailsPanelLoaded', [{ loaded: true }, tabWidgetId]);
    
              // mark the frame as loaded
              iframe._finishedLoading = true;
    
              // effect a scheduled refresh if there is one
              if (iframe._scheduledRefresh) {
                curam.util.ContextPanel.refresh(tab);
                // scheduled refresh done - reset the indicator
                iframe._scheduledRefresh = false;
              }
            }         
        });

    onLoad.addSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    
    curam.tab.unsubscribeOnTabClose(unsToken, tabWidgetId);
    curam.tab.executeOnTabClose(function() {
      onLoad.removeSubscriber(iframeId, curam.util.ContextPanel.addTitle);
    }, tabWidgetId);
  },
  
  /**
   * Refreshes the content panel of the specified tab.
   * This function is expected to be called in the top window runtime context. 
   */
  refresh: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        curam.debug.log(debug
          .getProperty("curam.util.ContextPanel.refresh.prep"));
        if (iframe._finishedLoading) {
          curam.debug.log(debug
            .getProperty("curam.util.ContextPanel.refresh"));
          // we will be reloading so reset the flag to guard against in-flight
          // refreshes interrupting
          iframe._finishedLoading = false;
          var doc =  iframe.contentDocument // W3C
                  || iframe.contentWindow.document; //IE
          // reload the context panel, but do use cached static resources 
          doc.location.reload(false);
  
        } else {
          // frame not yet loaded, delay the refresh after it has loaded fully
          curam.debug.log(debug
            .getProperty("curam.util.ContextPanel.refresh.delay"));
          iframe._scheduledRefresh = true;
        }
      }
    },
    
    /**
     * 
     * @param tab The tab to look for context panel in.
     * @returns A context panel iframe or undefined if it was not found. 
     */
    _getIframe: function(tab) {
      if (tab) {
        var frames = dojo.query("iframe.detailsPanelFrame", tab.domNode);
        return frames[0];
      }     
  },
  
  addTitle: function(iframeId) {
    var iframe = dojo.query("." + iframeId)[0];
    var pageTitle = iframe.contentWindow.document.title;
    iframe.setAttribute("title", CONTEXT_PANEL_TITLE + " - " + pageTitle);
    },
    
    /**
     * Loads the context panel content in its iframe.
     * The function gracefully handles situations where there is no context
     * panel on the tab or it has been loaded already.
     * 
     * Initially context panel iframe has no src attribute so that we can
     * control at which point in time the content is loaded.
     * 
     * @param tab The tab object to load context panel content for.
     */
    load: function(tab) {
      var iframe = curam.util.ContextPanel._getIframe(tab);
      if (iframe) {
        var source = domAttr.get(iframe,
            curam.util.ContextPanel.CONTENT_URL_ATTRIB);
        if (source && source != "undefined") {
          iframe[curam.util.ContextPanel.CONTENT_URL_ATTRIB] = undefined;
          domAttr.set(iframe, "src", source);
        }
      }
    }
  });
  
  /* Only load the context panel when the tab is setup completely.
   * This is to work around the issue in IE9 that was causing the iframe to be
   * garbage collected inadvertently.
   */
  var topWin = curam.util.getTopmostWindow();
  if (typeof topWin._curamContextPanelTabReadyListenerRegistered != "boolean") {
    topWin.dojo.subscribe(
        "/curam/application/tab/ready", null, function(newTab) {
          curam.util.ContextPanel.load(newTab);
        });
    topWin._curamContextPanelTabReadyListenerRegistered = true;
  }
  layer.register("curam/util/ContextPanel", this);

  return curam.util.ContextPanel;
});

},
'curam/widget/Menu':function(){
/*
 * Copyright 2010-2018 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dijit/Menu",
        "dojo/_base/declare",
        "dojo/dom-class",
        "curam/debug",
        "curam/util",
        "dijit/registry",
        "dojo/on",
        "dojo/_base/lang",
        "dojo/has"
        ], function(menu, declare, domClass, debug, util, registry, on, lang, has) {
  
  /*
   * Modification History
   * -------------------
   * 03-Apr-2018  SK  Changes to fix the tablet accessibility issue on iPad.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "debug.log".
   * 03-Sep-2010  MV  [CR00218766] Initial version.
   */
  
  /**
   * @name curam.widget.Menu
   * @namespace Customized dijit.Menu class that tracks the active Menu
   *                by adding a specific class to its HTML element.
   */
  var Menu = declare("curam.widget.Menu", dijit.Menu,
  /**
   * @lends curam.widget.Menu.prototype
   */
  {
    /** The name of the class that active menus will be marked with.
     * @private
     */
    _CSS_CLASS_ACTIVE_MENU: "curam-active-menu",
    
    /** Event to publish when menu is opened.
     * @private
     */
    _EVENT_OPENED: "/curam/menu/opened",
    
    /** Event to publish when menu is closed.
     * @private
     */
    _EVENT_CLOSED: "/curam/menu/closed",
    
    /**
     * Holds the internal active state indicator of this menu.
     * @private
     */
    _amIActive: false,

    //  Setting to true to fix TEC-17836. DropDown menu should recieve focus when opened by JAWS,
    //  but this is not happening. Have raised a ticket to dojo (https://bugs.dojotoolkit.org/ticket/18361)
    autoFocus: true,
    
    // changes the accepted event type to open sub-menu  
    mobContext: has("ios"),
    
    /**
     * Setup the menu to manage its active state marker class.
     */
    postCreate: function() {
      curam.debug
        .log(debug.getProperty("curam.widget.Menu.created", [this.id]));
      this.own(on(this, "Open", dojo.hitch(this, function() {
    	 curam.debug
          .log(debug.getProperty("curam.widget.Menu.opened", [this.id]));
        // notify other menus that this one is becoming active
        curam.util.getTopmostWindow().dojo.publish(
            this._EVENT_OPENED, [ this.id ]);
        
        this._markAsActive(true);
      })));
      
      var unsTokOpened = curam.util.getTopmostWindow().dojo.subscribe(
          this._EVENT_OPENED, this, function(idOpened) {
        
        debug.log(debug.getProperty("curam.widget.Menu.event",
            [this.id, this._amIActive ? "active":"passive", idOpened]));
        
        // Deactivate this menu if other one opens - this is to handle submenu
        // scenarios in which multiple menus are open at the same time, but only
        // the last one opened is "active".
        //
        if (this.id != idOpened && this._amIActive) {
          debug.log(debug.getProperty("curam.widget.Menu.deactivate"));
          
          // deactivate
          this._markAsActive(false);

          // prepare for reactivation when the other menu closes again
          var unsTokClosed = curam.util.getTopmostWindow().dojo.subscribe(
              this._EVENT_CLOSED, this, function(idClosing) {
            
            if (idClosing == idOpened) {
              debug.log(debug.getProperty("curam.widget.Menu.reactivate",
                  [idOpened, this.id]));
              
              dojo.unsubscribe(unsTokClosed);
              
              this._markAsActive(true);
            }
          });
        }
      });
      
      this.own(on(this, "Close", dojo.hitch(this, function() {
        curam.debug
          .log(debug.getProperty("curam.widget.Menu.closing", [this.id]));

        // notify other menus that this one is closing
        curam.util.getTopmostWindow().dojo.publish(
            this._EVENT_CLOSED, [ this.id ]);
        
        this._markAsActive(false);
       
        dojo.unsubscribe(unsTokOpened);
      })));

      this.inherited(arguments);
    },
    
    /**
     * Mark and unmark the menu with a specific class based on the parameter.
     * Also swaps the internal active state indicator.
     * 
     * @private
     * 
     * @param {Boolean} active If true the menu will be marked as active,
     *            if false the active menu mark will be removed.
     */
    _markAsActive: function(active) {
      if (active) {
        // mark as active
        curam.debug
          .log(debug.getProperty("curam.widget.Menu.add.class"), this.id);
        domClass.add(this.domNode, this._CSS_CLASS_ACTIVE_MENU);
      
      } else {
        // remove the active mark
        curam.debug
          .log(debug.getProperty("curam.widget.Menu.remove.class"), this.id);
        domClass.remove(this.domNode, this._CSS_CLASS_ACTIVE_MENU);
      }

      this._amIActive = active;
    },

	onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
	  if (this.passive_hover_timer){
         this.passive_hover_timer.remove();
       }
       this.focusChild(item);
       if (item.disabled){
         return false;
       }
      if (item.popup){
        this.set("selected", item);
        this.set("activated", true);
        var byKeyboard = false;
        if (this.mobContext) {
          byKeyboard = /click/.test(evt._origType || evt.type);
        } else {
          byKeyboard = /^key/.test(evt._origType || evt.type) ||
            (evt.clientX == 0 && evt.clientY == 0);	// detects accessKey like ALT+SHIFT+F, where type is "click"
        }
        this._openItemPopup(item, byKeyboard);
      } else {
        // before calling user defined handler, close hierarchy of menus
	    // and restore focus to place it was when menu was opened
        this.onExecute();
        // user defined handler for click
	    item._onClick ? item._onClick(evt) : item.onClick(evt);
      }
	}

  });
  
  return Menu;
});

},
'dijit/_BidiMixin':function(){
define([], function(){

	// module:
	//		dijit/_BidiMixin

	// UCC - constants that will be used by bidi support.
	var bidi_const = {
		LRM : '\u200E',
		LRE : '\u202A',
		PDF : '\u202C',
		RLM : '\u200f',
		RLE : '\u202B'
	};

	return {
		// summary:
		//		When has("dojo-bidi") is true, _WidgetBase will mixin this class.   It enables support for the textdir
		//		property to control text direction independently from the GUI direction.
		// description:
		//		There's a special need for displaying BIDI text in rtl direction
		//		in ltr GUI, sometimes needed auto support.
		//		In creation of widget, if it's want to activate this class,
		//		the widget should define the "textDir".

		// textDir: String
		//		Bi-directional support,	the main variable which is responsible for the direction of the text.
		//		The text direction can be different than the GUI direction by using this parameter in creation
		//		of a widget.
		//
		//		Allowed values:
		//
		//		1. "ltr"
		//		2. "rtl"
		//		3. "auto" - contextual the direction of a text defined by first strong letter.
		//
		//		By default is as the page direction.
		textDir: "",

		getTextDir: function(/*String*/ text){
			// summary:
			//		Gets the right direction of text.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.
			return this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
		},

		_checkContextual: function(text){
			// summary:
			//		Finds the first strong (directional) character, return ltr if isLatin
			//		or rtl if isBidiChar.
			// tags:
			//		private.

			// look for strong (directional) characters
			var fdc = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(text);
			// if found return the direction that defined by the character, else return widgets dir as defult.
			return fdc ? ( fdc[0] <= 'z' ? "ltr" : "rtl" ) : this.dir ? this.dir : this.isLeftToRight() ? "ltr" : "rtl";
		},

		applyTextDir: function(/*DOMNode*/ element, /*String?*/ text){
			// summary:
			//		Set element.dir according to this.textDir, assuming this.textDir has a value.
			// element:
			//		The text element to be set. Should have dir property.
			// text:
			//		If specified, and this.textDir is "auto", for calculating the right transformation
			//		Otherwise text read from element.
			// description:
			//		If textDir is ltr or rtl returns the value.
			//		If it's auto, calls to another function that responsible
			//		for checking the value, and defining the direction.
			// tags:
			//		protected.

			if(this.textDir){
				var textDir = this.textDir;
				if(textDir == "auto"){
					// convert "auto" to either "ltr" or "rtl"
					if(typeof text === "undefined"){
						// text not specified, get text from element
						var tagName = element.tagName.toLowerCase();
						text = (tagName == "input" || tagName == "textarea") ? element.value :
							element.innerText || element.textContent || "";
					}
					textDir = this._checkContextual(text);
				}

				if(element.dir != textDir){
					// set element's dir to match textDir, but not when textDir is null and not when it already matches
					element.dir = textDir;
				}
			}
		},

		enforceTextDirWithUcc: function(option, text){
			// summary:
			//		Wraps by UCC (Unicode control characters) option's text according to this.textDir
			// option:
			//		The element (`<option>`) we wrapping the text for.
			// text:
			//		The text to be wrapped.
			// description:
			//		There's a dir problem with some HTML elements. For some elements (e.g. `<option>`, `<select>`)
			//		defining the dir in different direction then the GUI orientation, won't display correctly.
			//		FF 3.6 will change the alignment of the text in option - this doesn't follow the bidi standards (static text
			//		should be aligned following GUI direction). IE8 and Opera11.10 completely ignore dir setting for `<option>`.
			//		Therefore the only solution is to use UCC (Unicode  control characters) to display the text in correct orientation.
			//		This function saves the original text value for later restoration if needed, for example if the textDir will change etc.
			if(this.textDir){
				if(option){
					option.originalText = text;
				}
				var dir = this.textDir == "auto" ? this._checkContextual(text) : this.textDir;
				return (dir == "ltr" ? bidi_const.LRE : bidi_const.RLE ) + text + bidi_const.PDF;
			}
			return text;
		},

		restoreOriginalText: function(origObj){
			// summary:
			//		Restores the text of origObj, if needed, after enforceTextDirWithUcc, e.g. set("textDir", textDir).
			// origObj:
			//		The element (`<option>`) to restore.
			// description:
			//		Sets the text of origObj to origObj.originalText, which is the original text, without the UCCs.
			//		The function than removes the originalText from origObj!
			if(origObj.originalText){
				origObj.text = origObj.originalText;
				delete origObj.originalText;
			}
			return origObj;
		},

		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			if(!this._created || this.textDir != textDir){
				this._set("textDir", textDir);
				var node = null;
				if(this.displayNode){
					node = this.displayNode;
					this.displayNode.align = this.dir == "rtl" ? "right" : "left";
				}else{
					node = this.textDirNode || this.focusNode || this.textbox;
				}
				if(node){
					this.applyTextDir(node);
				}
			}
		}
	};
});

},
'curam/util/ListSort':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2021. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/dom",
        "dojo/dom-construct",
        "dojo/dom-style",
        "dojo/dom-attr",
        "curam/util",
        "curam/debug",
        "dojo/query",
        "dojo/on",
        "dojo/sniff"
        ], function(dom, domConstruct, domStyle, domAttr, util, debug, query, on, has) {

/*
 * Modification History
 * --------------------
 * 24-Mar-2021 BD [RTC266249] Updated setPlaceholders() to include role=button when is not Edge browser.
 * 08-Mar-2021 BD [RTC268442] Updated doFocus() to check _LS.sortedCell is not null before set focus.
 * 08-Jan-2021 BD [RTC265374] Updated onblur() event to be executed only on IE browser.
 * 10-Jun-2019 CMC[RTC248565] Updated sortTable() to count rows properly.
 * 05-Jun-2019 SK [RTC248394] Accumulating output to increase performance
 *                 when sorting.
 * 30-May-2019 CM [RTC247929] Add onBlur attribute to outer span to remove aria-label.
 * 30-May-2019 CMC[RTC248215] Removed multiple aria label readings.
 * 28-May-2019 SK [RTC241554] Updates accessibility readings upon sorting.
 * 27-May-2019 CMC[RTC247929] Updated readoutUpdater to update aria-label of column with full sorted text.
 * 24-May-2019 CMC[RTC247811] Including column header on aria-label for sorted columns on IE.
 * 21-May-2019 CMC[RTC247812] Do nothing for lists with zero rows or one row.
 * 21-May-2019 CMC[RTC247809] Removed role columnheader from column header text.
 * 26-Apr-2019  SK [RTC241554] Now updating the list control accessibility readings.
 * 18-Apr-2019 JH [RTC246501] Removed tab index from tables
 * 23-Jan-2019 BD [RTC230487] Included condition in the function readoutPrep
 * to execute it only for the actual table selected. Also, included the actTbl
   as parameter.
 * 12-Nov-2018 SK [RTC230487] Reworked the code for simplified list header
 * structure to have the better readouts and focusing.
 * 05-Nov-2018 SK [RTC230487] Adjusted the sorting logic for the weak sort orders
 * with duplicates and corrected focusing issues for Chrome. 
 * 31-Oct-2018 SK [RTC230487] Adjusted list sorting for the situations where
 * the same sort orders are output for the sortable items.
 * 31-Aug-2018 SK [RTC230487] Reworked sorting and sort order reading updating
 *   logic for normal (paginated), expandable and scrollable lists.
 * 13-Jul-2018 SK [RTC230487] Added list sort order screen reader announcement
 * logic.
 * 30-Oct-2014  BOS [CR00448089] Updated makeSortable() function to resolve
 * IE11 issues.
 * 13-Oct-2014 BOS [CR00446012] Refactored the makeSortable() function to make
 * it more robust and unit testable.
 * 16-May-2014 LL [CR00430437] Changed attribute for sort order to solve the
 * "ID values must be unique" Accessibility issue [TEC-16873].
 * 27-Dec-2012  SB  [CR00357739] Added tabindex of -1 for hidden table headers
 *                  in scrollable lists.
 * 20-Jun-2012  NLH [CR00332256] Incorrect Tooltips displaying for
 *              Table Column Headings.
 * 13-Mar-2012  MV  [CR00326704] Fix sorting of non-expandable lists.
 * 29-Feb-2012  BOS [TEC-9813] Fix the issue where the tooltip text for the
 *                    sorting of a column in alist cannot be localized.
 * 30-Aug-2011  SB  TEC-7261 Rewrite getSpanTitle() function to use id instead
 *                    of title.
 * 09-Aug-2011  JY  [CR00283846] Rewrite getSpanTitle() function to fix
 *                    the sorting issue when when there are disabled links
 *                    present in the list.
 * 03-May-2011  PK  [CR00264581] Fixed sorting for scrollable lists.
 * 29-Apr-2011  MV  [CR00265362] Stop the click event to avoid side effects
 *    after clicking a row to sort it.
 * 13-Dec-2010  MV  [CR00237821] Publish pre-sort event for the list.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM event with a function that will
 *    automatically disconnect on page unload.
 * 10-May-2010 MV [CR00196066] Adapted to also work on expandable lists.
 *                 Moved to a specific namespace.
 */

  var ListSort = _LS = dojo.setObject("curam.util.ListSort", {
    LIVE:'aria-live',
    READOUT:'aria-label',
    BUSY:'aria-busy',
	SCROLLABLE:'_slh',
	EVT_SORT_PREP:'/curam/list/toBeSorted',
	EVT_SORTED:'/curam/list/sorted',
    sortableTable:null,
    sortTexts:null,
    tablesWithListeners:[],
    sorters:[],
    headingUpdaters:[],
    currentUpdater: null,
    updatesByNow:-1,
    sortedCell: null,
    cleaner:null,

  /*
   * Add links to the column headings	
   */
  makeSortable: function(tableID, paginationId, isExpandable, sortableColText, sortTexts, isScrollable) {
	  dojo.addOnLoad(function(){
      var table = dom.byId(tableID);
      if (!table) {
        return;
      }
      // all cell (table header elements) on first tr (table row element)
      var tableHeaderCells = query("tHead tr th", table);
      if (tableHeaderCells == null) {
        return;
      }

      /* Table-wide variables */
      table.ariaListeners = [];
      table.onces = [];
      _LS.sortTexts = sortTexts.split("|");      
      // Setting the iteration step through the list;
      // normally 1 but expandable lists have the main and the
      // details rows hence the optional increment of 1 for them.
      var tStep = 1 + (+isExpandable),
        body = table.tBodies[0], rw = body && body.rows,
          lRows = rw ? rw.length : false, 
            ixLastVisible = lRows ? lRows - tStep : 0;
      var reapply = function(cell, ariatext) {
        return function() {
          domAttr.set(cell, _LS.READOUT, ariatext);
        }
      },
	  getSortedText = function(currentTxt, sortedInfo) {
 	    return currentTxt + '.' + sortedInfo;
	  },
      readoutUpdater = function(cellSpan, cNum, colLabel) {
        var fnUpdate = function(pgId, colNum, sIx, orderText) {
          /* do not update irrelevant table headers! */
          if (pgId == domAttr.get(cellSpan,'paginationId')) {
            if (_LS.updatesByNow > 0) {
              var sortedText = colLabel + ' ' + sortableColText;
              var fullReadout = null;
              if (cNum == colNum) {
            	fullReadout = sortedText + '.' + orderText;
            	sortedText = getSortedText(sortedText, orderText);
                _LS.sortedCell = cellSpan;
                if (has('trident')) {
                  domAttr.set(cellSpan, _LS.READOUT, " ");
                  domAttr.set(query('span', cellSpan)[0], _LS.READOUT, sortedText);
                } else {
                  domAttr.set(cellSpan, _LS.READOUT, sortedText);
                }
              } else {
                sortedText += '.' + _LS.sortTexts[0];
                table.onces.push(reapply(cellSpan, sortedText));
                has('trident')
                  && domAttr.set(query('span', cellSpan)[0], _LS.READOUT, sortedText);
              }
              domAttr.set(cellSpan, _LS.BUSY, 'false');
            }
            if (--_LS.updatesByNow == 0) {
              _LS.doFocus(table.onces, fullReadout);
            }
          }
        };
    	fnUpdate.cleanUp = function() {
          cellSpan = null;  
        };
        return fnUpdate;
      },
      
      /**
       * Prepare the span to receive the label text and
       * sets the atributte aria-busy=true as parameter 
       * in the cell span. 
       * Only executed for the table selected.   
       */
      readoutPrep = function(tbl, cellSpan, lblTxt) {
          return function(pid,actualTbl) {
            if (tbl == actualTbl) {
              _LS.sortedCell = null;
              tbl.onces = [];
              _LS.resetReadout(cellSpan, lblTxt);
              domAttr.set(cellSpan, _LS.BUSY, 'true');
            }
          }
        };
      
      // The header cells that should be converted to links have ids.
      tableHeaderCells.forEach(function(thCell, ix) {
        if (thCell.id && thCell.childNodes[0]) {
          var cellSpan = (isScrollable ? dom.byId(thCell.id + _LS.SCROLLABLE) : thCell).childNodes[0],
                cellFirst = cellSpan.childNodes[0];
          if (cellFirst && cellFirst.nodeType == 3) {
            var labelTxt = dojo.trim(cellFirst.nodeValue);  
            if ((labelTxt.length > 0) && (labelTxt != "\u00a0")) {
              cellSpan.innerHTML = '';
              var lblSortableTxt = labelTxt + ' ' + sortableColText, 
                 initUnsortedText = lblSortableTxt + ' ' + _LS.sortTexts[0];
              domAttr.set(cellSpan, {'tabindex':'0', 'paginationid':paginationId,
                                     'aria-label':initUnsortedText, className:'listSortable'});
              if (has('trident')) {
                var lblSortableTxt = lblSortableTxt + _LS.sortTexts[0];
                domAttr.set(cellSpan, {'onblur':'_LS.updateAriaLabel(this)'});
              }
              _LS.setPlaceholders(cellSpan, labelTxt, lblSortableTxt);
              _LS.sorters.push(on(cellSpan, "click, keyup",
                dojo.partial(_LS.sortTable, table, paginationId, ix, tStep, isExpandable, ixLastVisible)));
              _LS.sorters.push(dojo.subscribe(_LS.EVT_SORT_PREP, readoutPrep(table, cellSpan, labelTxt)));
              table.ariaListeners.push(dojo.subscribe(_LS.EVT_SORTED,
            		  readoutUpdater(cellSpan, ix, labelTxt)));
            }
          }
    	}
      });
      (table.ariaListeners.length > 0) && _LS.tablesWithListeners.push(table);
      query(".hidden-table-header a").forEach(function(hiddenAnchor){
        domAttr.set(hiddenAnchor, 'tabindex', '-1');
      });
      table._sortUp = true; // The direction of the next sort
      _LS.sortableTable = table;
      _LS.cleaner = on(window, "unload", _LS.cleanUp);
	 });
  },

  /*
   * Remove the aria-label from span when focus moves away.
   */
  updateAriaLabel: function(cellSpan) {
    domAttr.remove(cellSpan, ListSort.READOUT);
  },
  
  /*
   * Clean-up the memory at the end.
   */
  cleanUp: function(){
    _LS.tablesWithListeners.forEach(function(tbl){
      tbl.ariaListeners.forEach(function(lsn){
        dojo.unsubscribe(lsn); 
      });
      tbl.ariaListeners = null;
    });
    _LS.tablesWithListeners = null;
    _LS.sorters.forEach(function(srt){
      srt.cleanUp && srt.cleanUp();
    });
    _LS.sorters = null;
    _LS.sortedCell = null;
    _LS.sortableTable = null;
    _LS.cleaner.remove();
  },
  
  /*
   * Perform the sort
   */
  sortTable: function(table, pid, col, step, isExpandable, ixLastVisible, evt) {
	if (evt && evt.keyCode &&  !(evt.keyCode == 13 || evt.keyCode == 32)) {
	  return; /* only ENTER and SPACE do the sorting */	
	}
	
	var tbody = table.tBodies[0], tRows = tbody.rows;
    var numOfRecords = tbody && tbody.rows.length;
    // for lists with zero rows or one row do nothing
    if ((numOfRecords < 3 && isExpandable) ||
    		(numOfRecords < 2 && !isExpandable)) {
      return;
    }
    
	// A simple numeric comparator.
	var fnRev = table._sortUp ? function(a,b) { return a - b; } : function(a,b) { return b - a; }
	var sort_numeric = 
      function(a, b) {
	    var aa = _LS.getOrd(a.cells[col]);
	    var bb = _LS.getOrd(b.cells[col]);
	    return fnRev(aa,bb);
	  };
    // publish the "pre-sort" events
	dojo.publish('curam/sort/earlyAware', [pid]);
    dojo.publish(_LS.EVT_SORT_PREP, [pid,table]);
    
    count = tbody && tbody.rows.length;
    // for lists with zero rows
    if (count && count <= step) {
      return;
    }

    var existingOrder = _LS.getOrd(tRows[0].cells[col]);
    if (existingOrder >=0) { // skip sorting when the sort info is not available!
      var flatRows = [];
      var i = 0;
      while (i < count) {
    	var fl = tRows[i++];
        flatRows.push(fl);
        isExpandable && (fl._detailsRow = tRows[i++]);
      }
      flatRows.sort(sort_numeric);
      table._sortUp = !table._sortUp;
      var mainFrag = document.createDocumentFragment(),
        restFrag = document.createDocumentFragment();
      // Reshuffle rows in DOM.
      flatRows.forEach(function(newRow, ix) {
    	domAttr.set(newRow, 'data-lix', ix);
    	newRow.done = false;
    	var app = (ix <= ixLastVisible) ? mainFrag : restFrag;
    	app.appendChild(newRow);
        newRow._detailsRow && app.appendChild(newRow._detailsRow);
      });
      tbody.appendChild(mainFrag);

      // restore the CSS striping classes after sorting
      curam.util.stripeTable(table, isExpandable, ixLastVisible);
      tbody.appendChild(restFrag);

      var newOrder = 0;
      if (flatRows.length > 1) {
        var ordFirst = _LS.getOrd(flatRows[0].cells[col]),
             ordNext = _LS.getOrd(flatRows[flatRows.length - 1].cells[col]);
        // use the last row to avoid equal sort orders.
        newOrder = ordNext == ordFirst ? 0 /* equal orders for all cells */
        		                       : (ordNext > ordFirst) ? 1 : 2;
      }
      var sortOrderText = _LS.sortTexts[newOrder];
      _LS.updatesByNow = table.ariaListeners.length;
      // publish the "re-sort" event
      dojo.publish(_LS.EVT_SORTED, [pid, col, newOrder, sortOrderText]);
      // update the accessibility readouts
      var isHere = dojo.exists; 
      if (isHere('curam.listControls.' + pid)
    		  || isHere('curam.listTogglers.' + pid)
    		    || (isHere('curam.listMenus.' + pid)
    		         && curam.listMenus[pid].length > 0)) {
        dojo.publish('curam/update/readings/sort', [pid, flatRows]);
      }
    }
    return false;//suppress link action
  },

  doFocus:function(unsorts, fullSortedTxt) {
    domAttr.set(_LS.sortedCell, _LS.LIVE, 'polite');
    var fn;
    while (fn = unsorts.pop()) {
      fn();
    }
    _LS.sortedCell.aux && _LS.sortedCell.aux.focus();
    var to = setTimeout(function() {
      clearTimeout(to);
      _LS.sortedCell && _LS.sortedCell.focus();
    },500);
    if (fullSortedTxt) {
      var to1 = setTimeout(function() {
        clearTimeout(to1);
        _LS.sortedCell && domAttr.set(_LS.sortedCell, _LS.READOUT, fullSortedTxt);
      },2500);
    }
  },

  /*
   * Extracts the data-curam-sort-order attribute from a span element. The
   * numeric sort information is contained in this attribute.
   */
    getOrd: function(el) {
      if (!el) return -1;
      if (el.ord) return el.ord;
      var sps = query('span[data-curam-sort-order]', el)[0];
      if (!sps) {
        el.ord = -1;
        return el.ord;
      }
      var ord = domAttr.get(sps, 'data-curam-sort-order');
      var ordNo = parseInt(ord), res = isNaN(ordNo) ? -1 : ordNo;
      el.ord = res;
      return res;
    }
  });
  
  /*
   * Module level branching of the accessibility related browser-dependent code.
   */
  has('trident') ? dojo.mixin(ListSort, {
	  setPlaceholders:function(cellSpan, labelTxt, labelSortTxt){
		  domConstruct.create('p', {'aria-hidden':'true',
			  innerHTML:labelTxt, className:'sortColText'}, cellSpan);
		  var focusAux = domConstruct.create('span', { 'tabindex':-1,
	    	'aria-label': labelSortTxt}, cellSpan);
	    domStyle.set(focusAux,{'opacity':'0', 'margin':'0', 'padding':'0'});
	    cellSpan.aux = focusAux;
	  },
	  resetReadout: function(cellSpan, lblTxt) {
        //domAttr.set(cellSpan, ListSort.LIVE, 'off');
        domAttr.set(cellSpan, ListSort.READOUT, lblTxt);
	  }
   }) : dojo.mixin(ListSort, {
     setPlaceholders:function(cellSpan, labelTxt, labelSortTxt) {
	   !/Edg/.test(navigator.userAgent) && domAttr.set(cellSpan,'role','button');
       domConstruct.create('p', {'aria-hidden':'true',
    	   innerHTML:labelTxt, className:'sortColText'}, cellSpan);
     },
     resetReadout: function(cellSpan, lblTxt) {
       domAttr.remove(cellSpan, ListSort.LIVE);
       domAttr.remove(cellSpan, ListSort.READOUT);
     }
   });
   has('ios') && dojo.mixin(ListSort, {
	 setPlaceholders:function(cellSpan, labelTxt, labelSortTxt) {
	   domAttr.set(cellSpan,'role','link');
	   var cTxt = domConstruct.create('p', {'aria-hidden':'true',
			  innerHTML:'placeholder', className:'sortColText'},
			  cellSpan);
	   domStyle.set(cTxt,{'opacity':'0', 'margin':'0', 'padding':'0',
		                   'position':'absolute','bottom':'0'});
	   var lnk = domConstruct.create('a', { 'tabindex':0,
		    	'aria-label': labelTxt, 'href':'#',innerHTML:labelTxt},
		    	cellSpan);
	 }
   });

  return ListSort;
});
},
'dojo/fx':function(){
define([
	"./_base/lang",
	"./Evented",
	"./_base/kernel",
	"./_base/array",
	"./aspect",
	"./_base/fx",
	"./dom",
	"./dom-style",
	"./dom-geometry",
	"./ready",
	"require" // for context sensitive loading of Toggler
], function(lang, Evented, dojo, arrayUtil, aspect, baseFx, dom, domStyle, geom, ready, require){

	// module:
	//		dojo/fx
	
	// For back-compat, remove in 2.0.
	if(!dojo.isAsync){
		ready(0, function(){
			var requires = ["./fx/Toggler"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var coreFx = dojo.fx = {
		// summary:
		//		Effects library on top of Base animations
	};

	var _baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		arrayUtil.forEach(this._animations, function(a){
			if(a){
				if(typeof a.duration != "undefined"){
	        		this.duration += a.duration;
				}
				if(a.delay){
					this.duration += a.delay;
				}
			}
		}, this);
	};
	_chain.prototype = new Evented();
	lang.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			this._onAnimateCtx.remove();
			this._onEndCtx.remove();
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
				this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = aspect.after(this._current, "beforeBegin", lang.hitch(this, function(){
					this._fire("beforeBegin");
				}), true),
				onBegin = aspect.after(this._current, "onBegin", lang.hitch(this, function(arg){
					this._fire("onBegin", arguments);
				}), true),
				onPlay = aspect.after(this._current, "onPlay", lang.hitch(this, function(arg){
					this._fire("onPlay", arguments);
					beforeBegin.remove();
					onBegin.remove();
					onPlay.remove();
				}));
			if(this._onAnimateCtx){
				this._onAnimateCtx.remove();
			}
			this._onAnimateCtx = aspect.after(this._current, "onAnimate", lang.hitch(this, "_onAnimate"), true);
			if(this._onEndCtx){
				this._onEndCtx.remove();
			}
			this._onEndCtx = aspect.after(this._current, "onEnd", lang.hitch(this, "_onEnd"), true);
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = aspect.after(this._current, "onPause", lang.hitch(this, function(arg){
						this._fire("onPause", arguments);
						e.remove();
					}), true);
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;

			arrayUtil.some(this._animations, function(a, index){
				if(offset <= a.duration){
					this._current = a;
					this._index = index;
					return true;
				}
				offset -= a.duration;
				return false;
			}, this);
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration);
			}
			if (andPlay) { this.play(); }
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = aspect.after(this._current, "onStop", lang.hitch(this, function(arg){
						this._fire("onStop", arguments);
						e.remove();
					}), true);
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			this.stop();
			if(this._onAnimateCtx){ this._onAnimateCtx.remove(); }
			if(this._onEndCtx){ this._onEndCtx.remove(); }
		}
	});
	lang.extend(_chain, _baseObj);

	coreFx.chain = function(/*dojo/_base/fx.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo/_base/fx.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo/_base/fx.Animation` which will play all passed
		//		`dojo/_base/fx.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.chain([
		//	|			fx.fadeIn({ node:node }),
		//	|			fx.fadeOut({ node:otherNode })
		//	|		]).play();
		//	|	});
		//
		return new _chain(animations); // dojo/_base/fx.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		arrayUtil.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(aspect.after(a, "onEnd", lang.hitch(this, "_onEnd"), true));
		}, this);

		this._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		arrayUtil.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(aspect.after(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); },
				true));
			}
		);
	};
	lang.extend(_combine, {
		_doAction: function(action, args){
			arrayUtil.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			arrayUtil.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			this.stop();
			arrayUtil.forEach(this._connects, function(handle){
				handle.remove();
			});
		}
	});
	lang.extend(_combine, _baseObj);

	coreFx.combine = function(/*dojo/_base/fx.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo/_base/fx.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo/_base/fx.Animation`s to run in parallel,
		//		providing a new `dojo/_base/fx.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.combine([
		//	|			fx.fadeIn({ node:node }),
		//	|			fx.fadeOut({ node:otherNode })
		//	|		]).play();
		//	|	});
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	require(["dojo/fx"], function(fx){
		//	|		var anim = fx.combine([
		//	|			fx.fadeIn({ node: n, duration:700 }),
		//	|			fx.fadeOut({ node: otherNode, duration: 300 })
		//	|		]);
		//	|		aspect.after(anim, "onEnd", function(){
		//	|			// overall animation is done.
		//	|		}, true);
		//	|		anim.play(); // play the animation
		//	|	});
		//
		return new _combine(animations); // dojo/_base/fx.Animation
	};

	coreFx.wipeIn = function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.wipeIn({
		//	|			node:"someId"
		//	|		}).play()
		//	|	});

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = domStyle.get(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		var fini = function(){
			s.height = "auto";
			s.overflow = o;
		};
		aspect.after(anim, "onStop", fini, true);
		aspect.after(anim, "onEnd", fini, true);

		return anim; // dojo/_base/fx.Animation
	};

	coreFx.wipeOut = function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	require(["dojo/fx"], function(fx){
		//	|		fx.wipeOut({ node:"someId" }).play()
		//	|	});

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		aspect.after(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		}, true);
		var fini = function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		};
		aspect.after(anim, "onStop", fini, true);
		aspect.after(anim, "onEnd", fini, true);

		return anim; // dojo/_base/fx.Animation
	};

	coreFx.slideTo = function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo/_base/fx.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = dom.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = domStyle.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = geom.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		aspect.after(anim, "beforeBegin", init, true);

		return anim; // dojo/_base/fx.Animation
	};

	return coreFx;
});

},
'curam/inPageNavigation':function(){
/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dijit/registry",
        "curam/inspection/Layer",
        "curam/tab",
        "curam/ui/PageRequest",
        "curam/debug",
        "dojo/_base/declare",
        "dojo/dom-attr",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-geometry"
        ], function(registry, layer, tab, pageRequest, debug, declare, domAttr, 
            domStyle, domClass, domGeom) {
  
  /*
   * Modification History
   * --------------------
   * 22-Sep-2014  SK [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 11-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 06-May-2011 SD [CR00265812] Improve IPN loading mask to handle switching
   *             between navigation tabs.  
   * 29-Mar-2011 SD [CR00256180] Reworked IPN tabs for main content area. The
   *             UumController class is now not utilised for main content area
   *             IPN tabs. TabContainer is now generated within the iFrame. 
   * 09-Nov-2010 MV [CR00220649] Handle conditionally hidden links. 
   * 05-Jul-2010 BD [CR00204119] Rework of this file. Now a class that describes 
   *             an in page navigation link. Also contains a utility function to
   *             return the set of links from and iframe.
   */
  
  /**
   * Javascript object representing a in page navigation links. The constructor
   * takes the title, url and a boolean value indicating the currently selected 
   * link. 
   * 
   * The getLinks static method 
   */
  var inPageNavigation = declare("curam.inPageNavigation", null , {

    // title: String
    //   The title for the tab, taken from the localized LABEL attribute of the 
    //   ACTION_CONTROL element on the UIM.
    title:"",
    // href: String
    //   page link including all parameters, taken from the LINK element and 
    //   any child PARAM elements.
    href:"",
    // selected: Boolean
    //   boolean indicating if this is the selected link, taken from the STYLE
    //   attribute on the ACTION_CONTROL element, where the value 
    //   "in-page-current-link" indicates the item is selected.
    selected:false,
    
    constructor: function(args){

      // summmary:
      //    create an inPageNavigation object that will describe a single link by 
      //    title, href(url) and whether it is selected or not.
    
      this.title = args.title;
      this.href = args.href;
      this.selected = args.selected;
      debug.log("curam.inPageNavigation " 
        + debug.getProperty("curam.inPageNavigation.msg")+ this);
      layer.register("curam/inPageNavigation", this);
      
    },
      

    getLinks: function(){
      
      // summary:
      //     Return an array of inPageNavigation objects that describe the set
      //     of in page navigation links for the current page.

      var ipnLinksWrapper = dojo.query(".in-page-navigation-tabs")[0];
      var ipnLinks = dojo.query('li', ipnLinksWrapper);
      var ipnItems = new Array();
      dojo.forEach(ipnLinks,  function(link) {
        var anchor = dojo.query("a",link)[0];
        if (!anchor) {
          // conditionally hidden links will output no anchor - skip them
          return;
        }
        // Browsers vary on getting plain text from a node. 
        // http://clubajax.org/plain-text-vs-innertext-vs-textcontent/
        // Because we know our anchor tags do not have child markup it's safe
        // to do the following (innderText for IE, textContent for FF)
        var title = anchor.innerText || anchor.textContent;
        var selected = false;

        // TODO: Can this be replaced with domClass.contains()?
        dojo.filter(domAttr.get(anchor,"class").split(" "), function(className){
          if(className == "in-page-current-link"){
            selected = true;
            return;
          }
        });

        var href = domAttr.get(anchor,"href");
        var navItem = new curam.inPageNavigation({'title':title,'selected':selected,'href':href});
        ipnItems.push(navItem);
      });
      return ipnItems;
     },
     
     processMainContentAreaLinks: function() {

       // summary:
       //     This method exclusively handles IPN tabs in the main content area.
       //     Modal and expandabale list IPN tabs are still handled using the
       //     UIMController class.
       //
       //     IPN links within the main content area are populated (upon clicking)
       //     by reading the generated Curam link to reload the iFrame. Switching
       //     between the actual tabs is controlled by the Dojo tabContainer.
       dojo.addOnLoad(function(){
         var inPageNavigationTabNode = dojo.query(".ipn-page")[0];
         
         if(inPageNavigationTabNode){
           
           var inPageNavigationTabWidget = 
             registry.byId(domAttr.get(inPageNavigationTabNode, "id"));
          
           // Handle conditional in-page-navigation by removing the dummy child
           // inserted in gen-jsp.xsl
           var dummyChild = inPageNavigationTabWidget.getChildren()[0];
           inPageNavigationTabWidget.removeChild(dummyChild);

           if (inPageNavigationTabWidget.getChildren().length == 0) {
             return;
           }

           // Set the height on the content area based on the height of the content.
           var contentWrapper = dojo.query(".in-page-nav-contentWrapper")[0];
           var nodes = dojo.query("> *",  contentWrapper);
           var bottomNode = nodes[nodes.length - 1];
           var pos = domGeom.position(bottomNode);
           var height = pos.y;
           var heightStyle = "height: " + height + "px;";
           domAttr.set(contentWrapper,"style", heightStyle);

           // Create a listener for the tab switch event.
           dojo.connect(inPageNavigationTabWidget,"_transition", function(newPage, oldPage){

           // At this point we have passed through the clickHandler function and have been
           // ignored. Now we are going to process the link again in the same way the clickHandler
           // handles clicks. This time we explicitly call the handlePageRequest function.
           var link = dojo.query(".in-page-link",newPage.id)[0];
           var uimPageRequest = new curam.ui.PageRequest(link.href);
           if (jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")) {
             uimPageRequest.pageHolder = window;
           }
           curam.tab.getTabController().handlePageRequest(uimPageRequest);
           });
           
           // when clicking between IPN links, the tab container is hidden until fully
           // loaded due to slow rendering of tab container in browser, especially
           // IE7.
           domStyle.set(inPageNavigationTabNode, 'visibility', 'visible');
         }
       });
     }
  });
  
  return inPageNavigation;
});

},
'curam/util/LocalConfig':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2021. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 04-Feb-2021  BOS [RTC267998]  Make the code more defensive to guard
 * against the local configuration being available for some reason.
 * 04-Mar-2014  MV  [CR00421036] Added implementation.
 * 27-Feb-2014  MV  [CR00419961] Initial version.
 */

/**
 * @name curam.util.LocalConfig
 * @namespace Provides support for accessing application properties
 *    from JavaScript and overriding their values locally.
 *      <p/>
 *    The basic idea is that desired options are determined at application
 *    init time (in the main app page) and they are "seeded" using this API.
 *    From then on JavaScript code can access the values of these options.
 *      <p/>
 *    It is then possible to override individual option values and the API
 *    will persist the overrides in local Web storage. This allows
 *    for individual users to control the behaviour of the application
 *    without the need to set options globally for all users in admin pages.
 *      <p/>
 *    Please note the option values and overrides are stored in the "top"
 *    browser window, even if the API is used from nested iframes.
 */
define([
        ], function() {
  
  // the code below ensures we store the values globally
  var globalName = function(name) {
        return 'curam_util_LocalConfig_' + name;
      },
      initGlobal = function(name, value) {
        var gName = globalName(name);
        
        // only initialize if it doesn't already exist!
        if (typeof top[gName] === 'undefined') {
          top[gName] = value;
        }
        
        return top[gName];
      },
      getGlobal = function(name) {
        return top && top !=null ? top[globalName(name)] : undefined;
      };
  
  initGlobal('seedValues', {}),
  initGlobal('overrides', {});
  
  var _checkIsString = function(value, valName) {
    if (typeof value !== 'undefined' && typeof value !== 'string') {
      throw new Error('Invalid ' + valName + ' type: ' + typeof value
          + '; expected string');
    }
  };
  
  var LocalConfig =
  /**
   * @lends curam.util.LocalConfig.prototype
   */
  {
    /**
     * Sets the "global" value for the option.
     * This can be later overriden to provide a local value. 
     *
     * @param name Name of the option to set.
     * @param value Value of the option to set. If this is undefined
     *  then default value will be used instead.
     * @param defaultValue Default value to be used if value is not specified.
     */
    seedOption: function(name, value, defaultValue) {
      _checkIsString(value, 'value');
      _checkIsString(defaultValue, 'defaultValue');
      
      // code below treats null as a valid value to be used
      getGlobal('seedValues')[name] =
          (typeof value !== 'undefined') ? value : defaultValue;
    },
    
    /**
     * Sets local override for the value of given option.
     * The override is persisted to local Web storage, if available.
     * 
     * @param name Name of the option to override.
     * @param value The local value to be used.
     */
    overrideOption: function(name, value) {
      _checkIsString(value, 'value');

      // persist the value, if possible
      if(typeof(Storage) !== "undefined") {
        localStorage[name] = value;

      // otherwise just store in memory - override will not be permanent
      } else {
        getGlobal('overrides')[name] = value;
      }
    },
    
    /**
     * Reads the value of the given option. It takes the values in the following
     * precedence order. The first that is found is returned.
     * <ul>
     * <li>override from local persistent Web storage</li>
     * <li>override from session memory</li>
     * <li>the global value</li>
     * <li>return the provided default value</li>
     * </ul>
     * 
     * @param name Name of the option to read.
     * @param defaultValue Default value to return if value is not set.
     * @returns Value of the option or provided default value.
     */
    readOption: function(name, defaultValue) {
      var seedValues = getGlobal('seedValues');
	  var overridesValues = getGlobal('overrides');
      _checkIsString(defaultValue, 'defaultValue');

      var finalValue = null;

      // use local persistent value, if possible and if available
      if (typeof(Storage) !== "undefined"
          && localStorage && typeof localStorage[name] !== 'undefined') {
        finalValue = localStorage[name];
    
      // otherwise fall back to local non-persistent override
      } else if (overridesValues && typeof overridesValues[name] !== 'undefined') {
        finalValue = overridesValues[name];
  
      // otherwise fall back to the seed value
      } else if (seedValues && typeof seedValues[name] !== 'undefined') {
        finalValue = seedValues[name];
  
      // otherwise fall back to the specified default value
      } else {
        finalValue = defaultValue;
      }

      return finalValue;
    },
    
    /**
     * Completely removes the option from configuration.
     * After using this method the readOption() will return the provided
     * default value.
     *
     * @param name Name of the option to clear.
     */
    clearOption: function(name) {
      if(typeof(Storage) !== "undefined") {
        localStorage.removeItem(name);
      }
      delete getGlobal('overrides')[name];
      delete getGlobal('seedValues')[name];
    }
  };
  
  return LocalConfig;
  
});

},
'dojo/data/util/sorter':function(){
define(["../../_base/lang"], function(lang){
	// module:
	//		dojo/data/util/sorter
	// summary:
	//		TODOC

var sorter = {};
lang.setObject("dojo.data.util.sorter", sorter);

sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	// summary:
	//		Basic comparison function that compares if an item is greater or less than another item
	// description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.

	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

sorter.createSortFunction = function(	/* attributes[] */sortSpec, /*dojo/data/api/Read*/ store){
	// summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	// description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	// sortSpec:
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	// |	{
	// |		attribute: "attributeName-string" || attribute,
	// |		descending: true|false;   // Default is false.
	// |	}
	// store:
	//		The datastore object to look up item values from.

	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

return sorter;
});

},
'curam/ui/PageRequest':function(){
/*
 * Copyright 2010-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.ui.PageReques
 * 
 * @namespace Represents an page request.
 *
 */
define(["dojo/_base/declare",
        "curam/debug"], function(declare, debug) {
/*
 * Modification History
 * --------------------
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 26-Jan-2011  MV  [CR00244801] Added another type of refresh indicator.
 * 21-Jan-2011  DG  [CR00243540] Removed unused log function.
 * 21-Jan-2011  MV  [CR00243263] Implement "force refresh" behaviour.
 * 16-Jan-2011  DG  [CR00242400] Removed "requires". Now handled by cdej.js.
 * 09-Dec-2010  DG  [CR00217921] Now supports TabDescriptor objects.
 * 02-Jun-2010  PK  [CR00203531] Initial version (moved from tab-common.js).
 */

/**
 * Creating Resource Bundle Object to access localized resources.
 */

var PageRequest = declare("curam.ui.PageRequest", null, 
  /** @lends curam.ui.PageRequest.prototype */ {
  
  /** If set to true then the page will be loaded even if it has the same URL. */
  forceLoad: false,

  /** If set to true then the existing page will be loaded instead of changing
   * to the URL passed in this request.
   */
  justRefresh: false,

  /**
   * Creates a new page request object.
   *
   * @param requestedPage If this is a string, it is interpreted as the URI of
   *   of the requested page. If it is an object, it is interpreted as a
   *   <code>curam.tab.TabDescriptor</code> and the URI is constructed from
   *   the properties of the tab descriptor's "tabContent" property.
   * @param {Boolean} isHomePage true if this is a home page (one whose tab
   *   will not be closed).
   * @param {Boolean} openInCurrentTab true if this page should be opened in
   *   the current tab instead of creating a new tab.
   */
  constructor: function(requestedPage, isHomePage, openInCurrentTab) {
    this.parameters = {};
    this.cdejParameters = {};
    this.cdejParameters["o3ctx"] = "4096";

    // Normalize these two arguments to Boolean values.
    if (isHomePage) {
      this.isHomePage = true;
    } else {
      this.isHomePage = false
    }
    if (openInCurrentTab) {
      this.openInCurrentTab = true;
    } else {
      this.openInCurrentTab = false
    }

    // This will be used to specify the location to open the page in. If not
    // specified the "Tab Controller" will always open the page in the main
    // content panel.
    this.pageHolder = null;

    var url;
    if (dojo.isString(requestedPage)) {
      url = requestedPage;
      curam.debug.log("PAGE REQUEST: " 
        + debug.getProperty("curam.ui.PageRequest.url") + " " + url);
    } else {
      curam.debug.log("PAGE REQUEST: " 
        + debug.getProperty("curam.ui.PageRequest.descriptor") + " "
          + requestedPage.toJson());
      // Value is a curam.tab.TabDescriptor. See that class for details.
      // TODO: Is there any good reason why we should create a string from its
      // parts and then parse the string back to its parts again? -- DG
      var tc = requestedPage.tabContent;
      url = tc.pageID + "Page.do";
      var firstParam = true;
      for (param in tc.parameters) {
        if (firstParam) {
          url += "?";
          firstParam = false;
        } else {
          url += "&";
        }
        url += param + "=" + encodeURIComponent(tc.parameters[param]);
      }
      curam.debug.log("PAGE REQUEST: " 
        + debug.getProperty("curam.ui.PageRequest.derived") + " " + url);
    }

    var tokens = url.split("?");
    this.parseUIMPageID(tokens[0]);
    if (tokens.length == 2) {
      // parse the query string
      this.parseParameters(tokens[1]);
    }
  },

  parseUIMPageID: function(url) {
    var pageIDTokens = url.split("/");
    var pageIDString = pageIDTokens[pageIDTokens.length - 1];
    this.pageID = pageIDString.replace("Page.do", "");
  },

  parseParameterName: function(name) {
    // parameter values are tokenized by "&". However the urls generated
    // from the menu bar and navigation renderers is run through a serializer
    // and "&" escaped as "&amp;" when generating JavaScript code (e.g. JSON)
    // This function is a temporary workaround to check if the paramter value
    // begins with "amp;" (i.e. without the & which was the "token") and if so
    // we chop it off.

    // Note that while this escaping also takes place in the href attribute of
    // an anchor tag on all of our existing standard links, it's not an issue
    // in this case.
    // When we access that through the DOM API the &amp; is
    // unescaped to "&" (TODO: check this on all browsers). For example:
    // <a href="SomePage.do?param1=2&amp;param2=2">Click Here</a>
    // Now consider the following JavaScript (assuming "theAnchor" refers to
    // the href above):
    // var x = theAnchor.href;
    // "x" will be "SomePage.do?param1=2&param2=2"

    // Now consider some JavaScript written (or generated) as follows:
    // <script>
    // var jsonData = {nodeTitle: "Addresses",
    //                 url: "SomePage.do?param1=2&amp;param2=2"};
    // </script>
    // Now when we access jsonData.url we are going to get the string exactly
    // as it is above with the "&amp;"

    if (name.charAt(0) == 'a' && name.charAt(1) == 'm'
        && name.charAt(2) == 'p' && name.charAt(3) == ';') {
      // temp workaround to chop off the "amp;" at the start of the
      return name.substring(4, name.length);
    } else {
      return name;
    }
  },
  
  parseParameters: function(queryString) {
    // NOTE: The resolvePageCheckSuccess method of UIController.js access the
    // cdejParameters array directly. Therefore any change to encoding\decoding
    // of these parameters here needs to be checked on that method.
    var keyValuePairs = queryString.split("&");
    for (var i = 0; i < keyValuePairs.length; i++) {
      var keyValuePair = keyValuePairs[i].split("=");
      var paramName = this.parseParameterName(keyValuePair[0]);
      // TODO: Temporary fix for potential WAS issue.
      if (paramName.length > 0) {
        if (!this.isCDEJParam(paramName)) {
          this.parameters[paramName] = decodeURIComponent(keyValuePair[1].replace(/\+/g, " "));
        } else {
          if (paramName != "o3nocache") {
            this.cdejParameters[paramName] =
              decodeURIComponent(keyValuePair[1].replace(/\+/g, " "));
          }
        }
      }
    }
  },
    isCDEJParam: function(paramName) {
    return (paramName.charAt(0) == 'o' && paramName.charAt(1) == '3')
           || (paramName.charAt(0) == '_' && paramName.charAt(1) == '_'
               && paramName.charAt(2) == 'o' && paramName.charAt(3) == '3');
  },

  getQueryString: function(filterCDEJParams) {
    // TODO: re-enable caching....
    //if (this.queryString) {
    //  return this.queryString;
    //}
    var newQS = "";
    var paramName;
    for (paramName in this.parameters) {
      newQS += paramName + "=" + encodeURIComponent(this.parameters[paramName])
          + "&";
    }
    if (!filterCDEJParams == true || filterCDEJParams == false) {
      for (paramName in this.cdejParameters) {
        newQS += paramName + "="
            + encodeURIComponent(this.cdejParameters[paramName]) + "&";
      }
    }
    newQS = newQS.substring(0, newQS.length - 1);
    this.queryString = newQS;
    return this.queryString;
  },

  getURL: function(filterCDEJParams) {
    // TODO: re-enable caching....
    // if (this.url) {
    //   return this.url;
    // }

    var newURL = this.pageID + "Page.do";
    //if (this.parameters.length > 0) {
    var qs = this.getQueryString(filterCDEJParams);
    if (qs != "") {
      newURL += "?" + qs;
    }
    // for (paramName in this.parameters) {
    //  this.url += parmName + "=" + this.parameters[paramName] + "&"
    // }
    // this.url = this.url.substring(0, this.url.length - 2);
    // }
    this.url = newURL;
    return this.url;
  }
});

return PageRequest;
});

},
'dojo/window':function(){
define(["./_base/lang", "./sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style", "./dom-construct"],
	function(lang, has, baseWindow, dom, geom, style, domConstruct){

	// feature detection
	/* not needed but included here for future reference
	has.add("rtl-innerVerticalScrollBar-on-left", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'hidden', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', width:'64px', height:'64px'}
			}, body, "last"),
			center = domConstruct.create('center', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			inner = domConstruct.create('div', {
				style: {overflow:'visible', display:'inline' }
			}, center, "last");
		inner.innerHTML="&nbsp;";
		var midPoint = Math.max(inner.offsetLeft, geom.position(inner).x);
		var ret = midPoint >= 32;
		center.removeChild(inner);
		scrollable.removeChild(center);
		body.removeChild(scrollable);
		return ret;
	});
	*/
	has.add("rtl-adjust-position-for-verticalScrollBar", function(win, doc){
		var	body = baseWindow.body(doc),
			scrollable = domConstruct.create('div', {
				style: {overflow:'scroll', overflowX:'visible', direction:'rtl', visibility:'hidden', position:'absolute', left:'0', top:'0', width:'64px', height:'64px'}
			}, body, "last"),
			div = domConstruct.create('div', {
				style: {overflow:'hidden', direction:'ltr'}
			}, scrollable, "last"),
			ret = geom.position(div).x != 0;
		scrollable.removeChild(div);
		body.removeChild(scrollable);
		return ret;
	});

	has.add("position-fixed-support", function(win, doc){
		// IE6, IE7+quirks, and some older mobile browsers don't support position:fixed
		var	body = baseWindow.body(doc),
			outer = domConstruct.create('span', {
				style: {visibility:'hidden', position:'fixed', left:'1px', top:'1px'}
			}, body, "last"),
			inner = domConstruct.create('span', {
				style: {position:'fixed', left:'0', top:'0'}
			}, outer, "last"),
			ret = geom.position(inner).x != geom.position(outer).x;
		outer.removeChild(inner);
		body.removeChild(outer);
		return ret;
	});

	// module:
	//		dojo/window

	var window = {
		// summary:
		//		TODOC

		getBox: function(/*Document?*/ doc){
			// summary:
			//		Returns the dimensions and scroll position of the viewable area of a browser window

			doc = doc || baseWindow.doc;

			var
				scrollRoot = (doc.compatMode == 'BackCompat') ? baseWindow.body(doc) : doc.documentElement,
				// get scroll position
				scroll = geom.docScroll(doc), // scrollRoot.scrollTop/Left should work
				w, h;

			if(has("touch")){ // if(scrollbars not supported)
				var uiWindow = window.get(doc);   // use UI window, not dojo.global window
				// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
				w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
				h = uiWindow.innerHeight || scrollRoot.clientHeight;
			}else{
				// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
				// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
				w = scrollRoot.clientWidth;
				h = scrollRoot.clientHeight;
			}
			return {
				l: scroll.x,
				t: scroll.y,
				w: w,
				h: h
			};
		},

		get: function(/*Document*/ doc){
			// summary:
			//		Get window object associated with document doc.
			// doc:
			//		The document to get the associated window for.

			// In some IE versions (at least 6.0), document.parentWindow does not return a
			// reference to the real window object (maybe a copy), so we must fix it as well
			// We use IE specific execScript to attach the real window reference to
			// document._parentWindow for later use
			if(has("ie") && window !== document.parentWindow){
				/*
				In IE 6, only the variable "window" can be used to connect events (others
				may be only copies).
				*/
				doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
				//to prevent memory leak, unset it after use
				//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
				var win = doc._parentWindow;
				doc._parentWindow = null;
				return win;	//	Window
			}

			return doc.parentWindow || doc.defaultView;	//	Window
		},

		scrollIntoView: function(/*DomNode*/ node, /*Object?*/ pos){
			// summary:
			//		Scroll the passed node into view using minimal movement, if it is not already.

			// Don't rely on node.scrollIntoView working just because the function is there since
			// it forces the node to the page's bottom or top (and left or right in IE) without consideration for the minimal movement.
			// WebKit's node.scrollIntoViewIfNeeded doesn't work either for inner scrollbars in right-to-left mode
			// and when there's a fixed position scrollable element

			try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
				node = dom.byId(node);
				var	doc = node.ownerDocument || baseWindow.doc,	// TODO: why baseWindow.doc?  Isn't node.ownerDocument always defined?
					body = baseWindow.body(doc),
					html = doc.documentElement || body.parentNode,
					isIE = has("ie") || has("trident"),
					isWK = has("webkit");
				// if an untested browser, then use the native method
				if(node == body || node == html){ return; }
				if(!(has("mozilla") || isIE || isWK || has("opera") || has("trident") || has("edge"))
						&& ("scrollIntoView" in node)){
					node.scrollIntoView(false); // short-circuit to native if possible
					return;
				}
				var	backCompat = doc.compatMode == 'BackCompat',
					rootWidth = Math.min(body.clientWidth || html.clientWidth, html.clientWidth || body.clientWidth),
					rootHeight = Math.min(body.clientHeight || html.clientHeight, html.clientHeight || body.clientHeight),
					scrollRoot = (isWK || backCompat) ? body : html,
					nodePos = pos || geom.position(node),
					el = node.parentNode,
					isFixed = function(el){
						return (isIE <= 6 || (isIE == 7 && backCompat))
							? false
							: (has("position-fixed-support") && (style.get(el, 'position').toLowerCase() == "fixed"));
					},
					self = this,
					scrollElementBy = function(el, x, y){
						if(el.tagName == "BODY" || el.tagName == "HTML"){
							self.get(el.ownerDocument).scrollBy(x, y);
						}else{
							x && (el.scrollLeft += x);
							y && (el.scrollTop += y);
						}
					};
				if(isFixed(node)){ return; } // nothing to do
				while(el){
					if(el == body){ el = scrollRoot; }
					var	elPos = geom.position(el),
						fixedPos = isFixed(el),
						rtl = style.getComputedStyle(el).direction.toLowerCase() == "rtl";

					if(el == scrollRoot){
						elPos.w = rootWidth; elPos.h = rootHeight;
						if(scrollRoot == html && (isIE || has("trident")) && rtl){
							elPos.x += scrollRoot.offsetWidth-elPos.w;// IE workaround where scrollbar causes negative x
						}
						elPos.x = 0;
						elPos.y = 0;
					}else{
						var pb = geom.getPadBorderExtents(el);
						elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
						var clientSize = el.clientWidth,
							scrollBarSize = elPos.w - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							if(rtl && has("rtl-adjust-position-for-verticalScrollBar")){
								elPos.x += scrollBarSize;
							}
							elPos.w = clientSize;
						}
						clientSize = el.clientHeight;
						scrollBarSize = elPos.h - clientSize;
						if(clientSize > 0 && scrollBarSize > 0){
							elPos.h = clientSize;
						}
					}
					if(fixedPos){ // bounded by viewport, not parents
						if(elPos.y < 0){
							elPos.h += elPos.y; elPos.y = 0;
						}
						if(elPos.x < 0){
							elPos.w += elPos.x; elPos.x = 0;
						}
						if(elPos.y + elPos.h > rootHeight){
							elPos.h = rootHeight - elPos.y;
						}
						if(elPos.x + elPos.w > rootWidth){
							elPos.w = rootWidth - elPos.x;
						}
					}
					// calculate overflow in all 4 directions
					var	l = nodePos.x - elPos.x, // beyond left: < 0
//						t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
						t = nodePos.y - elPos.y, // beyond top: < 0
						r = l + nodePos.w - elPos.w, // beyond right: > 0
						bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
					var s, old;
					if(r * l > 0 && (!!el.scrollLeft || el == scrollRoot || el.scrollWidth > el.offsetHeight)){
						s = Math[l < 0? "max" : "min"](l, r);
						if(rtl && ((isIE == 8 && !backCompat) || has("trident") >= 5)){ s = -s; }
						old = el.scrollLeft;
						scrollElementBy(el, s, 0);
						s = el.scrollLeft - old;
						nodePos.x -= s;
					}
					if(bot * t > 0 && (!!el.scrollTop || el == scrollRoot || el.scrollHeight > el.offsetHeight)){
						s = Math.ceil(Math[t < 0? "max" : "min"](t, bot));
						old = el.scrollTop;
						scrollElementBy(el, 0, s);
						s = el.scrollTop - old;
						nodePos.y -= s;
					}
					el = (el != scrollRoot) && !fixedPos && el.parentNode;
				}
			}catch(error){
				console.error('scrollIntoView: ' + error);
				node.scrollIntoView(false);
			}
		}
	};

	 1  && lang.setObject("dojo.window", window);

	return window;
});

},
'dojo/DeferredList':function(){
define(["./_base/kernel", "./_base/Deferred", "./_base/array"], function(dojo, Deferred, darray){
	// module:
	//		dojo/DeferredList


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Deprecated, use dojo/promise/all instead.
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	// list:
	//		The list of deferreds to be synchronizied with this DeferredList
	// fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	// fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	// canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	darray.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}

		}
	});
};
dojo.DeferredList.prototype = new Deferred();

dojo.DeferredList.prototype.gatherResults = function(deferredList){
	// summary:
	//		Gathers the results of the deferreds for packaging
	//		as the parameters to the Deferred Lists' callback
	// deferredList: dojo/DeferredList
	//		The deferred list from which this function gathers results.
	// returns: dojo/DeferredList
	//		The newly created deferred list which packs results as
	//		parameters to its callback.

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		darray.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

return dojo.DeferredList;
});

},
'curam/widgets':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  Copyright IBM Corporation 2009,2021. All Rights Reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 31-Jan-2012 MV [CR00302081] Move away from global context. 
 */

define(["dojo/dom",
        "dojo/dom-style",
        "dojo/dom-construct"], function(dom, domStyle, domConstruct) {

//************************ AccordionControl *********************************
var AccordionControl = function(accordionDivId) {
  /* Disabling toolbar until we get proper icons from graphics Team
  var panel = dom.byId('controlPanel');
  var expander = domConstruct.create('img', {
      src:'../themes/classic/images/evidence-review/ExpandAllButton.png'
    }, panel
  );
  
  expander.switchboard = this;
  this.expander = expander;
  
  var modeSwitch = 
      domConstruct.create('input', {
          id:'switcher', type:'checkbox', value:'off'
        }, panel);
  modeSwitch.onclick=this.switchMode;
  modeSwitch.switchboard=this;
  this.modeSwitch=modeSwitch;
  panel.appendChild(modeSwitch);

  var lbl = domConstruct.create('label',{
    innerHTML: 'Switch Mode'
  }, panel);
  
  var collapser = 
      domConstruct.create('img',{
          src:'../themes/classic/images/evidence-review/CollapseAllButton.png',
          style: {display:'none'}
        }, panel);
  
  collapser.switchboard = this;
  this.collapser = collapser;
  */
  this.accordion = new AccordionWidget(accordionDivId, this);
  this.accordion.switchboard = this;
};

var theAccordionControl = {
  updateButtons: function() {
    var accord = this.accordion;
    this.collapser.disabled = accord.staysStill(false);
    this.expander.disabled = accord.staysStill(true);
  },

  switchMode: function() {
    if (this.checked){
      this.switchboard.accordion.accordMode = false;
      this.switchboard.expander.onclick = this.switchboard.accordion.expandRest;
      this.switchboard.collapser.style.display = '';
      this.switchboard.updateButtons();
    }else{
      this.switchboard.accordion.accordMode = true;
      this.switchboard.collapser.style.display = 'none';
      this.switchboard.accordion.collapseAll();
      this.switchboard.expander.value = 'Expand All';
      this.switchboard.expander.onclick = this.switchboard.accordion.expandAll;
      this.switchboard.expander.disabled = false;
    }
  }
};

dojo.mixin(AccordionControl.prototype, theAccordionControl);

//************************ AccordionWidget *********************************
var AccordionWidget = function(topDivId, switchboard) {
  var currentHeader;
  this.panelHeight = '250px';
  this.accordMode = true;
  this.switchboard = switchboard;
  this.topElement = dom.byId(topDivId);
  this.tabs = [];
  var allDivs = dojo.query("div", this.topElement);
  for (var i = 0; i < allDivs.length; i++){    
    if (allDivs[i].className=='accordionTab'){
      while (allDivs[++i].className!='tabHeader'){};
      currentHeader=allDivs[i];
      while (allDivs[++i].className!='tabContent'){};
      this.tabs[this.tabs.length] =
          new AccordionTab(this, currentHeader, allDivs[i]);
    }
  }
  this.lastTab = this.tabs[0];
  for (var i = 1; i < this.tabs.length; i++){
    this.tabs[i].collapse(false);
  }
};

var theAccordionWidget = {
  expandAll: function(){
    var accShortcut = this.switchboard.accordion;
    for (var i = 0; i < accShortcut.tabs.length; i++){
      accShortcut.tabs[i].stateExpanded();
    }
    this.src = '../themes/classic/images/evidence-review/CollapseAllButton.png';
    this.onclick = accShortcut.collapseAll;
  },
  
  collapseAll: function() {
    var accShortcut = this.switchboard.accordion;
    for (var i = 0; i < accShortcut.tabs.length; i++){
      accShortcut.tabs[i].collapse(false);
    }
    accShortcut.lastTab.expand(false);
    this.src = '../themes/classic/images/evidence-review/ExpandAllButton.png';
    this.onclick = accShortcut.expandAll;
  },
  
  expandRest: function() {
    if (!this.switchboard.accordion.staysStill(true)){
      this.switchboard.accordion.expandAll();
    }
    this.switchboard.updateButtons();
  },
  
  collapseRest: function() {
    if (!this.switchboard.accordion.staysStill(false)){
        this.switchboard.accordion.collapseAll();
    }
    this.switchboard.updateButtons();
  },
  
  staysStill: function(expand) {
    var allExp = 0;
    var allTabs = this.tabs.length;
    for (var i = 0; i < allTabs; i++){
      if (this.tabs[i].expanded==true) {
        allExp++;
      }
    }
    return (expand==true)?(allTabs - allExp == 0) : (allExp == 1);
  }
};

dojo.mixin(AccordionWidget.prototype, theAccordionWidget);

//************************ AccordionTab *********************************
var AccordionTab = function(accordion,headerRef,contentRef) {
  this.accordion = accordion;
  this.switchboard = accordion.switchboard;
  this.header = headerRef;
  this.header.tab = this;
  this.content = contentRef;
  domStyle.set(this.content, {
    height: accordion.panelHeight,
    overflow: "auto"
  });
  this.content.tab = this;
  this.expanded = true;
  dojo.connect(this.header, "onclick", this.toggleState);
  dojo.connect(this.header, "onmouseover", this.hoverStyle);
  dojo.connect(this.header, "onmouseout", this.stillStyle);
};

var theAccordionTab = {
  hoverStyle: function(e) {
    if (!this.tab.expanded) {
      this.className += ' tabHeaderHover';
    }
  },
  
  stillStyle: function(e) {
    this.className = 'tabHeader';
  },
  
  collapse: function(animate) {
    if (this.accordion.lastTab == this) {
      return;
    }
    if (this.accordion.staysStill(false)) {
      return;
    }
    if (animate && this.accordion.accordMode==false){
      new SingleSlowMotion(this.content, 'down');
    }else{
      domStyle.set(this.content, {
        height: "1px",
        display: "none"
      });
    }
    this.expanded = false;
    this.content.style.overflow = "hidden";
    if (this.accordion.accordMode == false){
      this.switchboard.updateButtons();
    }
  },
  
  expand: function(animate) {
    if (this.accordion.lastTab == this) {
      return;
    }
    if (this.accordion.staysStill(true)) {
      return;
    }
    var collapsingTab = this.accordion.lastTab;
    this.stateExpanded(animate);
    this.accordion.lastTab = this;
    if (this.accordion.accordMode == true){
      collapsingTab.collapse(true);
    }else{
      this.switchboard.updateButtons();
    }
  },
  
  stateExpanded: function(animate) {
    if (animate){
      this.content.style.display = '';
      if (this.accordion.accordMode == true){
        new SynchroSlowMotion(this.content, this.accordion.lastTab.content);
      }else{
        new SingleSlowMotion(this.content, 'up');
      }
    }else{
      domStyle.set(this.content, {
        height: this.accordion.panelHeight,
        display: "",
        overflow: "auto"
      });
      this.expanded=true;
    }
  },
  
  toggleState: function() {
    if (this.tab.expanded == true){
      this.tab.collapse(true);
    }else{
      this.tab.expand(true);
    }
  }
};
  
dojo.mixin(AccordionTab.prototype, theAccordionTab);

//************************ SingleSlowMotion *********************************
var SingleSlowMotion = function(contentRef, direction) {
  this.contentRef = contentRef;
  this.direction = direction;
  this.duration = 100;
  this.steps = 6;
  this.step();
};

var theSingleSlowMotion = {
   step: function() {
     var deltaH;
     if (this.steps <= 0 ) {
       if (this.direction=='down'){
         domStyle.set(this.contentRef, {
           height: "1px",
           display: "none"
         });
         this.contentRef.tab.expanded=false;
       }else{
         this.contentRef.style.height=this.contentRef.tab.accordion.panelHeight;
         this.contentRef.tab.expanded=true;
       }
       this.contentRef.tab.switchboard.updateButtons();
       return;
     }
     if (this.timer) {
       clearTimeout(this.timer);
     }
     var deltaT = Math.round(this.duration/this.steps);
     if (this.direction == 'down'){
       deltaH = this.steps > 0 ? 
             (parseInt(this.contentRef.offsetHeight) - 1)/this.steps : 0;
     }else{
       deltaH = this.steps > 0 ? 
             (parseInt(this.contentRef.tab.accordion.panelHeight) 
                   - parseInt(this.contentRef.offsetHeight))/this.steps : 0;
     }
     this.resizeBy(deltaH);
     this.duration -= deltaT;
     this.steps--;
     this.timer = setTimeout(dojo.hitch(this, this.step), deltaT);
   },

   resizeBy: function(deltaH) {
     var currentHeight = this.contentRef.offsetHeight;
     var intDiff = parseInt(deltaH);
      if (deltaH != 0){
        if (this.direction=='down'){
          this.contentRef.style.height = (currentHeight - intDiff) + "px";
        } else {
          this.contentRef.style.height = (currentHeight + intDiff) + "px";
        }
      }
   }
};

dojo.mixin(SingleSlowMotion.prototype, theSingleSlowMotion);

//************************ SynchroSlowMotion *********************************  
var SynchroSlowMotion = function(expandingRef, collapsingRef) {
  this.collapsingContent = collapsingRef;
  this.collapsingContent.style.overflow = 'hidden';
  this.expandingContent=expandingRef;
  this.limit = 250;
  this.duration = 100;
  this.steps = 10;
  this.expandingContent.style.display = '';
  this.step();
};

var theSynchroSlowMotion = {
   step: function() {
     if (this.steps <= 0){
       domStyle.set(this.collapsingContent, {
         height: "1px",
         display: "none"
       });
       domStyle.set(this.collapsingContent, {
         height: this.limit,
         overflow: "auto"
       });
       this.collapsingContent.tab.expanded = false;
       this.expandingContent.tab.expanded = true;
       return;
     }
     if (this.timer) {
       clearTimeout(this.timer);
     }
     var deltaT = Math.round(this.duration/this.steps);
     var deltaH = this.steps>0 ?
             (parseInt(this.collapsingContent.style.height)-1)/this.steps : 0;
     this.resizeBoth(deltaH);
     this.duration -= deltaT;
     this.steps--;
     this.timer = setTimeout(dojo.hitch(this, this.step), deltaT);
   },
   
   resizeBoth: function(deltaH) {
     var h1 = parseInt(this.collapsingContent.style.height);
     var h2 = parseInt(this.expandingContent.style.height);
     var intDiff=parseInt(deltaH);
      if (deltaH!=0){
        if (h2 + intDiff < this.limit) {
          this.collapsingContent.style.height = (h1 - intDiff) + "px";
          this.expandingContent.style.height = (h2 + intDiff) + "px";          
        }
      }
   }
};

dojo.mixin(SynchroSlowMotion.prototype, theSynchroSlowMotion);

//********** Accordion widget ***********************************************
var Widgets = {
  version: "1",
  
  AccordionControl: AccordionControl,
  AccordionWidget: AccordionWidget,
  AccordionTab: AccordionTab,
  SingleSlowMotion: SingleSlowMotion,
  SynchroSlowMotion: SynchroSlowMotion,

  registerAccordion: function(id) {
    AccordionControl.constructor(id);
  }
};


//************************ HEATMAP widget *********************************
var HeatMap = function(numRegions) {
  this.steps = numRegions;
  this.regions = new Array();
  this.RGB = new Array(256);
  var k = 0;
  var hex = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", 
                      "9", "A", "B", "C", "D", "E", "F");
  for (var i = 0; i < 16; i++) {
    for (j = 0; j < 16; j++) {
      this.RGB[k] = hex[i] + hex[j];
      k++;
    }
  }
};

var theHeatMap = {
  addRegion: function(regionId) {
    this.regions[this.regions.length] = regionId;
  },
  
  drawMap: function() {
    var midPoint;
    
    if (this.steps % 2 == 0) {
      midPoint = this.steps/2;
    } else {
      midPoint = (this.steps - 1)/2;
    }
    
    var step = parseInt(255/midPoint);
    var red, green, blue;
    for (var i = 0; i < this.steps; ++i) {
      var colour;
      if (i == 0) {
        colour = '#ff0000';
      } else if (i == (this.steps - 1)) {
        colour = '#0000ff';
      } else if (i == midPoint) {
        colour = '#ffffff';
      } else if (i > midPoint) {
        var green = 255;
        var red = 255;
        green -= (i - midPoint) * step;
        red -= (i - midPoint) * step;
        colour = this.rgbToHex(red, green, 255);
      } else if (i < midPoint) {
        green = 0;
        blue = 0;
        green += step * i;
        blue += step * i;
        colour = this.rgbToHex(255, green, blue);
      }
      var table = dom.byId('heatmapTable');
      if (table){
        var allCells = table.getElementsByTagName('td');
       
        for (var j = 0; j < allCells.length; j++) { 
          if (allCells[j].className.indexOf('region' + this.regions[i]) > -1) {
                allCells[j].style.background = colour;
                if (i > midPoint) {
                  domStyle.set(dojo.query("a", allCells[j])[0], "color", "white");
                }
          }
        }
      }
      domStyle.set(dom.byId('legendImage' + this.regions[i]), {
        color: colour,
        background: colour
      });
    }
  },

  rgbToHex: function(r, g, b) {
    var rr = this.RGB[r];
    var gg = this.RGB[g];
    var bb = this.RGB[b];      
    return '#' + rr + gg + bb;
  }
};

dojo.mixin(HeatMap.prototype, theHeatMap);

// TODO move away from global scope
dojo.global.getDataIn = function(whatVar) {
  return eval(whatVar);
};

// Keep the functions in the global scope for backwards compatibility.
// TODO: remove when code calling these functions is updated
dojo.global.Widgets = Widgets;
dojo.global.HeatMap = HeatMap;

return Widgets;
});

},
'dijit/registry':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/window", // win.body
	"./main"	// dijit._scopeName
], function(array, win, dijit){

	// module:
	//		dijit/registry

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		Registry of existing widget on page, plus some utility methods.

		// length: Number
		//		Number of registered widgets
		length: 0,

		add: function(widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			// widget: dijit/_WidgetBase
			//		Any dijit/_WidgetBase subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit/_WidgetBase
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit/_WidgetBase
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit/_WidgetBase[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(root, skipNode){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).
			// root: DOMNode
			//		Node to search under.
			// skipNode: DOMNode
			//		If specified, don't search beneath this node (usually containerNode).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else if(node !== skipNode){
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.nodeType == 1 && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	dijit.registry = registry;

	return registry;
});

},
'curam/validation':function(){
define(["dojo/dom",
        "curam/define",
        "curam/date"
        ], function(dom) {
  /*
   * Modification History
   * --------------------
   * 14-Sep-2017  BD  [RTC-201736] Inserted dom as parameter.
   */
   
   curam.define.singleton("curam.validation", {
    /* Holds div nodes which flag file upload controls to check. */
    FILE_UPLOAD_FLGS: [],

    /* The function that will perform the file upload pre-submit check. */
    fileUploadChecker: null,

    invalidPathMsg: null,

    preventKeyPress: function(event){
      if(dojo.isIE) { 
        event.cancelBubble = true;
        event.returnValue = false;
        return false;
      }
      return true;
    },

    activateFileUploadChecker: function(code) {
      if(!curam.validation.fileUploadChecker) {
        curam.validation.fileUploadChecker = function() {
          var form = dom.byId("mainForm");
          var doCheck = function(evt) {
            var flags = curam.validation.FILE_UPLOAD_FLGS;
            for(var i = 0; i < flags.length; i++) {
              var theId = flags[i];
              var input = cm.nextSibling(dom.byId(theId), "input");
              if(!curam.validation.isValidFilePath(input.value)) {
                dojo.stopEvent(evt);
                alert(curam.validation.invalidPathMsg + " \'" + input.value + "\'");

                // workaround for a global variable being set on the first submit attempt
                cm.setFormSubmitted(form, 0);
                return false; /* no point checking more paths */
              }
            }
            return true;
          };
          dojo.connect(form, "onsubmit", doCheck);
        };

        dojo.addOnLoad(curam.validation.fileUploadChecker);
      }
    },

    isValidFilePath: function(path) {
      
      // TODO: Remove this validation altogether as it is no longer necessary.
      return true;
    },
    
    validateDate: function(proposedDate) {
      // the variable jsDF contains the date format and is printed by
      // the curam:jsUserPreferences custom tag.
      // isDate() is available in date-formatting.js
      var resultStruct = {
        valid: curam.date.isDate(proposedDate, jsDF),
        validFormat: jsDF.toLowerCase()
      };
      
      return resultStruct;
    }
   
  });

  return curam.validation;
});

},
'dijit/PopupMenuBarItem':function(){
define([
	"dojo/_base/declare", // declare
	"./PopupMenuItem",
	"./MenuBarItem"
], function(declare, PopupMenuItem, MenuBarItem){

	// module:
	//		dijit/PopupMenuBarItem

	var _MenuBarItemMixin = MenuBarItem._MenuBarItemMixin;

	return declare("dijit.PopupMenuBarItem", [PopupMenuItem, _MenuBarItemMixin], {
		// summary:
		//		Item in a MenuBar like "File" or "Edit", that spawns a submenu when pressed (or hovered)
	});
});

},
'dijit/form/_FormMixin':function(){
define([
	"dojo/_base/array", // array.every array.filter array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(array, declare, kernel, lang, on, winUtils){

	// module:
	//		dijit/form/_FormMixin

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a `<form>` node or `dijit/form/Form` widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		// TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])


		_getDescendantFormWidgets: function(/*dijit/_WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features:
			//
			//		1. it will highlight any sub-widgets that are not valid
			//		2. it will call focus() on the first invalid sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
				return valid;
			}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				values = [].concat(values);
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w._get('value')) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 *	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
			});
			*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			//		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the defer(...) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

		isValid: function(){
			// summary:
			//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Deprecated method.   Applications no longer need to call this.   Remove for 2.0.
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			// TODO: rename for 2.0

			this._descendants = this._getDescendantFormWidgets();

			// To get notifications from children they need to be started.   Children didn't used to need to be started,
			// so for back-compat, start them here
			array.forEach(this._descendants, function(child){
				if(!child._started){ child.startup(); }
			});

			if(!inStartup){
				this._onChildChange();
			}
		},

		_onChildChange: function(/*String*/ attr){
			// summary:
			//		Called when child's value or disabled state changes

			// The unit tests expect state update to be synchronous, so update it immediately.
			if(!attr || attr == "state" || attr == "disabled"){
				this._set("state", this._getState());
			}

			// Use defer() to collapse value changes in multiple children into a single
			// update to my value.   Multiple updates will occur on:
			//	1. Form.set()
			//	2. Form.reset()
			//	3. user selecting a radio button (which will de-select another radio button,
			//		 causing two onChange events)
			if(!attr || attr == "value" || attr == "disabled" || attr == "checked"){
				if(this._onChangeDelayTimer){
					this._onChangeDelayTimer.remove();
				}
				this._onChangeDelayTimer = this.defer(function(){
					delete this._onChangeDelayTimer;
					this._set("value", this.get("value"));
				}, 10);
			}
		},

		startup: function(){
			this.inherited(arguments);

			// Set initial this.value and this.state.   Don't emit watch() notifications.
			this._descendants = this._getDescendantFormWidgets();
			this.value = this.get("value");
			this.state = this._getState();

			// Initialize value and valid/invalid state tracking.
			var self = this;
			this.own(
				on(
					this.containerNode,
					"attrmodified-state, attrmodified-disabled, attrmodified-value, attrmodified-checked",
					function(evt){
						if(evt.target == self.domNode){
							return;	// ignore events that I fire on myself because my children changed
						}
						self._onChildChange(evt.type.replace("attrmodified-", ""));
					}
				)
			);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.inherited(arguments);
		}

	});
});

},
'dijit/BackgroundIframe':function(){
define([
	"require",			// require.toUrl
	"./main",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/sniff" // has("ie"), has("trident"), has("quirks")
], function(require, dijit, config, domConstruct, domStyle, lang, on, has){

	// module:
	//		dijit/BackgroundIFrame

	// Flag for whether to create background iframe behind popups like Menus and Dialog.
	// A background iframe is useful to prevent problems with popups appearing behind applets/pdf files,
	// and is also useful on older versions of IE (IE6 and IE7) to prevent the "bleed through select" problem.
	// By default, it's enabled for IE6-10, excluding Windows Phone 8,
	// and it's also enabled for IE11 on Windows 7 and Windows 2008 Server.
	// TODO: For 2.0, make this false by default.  Also, possibly move definition to has.js so that this module can be
	// conditionally required via  dojo/has!bgIfame?dijit/BackgroundIframe
	has.add("config-bgIframe",
		(has("ie") && !/IEMobile\/10\.0/.test(navigator.userAgent)) || // No iframe on WP8, to match 1.9 behavior
		(has("trident") && /Windows NT 6.[01]/.test(navigator.userAgent)));

	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				// transparency needed for DialogUnderlay and for tooltips on IE (to see screen near connector)
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = document.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index shenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node).
		//
		//		Makes a background iframe as a child of node, that fills
		//		area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("config-bgIframe")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, "resize", node));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			//		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				this.iframe.parentNode.removeChild(this.iframe);
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'dijit/layout/TabController':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch lang.trim
	"./StackController",
	"../registry",
	"../Menu",
	"../MenuItem",
	"curam/inspection/Layer",
	"dojo/text!./templates/_TabButton.html",
	"curam/widget/_TabButton",
	"curam/widget/MenuItem",
	"dojo/i18n!../nls/common"
], function(declare, dom, domAttr, domClass, has, i18n, lang, StackController, registry, Menu, MenuItem, lm, template, CuramTabButton, CuramMenuItem){

    // module:
    // dijit/layout/TabController
        /* CURAM-FIX: Extend TabController to allow proper disabling of tab buttons. */

    /* CURAM-FIX: use our own _TabButton implementation. */
    var TabButton = CuramTabButton;
    /* END CURAM-FIX */

	if(has("dojo-bidi")){
		TabButton = declare("dijit.layout._TabButton", TabButton, {
		_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				this.applyTextDir(this.iconNode, this.iconNode.alt);
			}
		});
	}

	var TabController = declare("dijit.layout.TabController", StackController, {
		// summary:
		// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
		//		Used internally by `dijit/layout/TabContainer`.
		// description:
		//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
		//		TabController also monitors the TabContainer, and whenever a pane is
		//		added or deleted updates itself accordingly.
		// tags:
		//		private

		baseClass: "dijitTabController",

		templateString: "<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'></div>",

		// tabPosition: String
		//		Defines where tabs go relative to the content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		buttonWidget: TabButton,
		
		/* CURAM-FIX: added function */
		startup: function() {
		  this.inherited(arguments);

                  /* CURAM-FIX: When a new tab control button is added,
                   * connect a function that will remove the button when page
                   * is made invisible. */
                  this.connect(this, "onAddChild", function(page, insertIndex) {
                    var controller = this;
                    // store the page id for later use when positioning control buttons
                    page.controlButton._curamPageId = page.id;
                    // remove control button when the page is hiden,
                    // add it back when redisplayed
                    page.controlButton.connect(page.controlButton, "_setCuramVisibleAttr",
                        function() {
                          if (page.controlButton.curamVisible) {
                            // show button
                            // find the position at which to insert it
                            var actualChildIds = dojo.map(controller.getChildren(),
                                function(btn) { return btn._curamPageId; });
                            var tabWidgetId = curam.tab.getTabWidgetId(
                                curam.tab.getContainerTab(page.domNode));
                            var index = curam.util.TabNavigation.getInsertIndex(
                                tabWidgetId, actualChildIds, page.id);

                            // If the focus is currently on the tab that was last
                            // selected, set the resetFocus flag.
                            var resetFocus = false;
                            if (curam.util.getTopmostWindow().curam.util.tabButtonClicked && 
                               (document.activeElement === curam.util.getTopmostWindow().curam.util.tabButtonClicked)) {
                              resetFocus = true;
                            }

                            // and display it
                            controller.addChild(page.controlButton, index);
                            
                            // After the tab has been added to the controller,
                            // if the focus has moved away from the last selected
                            // tab and the resetFocus flag has been set, move the
                            // focus back to the tab.
                            if (resetFocus && (document.activeElement !== curam.util.getTopmostWindow().curam.util.tabButtonClicked)) {
                              curam.util.getTopmostWindow().curam.util.tabButtonClicked.focus();
                            }

                          } else {
                            // hide the button
                            var button = page.controlButton;
                            // only remove if not already removed
                            if (dojo.indexOf(controller.getChildren(), button) != -1) {
                              controller.removeChild(button);
                            }
                          }
                        });
                  });
                  /* END CURAM-FIX */
		},

		// buttonWidgetCloseClass: String
		//		Class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitTabCloseButton",

		postCreate: function(){
			this.inherited(arguments);
            /* CURAM-FIX Added inspection hookpoint */
			lm.register("dijit/layout/TabController", this);
			/* END CURAM-FIX */
			// Setup a close menu to be shared between all the closable tabs (excluding disabled tabs)
			var closeMenu = new Menu({
				id: this.id + "_Menu",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				targetNodeIds: [this.domNode],
				selector: function(node){
					return domClass.contains(node, "dijitClosable") && !domClass.contains(node, "dijitTabDisabled");
				}
			});
			this.own(closeMenu);
			
			var _nlsResources = i18n.getLocalization("dijit", "common"),
				controller = this;
			closeMenu.addChild(new MenuItem({
				label: _nlsResources.itemClose,
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				onClick: function(evt){
					var button = registry.byNode(this.getParent().currentTarget);
					controller.onCloseButtonClick(button.page);
				}
			}));
                        /* CURAM-FIX: addition */
                        //>>> addition next line had to add "dijit."
			var _nlsResourcesCuram = i18n.getLocalization("curam.application", "TabMenu"),
			closeAllMI = new CuramMenuItem({
                          onClickValue: "_onClickAll",
                          label: _nlsResourcesCuram["close.all.tabs.text"],
                          dir: this.dir,
                          lang: this.lang,
                          textDir: this.textDir,
                          onClick: function(evt){
                            this._onClickAll();
                          }
                          });
                        
                        closeMenu.addChild(closeAllMI);
                  /* END CURAM-FIX */


		},

                /* CURAM-FIX: addition */
                /**
                 * Called whenever one of my child buttons is pressed in an attempt to select a page.
                 * @private
                 */
                onButtonClick: function(/*dijit._Widget*/ page) {
                  if (!page.controlButton.get("curamDisabled")) {
                    var container = dijit.byId(this.containerId);
                    container.selectChild(page);
                  }
                }
                /* END CURAM-FIX */
	});

	TabController.TabButton = TabButton;	// for monkey patching

	return TabController;
});

},
'dijit/_MenuBase':function(){
define([
	"dojo/_base/array", // array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/mouse", // mouse.enter, mouse.leave
	"dojo/on",
	"dojo/window",
	"./a11yclick",
	"./registry",
	"./_Widget",
	"./_CssStateMixin",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(array, declare, dom, domAttr, domClass, lang, mouse, on, winUtils, a11yclick,
			registry, _Widget, _CssStateMixin, _KeyNavContainer, _TemplatedMixin){

	// module:
	//		dijit/_MenuBase

	return declare("dijit._MenuBase", [_Widget, _TemplatedMixin, _KeyNavContainer, _CssStateMixin], {
		// summary:
		//		Abstract base class for Menu and MenuBar.
		//		Subclass should implement _onUpArrow(), _onDownArrow(), _onLeftArrow(), and _onRightArrow().

		// selected: dijit/MenuItem
		//		Currently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.
		//		If a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if
		//		this Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because
		//		"selected" is not merely "hovered".
		selected: null,
		_setSelectedAttr: function(item){
			if(this.selected != item){
				if(this.selected){
					this.selected._setSelected(false);
					this._onChildDeselect(this.selected);
				}
				if(item){
					item._setSelected(true);
				}
				this._set("selected", item);
			}
		},

		// activated: [readonly] Boolean
		//		This Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,
		//		so mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the
		//		menu is not active (ie no dropdown) until an item is clicked.
		activated: false,
		_setActivatedAttr: function(val){
			domClass.toggle(this.domNode, "dijitMenuActive", val);
			domClass.toggle(this.domNode, "dijitMenuPassive", !val);
			this._set("activated", val);
		},

		// parentMenu: [readonly] Widget
		//		pointer to menu that displayed me
		parentMenu: null,

		// popupDelay: Integer
		//		After a menu has been activated (by clicking on it etc.), number of milliseconds before hovering
		//		(without clicking) another MenuItem causes that MenuItem's popup to automatically open.
		popupDelay: 500,

		// passivePopupDelay: Integer
		//		For a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause
		//		the popup to open.  Default is Infinity, meaning you need to click the menu to open it.
		passivePopupDelay: Infinity,

		// autoFocus: Boolean
		//		A toggle to control whether or not a Menu gets focused when opened as a drop down from a MenuBar
		//		or DropDownButton/ComboButton.   Note though that it always get focused when opened via the keyboard.
		autoFocus: false,

		childSelector: function(/*DOMNode*/ node){
			// summary:
			//		Selector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children
			//		like MenuSeparator.  If subclass overrides to a string (ex: "> *"), the subclass must require dojo/query.
			// tags:
			//		protected

			var widget = registry.byNode(node);
			return node.parentNode == this.containerNode && widget && widget.focus;
		},

		postCreate: function(){
			var self = this,
				matches = typeof this.childSelector == "string" ? this.childSelector : lang.hitch(this, "childSelector");
			this.own(
				on(this.containerNode, on.selector(matches, mouse.enter), function(){
					self.onItemHover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, mouse.leave), function(){
					self.onItemUnhover(registry.byNode(this));
				}),
				on(this.containerNode, on.selector(matches, a11yclick), function(evt){
					self.onItemClick(registry.byNode(this), evt);
					evt.stopPropagation();
				}),
				on(this.containerNode, on.selector(matches, "focusin"), function(){
					self._onItemFocus(registry.byNode(this));
				})
			);
			this.inherited(arguments);
		},

		onKeyboardSearch: function(/*MenuItem*/ item, /*Event*/ evt, /*String*/ searchString, /*Number*/ numMatches){
			// summary:
			//		Attach point for notification about when a menu item has been searched for
			//		via the keyboard search mechanism.
			// tags:
			//		protected
			this.inherited(arguments);
			if(!!item && (numMatches == -1 || (!!item.popup && numMatches == 1))){
				this.onItemClick(item, evt);
			}
		},

		_keyboardSearchCompare: function(/*dijit/_WidgetBase*/ item, /*String*/ searchString){
			// summary:
			//		Compares the searchString to the widget's text label, returning:
			//		-1: a high priority match and stop searching
			//		 0: no match
			//		 1: a match but keep looking for a higher priority match
			// tags:
			//		private
			if(!!item.shortcutKey){
				// accessKey matches have priority
				return searchString == item.shortcutKey.toLowerCase() ? -1 : 0;
			}
			return this.inherited(arguments) ? 1 : 0; // change return value of -1 to 1 so that searching continues
		},

		onExecute: function(){
			// summary:
			//		Attach point for notification about when a menu item has been executed.
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them, because they are about to execute the onClick handler.  In
			//		general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
			// summary:
			//		Attach point for notification about when the user cancels the current menu
			//		This is an internal mechanism used for Menus to signal to their parent to
			//		close them.  In general developers should not attach to or override this method.
			// tags:
			//		protected
		},

		_moveToPopup: function(/*Event*/ evt){
			// summary:
			//		This handles the right arrow key (left arrow key on RTL systems),
			//		which will either open a submenu, or move to the next item in the
			//		ancestor MenuBar
			// tags:
			//		private

			if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
				this.onItemClick(this.focusedChild, evt);
			}else{
				var topMenu = this._getTopMenu();
				if(topMenu && topMenu._isMenuBar){
					topMenu.focusNext();
				}
			}
		},

		_onPopupHover: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This handler is called when the mouse moves over the popup.
			// tags:
			//		private

			// if the mouse hovers over a menu popup that is in pending-close state,
			// then stop the close operation.
			// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)

			// highlight the parent menu item pointing to this popup (in case user temporarily moused over another MenuItem)
			this.set("selected", this.currentPopupItem);

			// cancel the pending close (if there is one) (in case user temporarily moused over another MenuItem)
			this._stopPendingCloseTimer();
		},

		onItemHover: function(/*MenuItem*/ item){
			// summary:
			//		Called when cursor is over a MenuItem.
			// tags:
			//		protected

			// Don't do anything unless user has "activated" the menu by:
			//		1) clicking it
			//		2) opening it from a parent menu (which automatically activates it)

			if(this.activated){
				this.set("selected", item);
				if(item.popup && !item.disabled && !this.hover_timer){
					this.hover_timer = this.defer(function(){
						this._openItemPopup(item);
					}, this.popupDelay);
				}
			}else if(this.passivePopupDelay < Infinity){
				if(this.passive_hover_timer){
					this.passive_hover_timer.remove();
				}
				this.passive_hover_timer = this.defer(function(){
					this.onItemClick(item, {type: "click"});
				}, this.passivePopupDelay);
			}

			this._hoveredChild = item;

			item._set("hovering", true);
		},

		_onChildDeselect: function(item){
			// summary:
			//		Called when a child MenuItem becomes deselected.   Setup timer to close its popup.

			this._stopPopupTimer();

			// Setup timer to close all popups that are open and descendants of this menu.
			// Will be canceled if user quickly moves the mouse over the popup.
			if(this.currentPopupItem == item){
				this._stopPendingCloseTimer();
				this._pendingClose_timer = this.defer(function(){
					this._pendingClose_timer = null;
					this.currentPopupItem = null;
					item._closePopup(); // this calls onClose
				}, this.popupDelay);
			}
		},

		onItemUnhover: function(/*MenuItem*/ item){
			// summary:
			//		Callback fires when mouse exits a MenuItem
			// tags:
			//		protected

			if(this._hoveredChild == item){
				this._hoveredChild = null;
			}

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
				this.passive_hover_timer = null;
			}

			item._set("hovering", false);
		},

		_stopPopupTimer: function(){
			// summary:
			//		Cancels the popup timer because the user has stop hovering
			//		on the MenuItem, etc.
			// tags:
			//		private

			if(this.hover_timer){
				this.hover_timer = this.hover_timer.remove();
			}
		},

		_stopPendingCloseTimer: function(){
			// summary:
			//		Cancels the pending-close timer because the close has been preempted
			// tags:
			//		private
			if(this._pendingClose_timer){
				this._pendingClose_timer = this._pendingClose_timer.remove();
			}
		},

		_getTopMenu: function(){
			// summary:
			//		Returns the top menu in this chain of Menus
			// tags:
			//		private
			for(var top = this; top.parentMenu; top = top.parentMenu){}
			return top;
		},

		onItemClick: function(/*dijit/_WidgetBase*/ item, /*Event*/ evt){
			// summary:
			//		Handle clicks on an item.
			// tags:
			//		private

			if(this.passive_hover_timer){
				this.passive_hover_timer.remove();
			}

			this.focusChild(item);

			if(item.disabled){
				return false;
			}

			if(item.popup){
				this.set("selected", item);
				this.set("activated", true);
				var byKeyboard = /^key/.test(evt._origType || evt.type) ||
					(evt.clientX == 0 && evt.clientY == 0);	// detects accessKey like ALT+SHIFT+F, where type is "click"
				this._openItemPopup(item, byKeyboard);
			}else{
				// before calling user defined handler, close hierarchy of menus
				// and restore focus to place it was when menu was opened
				this.onExecute();

				// user defined handler for click
				item._onClick ? item._onClick(evt) : item.onClick(evt);
			}
		},

		_openItemPopup: function(/*dijit/MenuItem*/ from_item, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath the current menu item, and optionally focus first item
			// tags:
			//		protected

			if(from_item == this.currentPopupItem){
				// Specified popup is already being shown, so just return
				return;
			}
			if(this.currentPopupItem){
				// If another popup is currently shown, then close it
				this._stopPendingCloseTimer();
				this.currentPopupItem._closePopup();
			}
			this._stopPopupTimer();

			var popup = from_item.popup;
			popup.parentMenu = this;

			// detect mouseover of the popup to handle lazy mouse movements that temporarily focus other menu items\c
			this.own(this._mouseoverHandle = on.once(popup.domNode, "mouseover", lang.hitch(this, "_onPopupHover")));

			var self = this;
			from_item._openPopup({
				parent: this,
				orient: this._orient || ["after", "before"],
				onCancel: function(){ // called when the child menu is canceled
					if(focus){
						// put focus back on my node before focused node is hidden
						self.focusChild(from_item);
					}

					// close the submenu (be sure this is done _after_ focus is moved)
					self._cleanUp();
				},
				onExecute: lang.hitch(this, "_cleanUp", true),
				onClose: function(){
					// Remove handler created by onItemHover
					if(self._mouseoverHandle){
						self._mouseoverHandle.remove();
						delete self._mouseoverHandle;
					}
				}
			}, focus);

			this.currentPopupItem = from_item;

			// TODO: focusing a popup should clear tabIndex on Menu (and it's child MenuItems), so that neither
			// TAB nor SHIFT-TAB returns to the menu.  Only ESC or ENTER should return to the menu.
		},

		onOpen: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback when this menu is opened.
			//		This is called by the popup manager as notification that the menu
			//		was opened.
			// tags:
			//		private

			this.isShowingNow = true;
			this.set("activated", true);
		},

		onClose: function(){
			// summary:
			//		Callback when this menu is closed.
			//		This is called by the popup manager as notification that the menu
			//		was closed.
			// tags:
			//		private

			this.set("activated", false);
			this.set("selected", null);
			this.isShowingNow = false;
			this.parentMenu = null;
		},

		_closeChild: function(){
			// summary:
			//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
			// tags:
			//		private
			this._stopPopupTimer();

			if(this.currentPopupItem){
				// If focus is on a descendant MenuItem then move focus to me,
				// because IE doesn't like it when you display:none a node with focus,
				// and also so keyboard users don't lose control.
				// Likely, immediately after a user defined onClick handler will move focus somewhere
				// else, like a Dialog.
				if(this.focused){
					domAttr.set(this.selected.focusNode, "tabIndex", this.tabIndex);
					this.selected.focusNode.focus();
				}

				// Close all popups that are open and descendants of this menu
				this.currentPopupItem._closePopup();
				this.currentPopupItem = null;
			}
		},

		_onItemFocus: function(/*MenuItem*/ item){
			// summary:
			//		Called when child of this Menu gets focus from:
			//
			//		1. clicking it
			//		2. tabbing into it
			//		3. being opened by a parent menu.
			//
			//		This is not called just from mouse hover.

			if(this._hoveredChild && this._hoveredChild != item){
				this.onItemUnhover(this._hoveredChild);	// any previous mouse movement is trumped by focus selection
			}
			this.set("selected", item);
		},

		_onBlur: function(){
			// summary:
			//		Called when focus is moved away from this Menu and it's submenus.
			// tags:
			//		protected

			this._cleanUp(true);
			this.inherited(arguments);
		},

		_cleanUp: function(/*Boolean*/ clearSelectedItem){
			// summary:
			//		Called when the user is done with this menu.  Closes hierarchy of menus.
			// tags:
			//		private

			this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
			if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
				this.set("activated", false);
			}

			if(clearSelectedItem){
				this.set("selected", null);
			}
		}
	});
});

},
'curam/ModalUIMController':function(){
/*
   * Licensed Materials - Property of IBM
   *
   * Copyright IBM Corporation 2012-2014. All Rights Reserved.
   *
   * US Government Users Restricted Rights - Use, duplication or disclosure
   * restricted by GSA ADP Schedule Contract with IBM Corp.
   */

    /*
     * Modification History
     * --------------------
     * 24-Feb-2015  AZ [CR00458302] Load ModalUIMController.html template 
     *                          instead of static string
     * 05-Nov-2014  MV [CR00448634] Fixed template inclusion, removed obsolete
     * 22-Sep-2014  SK [CR00445339] Added inspection layer integration.
     * 14-Jul-2014 AS [CR00430056] Added role presentation to end of modal span.
     * 20-Feb-2014  AS [CR00414442] Added a method to be called on key down event of
     *                              end of modal span. This method sets the focus on help 
     *                              icon of modal title while doing tab navigation.   
     * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
     *                include required bundle. 
     * 13-Mar-2013  AF  [CR00373989]  Initial Version.
     */

  define(["dojo/text!curam/layout/resources/ModalUIMController.html",
          "dojo/_base/declare",
  	  "dojo/parser",
  	  "curam/inspection/Layer",
          "curam/UIMController",
          "curam/debug",
          "curam/util/onLoad"], function(template, declare, parser, layer, uimController) {
    
    /**
     * @name curam.ModalUIMController
     * @namespace Create and manage a widget that controls an IFRAME that is known
     * to load UIM pages in modal. The controller will handle official communications
     * from the modal IFRAME to the parent window using the event system.
     * This will bridge the gap created by security restrictions that stop parent
     * windows manipulating the content of IFRAMES they control.
     */
    
    var ModalUIMController = declare("curam.ModalUIMController",
          [uimController],
    /**
     * @lends curam.ModalUIMController.prototype
     */
    {    
      /**
       * This text is hidden, but is picked up by a screen reader. Indicates the start of a modal.
       */
      startModalUIMController: LOCALISED_ACCESSIBILITY_MODAL_START,
      
      /**
       * This text is hidden, but is picked up by a screen reader. Indicates the end of a modal.
       */
      endModalUIMController: LOCALISED_ACCESSIBILITY_MODAL_END,
      
      templateString: template,
      
      constructor: function(args) {
        layer.register("curam/ModalUIMController", this);    
      }
    });

    return ModalUIMController;
  });

},
'dijit/layout/ScrollingTabController':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/fx", // Animation
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/query", // query
	"dojo/dom-attr",
	 "curam/debug",
	"dojo/sniff", // has("ie"), has("webkit"), has("quirks")
	"../registry",	// registry.byId()
	"dojo/text!./templates/ScrollingTabController.html",
	"dojo/text!./templates/_ScrollingTabControllerButton.html",
	"./TabController",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_WidgetsInTemplateMixin",
	"../Menu",
	"../MenuItem",
	"../form/Button",
	"../_HasDropDown",
	"dojo/NodeList-dom", // NodeList.style
	"../a11yclick"	// template uses ondijitclick (not for keyboard support, but for responsive touch support)
], function(array, declare, domClass, domGeometry, domStyle, fx, lang, on, query, domattr, debug, has,
	registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin,
	Menu, MenuItem, Button, _HasDropDown){

// module:
//		dijit/layout/ScrollingTabController

/* CURAM-FIX: Performance fixes and extension to support for disabling and hiding tabs */

var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	baseClass: "dijitTabController dijitScrollingTabController",

	templateString: tabControllerTemplate,

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	// Override default behavior mapping class to DOMNode
	_setClassAttr: { node: "containerNode", type: "class" },
	
       /* CURAM-FIX: added class member variable */
	_tabsWidth: -1,

	/* CURAM-FIX: added class member variable */
       _tablistMenuItemIdSuffix: "_stcMi",


	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
       domClass.add(n, "tabStrip-disabled");
		}

		domClass.add(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// TabController is hidden until it finishes drawing, to give
		// a less visually jumpy instantiation.   When it's finished, set visibility to ""
		// to that the tabs are hidden/shown depending on the container's visibility setting.

		/* CURAM-FIX: don't touch visibility - this is slow in IE7
		 * this goes with a change in the HTML template, which now doesn't set
		 * visibility: hidden */
		// domStyle.set(this.domNode, "visibility", "");

		this._postStartup = true;

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
      this.own(on(this.containerNode, "attrmodified-label, attrmodified-iconclass",
        lang.hitch(this,
          function(evt){
				if(this._dim){
					this.resize(this._dim);
				}
		                       
				/* CURAM-FIX: addition */
		                          // When a label is changed, the size cache should be invalidated
		                          this.bustSizeCache = true;
		                          this._tabsWidth = -1;
		                          // Clear the cached width of a button
				evt.detail.widget.domNode._width = 0;
				/* END CURAM-FIX */
				
			})));
		},

		onAddChild: function(page, insertIndex){
			this.inherited(arguments);

                        /* CURAM-FIX: addition */
                        var pageID = page.id;
                        // When a child is added, the size cache should be invalidated
                        this.bustSizeCache = true;
                        this._tabsWidth = -1;
                        /* END CURAM-FIX */			

		/* CURAM-FIX: addition to enable tab hiding/disabling
		 * because this function has been created as a local variable, "this" has
		 * to be passed as a parameter. See calls to getMenuItem below.
		 * TODO: why was this created as a local variable? Can the function be
		 * attached to the class? Or should we hitch it in the class below?
		 * For now, "this" will be supplied as a parameter. Lowest risk change.
		 */
		    var getMenuItem = function(pid, theRealThis) {
		      var menuItem = null;
		      if (theRealThis._menuBtn.dropDown) {
		        var menuItemNode = dojo.query(pid + theRealThis._tablistMenuItemIdSuffix,
		            theRealThis._menuBtn.dropDown.domNode)[0];
		        if (menuItemNode) {
		          menuItem = dijit.byNode(menuItemNode);
		        }
		      }
		      return menuItem;
		    };

		    // update the menuItem visibility when the button visibility is updated
		    this.pane2button(pageID).connect(this.pane2button(pageID), "_setCuramVisibleAttr",
		      lang.hitch(this, function() {
		        var menuItem = getMenuItem(pageID, this);
		        if(menuItem) {
		          this._setCuramVisibility(menuItem, pageID);
		        }
		      }));

		    // update the menuItem availability when the button availability is updated
      this.pane2button(pageID).connect(this.pane2button(pageID), "_setCuramDisabledAttr",
        lang.hitch(this,
          function() {
		      // getMenuItem
		      var menuItem = getMenuItem(pageID, this);
		      if(menuItem) {
		        this._setCuramAvailability(menuItem, pageID);
		      }
		    }));
		/* END CURAM-FIX */


		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		domStyle.set(this.containerNode, "width",
			(domStyle.get(this.containerNode, "width") + 200) + "px");
		this.containerNode._width = 0; //  Invalidate the cached width of the wrapper
	},

	/* CURAM-FIX: added functions needed by Curam specific code */    
	_setCuramVisibility: function(menuItem, pageId) {
	      var visible = this.pane2button(pageId).curamVisible;
	      if (visible) {
	        dojo.replaceClass(menuItem.domNode, "visible", "hidden");
	      } else {
	        dojo.replaceClass(menuItem.domNode, "hidden", "visible");
	      }
	    },

	    _setCuramAvailability: function(menuItem, pageId) {
	      var enabled = !this.pane2button(pageId).curamDisabled;
	          menuItem.disabled = !enabled;
	          if (enabled) {
	            dojo.replaceClass(menuItem.domNode, "enabled", "disabled");

	          } else {
	            dojo.replaceClass(menuItem.domNode, "disabled", "enabled");
	          }
	     },
	    
	    /**
	     * Checks if we have cached the width for this node, and returns it if so
	     * Otherwise measures the width.
	     * @param node The node to measure.
	     * @returns The node width.
	     */
	    _getNodeWidth: function(node) {
	      if(!node._width){
	        node._width = domStyle.get(node, "width");
	      }
	      return node._width;
	    },

	    destroyRendering: function(preserveDom) {
      array.forEach(this._attachPoints,
        function (point) {
	        delete this[point];
        },
        this);
	      this._attachPoints = [];
	      array.forEach(this._attachEvents, this.disconnect, this);
	      this.attachEvents = [];
	    },
	    
	    destroy: function() {
	      if (this._menuBtn) {
	        this._menuBtn._curamOwnerController = null;
	      }
	      
	      this.inherited(arguments);
	    },
	/* END CURAM-FIX */
	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
			var button = this.pane2button(page.id);
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
			
		/* CURAM-FIX: addition */
		// When a child is removed, the size cache should be invalidated
		this.bustSizeCache = true;
		this._tabsWidth = -1;
		/* END CURAM-FIX */
			
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		/* CURAM-FIX: subscription to the tab title setting event to adjust the tab 
		   scroll buttons subsequently */
		this.subscribe("tab.title.name.finished", this._measureBtns);
		/* END CURAM-FIX */
		this._btnWidth = 0;
      this._buttons =
        query("> .tabStripButton", this.domNode).filter(
          function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
		                /* CURAM-FIX: replace next line to use getMarginBoxSimple() */
                                // this._btnWidth += domGeometry.getMarginSize(btn).w;
		                this._btnWidth += domGeometry.getMarginBoxSimple(btn).w;
		            //set node title
		                domattr.set(this._menuBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navMenu.title"));
		                
		           //role presentation for menuBtn
		                domattr.set(this._menuBtn, "role", "presentation");
		                
		          //sets tabindex attribute for the menuBtn
		              domattr.set(this._menuBtn, "tabindex", 0);
		                
		        return true;
				
			}else{
				domStyle.set(btn, "display", "none");
				return false;
			}
		}, this);
		/* CURAM-FIX: addition next line */
	      this._menuBtn._curamOwnerController = this;
	},
		  
	_getTabsWidth: function(){
	      /* CURAM-FIX: addition */
	      if(this._tabsWidth > -1){
	        return this._tabsWidth;
	      }
	      /* END CURAM-FIX */
	      
		var children = this.getChildren();
		if(children.length){
			var /* CURAM-FIX: comment this out: leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode, */
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			/* CURAM-FIX: comment out the next line and replace with the next addition
                         * to remove one call to leftTab.offsetLeft */
			// return rightTab.offsetLeft + domStyle.get(rightTab, "width") - leftTab.offsetLeft;
			var rightWidth = this._getNodeWidth(rightTab);
			if(this.isLeftToRight()){	                
	                this._tabsWidth = rightTab.offsetLeft + rightWidth;
			}else{
				var leftTab = children[children.length - 1].domNode;
		    	this._tabsWidth = rightTab.offsetLeft + rightWidth - leftTab.offsetLeft;
			}
	                return this._tabsWidth;
	                /* END CURAM-FIX */
			
		}else{
			return 0;
		}
	},


	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || domStyle.get(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	/* CURAM-FIX: additional method to re-measure tab controller to
    adjust tab scroll buttons	*/
	_measureBtns: function() {
      // summary:
	  // triggers controller size adjustment following tab name set to
	  // draw tab scrolling buttons once the correct width value is known.
	  if (this._enableBtn() && this._rightBtn.domNode.style.display == "none") {
	    this.resize(this._dim);
	    if (this.isLeftToRight()) {
	      this._rightBtn.set("disabled", true);
	    } else {
	      this._leftBtn.set("disabled", true);
		}
      }
	},
	/* END CURAM-FIX */

	/* CURAM-FIX: IE7 related optimizations to code around using the expensive
         * offsetWidth/offsetHeight calls
         */
	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

    	      /* CURAM-FIX: addition - If there are no children, just hide the tab bar */
    	      if(dojo.query("> *", this.containerNode).length < 1){
    	        if(this.domNode.style.height != "1px"){
    	          domStyle.set(this.domNode, "height", "1px");
    	        }
    	        return;
    	      }
    	      // If the width is the same, do nothing
    	      if(!this.bustSizeCache && this._dim && dim && this._dim.w == dim.w){
    	        return;
    	      }
    	      this.bustSizeCache = false;
    
    	      // curam.debug.log(bundle.getProperty("curam.dojo-hacks.msg"), this.domNode);
    	      this.scrollNodeHeight = this.scrollNodeHeight || this.scrollNode.offsetHeight;
    	      /* END CURAM_FIX */

	      // Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		/* CURAM-FIX: replace expensive call to offsetHeight */
                // cb.h = this.scrollNode.offsetHeight;
		cb.h = this.scrollNodeHeight;
		domGeometry.setContentSize(this.domNode, cb);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
			this._leftBtn.region = "left";
			this._rightBtn.region = "right";
			this._menuBtn.region = this.isLeftToRight() ? "right" : "left";
		  // set node title
		      domattr.set(this._leftBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navLeft.title"));
		 // set node title
		      domattr.set(this._rightBtn, "title", debug.getProperty("dijit.layout.ScrollingTabController.navRight.title"));
		    
		 //role presentation for the Navigation right button
		      domattr.set(this._rightBtn, "role", "presentation");
		    
		 //role presentation for the Navigation left button
		      domattr.set(this._leftBtn, "role", "presentation");
		      
		/* CURAM-FIX: replace the following statement*/ 
                //layoutUtils.layoutChildren(this.domNode, this._contentBox,
                  // [this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

                // fakeWidget property tells the layout code not to bother updating
	        // this JSON object with the widget size
	        var childDims;
	        if(enable){
	          childDims = dijit.layout.utils.layoutChildren(this.domNode, this._contentBox,
	            [this._menuBtn, this._leftBtn, this._rightBtn,
	             {domNode: this.scrollNode, layoutAlign: "client", fakeWidget: true}]);
	        } else {
	          childDims = dijit.layout.utils.layoutChildren(this.domNode, this._contentBox,
	            [{domNode: this.scrollNode, layoutAlign: "client", fakeWidget: true}]);
	        }
	        this.scrollNode._width = childDims.client.w;
	        /* END CURAM-FIX */

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());

		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},


	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
      return (this.isLeftToRight() || has("ie") < 8 || (has("trident") && has("quirks")) || has("webkit"))
               ? this.scrollNode.scrollLeft
               : domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width")
                   + (has("trident") || has("edge") ? -1 : 1) * this.scrollNode.scrollLeft;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
      if(this.isLeftToRight() || has("ie") < 8 || (has("trident") && has("quirks")) || has("webkit")){
			return val;
		}else{
			var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
        return (has("trident") || has("edge") ? -1 : 1) * (val - maxScroll);
		}
	},

	/* CURAM-FIX: Overriding this method to skip getting the scroll position
         * which can be expensive */
    onSelectChild: function(/*dijit._Widget*/ page, /*Boolean*/ tabContainerFocused){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

			var tab = this.pane2button(page.id);
			if(!tab){
				return;
			}

		var node = tab.domNode;

		// Save the selection
		if(node != this._selectedTab){
			this._selectedTab = node;

			// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
			if(this._postResize){
				/* CURAM-FIX: addition Curam customized this to skip getting the scroll if not required */
				var scrollNodeWidth = this._getNodeWidth(this.scrollNode);
				if(this._getTabsWidth() < scrollNodeWidth){
                                    tab.onClick(null);
                                    /* CURAM-FIX rtc231858 focus required for screen readers */
                                    tab.focus();
                                    /* END CURAM-FIX  focus required for screen readers */
				} else {
					/* END CURAM-FIX */
					var sl = this._getScroll();

					if(sl > node.offsetLeft ||
							/* CURAM-FIX: replace following line */
							// sl + domStyle.get(this.scrollNode, "width") <
							sl + scrollNodeWidth <
							/* CURAM-FIX: replace following line */
							// node.offsetLeft + domStyle.get(node, "width")){
							node.offsetLeft + this._getNodeWidth(node)) {
								//this.createSmoothScroll().play(); older version
								var anim = this.createSmoothScroll();
								if(tabContainerFocused){
									anim.onEnd = function(){
										// Focus is on hidden tab or previously selected tab label.  Move to current tab label.
										tab.focus();
									};
								}
								anim.play();
					} else if(tabContainerFocused){
						// Focus is on hidden tab or previously selected tab label.  Move to current tab label.
						tab.focus();
					}
					/* CURAM-FIX: addition */
				}
				/* END CURAM-FIX */
			}
		}
		this.inherited(arguments);
		/**
		 * Keep track that the user is navigating through tabs in the navigation tab. 
		 * The tab button will be used by the doSetFocus to keep the focus on the 
		 * tab button instead of focusing on the first editable field.
		 * **/
		var tabButton = document.activeElement;
		if (typeof tabButton !== 'undefined' && tabButton != null) {
		  if (tabButton.className == "tabLabel" && (query(tabButton).closest(".nav-panel")).length > 0) {
			  curam.util.setTabButtonClicked(tabButton);
		  }
		}
	},


	/* CURAM-FIX: Overriding this method to stop using offsetLeft and dojo.style calls
         * which can be expensive.
         */
	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			/* CURAM-FIX: replace the style call in next two lines by faster function */
		        // scrollNodeWidth = domStyle.get(this.scrollNode, "width"),		// about 500px
			// containerWidth = domStyle.get(this.containerNode, "width"),	// 50,000px
		        scrollNodeWidth = this._getNodeWidth(this.scrollNode),     // about 500px
		        containerWidth = this._getNodeWidth(this.containerNode),   // 50,000px
		        /* END CURAM-FIX */
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				//There is a padding of 10px at right of tabs list. See ".rtl .soria .appTabContainer .dijitTabContainerTop-tabs"
				//  in \TIVOB\client\CoreInf\CuramCDEJ\lib\curam\web\themes\soria_rtl\css\ApplicationTabContainer_rtl.css
				//  This padding is not included in the calculations. So, Decrease the minimum scroll value here.
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,  // 10px for padding of the wrapper
	                        /* CURAM-FIX: replace following line */      
				//max: this.isLeftToRight() ?
               //  children[children.length-1].domNode.offsetLeft + domStyle.get(children[children.length-1].domNode, "width")) - scrollNodeWidth :
				//	maxPossibleScroll
		                max: this.isLeftToRight() ? tabsWidth - scrollNodeWidth : maxPossibleScroll 
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},


	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
			var pos = (n.offsetLeft + domStyle.get(n, "width") / 2) - scrollNodeWidth / 2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new fx.Animation({
				beforeBegin: function(){
						if(this.curve){
							delete this.curve;
						}
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new fx._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

			return anim; // dojo/_base/fx/Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !domClass.contains(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
			this.doSlide(-1, this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
			//		If the direction is 1, the widget scrolls to the right, if it is -1,
			//		it scrolls to the left.

			if(node && domClass.contains(node, "dijitTabDisabled")){
				return;
			}

		var sWidth = domStyle.get(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: buttonTemplate,

		// Override inherited tabIndex: 0 from dijit/form/Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
		isFocusable: function(){
			return false;
		}
	});

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerButton", [Button, ScrollingTabControllerButtonMixin]);

	// Class used in template
	declare("dijit.layout._ScrollingTabControllerMenuButton", [Button, _HasDropDown, ScrollingTabControllerButtonMixin], {
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new Menu({
			id: this.containerId + "_menu",
				ownerDocument: this.ownerDocument,
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		});
		var container = registry.byId(this.containerId);
      array.forEach(container.getChildren(),
        function(page){
          var menuItem =
            new MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
					disabled: page.disabled,
					ownerDocument: this.ownerDocument,
				dir: page.dir,
				lang: page.lang,
					textDir: page.textDir || container.textDir,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		
		/* CURAM-FIX: set the right visibility and availability
		 * on newly loaded menu items
		 */
      dojo.forEach(this.dropDown.getChildren(),
          lang.hitch(this,
              function(menuItem) {
                  var pageId = menuItem.id.split(
                      this._curamOwnerController._tablistMenuItemIdSuffix)[0];
                      this._curamOwnerController._setCuramAvailability(menuItem, pageId);
                      this._curamOwnerController._setCuramVisibility(menuItem, pageId);
                      dojo.connect(menuItem, "destroy", function() {
                        setDynState = null;
                      });
                }));		      
		/* END CURAM-FIX */
		
		callback();
	},


	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
				this._popupStateNode.removeAttribute("aria-owns");	// remove ref to node that we are about to delete
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

return ScrollingTabController;
});

},
'curam/core-uim':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 25-Oct-2012 MV [CR00347765] Remove extraneous dependency to save load time.
 * 23-Oct-2012 MV [CR00347543] Remove dependency on UIController, remove
 *    duplicate dependencies, add missing dependency.
 * 07-Sep-2012 MV [CR00339639] Initial version.
 */ 

 /**
 * This is the top level Cram module that pre-loads a number of modules
 * commonly used by UIM pages.
 * 
 * FIXME: This is a workaround - we should "require" the modules where they are
 * needed, but this will need a trawl through all code to identify
 * and add necessary require statements.
 *
 */
define([
        "cm/_base/_dom",
        "cm/_base/_form",
        "cm/_base/_pageBehaviors",
        "curam/util",
        "curam/date",
        "curam/validation",
        "curam/util/ScreenContext",
        "curam/util/onLoad",
        "curam/ui/UIMPageAdaptor",
        "curam/util/ExpandableLists",
        "curam/util/Refresh",
        "curam/omega3-util",
        "dijit/layout/ContentPane",
        "curam/layout/TabContainer",
        "curam/inPageNavigation"
        ], function() {
  // empty - just to pre-load the above modules
});

},
'dijit/form/_ListMouseMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/touch",
	"./_ListBase"
], function(declare, on, touch, _ListBase){

	// module:
	//		dijit/form/_ListMouseMixin

	return declare("dijit.form._ListMouseMixin", _ListBase, {
		// summary:
		//		A mixin to handle mouse or touch events for a focus-less menu
		//		Abstract methods that must be defined externally:
		//
		//		- onClick: item was chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		// tags:
		//		private

		postCreate: function(){
			this.inherited(arguments);

			// Add flag to use normalized click handling from dojo/touch
			this.domNode.dojoClick = true;

			this._listConnect("click", "_onClick");
			this._listConnect("mousedown", "_onMouseDown");
			this._listConnect("mouseup", "_onMouseUp");
			this._listConnect("mouseover", "_onMouseOver");
			this._listConnect("mouseout", "_onMouseOut");
		},

		_onClick: function(/*Event*/ evt, /*DomNode*/ target){
			this._setSelectedAttr(target, false);
			if(this._deferredClick){
				this._deferredClick.remove();
			}
			this._deferredClick = this.defer(function(){
				this._deferredClick = null;
				this.onClick(target);
			});
		},

		_onMouseDown: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			this._isDragging = true;
			this._setSelectedAttr(target, false);
		},

		_onMouseUp: function(/*Event*/ evt, /*DomNode*/ target){
			this._isDragging = false;
			var selectedNode = this.selected;
			var hoveredNode = this._hoveredNode;
			if(selectedNode && target == selectedNode){
				this.defer(function(){
					this._onClick(evt, selectedNode);
				});
			}else if(hoveredNode){ // drag to select
				this.defer(function(){
					this._onClick(evt, hoveredNode);
				});
			}
		},

		_onMouseOut: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._hoveredNode){
				this.onUnhover(this._hoveredNode);
				this._hoveredNode = null;
			}
			if(this._isDragging){
				this._cancelDrag = (new Date()).getTime() + 1000; // cancel in 1 second if no _onMouseOver fires
			}
		},

		_onMouseOver: function(/*Event*/ evt, /*DomNode*/ target){
			if(this._cancelDrag){
				var time = (new Date()).getTime();
				if(time > this._cancelDrag){
					this._isDragging = false;
				}
				this._cancelDrag = null;
			}
			this._hoveredNode = target;
			this.onHover(target);
			if(this._isDragging){
				this._setSelectedAttr(target, false);
			}
		}
	});
});

},
'curam/util/Constants':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["curam/define"
        ], function() {
  
  /*
   * Modification History
   * --------------------
   * 05-Jul-2011  KW  [CR00275353] Initial version
   */

  /**
   * Maintains a list of parameter name constants. 
   */
  curam.define.singleton("curam.util.Constants", {
    RETURN_PAGE_PARAM: "__o3rpu"
  });
  
  return curam.util.Constants;
});

},
'curam/tab/TabSessionManager':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------  
 * 10-Jan-2023  AT [SPM-126441] Autorecovery: fix timing for publish of restoreModal message.
 * 07-Jan-2023 BOS [SPM-126610] Added call to set the inlined tab action menu items
 * to be displayed so that the surplus ones will be hidden in overflow menu, when tab
 * selected.
 * 13-Dec-2022  AT [SPM-126244] Autorecovery: handle recovery of sections without tabs.
 * 29-Nov-2022  COC [SPM-125684] Updates for the multi browser tab flows.
 * 22-Nov-2022  AT  [SPM-126184] Autorecovery: restore modal only after iframe content has loaded.
 * 08-Nov-2022  COC [SPM-125563] Added the auto recovery enabled condition around the _restoreModal.
 * 26-Aug-2022  COC [SPM-125576] Auto recovery to include the restore modal.
 * 14-Jun-2022  BOS [RTC278134] Adding configuration for maximum timeout for spinner.
 * 09-Jun-2022  CM  [RTC277941]  Update the _isNewSession code to return false for browser refresh.
 * 09-Mar-2022  CM  [RTC276771]  Check if application was reloaded from changing user locale (SessionStorage localeRefresh)
 * 22-Oct-2019  CMC [RTC251184]  Ensure a Word File Edit widget dialog is never stored in tab session.
 * 23-Aug-2018  BD  [RTC229425]  Included publish to alert the tabwiget selected.
 * 31-Aug-2016  CMC [170373]     Added configuration properties for Progress Widget.
 * 24-Aug-2015  AB  [CR00465809] Dynamic browser tab titles.
 * 17-Aug-2015  AZ  [CR00465620] Set tab order behavior from JSON object.
 * 12-Sep-2014  MV  [CR00444603] Replace dojox/storage with HTML5 local storage.  
 * 28-Sep-2013  BOS [CR00396277] Modified _connectSelectionListeners function to
 *                    ensure an undefined tab container handled correctly.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 11-Sep-2012  MV  [CR00339639] Do not declare dependency on a dijit class
 *              to save time. Use local storage API from topmost window to avoid
 *              loading storage for every page.
 * 23-Aug-2012  BOS [CR00338361] Enabling support to set a maximum number of
 *                    tabs that can be open in an application.
 * 22-Feb-2012  KW  [TEC-9557]  When JSESSIONID is not available, it is always
 *                  presumed to be a new session.
 * 07-Feb-2012  MV  [CR00301458] Code cleanup - added missing semicolon.
 * 14-Dec-2011  KW  [TEC-8648]  Directly accessed URLs are now handled during
 *                              _restoreTabSession().
 * 26-Jan-2011  MV  [CR00244801] Fixed check for DEBUG flag.
 * 17-Jan-2011  PK  [CR00242982] Added error handling when the user home page
 *                    has not been configured correctly.
 * 15-Jan-2011  DG  [CR00242400] Wrapped local storage calls with utility method
 *                    that ensures proper storage initialization (I think).
 *                    Record selected tab when section is changed. Removed most
 *                    "requires", as they are handled by "cdej.js".
 * 12-Jan-2011  DG  [CR00238642] Added note to acknowledge that unnecessary
 *                    update events occur when the tab session is restored.
 * 17-Dec-2010  DG  [CR00239200] Fix to avoid losing the recorded selection.
 * 20-Aug-2010  DG  [CR00217921] Rewrote almost everything.
 * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
 *                    tab-app-controller.js and tab-app-common.js.
 * 23-Jun-2010  PK  [CR00203531] Updates due to new "page linking"
 *                    infrastructure to handle applications and sections.
 * 08-Dec-2009  MV  [CR00181267] Take on dojo v 1.4 - fix issues
 * 06-Nov-2009  SC  [CR00172239] Initial Version
 */

define([
/* The following dependencies are commented out and left in place intentionally.
 * For performance reasons they are preloaded elsewhere, but this module still
 * depends on them, so this is why I prefer to leave them in place. They will
 * be uncommented again in future. */
        /* "dojox/encoding/digests/SHA1", */
        /*"dojox/layout/ContentPane"*/
        "dojo/_base/declare",
        "curam/debug",
        "curam/tab",
        "curam/util/AutoRecoveryAPI"
        ], function(declare, debug, tab, autoRecovery) {

/**
 * <p>
 * The tab session manager handles the list of open tabs. This includes picking
 * up when a new tab is created, a tab is updated or a tab is removed. It also
 * includes handling when a refresh even happens. Tabs are always represented
 * using a <code>curam.tab.TabDescriptor</code> object. See that class for
 * information about how tabs are represented.
 * </p>
 * <p>
 * One complication that the tab session manager has to deal with is the state
 * when there is no tab session to be restored. In this case, a tab descriptor
 * representing the user's home page is created and that is used as tab session
 * to be restored.
 * </p>
 * <p>
 * Sections are handled relatively transparently. The <code>UIController</code>
 * will add tabs to the correct section. The only contribution of the tab
 * session manager is to ensure that the correct tab in the correct section is
 * selected on restoration.
 * </p>
 * <p>
 * Except for the selected tab, tabs are opened in the background. Dojo's
 * content pane will only load the content of these background tabs when they
 * are selected by the user and brought into the foreground.
 * </p>
 */
  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  var TabSessionManager = declare("curam.tab.TabSessionManager", null, {
  /**
   * Determine if there are tabs already listed in the session and if so, open
   * them. If not, determine the open page and open it.
   */
  init: function(directBrowseURL) {
    // The ClientDataAccessor "getRaw" method will call back either to
    // "restoreTabSession" on success or to "handleGetTabFailure" on failure.
    // The "hitch" ensures that the call-back operates on the right object.
    if (directBrowseURL) {
      this._directBrowseURL = directBrowseURL;
    }
    new curam.ui.ClientDataAccessor().getRaw("/data/tab/get",
      dojo.hitch(this, this._restoreTabSession),
      dojo.hitch(this, this._handleGetTabFailure));
  },

  /**
   * If cannot get the list of tabs, most likely that the server is down. Output
   * an error message. Note: This is for IE only, as the result when a server is
   * down in Firefox is a 404 error.
   *
   * @param error The JavaScript Error object
   * @param ioargs Detailed information on the xhr request.
   *
   * @private
   */
  _handleGetTabFailure: function(error, ioargs) {
    var tabContainer = curam.tab.getTabContainer();
    var errorDetails = dojo.toJson(error);

    this._log(debug.getProperty("curam.tab.TabSessionManager.error")
      + errorDetails);
    var tab = new dojox.layout.ContentPane({
      title: "Error",
      // TODO: Any reason why these are not closable? -- DG
      closable: true,
      content: "An error occurred. Try refreshing the browser or contact your "
               + "administrator if it persists. Error: " + error.message
    });
    tabContainer.addChild(tab);
  },

  /**
   * <p>
   * Restore the tabs from the saved session. They are supplied as an array of
   * strings that can be parsed to re-create the <code>TabDescriptor</code>
   * objects that gave rise to them originally.
   * </p>
   * <p>
   * When a session is refreshed, the tabs are restored to the same state as
   * before with the same selected tab. When a new session is started, either
   * when a user logs out and logs in again or the old session times out, the
   * tabs are restored, but the home tab is selected. If no selected tab can be
   * found when refreshing, the home tab will also be selected. If no home tab
   * is recorded in the session, the user's home tab will be opened in addition
   * to the restored tabs.
   * </p>
   * <p>
   * The home page is a special case, as, in the event that no stored tab
   * session is found, the home page must be opened in its tab. A tab descriptor
   * for this tab is created separately and injected into the list of other
   * tabs to be opened (if any).
   * </p>
   *
   * @param {Array} sessionTabs The object holding the array of tab descriptor
   *   JSON strings in the "tabs" property. These strings need to be parsed to
   *   <code>TabDescriptor</code> objects.
   * @param ioargs (Something to do with the XHR request. Not used.)
   * @private
   */
  _restoreTabSession: function(sessionTabs, ioargs) {
    // Tabs to be opened in the current section. One of these will be selected.
    var currentSectionTabs = [];
    // Tabs to be opened in other sections. All of these will be opened in the
    // background after the tabs in the current section has been dealt with.
    var otherSectionTabs = [];
    // The section IDs are collected to allow the tab containers to be set up
    // for the selection event handlers.
    var allSectionIDs = [];

    curam.tab.getTabController().MAX_NUM_TABS = sessionTabs.maxTabs;
    curam.tab.getTabController().TABS_SEQUENTIAL_ORDER = sessionTabs.tabsInSequence;

    // Initialise progress widget subcribers and properties.
    curam.widget.ProgressSpinner.PROGRESS_WIDGET_ENABLED = sessionTabs.progressWidgetEnabled;
    curam.widget.ProgressSpinner.PROGRESS_WIDGET_DEFAULT_THRESHOLD = sessionTabs.progressWidgetThreshold;
    curam.widget.ProgressSpinner.PROGRESS_WIDGET_TIMEOUT_MAX = sessionTabs.progressWidgetTimeoutMax;
    curam.widget.ProgressSpinner.init();
    
    // Is this a refresh of the current session or a new session? Get the
    // previously selected tab if the session is the same.
    var isNewSession = this._isNewSession();
    var selectedTD = isNewSession ? null : this._getPrevSelectedTab();

    // If there was no previously selected tab, or we do not want to use it for
    // a new session, choose the home tab (and consequently its section). We
    // need to record which tab we are selecting in case we are changing it to
    // the home tab when it was not previously the home tab.
    var homeTD = this._getHomePageTab();
    selectedTD = selectedTD ? selectedTD : homeTD;
    this.tabSelected(selectedTD);

    // Just in case the home tab is in a section on its own and was not in the
    // session tabs....
    allSectionIDs[homeTD.sectionID] = true;

    if (sessionTabs && sessionTabs.tabs && sessionTabs.tabs.length > 0) {
      var tabs = sessionTabs.tabs;
      this._log(debug.getProperty("curam.tab.TabSessionManager.previous")
          + tabs.length
          + " " + debug.getProperty("curam.tab.TabSessionManager.tabs"));

      // Filter the tabs into two groups and remove the home page tab. We will
      // add it back in the correct position later. This ensures it is present
      // and correct in case it did not exist or was in the wrong position.
      for (var i = 0; i < tabs.length; i++) {
        var newTD = curam.tab.TabDescriptor.fromJson(tabs[i]);
        if (newTD.tabSignature == homeTD.tabSignature) {
          // Prefer the stored home page descriptor, as it will probably have a
          // proper title, unlike the tab descriptor we created.
          if (!isNewSession) {
            if (this._directBrowseURL) {
              selectedTD = newTD;
            } else {
              homeTD = newTD;
            }
          }
        } else {
          // Add other tabs to the "to do" lists.
          if (newTD.sectionID == selectedTD.sectionID) {
            currentSectionTabs.push(newTD);
          } else {
            otherSectionTabs.push(newTD);
          }
        }
        allSectionIDs[newTD.sectionID] = true;
      }

      // Put the home tab first in the correct group. It does not matter that
      // the "otherSectionTabs" are mixed together from different sections;
      // putting the home tab first in that list has the desired effect.
      if (homeTD.sectionID == selectedTD.sectionID) {
        currentSectionTabs.unshift(homeTD);
      } else {
        otherSectionTabs.unshift(homeTD);
      }
    } else {
      this._log(debug.getProperty("curam.tab.TabSessionManager.no.session"));
      currentSectionTabs.push(homeTD);
    }

    // NOTE: Restoring tabs will trigger tab session update requests to the
    // server, even though the server has just supplied the same session data.
    // This may trigger unnecessary writes to the database when the "updated"
    // tab session data is rewritten, but that is not much of a problem (as
    // writes do not happen on every update) and it is quite difficult to avoid
    // doing it (especially with the potential introduction of a new home page
    // tab descriptor that *does* need to be recorded). Therefore, we let it
    // happen in the interest of simplicity.

    // Restore all the tabs. Do the section with the selected tab first, so
    // that the tabs in the other sections are loaded behind the scenes.
    this._restoreSectionTabs(currentSectionTabs, selectedTD);
    this._restoreSectionTabs(otherSectionTabs, null);
    this._selectedTD = selectedTD;
    
    // Restore the foreground page previously opened in a modal if it exists
    // and auto recovery is enabled. Otherwise it will open the background page. 
    if (AUTORECOVERY_ENABLED === "true"){        	 
    	this._restoreModal(currentSectionTabs, otherSectionTabs);
    }
 
    // Only now do we connect the selection listeners. This prevents the
    // recorded selection from changing while the tabs were being restored.
    this._connectSelectionListeners(allSectionIDs);

    //When a page is directly requested by the user, the session is first
    //reloaded and then a request is sent for the requested page. This request
    //subscribes to the currently selected tab's main content loaded event. This
    //ensures the page will only be loaded after the session has been properly
    //restored. The call to 'goToUrl()' will determine if the page is to be
    //loaded in the currently selected tab, or in it's own tab.
    if (this._directBrowseURL) {

      //Closure to access 'this' in callback function later
      var dirBrowseCls = this._createDirectBrowseClosure();

      var topWin = curam.util.getTopmostWindow();
      var dirBrowseSub = topWin.dojo.subscribe(
                  "/curam/main-content/page/loaded",
                  null,
                  function(associatedPgID, associatedTabID) {

                    var that = dirBrowseCls.getThis();
                    var goToUrl = that._directBrowseURL;
                    var currentPgID = that._selectedTD.tabContent.pageID;

                    //After we request the page we need to update the stored
                    //value for the selected tab. We only want to request the
                    //page after the currently selected tab is finshed loading,
                    //we do not care about any other pontentaily open tabs.
                    if (associatedPgID === currentPgID) {
                      
                      require(["curam/util/Navigation"], function(nav) {
                        nav.goToUrl(goToUrl); //request page
                      });
                      
                      //Update tab description.
                      that._selectedTD.tabContent.pageID =
                                            goToUrl.replace(/Page.do\??.*/, '');
                      //Store updated value.
                      that.tabSelected(that._selectedTD);

                      //Unsubscribe as requested page will also cause content
                      //loaded event.
                      dojo.unsubscribe(dirBrowseSub);
                    }
                  });
    }
  },

  //A closure is required as we need access to 'this' in the load event
  //callback function despite the loss of scope.
  _createDirectBrowseClosure: function() {
    var that = this;
    return {
      getThis: function() {
        return that;
      }
    };
  },

  /**
   * Restores all of the tabs to their sections. If a selected tab is
   * identified, it will be opened in the foreground (the tab and its section
   * will be selected). All other tabs will be opened in the background.
   *
   * @param {Array} sectionTabs The tab descriptors for the tabs to be opened.
   * @param {curam.tab.TabDescriptor} selectedTD The tab descriptor of the tab
   *   to be opened in the foreground (selected).
   * @private
   */
  _restoreSectionTabs: function(sectionTabs, selectedTD) {
    // TODO: It might help make the trace messages more meaningful if the
    // position variable were corrected so that it related to the position
    // within each section, or even just in the overall list. -- DG
    this._log(debug.getProperty("curam.tab.TabSessionManager.saved.tabs"));
    
	for (var i = 0; i < sectionTabs.length; i++) {
	  var tabDescriptor = sectionTabs[i];
	  this._log(debug.getProperty("curam.tab.TabSessionManager.saved.tab"),
        tabDescriptor, i);
	  dojo.publish(curam.tab.getTabController().TAB_TOPIC,
	    [new curam.ui.OpenTabEvent(tabDescriptor, null,
        this._isOpenInBackground(tabDescriptor, selectedTD, i))]);
	 }
  },
  
  /**
   * Publish the message to begin the restore modal flow once the main-content frame has loaded.
   * 
   * @param {Array} currentSectionTabs The tab descriptors for the tabs to be opened in the section loaded.
   * @param {Array} otherSectionTabs The tab descriptors for the tabs to be opened in the other sections.
   * 
   * @private 
   */
  _restoreModal: function(currentSectionTabs, otherSectionTabs) {
    this._log(debug.getProperty("curam.tab.TabSessionManager.restore.modal"));

    // Keep track of how many main-content frames we load.
    this._tabLoadedCount = 0;

    // The number of tabs being restored in the section being shown.
    this._tabCountForCurrentSection = currentSectionTabs.length;

    // The number of tabs being loaded in the other sections (regardless of how many
    // tabs in otherSectionTabs, we only load 1 per section).
    this._tabCountForOtherSections = 0;
    var otherSectionIDs = [];
    for (var i = 0; i < otherSectionTabs.length; i++) {
      if (!otherSectionIDs.includes(otherSectionTabs[i].sectionID)) {
        otherSectionIDs.push(otherSectionTabs[i].sectionID);
        this._tabCountForOtherSections++;
      }
    }
    var mainContentSub = curam.util.getTopmostWindow().dojo.subscribe(
        '/curam/main-content/page/loaded', this, function(associatedPgID, associatedTabID, sourceTab) {

          // Determine if we can restore the modal.
          this._tabLoadedCount++;
          var restoreModal = false;

          // 1) The main content frame for the foreground tab has loaded.
          if (sourceTab.tabDescriptor.openInBackground === false) {
            restoreModal = true;
          } 
          // 2) There are no foreground tabs being restored: wait for the home tab of each section to be loaded.
          else if (this._tabCountForCurrentSection === 0 && this._tabLoadedCount === this._tabCountForOtherSections) {			  		
            restoreModal = true;
          }	
          // 3) There is only one tab. 
          // When we log back in, and are not restoring tabs, we have one tab in currentSectionTabs but fail to identify it as
          // the foreground due to _isNewSession always returning false; this condition is to catch that scenario.
          else if (this._tabCountForCurrentSection + this._tabCountForOtherSections <= 1) {
            restoreModal = true;
          }

          if (restoreModal) {              
            dojo.publish("curam/tab/restoreModal");  
            dojo.unsubscribe(mainContentSub);
          }
        });
  },

  /**
   * <p>
   * Connects all of the selection listeners to the tab containers. When a tab
   * is selected within a container, it will be recorded in local storage as
   * the currently selected tab. This allows it to be restored when the browser
   * is refreshed. This selection is not persisted across J2EE sessions, as the
   * home tab is always selected if a new J2EE session is started.
   * </p>
   * <p>
   * The selection listener is subscribed to the tab container widget's
   * "&lt;widget-id&gt;-selectChild" topic. This fires only once when a tab is
   * selected, whereas the "selectChild" event is fired twice and we do not
   * want that. (The event fires first when the user clicks the tab button and
   * again when the tab is brought into the foreground. The topic only fires
   * for the latter operation.)
   * </p>
   *
   * @param {Arrary} sectionIDs An array of the section IDs. The section IDs
   *   are the keys to the array values. The values are always "true".
   * @private
   */
  _connectSelectionListeners: function(sectionIDs) {
    var hasTabContainer = false;
    for (var sectionID in sectionIDs) {
      if (curam.tab.getTabContainer(sectionID)) {
        // The selected child tab content pane is passed to the listener
        // function.
        dojo.subscribe(curam.tab.getTabContainer(sectionID).id + "-selectChild",
          dojo.hitch(this, this.tabContentPaneSelected));
        hasTabContainer = true;
      }
    }

    // If the users changes the section, then the selected tab in that section
    // must be marked as the selected tab, otherwise the last explicitly
    // selected tab will not be changed. This would lead to the wrong tab being
    // selected after a refresh.
    dojo.subscribe(curam.tab.SECTION_TAB_CONTAINER_ID + "-selectChild",
        dojo.hitch(this, this.tabSectionSelected));
    return hasTabContainer;
  },

  /**
   * Invoked when a new tab is opened or when the content of an existing tab
   * is changed. This will add or update a record of this tab in the session.
   * A Word File Edit widget should not be stored in tab session.
   * @param {curam.tab.TabDescriptor} tabDescriptor The descriptor of the tab
   *   to be saved to the session.
   */
  tabUpdated: function(tabDescriptor) {
	var isFileEditWigetDialog = sessionStorage.getItem("fileEditWigetDialog");
	if (!isFileEditWigetDialog) {
	  // If not loading a Word File Edit widget dialog
      this._log(debug.getProperty("curam.tab.TabSessionManager.saving.tab"),
        tabDescriptor);
      new curam.ui.ClientDataAccessor().set(
        "/data/tab/update", tabDescriptor.toJson());
    } else {
      sessionStorage.removeItem("fileEditWigetDialog");
	}
  },

  /**
   * Invoked when a tab is closed. This will remove the tab from the session
   * (unless it is the first recorded tab, assumed to be the home page).
   *
   * @param {curam.tab.TabDescriptor} tabDescriptor The descriptor of the tab
   *   to be removed from the session.
   */
  tabClosed: function(tabDescriptor) {
    this._log(debug.getProperty("curam.tab.TabSessionManager.tab.closed"),
      tabDescriptor);
    new curam.ui.ClientDataAccessor().set(
        "/data/tab/close", tabDescriptor.toJson());
  },

  /**
   * Store the currently selected tab ID in local storage. This will be used on
   * a refresh to determine the correct tab to select. This is called when a
   * tab is selected or when a new tab is opened and the loaded page calls
   * back to set its signature.
   *
   * @param {curam.tab.TabDescriptor} tabDescriptor The descriptor of the
   *   selected tab to be recorded in local storage.
   */
  tabSelected: function(tabDescriptor) {
    this._log(debug.getProperty("curam.tab.TabSessionManager.selected.tab"),
      tabDescriptor);

    if (tabDescriptor.tabSignature) {
      // Only set the selected tab when it has a signature, otherwise it cannot
      // be matched to a tab on restoration. A tab descriptor may have no
      // signature if the tab has just been created but the content page has
      // not loaded yet and called back to set the signature. If a tab is
      // selected again or restored, then it will have its stored signature.
      localStorage[curam.tab.TabSessionManager.SELECTED_TAB_KEY] =
          tabDescriptor.toJson();

      this._log(debug.getProperty("curam.tab.TabSessionManager.recorded"),
        tabDescriptor);
    } else {
      this._log(debug.getProperty("curam.tab.TabSessionManager.not.recorded"),
                tabDescriptor);
    }

    // Update the browser tab title
    curam.debug.log("curam.tab.TabSessionManager.tabSelected calling curam.util.setBrowserTabTitle");
    curam.util.setBrowserTabTitle();
  },

  /**
   * Store the currently selected tab ID in dojo storage. This will be used on
   * a refresh to determine the correct tab to select. This is called when a
   * tab is selected and when a new tab is opened. The stored details are taken
   * from the tab content pane's "tabDescriptor" property.
   *
   * @param tabContentPane The tab content pane for the tab to be recorded as
   *   selected in local storage.
   */
  tabContentPaneSelected: function(tabContentPane) {
    if (tabContentPane.tabDescriptor) {
      this.tabSelected(tabContentPane.tabDescriptor);
      dojo.publish("curam/tab/selected",[tabContentPane.id]);
    } else {
      // This cannot happen unless the code is broken...surely?
      this._log(
        debug.getProperty("curam.tab.TabSessionManager.no.descriptor"));
    }
    
    if (tabContentPane.isLoaded) {
      curam.util.TabActionsMenu.setInlinedTabMenuItemsDisplayed(tabContentPane.id);
    }
  },

  /**
   * Store the currently selected tab ID in dojo storage. This will be used on
   * a refresh to determine the correct tab to select. This is called when a
   * <i>section</i> tab is selected, thereby changing the apparently selected
   * tab. The stored details are taken from that section's selected tab's
   * content pane's "tabDescriptor" property.
   *
   * @param sectionTabContentPane The tab content pane of the section whose
   *   selected tab is to be recorded as selected in local storage.
   */
  tabSectionSelected: function(sectionTabContentPane) {
    var selected = false;
    // The object provided may not be the actual tab container, but a wrapper
    // border container. The wrapper has the ID "<section-id>-stb" so we derive
    // the section ID from that and then defer to the usual function.
    // TODO: This would be easier if the section ID were part of the message
    // or were attached to the widgets as a property. -- DG
    if (sectionTabContentPane) {
      var id = sectionTabContentPane.id;
      this._log(
          debug.getProperty("curam.tab.TabSessionManager.new.section") + " '"
          + id + "'.");
      var sectionID = id.substring(0, id.length - 4);
      var selectedTab = curam.tab.getSelectedTab(sectionID);
      // It is possible that there are no tabs in the section, so check first.
      if (selectedTab) {
        this._log(
          debug.getProperty("curam.tab.TabSessionManager.changing.selection"));
        this.tabContentPaneSelected(selectedTab);
        selected = true;
      } else {
        this._log(debug
          .getProperty("curam.tab.TabSessionManager.not.changing.selection"));
      }
    } else {
      // This cannot happen unless the code is broken...surely?
      this._log(debug.getProperty("curam.tab.TabSessionManager.no.container"));
    }

    // Update the browser tab title
    curam.debug.log("curam.tab.TabSessionManager.tabSectionSelected calling curam.util.setBrowserTabTitle");
    curam.util.setBrowserTabTitle();

    return selected;
  },

  /**
   * Currently, this function always returns false as cookies can no longer be 
   * accessed client-side due to PSIRT update on cookies to set httpOnly flag to
   * true. The browser behaviour still behaves as prior to this PSIRT update. 
   *
   * Previously this function checked if it was a new session or the  continuation
   * of an existing session by retrieving the copy of the "JSESSIONID" cookie value
   * placed in local storage the last time this method was called. If the value did
   * not exist or did not match the current "JSESSIONID" cookie, then it was a
   * new session and the new "JSESSIONID" was saved to local storage for
   * the next time this method was invoked. Any record of the previously selected
   * tab was removed, as the home tab was then selected for the new session. If
   * the values matched, then this was the continuation of a session, such as the
   * case where the user refreshed the browser.
   *
   * @return {Boolean} false always.
   * @private
   */
  _isNewSession: function() {
  
    return false;
  },

  /**
   * Gets the tab descriptor of the tab that was previously recorded as the
   * session's selected tab.
   *
   * @return {curam.tab.TabDescriptor} The tab descriptor of the selected tab
   *   recorded in the session, or null if there was no selected tab.
   * @private
   */
  _getPrevSelectedTab: function() {
    this._log(debug.getProperty("curam.tab.TabSessionManager.previous.tab"));
    var jsonTabDescriptor;
    jsonTabDescriptor = localStorage[curam.tab.TabSessionManager.SELECTED_TAB_KEY];
    var selectedTD = null;
    if (jsonTabDescriptor) {
      selectedTD = curam.tab.TabDescriptor.fromJson(jsonTabDescriptor);
      this._log(
        debug.getProperty("curam.tab.TabSessionManager.previous.tab.found"),
          selectedTD);
    } else {
      this._log(debug
        .getProperty("curam.tab.TabSessionManager.previous.tab.not.found"));
    }
    return selectedTD;
  },
  
   /**
   * Gets the tab descriptor of the modal that was previously when the modal
   * was opened. 
   *
   * @return {curam.tab.TabDescriptor} The tab descriptor of the selected modal
   *   recorded in the session, or null if there was no selected modal.
   * @private
   */
  _getPrevSelectedModal: function() {
    this._log(debug.getProperty("curam.tab.TabSessionManager.previous.modal"));
    var jsonTabDescriptor;
    jsonTabDescriptor = localStorage[curam.tab.TabSessionManager.PREVIOUSLY_SELECTED_MODAL_KEY];
    var selectedTD = null;
    if (jsonTabDescriptor) {
      selectedTD = curam.tab.TabDescriptor.fromJson(jsonTabDescriptor);
      this._log(
        debug.getProperty("curam.tab.TabSessionManager.previous.modal.found"),
          selectedTD);
    } else {
      this._log(debug
	    .getProperty("curam.tab.TabSessionManager.previous.modal.not.found"));
    }
    return selectedTD;
  },

  /**
   * Determines if a tab should be opened in the background (not selected) or
   * foreground (selected). A tab will open in the foreground if its signature
   * matches the signature of the selected tab, otherwise it will be opened in
   * the background.
   *
   * @param {curam.tab.TabDescriptor} newTD The tab descriptor for the new tab.
   *   Will not be null.
   * @param {curam.tab.TabDescriptor} selectedTD The tab descriptor for the
   *   selected tab. May be null.
   * @param {Number} pos The position of the new tab in the sequence of restored
   *   tab. This is just used for logging purposes.
   * @return {Boolean} true if the new tab should be opened in the background,
   *   false otherwise.
   * @private
   */
  _isOpenInBackground: function(newTD, selectedTD, pos) {
    var openInBackground = true;

    if (selectedTD && selectedTD.tabSignature == newTD.tabSignature) {
      this._log(debug.getProperty("curam.tab.TabSessionManager.foreground"),
        newTD, pos);
      openInBackground = false;
    } else {
      this._log(debug.getProperty("curam.tab.TabSessionManager.background"),
        newTD, pos);
    }
    return openInBackground;
  },

  /**
   * Gets a tab descriptor for the user's home page. When there is no session
   * available, then this tab descriptor must be used to restore the default
   * session. It may also be required if the tab configuration changes and
   * makes the previously recorded home page within the tab configuration
   * invalid. Information generated into the "AppController.jspx" is used to
   * construct the necessary tab descriptor. It is assumed that there are no
   * parameters (which there should not be for a home page). The tab descriptor
   * will be updated in the session when this method is called.
   *
   * @return {curam.tab.TabDescriptor} A tab descriptor for the user's home
   *   page.
   * @private
   */
  _getHomePageTab: function() {
    // Just assume that the one and only tab ID is the right one.
    this._log(debug.getProperty("curam.tab.TabSessionManager.home.page")
      + " '" + USER_HOME_PAGE_ID + "'.");
    // Check for the scenario where the home page has not been configured
    // correctly and does not have an associated section or tab. This could be
    // caused by it being omitted from the tab configuration files or a mismatch
    // in the actual UIM file name and it's reference in the tab configuration
    // files.
    if (!USER_HOME_PAGE_TAB_ASSOC.tabIDs
        || !USER_HOME_PAGE_TAB_ASSOC.sectionID) {
      // TODO: localization
      throw new Error(
        "The application cannot be launched because the home page, '"
        + USER_HOME_PAGE_ID + "', has not been associated with a section or "
        + " tab.");
    }
    var tabID = USER_HOME_PAGE_TAB_ASSOC.tabIDs[0];
    var sectionID = USER_HOME_PAGE_TAB_ASSOC.sectionID;
    var homeTD = new curam.tab.TabDescriptor(sectionID, tabID);
    var uimPageRequest = new curam.ui.PageRequest(USER_HOME_PAGE_ID, true);

    // Set the details on the TD that are normally collected after the tab has
    // opened. This will actually trigger the saving of the "newly opened tab"
    // into the session. That will either update the old record or create a
    // new one, either way, we have to take care to avoid duplicating the tab
    // later or creating it in the wrong position. We usually read the tab list
    // from the session before calling this method, so beware of that, too.
    // Also, the flag argument on "setTabSignature" is used to avoid marking
    // the tab as the currently selected tab, as we may be restoring the
    // previously saved selection instead.
    homeTD.isHomePage = true;
    homeTD.setTabSignature([], uimPageRequest, true);
    homeTD.setTabContent(uimPageRequest);

    this._log(debug.getProperty("curam.tab.TabSessionManager.created"),
      homeTD);
    return homeTD;
  },

  /**
   * Simplifies logging of consistently formed messages for the tab session
   * manager.
   *
   * @param msg The message to be logged.
   * @param tab An object with "sectionID" and "tabID" properties to report.
   *              May be null and may have no properties. They will not be
   *              reported in that case.
   * @param pos The position of the tab within a sequence, such as the list
   *              of tabs being restored from a saved session. Optional.
   * @private
   */
  _log: function(msg, tabDescriptor, pos) {
    // If debug logging is turned off, then we do not want to keep the overhead
    // of converting objects to JSON form to create the log message, so we
    // check the DEBUG switch even before calling "curam.debug.log".
    if (curam.debug.enabled()) {
      var prefix = "TAB SESSION";

      if (typeof pos == "number") {
        prefix += " [pos=" + pos + "]";
      }
      curam.debug.log(prefix + ": " + msg
          + (tabDescriptor ? " " + tabDescriptor.toJson() : ""));
    }
  }
});


/*
 * Add "static" fields to the above class. This allows them to be accessed via
 * "this.<name>" or "curam.tab.TabSessionManager.<name>" depending on what is
 * possible or convenient in a given context.
 */
dojo.mixin(curam.tab.TabSessionManager, {
  /**
   * The key to the selected tab descriptor (in JSON form) in the browser local
   * storage. This is recorded each time a tab is selected. When a tab session
   * is refreshed, this tab will be selected. However, if a user starts a new
   * session, their home tab will be selected instead.
   */
  SELECTED_TAB_KEY: "curam_selected_tab",
  
   /**
   * The key to the previously selected modal tab descriptor (in JSON form) in 
   * the browser local storage. This is recorded each time a modal is selected. 
   */
  PREVIOUSLY_SELECTED_MODAL_KEY: "curam_previously_selected_modal",

  /**
   * The key to the session ID in the browser local storage for the session in
   * which the recorded selected tab was selected. It is only restored if the
   * session matches this session, otherwise it is a new session and the home
   * tab will be selected by default.
   */
  SELECTED_TAB_SESSION_KEY: "curam_selected_tab_session"
  });

  return TabSessionManager;
});

},
'dijit/tree/_dndSelector':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel",	// global
	"dojo/_base/lang", // lang.hitch
	"dojo/dnd/common",
	"dojo/dom", // isDescendant
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/touch",
	"../a11yclick",
	"./_dndContainer"
], function(array, declare, kernel, lang, dndCommon, dom, mouse, on, touch, a11yclick, _dndContainer){

	// module:
	//		dijit/tree/_dndSelector

	return declare("dijit.tree._dndSelector", _dndContainer, {
		// summary:
		//		This is a base class for `dijit/tree/dndSource`, and isn't meant to be used directly.
		//		It's based on `dojo/dnd/Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Object
		//		(id to DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			this.events.push(
				// listeners setup here but no longer used (left for backwards compatibility
				on(this.tree.domNode, touch.press, lang.hitch(this,"onMouseDown")),
				on(this.tree.domNode, touch.release, lang.hitch(this,"onMouseUp")),

				// listeners used in this module
				on(this.tree.domNode, touch.move, lang.hitch(this,"onMouseMove")),
				on(this.tree.domNode, a11yclick.press, lang.hitch(this,"onClickPress")),
				on(this.tree.domNode, a11yclick.release, lang.hitch(this,"onClickRelease"))
			);
		},

		// singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit/Tree._TreeNode*/ node, /*Boolean?*/isAnchor){
			// summary:
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		remove node and it's descendants from current selection
			// node: Node
			//		node to remove
			var newSelection = array.filter(this.getSelectedTreeNodes(), function(selectedNode){
				return !dom.isDescendant(selectedNode.domNode, node.domNode); // also matches when selectedNode == node
			});
			this.setSelection(newSelection);
			return node;
		},
		isTreeNodeSelected: function(/*dijit/Tree._TreeNode*/ node){
			// summary:
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit/Tree._TreeNode[]*/ newSelection){
			// summary:
			//		set the list of selected nodes to be exactly newSelection. All changes to the
			//		selection should be passed through this function, which ensures that derived
			//		attributes are kept up to date. Anchor will be deleted if it has been removed
			//		from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//		list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			array.forEach(this._setDifference(oldSelection, newSelection), lang.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			array.forEach(this._setDifference(newSelection, oldSelection), lang.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary:
			//		Returns a copy of xs which lacks any objects
			//		occurring in ys. Checks for membership by
			//		modifying and then reading the object, so it will
			//		not properly handle sets of numbers or strings.

			array.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = array.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			array.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function(){
			// summary:
			//		Update the following tree properties from the current selection:
			//		path[s], selectedItem[s], selectedNode[s]

			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			array.forEach(selected, function(node){
				var ary = node.getTreePath();
				nodes.push(node);
				paths.push(ary);
			}, this);
			var items = array.map(nodes,function(node){ return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},

		// selection related events
		onClickPress: function(e){
			// summary:
			//		Event processor for onmousedown/ontouchstart/onkeydown corresponding to a click event
			// e: Event
			//		onmousedown/ontouchstart/onkeydown event
			// tags:
			//		protected

			// ignore mouse or touch on expando node
			if(this.current && this.current.isExpandable && this.tree.isExpandoNode(e.target, this.current)){ return; }

			if(e.type == "mousedown" && mouse.isLeft(e)){
				// Prevent text selection while dragging on desktop, see #16328.   But don't call preventDefault()
				// for mobile because it will break things completely, see #15838.  Also, don't preventDefault() on
				// MSPointerDown or pointerdown events, because that stops the mousedown event from being generated,
				// see #17709.
				// TODO: remove this completely in 2.0.  It shouldn't be needed since dojo/dnd/Manager already
				// calls preventDefault() for the "selectstart" event.  It can also be achieved via CSS:
				// http://stackoverflow.com/questions/826782/css-rule-to-disable-text-selection-highlighting
				e.preventDefault();
			}

			var treeNode = e.type == "keydown" ? this.tree.focusedChild : this.current;

			if(!treeNode){
				// Click must be on the Tree but not on a TreeNode, happens especially when Tree is stretched to fill
				// a pane of a BorderContainer, etc.
				return;
			}

			var copy = dndCommon.getCopyKeyState(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onClickRelease: function(e){
			// summary:
			//		Event processor for onmouseup/ontouchend/onkeyup corresponding to a click event
			// e: Event
			//		onmouseup/ontouchend/onkeyup event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// an already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drag an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(e.type == "keyup" ? this.tree.focusedChild : this.current, dndCommon.getCopyKeyState(e), e.shiftKey);
		},
		onMouseMove: function(/*===== e =====*/){
			// summary:
			//		event processor for onmousemove/ontouchmove
			// e: Event
			//		onmousemove/ontouchmove event
			this._doDeselect = false;
		},

		// mouse/touch events that are no longer used
		onMouseDown: function(){
			// summary:
			//		Event processor for onmousedown/ontouchstart
			// e: Event
			//		onmousedown/ontouchstart event
			// tags:
			//		protected
		},
		onMouseUp: function(){
			// summary:
			//		Event processor for onmouseup/ontouchend
			// e: Event
			//		onmouseup/ontouchend event
			// tags:
			//		protected
		},

		_compareNodes: function(n1, n2){
			if(n1 === n2){
				return 0;
			}

			if('sourceIndex' in document.documentElement){ //IE
				//TODO: does not yet work if n1 and/or n2 is a text node
				return n1.sourceIndex - n2.sourceIndex;
			}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
				return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
			}else if(document.createRange){ //Webkit
				var r1 = doc.createRange();
				r1.setStartBefore(n1);

				var r2 = doc.createRange();
				r2.setStartBefore(n2);

				return r1.compareBoundaryPoints(r1.END_TO_END, r2);
			}else{
				throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
			}
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//		to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = this._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;

					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					var nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end){
						nodes.push(begin);
						begin = this.tree._getNext(begin);
					}
					nodes.push(end);

					this.setSelection(nodes);
				}else{
					if( this.selection[ node.id ] && multi ){
						this.removeTreeNode( node );
					}else if(multi){
						this.addTreeNode(node, true);
					}else{
						this.setSelection([node]);
						this.anchor = node;
					}
				}
			}
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo/dnd/Container._Item (representing a dragged node) by it's key (id).
			//		Called by dojo/dnd/Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key];
			return {
				data: widget,
				type: ["treeNode"]
			}; // dojo/dnd/Container._Item
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo/dnd/Container.forInItems()` for details
			o = o || kernel.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
	});
});

},
'dijit/_OnDijitClickMixin':function(){
define([
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/has", // has("dom-addeventlistener")
	"./a11yclick"
], function(on, array, keys, declare, has, a11yclick){

	// module:
	//		dijit/_OnDijitClickMixin

	var ret = declare("dijit._OnDijitClickMixin", null, {
		// summary:
		//		Deprecated.   New code should access the dijit/a11yclick event directly, ex:
		//		|	this.own(on(node, a11yclick, function(){ ... }));
		//
		//		Mixing in this class will make _WidgetBase.connect(node, "ondijitclick", ...) work.
		//		It also used to be necessary to make templates with ondijitclick work, but now you can just require
		//		dijit/a11yclick.

		connect: function(obj, event, method){
			// override _WidgetBase.connect() to make this.connect(node, "ondijitclick", ...) work
			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});

	ret.a11yclick = a11yclick;	// back compat

	return ret;
});

},
'curam/pagination':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 15-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 28-Apr-2011  MV  [CR00265362] When loading list parts, only re-parse the new
   *     chunk, not the whole page.
   * 13-Apr-2011  SD  [CR00263757] Amended the use of parser to limit it to
   *    specified script content instead of the entire page.
   * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "debug.log".
   * 20-Dec-2010  MV  [CR00239063] Add support for lists with row actions menu.
   * 13-Dec-2010  MV  [CR00237821] Performance improvement - added supporting
   *    common functions and event handler.
   * 09-Jun-2010 MV [CR00202794] Fix start row index in addPagination() function.
   * 13-Apr-2010 MV [CR00192550] Added localizable strings array.
   * 11-Mar-2010 MV [CR00136536] Initial version.
   */

define(["dojo/parser",
        "dojo/dom-class",
        "dojo/dom-construct",
        "dojo/dom-attr",
        "curam/debug",
        "curam/define",
        "curam/pagination/ControlPanel",
        "curam/pagination/StateController"
        ], function(parser, domClass, domConstruct, domAttr, debug) {
  
  curam.define.singleton("curam.pagination", {
    defaultPageSize: 15,
    threshold: 15,
    listModels: {},
    
    ROW_COUNT_CLASS_NAME: "numRows-",
    ESC_SCRIPT_START: "<!--@pg@",
    ESC_SCRIPT_END: "@pg@-->",
    
    localizedStrings: {
      firstPage_btn: "|<",
      firstPage_title: "$not-localized$ First page",
      prevPage_btn: "<",
      prevPage_title: "$not-localized$ Previous page",
      nextPage_btn: ">",
      nextPage_title: "$not-localized$ Next page",
      lastPage_btn: ">|",
      lastPage_title: "$not-localized$ Last page",
      pageSize_title: "$not-localized$ Page size",
      pagination_info: "$not-localized$ Displaying rows %s to %s out of %s",
      page_title:"Go to page"
    },
    
    /**
     * Initialize pagination on the specified list.
     */
    addPagination: function(listModel, controlPanelParentNode) {
      // do not add pagination in short lists
      var numRows = listModel.getRowCount();
      var listId = listModel.getId();
      if (numRows <= curam.pagination.threshold) {
        dojo.setObject('curam.shortlist.'+ listId, true);
    	// show the hidden rows
        listModel.showRange(1, numRows);
        return;
      }
      
      debug.log("curam.pagination.addPagination: listId: ", listId);
      if (curam.pagination.listModels[listId]) {
        throw "Pagination on this list has already been initialized: " + listId;
      }
      
      curam.pagination.listModels[listId] = listModel;
      debug.log("curam.pagination.listModels : ",
          curam.pagination.listModels);
      
      var gui = new curam.pagination.ControlPanel(controlPanelParentNode);
      var controller = new curam.pagination.StateController(listModel, gui);
      
      listModel._controller = controller;

      // listen to pre-sort events and notify pagination code
      dojo.subscribe("/curam/list/toBeSorted", this, function(listUniqueId) {
        debug.log(debug.getProperty("curam.omega3-util.received") 
            + " /curam/list/toBeSorted " 
            + debug.getProperty("curam.omega3-util.for")+ ":",
            listUniqueId);
        var model = curam.pagination.listModels[listUniqueId]
        model && curam.pagination.unpackAll(model);
      });

      // listen to sort events and notify pagination code
      dojo.subscribe("/curam/list/sorted", this, function(listUniqueId) {
        debug.log(debug.getProperty("curam.omega3-util.received") 
            + " /curam/list/sorted " 
            + debug.getProperty("curam.omega3-util.for")+ ":",
            listUniqueId);
        var model = curam.pagination.listModels[listUniqueId];
        model && curam.pagination.paginatedListSorted(model);
      });
      
      controller.gotoFirst();
    },

    /**
     * Called by custom list implementations to notify pagination that the list
     * has been resorted.
     */
    paginatedListSorted: function(listModel) {
      listModel._controller.reset();
    },
    
    unpackRows: function(scriptNode, fragment) {
      var rowsData = scriptNode.innerHTML;
      // the data may contain "escaped" script tags so unescape these
      var hasRowActions = domClass.contains(scriptNode, "has-row-actions");
      if (hasRowActions) {
        rowsData = rowsData.replace(
            new RegExp(curam.pagination.ESC_SCRIPT_START, "g"), "<script type=\"text/javascript\">");
        rowsData = rowsData.replace(
            new RegExp(curam.pagination.ESC_SCRIPT_END, "g"), "</script>");
      }
      // now parse the HTML
      var scriptContents = domConstruct.toDom(rowsData);
      
      if (hasRowActions) {
        // evaluate any contained JavaScript
        dojo.query("script", scriptContents).forEach(function(s) {
          eval(s.innerHTML);
        });

        // parse the new content to find uninstantiated Dijits
        parser.parse(scriptContents);
      }
      if (fragment) {
        fragment.appendChild(scriptContents);
      } else {
        // insert script contents in place of the script tag
        domConstruct.place(scriptContents, scriptNode, "replace");
      }
    },
    
    unpackAll: function(listModel) {
      // go to the last page - this unpacks all the rows
      listModel._controller.gotoLast();
    },
    
    readListContent: function(tableNode) {
      return dojo.query("tbody > *", tableNode).filter(function(n){
        return typeof(n.tagName) != "undefined"
          && (n.tagName == "TR" || (n.tagName == "SCRIPT"
          && domAttr.get(n, "type") == "list-row-container"));
      });
    },
    
    getNumRowsInBlock: function(scriptBlockNode) {
      var countClass = dojo.filter(
          scriptBlockNode.className.split(" "), function(cn) {
            return cn.indexOf(curam.pagination.ROW_COUNT_CLASS_NAME) == 0;
          });
      return parseInt(countClass[0].split(
          curam.pagination.ROW_COUNT_CLASS_NAME)[1]);
    }
  });
  
  return curam.pagination;
});

},
'dijit/layout/StackController':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-construct",
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.getObject
	"dojo/on",
	"dojo/topic",
	"../focus", // focus.focus()
	"../registry", // registry.byId
	"../_Widget",
	"../_TemplatedMixin",
	"../_Container",
	"../form/ToggleButton",
	"dojo/touch"	// for normalized click handling, see dojoClick property setting in postCreate()
], function(array, declare, domClass, domConstruct, keys, lang, on, topic,
			focus, registry, _Widget, _TemplatedMixin,_Container, ToggleButton){

	// module:
	//		dijit/layout/StackController

	var StackButton = declare("dijit.layout._StackButton", ToggleButton, {
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		// closeButton: Boolean
		//		When true, display close button for this tab
		closeButton: false,

		_aria_attr: "aria-selected",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			(this.focusNode || this.domNode).setAttribute("role", "tab");
		}
	});


	var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {
		// summary:
		//		Set of buttons to select a page in a `dijit/layout/StackContainer`
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

		baseClass: "dijitStackController",

		templateString: "<span role='tablist' data-dojo-attach-event='onkeydown'></span>",

		// containerId: [const] String
		//		The id of the page container that I point to
		containerId: "",

		// buttonWidget: [const] Constructor
		//		The button widget to create to correspond to each page
		buttonWidget: StackButton,

		// buttonWidgetCloseClass: String
		//		CSS class of [x] close icon, used by event delegation code to tell when close button was clicked
		buttonWidgetCloseClass: "dijitStackCloseButton",

		pane2button: function(/*String*/ id){
			// summary:
			//		Returns the button corresponding to the pane w/the given id.
			// tags:
			//		protected
			return registry.byId(this.id + "_" + id);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Listen to notifications from StackContainer.  This is tricky because the StackContainer may not have
			// been created yet, so abstracting it through topics.
			// Note: for TabContainer we can do this through bubbled events instead of topics; maybe that's
			// all we support for 2.0?
			this.own(
				topic.subscribe(this.containerId + "-startup", lang.hitch(this, "onStartup")),
				topic.subscribe(this.containerId + "-addChild", lang.hitch(this, "onAddChild")),
				topic.subscribe(this.containerId + "-removeChild", lang.hitch(this, "onRemoveChild")),
				topic.subscribe(this.containerId + "-selectChild", lang.hitch(this, "onSelectChild")),
				topic.subscribe(this.containerId + "-containerKeyDown", lang.hitch(this, "onContainerKeyDown"))
			);

			// Listen for click events to select or close tabs.
			// No need to worry about ENTER/SPACE key handling: tabs are selected via left/right arrow keys,
			// and closed via shift-F10 (to show the close menu).
			// Also, add flag to use normalized click handling from dojo/touch
			this.containerNode.dojoClick = true;
			this.own(on(this.containerNode, 'click', lang.hitch(this, function(evt){
				var button = registry.getEnclosingWidget(evt.target);
				if(button != this.containerNode && !button.disabled && button.page){
					for(var target = evt.target; target !== this.containerNode; target = target.parentNode){
						if(domClass.contains(target, this.buttonWidgetCloseClass)){
							this.onCloseButtonClick(button.page);
							break;
						}else if(target == button.domNode){
							this.onButtonClick(button.page);
							break;
						}
					}
				}
			})));
		},

		onStartup: function(/*Object*/ info){
			// summary:
			//		Called after StackContainer has finished initializing
			// tags:
			//		private
			this.textDir = info.textDir;
			array.forEach(info.children, this.onAddChild, this);
			if(info.selected){
				// Show button corresponding to selected pane (unless selected
				// is null because there are no panes)
				this.onSelectChild(info.selected);
			}

			// Reflect events like page title changes to tab buttons
			var containerNode = registry.byId(this.containerId).containerNode,
				pane2button = lang.hitch(this, "pane2button"),
				paneToButtonAttr = {
					"title": "label",
					"showtitle": "showLabel",
					"iconclass": "iconClass",
					"closable": "closeButton",
					"tooltip": "title",
					"disabled": "disabled",
					"textdir": "textdir"
				},
				connectFunc = function(attr, buttonAttr){
					return on(containerNode, "attrmodified-" + attr, function(evt){
						var button = pane2button(evt.detail && evt.detail.widget && evt.detail.widget.id);
						if(button){
							button.set(buttonAttr, evt.detail.newValue);
						}
					});
				};
			for(var attr in paneToButtonAttr){
				this.own(connectFunc(attr, paneToButtonAttr[attr]));
			}
		},

		destroy: function(preserveDom){
			// Since the buttons are internal to the StackController widget, destroy() should remove them.
			// When #5796 is fixed for 2.0 can get rid of this function completely.
			this.destroyDescendants(preserveDom);
			this.inherited(arguments);
		},

		onAddChild: function(/*dijit/_WidgetBase*/ page, /*Integer?*/ insertIndex){
			// summary:
			//		Called whenever a page is added to the container.
			//		Create button corresponding to the page.
			// tags:
			//		private

			// create an instance of the button widget
			// (remove typeof buttonWidget == string support in 2.0)
			var Cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
			var button = new Cls({
				id: this.id + "_" + page.id,
				name: this.id + "_" + page.id, // note: must match id used in pane2button()
				label: page.title,
				disabled: page.disabled,
				ownerDocument: this.ownerDocument,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir || this.textDir,
				showLabel: page.showTitle,
				iconClass: page.iconClass,
				closeButton: page.closable,
				title: page.tooltip,
				page: page
			});

			this.addChild(button, insertIndex);
			page.controlButton = button;	// this value might be overwritten if two tabs point to same container
			if(!this._currentChild){
				// If this is the first child then StackContainer will soon publish that it's selected,
				// but before that StackContainer calls layout(), and before layout() is called the
				// StackController needs to have the proper height... which means that the button needs
				// to be marked as selected now.   See test_TabContainer_CSS.html for test.
				this.onSelectChild(page);
			}

			// Add this StackController button to the list of things that labels that StackContainer pane.
			// Also, if there's an aria-labelledby parameter for the pane, then the aria-label parameter is unneeded.
			var labelledby = page._wrapper.getAttribute("aria-labelledby") ?
				page._wrapper.getAttribute("aria-labelledby") + " " + button.id : button.id;
			page._wrapper.removeAttribute("aria-label");
			page._wrapper.setAttribute("aria-labelledby", labelledby);
		},

		onRemoveChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever a page is removed from the container.
			//		Remove the button corresponding to the page.
			// tags:
			//		private

			if(this._currentChild === page){
				this._currentChild = null;
			}

			var button = this.pane2button(page.id);
			if(button){
				this.removeChild(button);
				button.destroy();
			}
			delete page.controlButton;
		},

		onSelectChild: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called when a page has been selected in the StackContainer, either by me or by another StackController
			// tags:
			//		private

			if(!page){
				return;
			}

			if(this._currentChild){
				var oldButton = this.pane2button(this._currentChild.id);
				oldButton.set('checked', false);
				oldButton.focusNode.setAttribute("tabIndex", "-1");
			}

			var newButton = this.pane2button(page.id);
			newButton.set('checked', true);
			this._currentChild = page;
			newButton.focusNode.setAttribute("tabIndex", "0");
			var container = registry.byId(this.containerId);
		},

		onButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons is pressed in an attempt to select a page
			// tags:
			//		private

			var button = this.pane2button(page.id);

			// For TabContainer where the tabs are <span>, need to set focus explicitly when left/right arrow
			focus.focus(button.focusNode);

			if(this._currentChild && this._currentChild.id === page.id){
				//In case the user clicked the checked button, keep it in the checked state because it remains to be the selected stack page.
				button.set('checked', true);
			}
			var container = registry.byId(this.containerId);
			container.selectChild(page);
		},

		onCloseButtonClick: function(/*dijit/_WidgetBase*/ page){
			// summary:
			//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
			// tags:
			//		private

			var container = registry.byId(this.containerId);
			container.closeChild(page);
			if(this._currentChild){
				var b = this.pane2button(this._currentChild.id);
				if(b){
					focus.focus(b.focusNode || b.domNode);
				}
			}
		},

		// TODO: this is a bit redundant with forward, back api in StackContainer
		adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Helper for onkeydown to find next/previous button
			// tags:
			//		private

			if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){
				forward = !forward;
			}
			// find currently focused button in children array
			var children = this.getChildren();
			var idx = array.indexOf(children, this.pane2button(this._currentChild.id)),
				current = children[idx];

			// Pick next/previous non-disabled button to focus on.   If we get back to the original button it means
			// that all buttons must be disabled, so return current child to avoid an infinite loop.
			var child;
			do{
				idx = (idx + (forward ? 1 : children.length - 1)) % children.length;
				child = children[idx];
			}while(child.disabled && child != current);

			return child; // dijit/_WidgetBase
		},

		onkeydown: function(/*Event*/ e, /*Boolean?*/ fromContainer){
			// summary:
			//		Handle keystrokes on the page list, for advancing to next/previous button
			//		and closing the current page if the page is closable.
			// tags:
			//		private

			if(this.disabled || e.altKey){
				return;
			}
			var forward = null;
			if(e.ctrlKey || !e._djpage){
				switch(e.keyCode){
					case keys.LEFT_ARROW:
					case keys.UP_ARROW:
						if(!e._djpage){
							forward = false;
						}
						break;
					case keys.PAGE_UP:
						if(e.ctrlKey){
							forward = false;
						}
						break;
					case keys.RIGHT_ARROW:
					case keys.DOWN_ARROW:
						if(!e._djpage){
							forward = true;
						}
						break;
					case keys.PAGE_DOWN:
						if(e.ctrlKey){
							forward = true;
						}
						break;
					case keys.HOME:
						// Navigate to first non-disabled child
						var children = this.getChildren();
						for(var idx = 0; idx < children.length; idx++){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.END:
						// Navigate to last non-disabled child
						var children = this.getChildren();
						for(var idx = children.length - 1; idx >= 0; idx--){
							var child = children[idx];
							if(!child.disabled){
								this.onButtonClick(child.page);
								break;
							}
						}
						e.stopPropagation();
						e.preventDefault();
						break;
					case keys.DELETE:
					case "W".charCodeAt(0):    // ctrl-W
						if(this._currentChild.closable &&
							(e.keyCode == keys.DELETE || e.ctrlKey)){
							this.onCloseButtonClick(this._currentChild);

							// avoid browser tab closing
							e.stopPropagation();
							e.preventDefault();
						}
						break;
					case keys.TAB:
						if(e.ctrlKey){
							this.onButtonClick(this.adjacent(!e.shiftKey).page);
							e.stopPropagation();
							e.preventDefault();
						}
						break;
				}
				// handle next/previous page navigation (left/right arrow, etc.)
				if(forward !== null){
					this.onButtonClick(this.adjacent(forward).page);
					e.stopPropagation();
					e.preventDefault();
				}
			}
		},

		onContainerKeyDown: function(/*Object*/ info){
			// summary:
			//		Called when there was a keydown on the container
			// tags:
			//		private
			info.e._djpage = info.page;
			this.onkeydown(info.e);
		}
	});

	StackController.StackButton = StackButton;	// for monkey patching

	return StackController;
});

},
'curam/cdsl/connection/CuramConnection':function(){
/*
 *  IBM Confidential
 *  
 *  OCO Source Materials
 *  
 *  Copyright IBM Corporation 2013,2020.
 *  
 *  The source code for this program is not published or otherwise divested
 *  of its trade secrets, irrespective of what has been deposited with the 
 *  US Copyright Office
 */

define(['dojo/_base/declare',
        'dojo/request/registry',
        'curam/cdsl/_base/_Connection',
        'curam/util'
        ], function(
            declare, request, _Connection, util) {

  /**
   * @name curam.cdsl.connection.CuramConnection
   * @namespace Allows invoking Curam facade methods via HTTP.
   */
  var CuramConnection = declare(_Connection,
  /**
   * @lends curam.cdsl.connection.CuramConnection.prototype
   */
  {
    _baseUrl: null,

    /**
     * Creates an instance of connection.
     * 
     * @param {String} baseUrl Base URL of Curam data service. Typically
     *    this will take the following form:
     *    http://&lt;host&gt;:&lt;port&gt;/Curam/dataservice 
     */
    constructor: function(baseUrl) {
      this._baseUrl = baseUrl;
    },

    /**
     * This method is not intended to be directly called by API clients.
     * @private
     */
    invoke: function(methodCall, timeout) {
      this.inherited(arguments);
      var topWindow = util.getTopmostWindow();
      return request(methodCall.url(this._baseUrl), {
        data: methodCall.toJson(),
        method: 'POST',
        headers: {"Content-Encoding": "UTF-8",
                  "csrfToken": topWindow.csrfToken},
        query: null,
        preventCache: true,
        timeout: timeout ? timeout : this._DEFAULT_REQUEST_TIMEOUT,
        handleAs: 'text'
      });
    }
  });
  
  return CuramConnection;
});

},
'dijit/form/_FormValueMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/lang",
	"dojo/on",
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, lang, on, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormValueMixin

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			domAttr.set(this.focusNode, 'readOnly', value);
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		}
	});
});

},
'dojo/date/stamp':function(){
define(["../_base/lang", "../_base/array"], function(lang, array){

// module:
//		dojo/date/stamp

var stamp = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.date.stamp", stamp);

// Methods to convert dates to or from a wire (string) format using well-known conventions

stamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){
	// summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	// description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//		- dates only
	//			- yyyy
	//			- yyyy-MM
	//			- yyyy-MM-dd
	//		- times only, with an optional time zone appended
	//			- THH:mm
	//			- THH:mm:ss
	//			- THH:mm:ss.SSS
	//		- and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	//		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
  	// formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	// defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!stamp._isoRegExp){
		stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
var __Options = {
	// selector: String
	//		"date" or "time" for partial formatting of the Date object.
	//		Both date and time will be formatted by default.
	// zulu: Boolean
	//		if true, UTC/GMT is used for a timezone
	// milliseconds: Boolean
	//		if true, output milliseconds
};
=====*/

stamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){
	// summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	// description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	// dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return stamp;
});

},
'dijit/layout/AccordionPane':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./ContentPane"
], function(declare, kernel, ContentPane){

	// module:
	//		dijit/layout/AccordionPane

	return declare("dijit.layout.AccordionPane", ContentPane, {
		// summary:
		//		Deprecated widget.   Use `dijit/layout/ContentPane` instead.
		// tags:
		//		deprecated

		constructor: function(){
			kernel.deprecated("dijit.layout.AccordionPane deprecated, use ContentPane instead", "", "2.0");
		},

		onSelected: function(){
			// summary:
			//		called when this pane is selected
		}
	});
});

},
'curam/omega3-util':function(){
/*
 *  IBM Confidential
 *  
 *  OCO Source Materials
 *  
 *  Copyright IBM Corporation 2005,2022.
 *  
 *  The source code for this program is not published or otherwise divested
 *  of its trade secrets, irrespective of what has been deposited with the 
 *  US Copyright Office
 */

define(["dojo/dom-geometry",
        "dojo/dom",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/dom-style",
        "dojo/dom-construct",
        "dojo/sniff",
        "dijit/registry",
        "curam/util/EditableList",
        "curam/debug",
        "curam/validation",
        "curam/util",
        "curam/html",
        "curam/GlobalVars",
        "cm/_base/_dom",
        "cm/_base/_form",
        "curam/util/RuntimeContext"
        ], function(domGeom, dom, domClass, domAttr, domStyle, domConstruct, has,
            registry, EditableList, debug, validation, util) {

/**
 * Utility functions used across Curam pages.
 */

/*
 * Modification History
 * --------------------
 * 27-Jul-2022 FN [RTC267283] Amended openPopupFromDomain(), openPopupNoDomain() and setParentFocus().
 * 11-Jan-2022 JD [RTC270575] Updated pop-up functions to accept hash tokens as parameters and updated openPopup()
 *                            to append the hash token to the generated URL.
 * 23-Aug-2021  SK [RTC273075] Added the clickMarker() hookpoint method.
 * 15-Jun-2021  SK  Removed long unused code to improve memory footprint.
 * 03-Jun-2021 BD [RTC271240] Updated openPopupFromDomain() calling method from curam.util to append place-holder-for-focus.
 * 25-Feb-2021 JD [RTC266244] Append place-holder-for-focus to the class of a popup-action anchor element to keep
 * the focus on the anchor element in all browsers once a pop-up window closes.
 * 16-Jan-2020 FN [RTC254490] Appending place-holder-for-focus to the class of a popup-action anchor element to keep
 *                            the focus on the anchor element when using IE11 once a pop-up window closes.
 * 20-Sep-2019 AA [RTC250096] Updated function dc to store the Search submit button 
 *                            id in session storage.
 * 24-May-2019 CM [RTC248002] Update setToggleClusterIcon method to update both
 *                the default and hover toggle button images when loaded initially.
 * 15-Apr-2019 CM [RTC246336] Use images for toggle button instead of background
 *				  images for accessiblity purposes.
 * 28-Mar-2019 SH [RTC241162] Handle CKEditor instances during toggleCluster().
 * 20-Dec-2018 CMC[RTC241390] Added function addClassToPositionQuestionaireStatic
 * 07-Dec-2018 SK [RTC228026] Added focus return logic upon pop up closing.
 * 23-May-2018 BD [RTC227148] Changed selector toggle from span to button.
 * 28-Jul-2016 AZ [107281] Reset popup tooltip on clear.
 * 05-Nov-2015 AB [CR00472177] Toggle buttons are not visible in Windows
 *                high-contrast mode.
 * 20-Oct-2015 AZ [CR00471645] Added ChooseCheckbox() method for more accurate 
 *                check box control.
 * 17-Nov-2014 JY [CR00449655] Added support using Editable List with 
 *                multi select widget.
 * 14-Mar-2014 JY [CR00422364] Added the support for aria-expanded in 
 *                toggleCluster().
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 22-Apr-2013 MV [CR00381705] Moved getMarginBoxSimple().
 * 03-Jan-2013 MV [CR00362118] Guard against missing parameter in clearPopup(). 
 * 14-Nov-2012 SB [CR00349320] Fixed form submit when enter key is pressed on 
 *                             toggle button.
 * 24-Oct-2012 MV [CR00347765] Load some dependencies only on demand, code
 *    cleanup.
 * 15-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 28-Aug-2012 MV [CR00339341] Add missing dependency.
 * 14-Aug-2012 MV [CR00338135] Remove dependency on full Dojo API. Add missing
 *      dependencies.
 * 31-Jul-2012 MV [CR00336202] Migrate to take on Dojo 1.7.3
 * 31-Jan-2012 MV [CR00302081] Move away from global context. 
 * 07-Nov-2011 PK [CR00289859] Dojo 1.6.1 upgrade and IE9+ support. 
 * 12-Jul-2011 KW [CR00275353] Refactored openUserPrefsEditor().
 * 25-Mar-2011 SK [TEC-6335]   Removed jsModals indicator, as modals are always
 *                             on for v6.
 * 18-Feb-2011 BOS[TEC-6255]   Changing 'openPopupFromCTCodeNoDomain' function
 *                              as a separator span has been removed to support
 *                              proper styling.
 * 31-Jan-2011 MK [CR00250297] Add uimType parameter to popup properties.
 * 28-Jan-2011 MV [CR00245381] Remove obsolete help settings for dialogs.
 * 21-Jan-2011 DG [CR00243540] Changed "console.log" to "debug.log".
 * 26-Jan-2011 KW [CR00244099] Rewrote the toggleCluster function.
 * 06-Jan-2011 KW [CR00240549] Cluster toggle arrow now reflects the cluster's
 *                             state
 * 13-Dec-2010 KW [CR00238319] Fixed so Cluster that are initially collapsed,
 *                             can be expanded.
 * 10-Dec-2010 MK [CR00232761] Fixed the functions that handle checkboxes.
 * 25-Nov-2010 SJ [CR00228438] Added calendarOpenModalDialog to handle link clicks
 *                             on calendar.
 * 03-Nov-2010 MV [CR00225331] Handle toggling for clusters with no header.
 * 19-Oct-2010 AF [CR00223550] Added span elements to link created in
 *                             replaceSubmitButton to display rounded corners.
 * 14-Oct-2010 MV [CR00223441] Move functions to curam.util namespace.
 * 04-Oct-2010 MV [CR00221605] When replacing submit buttons, preserve
 *    the existing element classes.
 * 20-Sep-2010 BOS[TEC-3591] Refactored "openPopup".
 * 27-Aug-2010 MV [CR00217499] Replace the use of escape() with the correct
 *                  function.
 * 28-Jul-2010 JY [CR00211660] Fix the issue that a cluster doesn't hide the description
 *                  when it is collapsed by invoking the 'toggleCluster' function.
 * 27-Jul-2010 MK [CR00211743] Optionally display the help icon on a modal dialog.
 * 22-Jul-2010 MV [CR00211225] Fixed toggling of clusters when there are more
 *                  than one.
 * 19-Jul-2010 MV [CR00210892] Fixed toggling of clusters containing paginated
 *                  LIST.
 * 05-Jul-2010 SOS[CR00209386] Fixed ScrollingTabController override to size vertically.
 * 29-Jun-2010 SC [CR00204664] Added ScrollingTabController override for performance improvement.
 * 08-Jun-2010 MV [CR00202412] Remove hardcoded sizes for date and frequency selectors.
 * 03-Jun-2010 MV [CR00202062] Rolled back some changes as the functions are still needed.
 * 27-May-2010 AF [CR00201814] Modified retrieval of collapsible header node.
 * 25-May-2010 SOS[CR00201419] Removed unused functions and moved globals to curam.GlobalVars
 * 12-Feb-2010 AF [CR00183263] Modified height and width settings for collapsible cluster.
 * 10-Feb-2010 MV [CR00188844] Move the openModalDialog() function to curam.util.
 * 20-Jan-2010 MV [CR00183142] Handle a null argument value in setParentFocus().
 * 25-Nov-2009 MV [CR00175955] Move the setFocus() function to curam.util.
 */

/*
NOTES:
 Removed the following mod history comment in the hope this CR won't clash
 with the DUIM work (CR00221023) for JDE 015.
 * 21-Sep-2011  PK  [CR00220520] Updated multi-select popup search method,
 *                    "openPopupFromCTCode" due to use of new Dojo
 *                    "FilterSelect" list.
*/
  
  var omega3Util = {

    // object which stores mapping information,
    PopupMapping: function(name,targetWidgetID) {
      this.name = name;
      this.targetWidgetID = targetWidgetID;
    },
    
    openPopupFromCTCode: function(anchorName, popupInstanceName, theLink,
        parameters, popupPageHashToken, createPageHashToken) {
      var selectedCode;
      var list = theLink.parentNode.parentNode.parentNode.childNodes[0];
      // "list" now points to the dom node of the FilteringSelect, dijit.byNode can
      // be used to get a reference to the dijit.
      var dijitFilteringSelect = dijit.byNode(list);
      if (dijitFilteringSelect) {
        selectedCode = dijitFilteringSelect.getValue();
      } else {
        var optionsList = theLink.parentNode.parentNode.parentNode.childNodes[1];
        
        try {
        	selectedCode = optionsList.options[optionsList.selectedIndex].value;	
        } catch(e){
        	// do nothing
        } 
        
    	if(selectedCode === undefined){
	        try {
	     		selectedCode = list.options[list.selectedIndex].value;
	        } catch(e){
	        	// do nothing
	        }
    	}
    	
    	if(selectedCode === undefined){       
	        try {
	        	var wrapperNode = theLink.parentNode.parentNode.parentNode.childNodes[0]
	        	selectedCode = wrapperNode.firstChild.value;               
	        } catch(e){
	        	// do nothing
	        } 
    	}
 
    	if(selectedCode === undefined){
        	curam.debug.log('Error: cannot find element containing codetable value in dropdown')
        }	
        
      }
      if (selectedCode != "") {
        if (curam.popupCTCodeMappings[selectedCode]) {
          openPopupFromDomain(anchorName, popupInstanceName,
            curam.popupCTCodeMappings[selectedCode], parameters, false, popupPageHashToken, createPageHashToken);
        }
      }
    },

    openPopupFromCTCodeNoDomain: function(anchorName, popupInstanceName,
        theLink, parameters, popupPageHashToken, createPageHashToken) {
      // there is  a filler span in between the input node
      // and the select node, so we have to go to the third node in the list
      var list = theLink.parentNode.parentNode.parentNode.childNodes[2];
      // "list" now points to the dom node of the FilteringSelect, dijit.byNode can
      // be used to get a reference to the dijit.
      var dijitFilteringSelect = dijit.byNode(list);
      var popupProps;
      var pageID;
      var createPageID;
      var height;
      var width;
      var scrollBars;
      var insertMode;
      var codeTableCode;
    
      if (dijitFilteringSelect) {
        var selectedCode = dijitFilteringSelect.getValue();
      } else {
        var list = theLink.parentNode.parentNode.parentNode.childNodes[1];
        var selectedCode = list.options[list.selectedIndex].value;
      }
    
      if (selectedCode != "") {
        if (curam.popupCTCodeMappings[selectedCode]) {
          popupProps = getPopupProperties(curam.popupCTCodeMappings[selectedCode]);
          pageID = popupProps.pageID;
          createPageID = popupProps.createPageID;
          height = popupProps.height;
          width = popupProps.width;
          scrollBars = popupProps.scrollBars;
          insertMode = popupProps.insertMode;
          codeTableCode = popupProps.codeTableCode;
    
          var uimType = popupProps.uimType; 
          if (uimType == "DYNAMIC") {
            openPopup(anchorName, popupInstanceName, null, pageID, createPageID,
                width, height, scrollBars, insertMode, null, null, parameters,
                false, popupPageHashToken, createPageHashToken);
          }
        }
      }
    },

    openPopupFromDomain: function(anchorName, popupInstanceName,
        domain, parameters, openCreatePage, popupPageHashToken, createPageHashToken) {
      var popupProps = getPopupProperties(domain);
      var pageID = popupProps.pageID;
      var createPageID = popupProps.createPageID;
      var height = popupProps.height;
      var width = popupProps.width;
      var scrollBars = popupProps.scrollBars;
      var insertMode = popupProps.insertMode;
      var codeTableCode = popupProps.codeTableCode;
      
       // Appends placeholder-for-focus to the class of the anchor element.
      var anchorElementToSaveFocusOn = dojo.byId(anchorName).previousElementSibling;
      anchorElementToSaveFocusOn && curam.util.addPlaceholderFocusClassToEventOrAnchorTag(anchorElementToSaveFocusOn, window);
    
      openPopup(anchorName, popupInstanceName, domain,
          pageID, createPageID, width, height, scrollBars, insertMode,
          codeTableCode, parameters, openCreatePage, popupPageHashToken, createPageHashToken);
    },
    
    openPopupNoDomain: function(anchorName, popupInstanceName, pageID,
        createPageID, width, height, scrollBars, insertMode, parameters,
        openCreatePage, popupPageHashToken, createPageHashToken) {
      openPopup(anchorName, popupInstanceName, null, pageID, createPageID, width,
                height, scrollBars, insertMode, null, null, parameters,
                openCreatePage, popupPageHashToken, createPageHashToken);

      var anchorElementToSaveFocusOn = dojo.byId(anchorName).previousElementSibling;
      domClass.add(anchorElementToSaveFocusOn, "placeholder-for-focus");
    },
    
    openPopup: function(anchorName, popupInstanceName, domain,
        pageID, createPageID, width, height, scrollBars, insertMode,
        codeTableCode, parameters, openCreatePage, popupPageHashToken, createPageHashToken) {
      setMappingsLoaded(popupInstanceName);

      //close what ever popup is open at the moment
      //currently can only have one popup open at the time
      if(curam.popupWindow && !curam.popupWindow.closed) {
        curam.popupWindow.close();
      }
    
      //the curam.currentPopupInstanceName variable must be set, because all popups
      //must use "executeOpenerMapping() to assign the selected result in the popup
      //to the widget curam.currentPopupInstanceName on the opening/parent page.
      curam.currentPopupInstanceName = popupInstanceName;
      curam.currentPopupProps
          = setPopupProperties(pageID,domain,codeTableCode,width,height,scrollBars,
                               createPageID,insertMode,null);
    
      //this should be excessive - remove after checking.
      var ctx = jsScreenContext;
      ctx.addContextBits('POPUP');
      ctx.clear('TAB|TREE|AGENDA');
      var url = "";
      var hashedTokenToAppend;
      if (openCreatePage == true) {
        url = createPageID;
        
        // The createPage hash token to append to the URL when the secure
        // URLs solution is enabled.
        if (createPageHashToken && createPageHashToken.length > 0) {
          hashedTokenToAppend = "&" + curam.util.secureURLsHashTokenParam 
          + "=" + createPageHashToken;
        }
      } else {
        url = pageID;
        // The popupPage hash token to append to the URL when the secure
        // URLs solution is enabled.
        if (popupPageHashToken && popupPageHashToken.length > 0) {
          hashedTokenToAppend = "&" + curam.util.secureURLsHashTokenParam 
          + "=" + popupPageHashToken;
        }
      }
      // Append hash token to URL.
      if (parameters && parameters.length > 0) {
        url = url + "?" + parameters;
        hashedTokenToAppend ? url += hashedTokenToAppend + "&" : url += "&";
      } else {
        url += "?";
      }
      url += ctx.toRequestString();
    
      if (window.curam.util.showModalDialog) {
        curam.util.showModalDialog(url, null, width, height, 0, 0, false, null, null);
      }
    },

    addPopupMapping: function(popupName, resultName, targetWidget) {
      var popupMappingRepository = curam.popupMappingRepository;
      // don't add the mappings again if they have been marked as loaded
      // i.e. the link to open the popup has been clicked multiple times, we don't
      // want to add multiple mappings.
      if(curam.popupMappingLoaded[popupName] == true){
        return;
      }
    
      // check if this is the first time we are adding a mapping for this popup
      if(popupMappingRepository[popupName] == null) {
    
        popupMappingRepository[popupName] = [];
        popupMappingRepository[popupName][resultName] = [];
        popupMappingRepository[popupName][resultName][0] = targetWidget;
      } else {
        // otherwise mappings have been added allready for this popup
        // now check if a mapping exists for this resultName
        if(popupMappingRepository[popupName][resultName] == null) {
          popupMappingRepository[popupName][resultName] = [];
          popupMappingRepository[popupName][resultName][0] = targetWidget;
        } else {
          // last scenario, mappings exist for this popup AND also exist for this result allready
          // we just add to the end of the array. ie. a popup result is being mapping to multiple widgets
    
          var numMappingsForResult = popupMappingRepository[popupName][resultName].length;
          popupMappingRepository[popupName][resultName][numMappingsForResult] = targetWidget;
        }
      }
    },

    setMappingsLoaded: function(popupName) {
      curam.popupMappingLoaded[popupName] = true;
    },

    // mappings are only supported to widgets with a value attribute (various <input>) and
    // innerHTML attributes. Currently this is used for only textfield, textarea, hidden field and
    // span tags.
    executeMapping: function(resultName, value) {
      dojo.body().setAttribute('tabIndex','-1');
      var pmr = curam.popupMappingRepository;
      var cpin = curam.currentPopupInstanceName;
      // execute all mappings for the currently opened popup
      if(!pmr || !pmr[cpin] || pmr[cpin][resultName] == null) {
        return; // a page may not map every result that a popup "exposes"
      }
      
      var lastTarget = null;
      for(var i = 0; i < pmr[cpin][resultName].length; i++) {
        var target = null;
        target = dom.byId(pmr[cpin][resultName][i]);
        lastTarget = target;
        // check the tag type to set it correctly
        if(target.tagName == "SPAN") {
          target.innerHTML = curam.html.splitWithTag(value, null, null, escapeXML);
          target.setAttribute("title", value); //sets title to string in field
          target._reposition = target._reposition || dojo.query("div", target).length > 0;
           if(target._reposition) {
             var actions = cm.nextSibling(target, "span");
             if(actions) {
               var targetHeight = domGeom.getMarginBoxSimple(target).h;
               var actionHeight = domGeom.getMarginBoxSimple(actions).h;
               domStyle.set(actions, "position", "relative");
                   var diff = targetHeight - actionHeight - 
                                ((dojo.isIE && dojo.isIE < 9) ? 2 : 0);
               domStyle.set(actions, "bottom", "-"+(diff) + "px");
             }
           }
        } else if (target.tagName == "TEXTAREA") {
          // Insertion at cursor position is only supported for text areas
          if (curam.currentPopupProps.insertMode == "insert") {
            insertAtCursor(target, escapeXML(value));
          } else if (curam.currentPopupProps.insertMode == "append") {
            target.value += value;
          } else {
            target.value = value;
          }
        } else if (registry.byId(pmr[cpin][resultName][i])) {
              registry.byId(pmr[cpin][resultName][i]).set("value", value);
          target.value = value;
        } else {
          target.value = value;
          var targetId = target.id;
          if (targetId.indexOf("_value") > 0) {
            var clearId = targetId.replace("_value", "_clear");
            var clearElement = dom.byId(clearId);
            clearElement.classList.remove("bx--search-close--hidden");
          }
        }
      }
      setTimeout(function() {
        if (lastTarget) {
    	  lastTarget.setAttribute('value', value);
    	  lastTarget.setAttribute('aria-label', value);
    	  lastTarget.focus();
    	}
      },300);
      dojo.body().setAttribute('tabIndex','0');
    },

    insertAtCursor: function(field, value) {
      if (document.selection) {
        //IE support
        field.focus();
        sel = document.selection.createRange();
        sel.text = value;
      } else if (field.selectionStart || field.selectionStart == '0') {
        //MOZILLA/NETSCAPE support
        var startPos = field.selectionStart;
        var endPos = field.selectionEnd;
        field.value = field.value.substring(0, startPos)
        + value
        + field.value.substring(endPos, field.value.length);
      } else {
        field.value += value;
      }
    },


    // Escapes XML characters in strings that are referenced in the XML document.
    escapeXML: function(string) {
      return string.replace(/&/g,"&#38;")
               .replace(/</g,"&#60;")
               .replace(/>/g,"&#62;")
               .replace(/"/g,"&#34;")
               .replace(/'/g,"&#39;");
    },

    // simple wrapper that is only called on a popup page to execute a mapping
    // on the page that opened it. This method reduces the amount of code our
    // custom jsp tags have to write into a page
    executeOpenerMapping: function(resultName, value) {
      var parent = undefined;
    
      // Check that it is a popup/modal & that parent exists
      if (curam.util.isModalWindow()) {
        // if opened as a modal dialog,
        parent = curam.dialog.getParentWindow(window);
    
      // the following branch caters for cases when modals are off and dialog opens
      // as normal popup
      } else if (window.dialogArguments) {
        // if opened as a popup dialog,
        parent = window.dialogArguments[0];
      }
    
      if ((parent) && (!parent.closed)) {
            parent.executeMapping(resultName,value);
      } else {
        debug.log("curam.omega3-util.executeOpenerMapping:, " 
            + debug.getProperty("curam.omega3-util.parent"));
      }  
    },

    storePopupInputFromWidget: function(name,widget) {
      var value = null;
      value = dom.byId(widget).value;
      if(value) {
        curam.popupInputs[name] = value;
      } else {
        curam.popupInputs[name] = "";
      }
    },

    getPopupInput: function(name) {
      if(curam.popupInputs[name] != null) {
        return curam.popupInputs[name];
      } else {
        return "";
      }
    },

    PopupProperties: function(pageID,width,height,scrollBars,createPageID,insertMode,uimType) {
      this.width = width;
      this.height = height;
      this.scrollBars = scrollBars;
      this.pageID = pageID;
      this.createPageID = createPageID;
      if (insertMode == null) {
        this.insertMode = "overwrite";
      } else {
        this.insertMode = insertMode;
      }
      if (uimType != null) {
        this.uimType = uimType;
      }
    },
    
    setPopupProperties: function(pageID,domain,codeTableCode,width,height,
        scrollBars,createPageID,insertMode,uimType) {
      if(codeTableCode) {
        curam.popupCTCodeMappings[codeTableCode] = domain;
      }
      curam.popupPropertiesRepository[domain] =
          new PopupProperties(pageID,width,height,scrollBars,createPageID,
              insertMode,uimType);
    },
    
    getPopupAttributes: function(width, height, scrollBars) {
      var attributeString =
        "width=" + width + "," +
        "height=" + height + "," +
        "scrollbars=" + (scrollBars ? "yes" : "no") + ",";
      return attributeString;
    },
    
    getPopupAttributesIEModal: function(popupType) {
      var attributeString =
        "dialogWidth:" + curam.popupPropertiesRepository[popupType].width + "px;"
        + "dialogHeight:"+ curam.popupPropertiesRepository[popupType].height + "px;";
      return attributeString;
    },
    
    trimFileExtension: function(fileName) {
      // get the file name without the extension
      var pathDelimIndex = fileName.lastIndexOf("/")+1;
      if(pathDelimIndex == -1) {
        // just in case, try a backslash
        pathDelimIndex = fileName.lastIndexOf("\\")+1;
      }
      if(pathDelimIndex == -1) {
        pathDelimIndex = 0;
      }
      return fileName.substring(pathDelimIndex,fileName.lastIndexOf("."));
    },


    getPopupProperties: function(popupType) {
  return curam.popupPropertiesRepository[popupType];
    },

    /*** BEGIN: Calendar Goto Date handlers ***/
    
    validateDate: function(proposedDate) {
      /* this function has been left here for backwards compatibility - to avoid customer impact.
         The functionality has moved into curam.validation.validateDate() */
      return curam.validation.validateDate(proposedDate).valid;
    },

    /**
     * Calendar "goto date" button handler. Validates the input and adds the required
     * "startDate" parameter to the URL.
     */
    addStartDate: function(event) {
      var inputStartDate = dom.byId("startDate").value;
      var valResult = curam.validation.validateDate(inputStartDate);
      if (valResult.valid) {
        var gotoDateLink = dom.byId('gotoDate');
        gotoDateLink.href = curam.util.replaceUrlParam(
            gotoDateLink.href, "startDate", inputStartDate);
        return true;
    
      } else {
        require(["curam/validation/calendar"], function(calendar) {
          alert(calendar.invalidGotoDateEntered.replace(
              "%s", inputStartDate).replace("%s", jsDFs));
        });
    
        dojo.stopEvent(event);
        return false;
      }
    },

    /** Key handler for the calendar's "goto date" field.
     * The function forwards the event to the goto date button handler
     * and if valid, goes to the new date.
     */
    checkEnter: function(keyPress) {
      if (keyPress.keyCode == 13) {
        if(addStartDate(keyPress)) {
          var gotoDateLink = dom.byId('gotoDate');
          window.location = gotoDateLink.href;
          return true;
        }
    
        return false;
      }
    
      return true;
    },

    /*** END: Calendar Goto Date handlers ***/

    createWindowName: function(windowName) {
      // javascript doesn't like '$' or '.' characters in window names,
      // unfortunately we use curam texthelper field names to give
      // each popup instance a unique name. So we have to relace
      // '$' with something javascript does like.
      // Can't get string.replace(regexp,""); function to work so
      // doing this the "long" way.
      var result = new String("");
      for (var i = 0; i < windowName.length; i++) {
        var ch = windowName.charAt(i);
        if(ch == "$" || ch == ".") {
          result += "_";
        } else {
          result += ch;
        }
      }
      return result;
    },
    
    clearPopup: function(idSource, event) {
      var id_base = idSource.id.substring(0,idSource.id.indexOf('_clear'));
      var valueID = id_base + "_value";
      var descriptionID = id_base + "_desc";
      var descriptionHiddenFieldID = id_base + "_deschf";
      var clearElement = dom.byId(idSource);
      clearElement.classList.add("bx--search-close--hidden");
    
      // NB: Use "value" instead of "innerHTML" for a text area to ensure it
      // works in all browsers.
    
      // Clear the element holding the "value" returned from the popup
      var valueElement = dom.byId(valueID);
      if (valueElement) {
        if (valueElement.tagName == "INPUT") {
          valueElement.value = "";
        } else if (valueElement.tagName == "TEXTAREA") {
          valueElement.value = "";
        } if (valueElement.tagName == "SPAN") {
          // You cannot set the width of a span so to ensure it stays visible
          // we use non-breaking spaces.
          valueElement.innerHTML = curam.POPUP_EMPTY_SPAN_VALUE;
        }
      }
    
    
      // the "visible" description field can be an input control, a text area or a
      // container such as <span>
      var descriptionElement = dom.byId(descriptionID);
      if(descriptionElement) {
        if (descriptionElement.tagName == "INPUT"){
          descriptionElement.value = "";
        } else if (descriptionElement.tagName == "TEXTAREA") {
          descriptionElement.value = "";
        } else if (descriptionElement.tagName == "SPAN") {
          // You cannot set the width of a span so to ensure it stays visible
          // we use non-breaking spaces.
          descriptionElement.innerHTML = curam.POPUP_EMPTY_SPAN_VALUE;
          
          domAttr.set(descriptionElement, "title", 
              domAttr.get(descriptionElement, "data-field-label"));
        }
      }
    
      // the "hidden" description field is always a hidden field
      var descriptionHiddenElement = dom.byId(descriptionHiddenFieldID);
      if(descriptionHiddenElement) {
        if (descriptionHiddenElement.tagName == "INPUT"){
          descriptionHiddenElement.value = '';
        } else {
          descriptionHiddenElement.innerHTML='&nbsp';
        }
      }
      if (event) {
        event = dojo.fixEvent(event);
        dojo.stopEvent(event);
      }
      return false;
    },

    showClearIcon: function(elementId) {
    	var clearElement = dom.byId(elementId+"_clear");
    	var inputElement = dom.byId(elementId+"_value");
    	if (inputElement.value == "") {
    		clearElement.classList.add("bx--search-close--hidden");
    	} else {
    		clearElement.classList.remove("bx--search-close--hidden");
    	}
    },


    /*
     * The following functions are used by the expanding / collapsing rules tree.
     * They are adapted from an article on A List Apart:
     *    http://www.alistapart.com/stories/dom2/
     */

    // Swap an image - used for rollovers
    swapImage: function(img_name, img_src) {
      dom.byId(img_name).src = img_src;
    },

    // This function provides support for using checkboxes
    // to select rows in a list. The value of each checkbox
    // is compiled into a tabbed delimited string and added
    // to the url of the hyperlink.
    // parameterName: The name of the parameter to create
    //                as well as being the name of the checkbox.
    // hyperLink: The link that has been clicked.
    appendTabColumn: function(parameterName, hyperlink) {
      var appendString;
      var values = [];
    
      dojo.query("input[name='" + parameterName + "']").filter(
      function(singleItem) {
        return singleItem.checked;
      }).forEach(function(singleItem){
            values.push(singleItem.value);
            });
    
      appendString = values.join("\t");
      // first check if we found any checkboxes
      hyperlink.href = hyperlink.href + (hyperlink.href.indexOf('?') == -1 ? '?' : '&');
    
      if (appendString != '') {
        hyperlink.href = hyperlink.href + parameterName + '='
            + encodeURIComponent(appendString);
      } else {
        hyperlink.href = hyperlink.href + parameterName + '=';
      }
    },

    // Following Javascripts allow setting and unsetting a range of checkboxes in a gantt chart.
    
    ToggleAll: function(e, paramName) {
      dojo.query("input[name='" + paramName + "']").forEach(function(singleItem){
      if (singleItem.checked === true){
        singleItem.checked = false;
      }else{
        singleItem.checked = true;
      }
      });
    },
    
    ToggleSelectAll: function(e, paramName) {
      if (e.checked) {
        CheckAll(paramName);
      } else {
        ClearAll(paramName);
      }
    },

    CheckAll: function(paramName) {
      dojo.query("input[name^='" + paramName + "'][onclick]").forEach(function(singleItem){
        singleItem.checked = true;
        
        // Enable/disabling the editable fields only when the multi select widget
        // is used with Editable List.
        EditableList._doToggling(singleItem);
      });
    },
    
    ClearAll: function(paramName) {
      dojo.query("input[name^='" + paramName + "'][onclick]").forEach(function(singleItem){
        singleItem.checked = false;
        
        // Enable/disabling the editable fields only when the multi select widget
        // is used with Editable List.
        EditableList._doToggling(singleItem);
      });
    },


    Check: function(e) {
      e.checked = true;
    },
    
    Clear: function(e) {
      e.checked = false;
    },
    
    ChooseSelectAll: function(e, sAllName, paramName) {
      var sAll = dom.byId(sAllName);
      if (sAll) {
        if (dojo.query("input[name='" + paramName + "']").every("return item.checked")) {
          Check(sAll);
        } else {
          Clear(sAll);
        }
      }
      
      // Enable/disabling the editable fields only when the multi select widget
      // is used with Editable List.
      // Here param 'e' is the checkbox element rather than the event object.
      EditableList._doToggling(e);
    },
    
    ChooseCheckbox: function(e, paramName) {
      var checkbox = dom.byId(paramName);
      if (checkbox) {
        if (e.checked) {
          Clear(paramName);
        } else {
          Check(paramName);
        }
      }
      
      EditableList._doToggling(e);
    },

    selectAllIfNeeded: function(sAllName, paramName) {
      if(dojo.query("input[name='" + paramName + "']").some("return !item.checked")) {
        return;
      }
      var sAll = dom.byId(sAllName);
      if (sAll) {
        Check(sAll);
      }
    },

    /**
     * Called on the "onsubmit" event of a form to suppress double-clicks on
     * the submit button. Returns true if form submission should be allowed
     * to continue.
     */
    dc: function(aForm, returnToSelft, event) {
      // if this form has already been submitted, don't allow it to be
      // submitted again
      if (cm.wasFormSubmitted(aForm)) {
        var evt = dojo.fixEvent(event);
        dojo.stopEvent(evt);
        return false;
      }
      cm.setFormSubmitted(aForm, 1);
      
      //store the Search submit button id in session storage
      var curamDefaultActionId = dojo.query(".curam-default-action")[0];
      if (curamDefaultActionId !== null && curamDefaultActionId !== undefined) {
        sessionStorage.setItem('curamDefaultActionId', curamDefaultActionId.id);
      }
      
      return true;
    },
    
    setFocus: function() {
      curam.util.setFocus();
    },

    /**
     * Once a pop up has carried out its functionality,
     * it needs to closed and focus reset on the parent.
     */
    setParentFocus: function(event) {
      debug.log("curam.omega3-util.setParentFocus: " 
        + debug.getProperty("curam.omega3-util.called"));
      
      var openerWin = curam.dialog.getParentWindow(window);
      //Check parent exists before trying to focus on it
    
      if(!openerWin.closed){
        var recallFocusOnWidgetCloseButton = dojo.query("button..bx--search-close.placeholder-for-focus", openerWin.document);
        if(recallFocusOnWidgetCloseButton.length == 1){
          //set focus on the close button of a search pop-up input
          recallFocusOnWidgetCloseButton[0].focus();
          domClass.remove(recallFocusOnWidgetCloseButton[0], "placeholder-for-focus");
        }else{  
          //set focus to parent
          openerWin.focus();
          //make sure there is no placeholder-for-focus left on the class of the element focused on.
          var cleanUpPlaceHolderForFocus = dojo.query(".placeholder-for-focus", openerWin.document);
          if(cleanUpPlaceHolderForFocus.length == 1){
            domClass.remove(cleanUpPlaceHolderForFocus[0], "placeholder-for-focus");
          }
        }
      } else{
            alert("The parent window has been closed");
      }
      if (event || window.event) {
        dojo.stopEvent(event || window.event);
      }
      //Close pop up
      curam.dialog.closeModalDialog();
    },

    /**
     * A collection of useful functions for manipulating the DOM.
     */
  
    getParentWin: function() {
      return curam.dialog.getParentWindow(window);
    },

    // Retrieve all checkboxes from the question popup page. If the
    // box is checked add this question to the Matrix i.e. the
    // 'opener' window of the popup.
    addQuestionsFromPopup: function(evt) {
      evt = dojo.fixEvent(evt);
      dojo.stopEvent(evt);
      //This guards against the user double clicking the button
      if(window._questionsAdded){return;}
      window._questionsAdded = true;
    
      var parentWin = getParentWin();
    
      var checkboxes = dojo.query('INPUT');
      var questions = [];
      dojo.query("INPUT[type='checkbox']")
                    .forEach(function(item){
                            if (item.checked && item.id.indexOf('__o3mswa') < 0) {
                                    questions.push(item.value);
                            }
                    });
    
      var array = dojo.toJson(questions);
    
      parentWin.newQuestions = array;
          parentWin.curam.matrix.Constants.container.matrix.addQuestionsFromPopup();
      curam.dialog.closeModalDialog();
      return false;
    },
    
    getRequestParams: function(uriString) {
      var newParams = [];
      var uri = new dojo._Url(uriString);
      if (uri.query != null) {
        var paramsArray = uri.query.split("&");
        for (var i=0; i < paramsArray.length; i++) {
          var arr = paramsArray[i].split("=");
          newParams[arr[0]]=arr[1];
        }
      }
      return newParams;
    },

    // Opens a modal dialog.
    //
    // @deprecated Replaced by curam.util.openModalDialog() function.
    openModalDialog: function(eventOrAnchorTag, windowOptions, left, top) {
      curam.util.openModalDialog(eventOrAnchorTag, windowOptions, left, top);
    },

    //Applies onclick events to collapsible clusters
    initCluster: function(headerNode) {
      var parentNode = headerNode.parentNode;
      var target = dojo.query("div.toggle-group", parentNode);
    
      //If the div has already been created, then just return it
      if (target.length >= 1) {
        return target[0];
      }
    
      var next = cm.nextSibling(headerNode, "p") || cm.nextSibling(headerNode, "table");
      if (!next) {
        return;//Odd. Shouldn't happen
      }
      target = domConstruct.create("div", { "class":"toggle-group" }, next, "before");
    
      var arr = [];
      var despNode = dojo.query("p.description", headerNode)[0];
      if(despNode) {
        arr.push(despNode);
        var marginBottom = domStyle.get(headerNode, "marginBottom");
        domStyle.set(headerNode, "marginBottom", 0);
        domStyle.set(despNode, "marginBottom", marginBottom + "px");
      }
    
      //Locate cluster node
      var orgClusterNode = parentNode;
      while(orgClusterNode && !(domClass.contains(orgClusterNode, "cluster")
          || domClass.contains(orgClusterNode, "list"))) {
        orgClusterNode = orgClusterNode.parentNode;
      }
    
      target.isClosed = domClass.contains(orgClusterNode, "uncollapse") ? true : false;
    
      //Do not display if initally collapsed
      if (target.isClosed) {
        domStyle.set(target, "display", "none");
      }
    
      for (var count = 0; count < parentNode.childNodes.length; count++) {
        if (parentNode.childNodes[count] == headerNode
                    || parentNode.childNodes[count] == target) {
          continue;
        }
        arr.push(parentNode.childNodes[count]);
      }
    
      for (var count = 0; count < arr.length; count++) {
        target.appendChild(arr[count]);
      }
    
      return target;
    },

    /**
     * In some circumstances, the height of a toggled cluster becomes incorrect
     * after animating its change.  This function fixes that.
     */
    initClusterHeight: function(containerNode, headerNode, isClosed) {
      if (containerNode.correctHeight) {
        return;
      }
      var headerHeight = dojo._getBorderBox(headerNode).h;
    
      var totalHeight = 0, childNode;
      for (var count = 0; count < containerNode.childNodes.length; count++) {
        childNode = containerNode.childNodes[count];
        if (childNode == headerNode) {
          continue;
        }
        totalHeight += dojo._getBorderBox(childNode).h;
      }
      if (totalHeight == 0) {
        return;
      }
      if (isClosed) {
        domStyle.set(headerNode.parentNode, "height", "");
      }
      containerNode.correctHeight = totalHeight;
    },
    
    getCursorPosition: function(/* DOMEvent */e){
      //      summary
      //      Returns the mouse position relative to the document (not the viewport).
      //      For example, if you have a document that is 10000px tall,
      //      but your browser window is only 100px tall,
      //      if you scroll to the bottom of the document and call this function it
      //      will return {x: 0, y: 10000}
      //      NOTE: for events delivered via dojo.connect() and/or dojoAttachEvent (for widgets),
      //      you can just access evt.pageX and evt.pageY, rather than calling this function.
      e = e || dojo.global().event;
      var cursor = {x:0, y:0};
      if(e.pageX || e.pageY){
              cursor.x = e.pageX;
              cursor.y = e.pageY;
      }else{
              var de = dojo.doc().documentElement;
              var db = dojo.body();
              cursor.x = e.clientX + ((de||db)["scrollLeft"]) - ((de||db)["clientLeft"]);
              cursor.y = e.clientY + ((de||db)["scrollTop"]) - ((de||db)["clientTop"]);
      }
      return cursor;  //      object
    },
    
    overElement: function(/* HTMLElement */element, /* DOMEvent */e) {
      //      summary
      //      Returns whether the mouse is over the passed element.
      //      Element must be display:block (ie, not a <span>)
      element = dom.byId(element);
      var mouse = getCursorPosition(e);
      var bb = dojo._getBorderBox(element);
      var absolute = dojo._abs(element, true);
      var top = absolute.y;
      var bottom = top + bb.h;
      var left = absolute.x;
      var right = left + bb.w;

      return (mouse.x >= left
              && mouse.x <= right
              && mouse.y >= top
              && mouse.y <= bottom
      );      //      boolean
    },

    /**
     * Gets default and hover toggle images for LTR/RTL mode.
     */
    _getToggleImages: function() {
      var expandedImage = "../themes/curam/images/chevron--down20-enabled.svg";
      var expandedImageHover = "../themes/curam/images/chevron--down20-enabled.svg";
      var collapsedImage;
      var collapsedImageHover;

      var isRtlMode = util.isRtlMode();
      
      if (isRtlMode) {
        // Right-To-Left images
        collapsedImage = "../themes/curam/images/chevron--right20-enabled.svg";
        collapsedImageHover = "../themes/curam/images/chevron--right20-enabled.svg";
      } else {
        collapsedImage = "../themes/curam/images/chevron--left20-enabled.svg";
        collapsedImageHover = "../themes/curam/images/chevron--left20-enabled.svg";
      }
      return [expandedImage, collapsedImage, expandedImageHover, collapsedImageHover];
    },

    /**
     * Sets the cluster toggle icon to the appropriate image. This method is
     * only called when the image loads for the first time.
     */
    setToggleClusterIcon: function(img) {
      var toggleImages = this._getToggleImages();
      var initialImage = toggleImages[0]; // Set to expanded image
      
      if (img.className=="hoverIcon") {
      	initialImage = toggleImages[2] // Set to expanded hover image
  	  }

      // Check for expanded/collapsed state, in case you can have a
      // pre-collapsed cluster.
      var clusterDiv = img;
      while(clusterDiv && !(domClass.contains(clusterDiv, "cluster")
          || domClass.contains(clusterDiv, "list"))){
        clusterDiv = clusterDiv.parentNode;
      }
      if (domClass.contains(clusterDiv, "is-collapsed")) {
        if (img.className=="hoverIcon") {
          initialImage = toggleImages[3]; // Set to collapsed hover image
        } else {
          initialImage = toggleImages[1]; // Set to collapsed image
        }
       
      }

      // Set source to initial image
      img.onload = null; // Remove onload to prevent infinite loop
      img.src = initialImage;
      img.alt = ""; // Alt text is handled by the enclosing span
    },

    /**
     * Shows/hides a cluster.
     */
    toggleCluster: function(clusterDiv, event) {
      
      var toggleButtonSpan = clusterDiv;

      // Get the default image and hover image so we can modify it later
      var img;
      var imgHover;
      var imgArray = dojo.query('img', clusterDiv);
      if (imgArray && imgArray.length == 2) {
        img = imgArray[0];
        imgHover = imgArray[1];
      }
      var toggleImages = this._getToggleImages();
      var expandedImage = toggleImages[0];
      var collapsedImage = toggleImages[1];
      var expandedImageHover = toggleImages[2];
      var collapsedImageHover = toggleImages[3];

      //find the top node containing the onclick arrow.
      while(clusterDiv && !(domClass.contains(clusterDiv, "cluster")
          || domClass.contains(clusterDiv, "list"))){
        clusterDiv = clusterDiv.parentNode;
      }

      //used to track if the cluster has a description.
      var descExists = false;
      
      //We will use dojo.fx animation to preform the expansion/collapsing of our clusters & lists
      //dojo.fx works best on div elements, so we must make the cluster table a child of a div
      //if there are other associated divs, already in place, that must also be part of the animation,
      //then these will be appended to target2, e.g. paginated lists page index

      //find all sibling elements of cluster head wrapper
      var toggleElements = dojo.query(' > :not(.header-wrapper) ', clusterDiv.childNodes[0]);
      
      //put all non-divs in target and divs in target 2
      if (!domClass.contains(toggleElements[0], "toggleDiv")) { //check if already created
        var target = domConstruct.create('div', { className: 'toggleDiv'}, toggleElements[0].parentNode);
        var target2 = domConstruct.create('div', { className: 'toggleDiv2'}, toggleElements[0].parentNode);
        toggleElements.forEach( function (node){

          // search for CKEditor instances. These need to be destroyed and recreated during 
          // the dom manipulation
          var editorTextareaID;
          var configFile;
          dojo.query('.cke', node).forEach(function(element) {
            // find the ID of the sibling textarea, which is where the editor will be reattached
            editorTextareaID = dojo.query('textarea', element.parentElement)[0].id;
            
            for(var i in CKEDITOR.instances) {
            	// match the editor instance name with the textarea ID
            	if (CKEDITOR.instances[i].name.includes(editorTextareaID)) {
                  // make sure to keep the existing config for recreating the editor
                  configFile = CKEDITOR.instances[i].config.customConfig;
                  CKEDITOR.instances[i].destroy();	
            	  }
              }
          });

            //append all found siblings
          if(node.tagName != "DIV") {
            target.appendChild(node);
          }
          else {
            target2.appendChild(node);
          }

          // replace CKEditor
          if (editorTextareaID) {
            CKEDITOR.replace(editorTextareaID, { customConfig: configFile });
          }
        });
      } else { //use already created.
        var target = toggleElements[0];
        var target2 = toggleElements[1];
      }
      
      //check for description, this will also have to be part of the animation
      var desc = dojo.query(' > .header-wrapper p ', clusterDiv.childNodes[0])[0];
      if(typeof desc != 'undefined'){
        descExists = true;
      }
      
      //should not be displayed if set to collapsed in uim
      if (domClass.contains(clusterDiv, "init-collapsed")) {
        domClass.remove(clusterDiv, "init-collapsed");
        domStyle.set(target, "display", "none");
      }
      
      //return if the animation has already begun
      if (!target || target.inAnimation) {
        return;
      }
      
      require(["dojo/fx"], function(fx) {
        //The arguments passed to the dojo.fx function are created here
        
        //wipeIn arguments. Used when expanding the cluster
        var DirDownArgs = {
          node: target,
          duration: 600,
          onBegin: function () {
            target.inAnimation = true;
            domClass.remove(clusterDiv, "is-collapsed");
            domClass.add(clusterDiv, "is-uncollapsed");
            domAttr.set(toggleButtonSpan, "aria-expanded", "true");
            dojo.stopEvent(event);
          },
          onEnd: function() { //change class name to reflect state.
            target.inAnimation = false;
          }
        };
      
        //wipeOut arguments. Used when collapsing the cluster
        var DirUpArgs = {
          node: target,
          duration: 600,
          onBegin: function () {
            target.inAnimation = true;
            domClass.remove(clusterDiv, "is-uncollapsed");
            domClass.add(clusterDiv, "is-collapsed");
            domAttr.set(toggleButtonSpan, "aria-expanded", "false");
            dojo.stopEvent(event);
          },
          onEnd: function() { //change class name to reflect state.
            target.inAnimation = false;
          }
        };
      
        
        //if associated divs exists, create their related animation args
        if (target2.hasChildNodes()) {
          var pageIndexDown = {
            node: target2,
            duration: 600
          };
          
          var pageIndexUp = {
              node: target2,
              duration: 600
            };
        }
      
        //if description exists, create its related animation args
        if(descExists) {
          var descDown = {
            node: desc,
            duration: 100
          };
          
          var descUp = {
              node: desc,
              duration: 100,
              delay: 500
            };
        }
        //end of arguments
      
        //Preform animation.
        //There will always be a cluster body, but we must cater for the presence
        //of descriptions and page indexes
        if (domClass.contains(clusterDiv, "is-collapsed")) { //will expand cluster
          if(typeof descDown != 'undefined') {
            fx.wipeIn(descDown).play(); //description exists
          }
          fx.wipeIn(DirDownArgs).play();  //main cluster body
          if(typeof pageIndexDown != 'undefined') {
            fx.wipeIn(pageIndexDown).play();  //page index exists
          }
          if (img) {
            img.src = expandedImage;
          }
          if (imgHover) {
            imgHover.src = expandedImageHover;
          }

        } else if (domClass.contains(clusterDiv, "is-uncollapsed")) { //will collapse cluster
          if(typeof pageIndexUp != 'undefined') {
            fx.wipeOut(pageIndexUp).play(); //page index exists
          }
          fx.wipeOut(DirUpArgs).play(); //main cluster body
          if(typeof descUp != 'undefined') {
            fx.wipeOut(descUp).play(); //description exists
          }
          if (img) {
            img.src = collapsedImage;
          }
          if (imgHover) {
            imgHover.src = collapsedImageHover;
          }

        } else {
          debug.log("The cluster does not have a class name indicating" +
                      "its collapsed/uncollapsed state");
        }
      });
    },

    /**
     * Removes the ability to show/hide a cluster or list
     */
    disableClusterToggle: function(node) {
      dojo.addOnLoad(function(){
        node = dom.byId(node);
        var body = dojo.body();
        while (node && node != body) {
          if (domClass.contains(node, "is-collapsed") || domClass.contains(node, "is-uncollapsed")) {
            domClass.remove(node, "is-collapsed");
            domClass.remove(node, "is-uncollapsed");
            domAttr.remove(dojo.query("BUTTON.grouptoggleArrow", node)[0], "onclick");
          }
          node = node.parentNode;
        }
      });
    },
    
    addClassToPositionQuestionaireStatic: function() {
      var body = document.getElementsByTagName('body')[0];
      body.className = body.className + " static-print-position";
    },
    
    openUserPrefsEditor: function(event) {
      event = dojo.fixEvent(event);
      var target = event.target;
      while(target && target.tagName != "A") {
        target = target.parentNode;
      }
      
      // mock window object to pass to RuntimeContext
      var mockWindow = {
        location: {
          href:target.href
        }
      };
      var rtc = new curam.util.RuntimeContext(mockWindow);
    
      var href = curam.util.setRpu("user-locale-selector.jspx", rtc);
    
      openModalDialog({href:href},"width=500,height=300",200,150, false);
      return false;
    },

    /**
     * Function that handles the clicks on standard activity
     * links in the calandar.
     *
     * @param event mouse click event object.
     * @param anchor the anchor element which has the URL.
     */
    calendarOpenModalDialog: function(event, anchor) {
      // this stops the event from propagating to any other event handlers e.g. UIMPageAdaptor.
      dojo.stopEvent(event);
      //any change in the functionality of opening modal dialog has an impact on this method too.
      curam.util.openModalDialog(anchor, "");
    },

    /**
     * Dummy function associated with certain link clicks to expose these events
     * to the underlying infrastructure (modal dialog).
     */
    clickMarker: function() {
      return true;
    }
  };

  // Keep the functions in the global scope for backwards compatibility.
  // TODO: remove when code calling these functions is updated
  for (prop in omega3Util) {
    dojo.global[prop] = omega3Util[prop];
  }
  
  return omega3Util;
});

},
'curam/widget/_ComboBoxMenu':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2019. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/**
 * Override of the Dojo _ComboBoxMenu module to add an additional attribute to
 * blank drop down options, enabling screen readers to correctly read the entry. 
 */
define(["dojo/_base/declare",
        "dojo/dom-attr",
        "curam/util/ResourceBundle",
        "dijit/form/_ComboBoxMenu"
], function(declare, domAttr, ResourceBundle) {
  
  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  //dojo.requireLocalization("curam.application", "FilteringSelect");
  var bundle = new ResourceBundle("FilteringSelect");
  
  /*
   * Modification History
   * --------------------
   * 01-Aug-2019 RS [RTC249288] Added a regular expression to remove HTML Tags before adding 
   *                            menuitem.innerHTML to menuitem.title
   * 14-Sep-2017 SO [RTC205990] Changed the title value from &nbsp; to Blank Value to fix screen readers issue
   * 21-Mar-2017 GB [RTC185863] Adding a title to the MenuItem so we have a tooltip displayed.
   * 20-Nov-2015 AZ [CR00472692] Initial Version
   */
  /**
   * @name curam.widget._ComboBoxMenu
   * @namespace Override of the Dojo _ComboBoxMenu in order to make the _ComboBoxMenu
   *              accessible using screen reader.
   */
  var ComboBoxMenu = declare("curam.widget._ComboBoxMenu", [dijit.form._ComboBoxMenu],
  /**
   * @lends curam.widget._ComboBoxMenu.prototype
   */
  {
    _createOption: function(/*Object*/ item, labelFunc){
    
      var menuitem = this._createMenuItem();
      var labelObject = labelFunc(item);
      if(labelObject.html){
        menuitem.innerHTML = labelObject.label;
      }else{
        menuitem.appendChild(
          menuitem.ownerDocument.createTextNode(labelObject.label)
        );
      }
      
      // #3250: in blank options, assign a normal height
      if(menuitem.innerHTML == ""){
        // CURAM CUSTOMIZATION START - Adding aria-label attribute to blank option to ensure
        // that the entry can be read by screen readers.
    	//menuitem.innerHTML = "&#160;";  // &nbsp;
        domAttr.set(menuitem, "aria-label", bundle.getProperty("curam.select.option.blank"));
        domAttr.set(menuitem, "title", bundle.getProperty("curam.select.option.blank"));
        // CURAM CUSTOMIZATION END
      } else {
    	  // This regular expression strips out HTML tags from the memuitem.innerHTML so only words, 
    	  // special characters and numbers can be added in the manuitem.title
    	  var removeHTMLTags = /<[a-zA-Z\/][^>]*>/g;
    	  var innerHTML = menuitem.innerHTML;
          menuitem.title = innerHTML.replace(removeHTMLTags,'');
      }
      return menuitem;
    }
  });

  return ComboBoxMenu;
});
},
'dijit/form/_AutoCompleterMixin':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.get
	"dojo/keys",
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/regexp", // regexp.escapeString
	"dojo/sniff", // has("ie")
	"./DataList",
	"./_TextBoxMixin", // defines _TextBoxMixin.selectInputText
	"./_SearchMixin"
], function(aspect, declare, domAttr, keys, lang, query, regexp, has, DataList, _TextBoxMixin, SearchMixin){

	// module:
	//		dijit/form/_AutoCompleterMixin

	var AutoCompleterMixin = declare("dijit.form._AutoCompleterMixin", SearchMixin, {
		// summary:
		//		A mixin that implements the base functionality for `dijit/form/ComboBox`/`dijit/form/FilteringSelect`
		// description:
		//		All widgets that mix in dijit/form/_AutoCompleterMixin must extend `dijit/form/_FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo/store/api/Store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		//		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(has("ie")){
				// in the case of a mouse click in a popup being handled,
				// then the document.selection is not the textarea, but the popup
				// var r = document.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = element.ownerDocument.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character", 0);
				ntr.move("character", 0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g, "").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			_TextBoxMixin.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			this.domNode.setAttribute("aria-disabled", value ? "true" : "false");
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			if(evt.charCode >= 32){
				return;
			} // alphanumeric reserved for searching

			var key = evt.charCode || evt.keyCode;

			// except for cutting/pasting case - ctrl + x/v
			if(key == keys.ALT || key == keys.CTRL || key == keys.META || key == keys.SHIFT){
				return; // throw out spurious events
			}

			var pw = this.dropDown;
			var highlighted = null;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//
			//	1. when drop down is not yet shown:
			//		- if user presses the down arrow key, call loadDropDown()
			//	2. when drop down is already displayed:
			//		- on ESC key, call closeDropDown()
			//		- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(evt.altKey || evt.ctrlKey || evt.metaKey){
				return;
			} // don't process keys with modifiers  - but we want shift+TAB

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					evt.stopPropagation();
					evt.preventDefault();
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							// prevent submit
							evt.stopPropagation();
							evt.preventDefault();
							break;
						}
						// prevent submit if ENTER was to choose an item
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
				// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
						break;
					}
					if(highlighted){
						this._selectOption(highlighted);
					}
				// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			//		Fill in the textbox with the first item from the drop down
			//		list, and highlight the characters that were
			//		auto-completed. For example, if user typed "CA" and the
			//		drop down list appeared, the textbox would be changed to
			//		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			_TextBoxMixin.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase ? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
				// only try to extend if we added the last character at the end of the input
				if((cpos + 1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					_TextBoxMixin.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				_TextBoxMixin.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			var wasSelected = this.dropDown.getHighlightedOption();
			this.dropDown.clearResultList();
			if(!results.length && options.start == 0){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}
			this._nextSearch = this.dropDown.onPage = lang.hitch(this, function(direction){
				results.nextPage(direction !== -1);
				this.focus();
			});

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			this.dropDown.createOptions(
				results,
				options,
				lang.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if("direction" in options){
				if(options.direction){
					this.dropDown.highlightFirstOption();
				}else if(!options.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(query[this.searchAttr].toString())){
				this._announceOption(this.dropDown.containerNode.firstChild.nextSibling); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).
			this.closeDropDown(true);
			this.openDropDown();
			this.domNode.setAttribute("aria-expanded", "true");
		},

		loadDropDown: function(/*Function*/ /*===== callback =====*/){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				this.domNode.setAttribute("aria-expanded", "false");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (newvalue == pw._messages["previousMessage"] || newvalue == pw._messages["nextMessage"])){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					this._handleOnChange(this.value, true);
				}
				this._refreshState();
			}
			// Remove aria-activedescendant since it may not be removed if they select with arrows then blur with mouse
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			var value = '';
			if(item){
				if(!displayedValue){
					displayedValue = this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
						this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
				}
				value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
			}
			this.set('value', value, priorityChange, displayedValue, item);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				var item = this.dropDown.items[node.getAttribute("item")];
				newValue = (this.store._oldAPI ? // remove getValue() for 2.0 (old dojo.data API)
					this.store.getValue(item, this.searchAttr) : item[this.searchAttr]).toString();
				this.set('item', item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._handleOnChange(this.value, true);
			// Remove aria-activedescendant since the drop down is no loner visible
			// after closeDropDown() but _announceOption() adds it back in
			this.focusNode.removeAttribute("aria-activedescendant");
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this.item = undefined; // undefined means item needs to be set
			this.inherited(arguments);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
					dropDownConstructor = lang.isString(this.dropDownClass) ?
						lang.getObject(this.dropDownClass, false) : this.dropDownClass;
				this.dropDown = new dropDownConstructor({
					onChange: lang.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir,
					textDir: this.textDir
				});
			}
			this._lastInput = key; // Store exactly what was entered by the user.
			this.inherited(arguments);
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit/form/_ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		postMixInProperties: function(){
			this.inherited(arguments);
			if(!this.store && this.srcNodeRef){
				var srcNodeRef = this.srcNodeRef;
				// if user didn't specify store, then assume there are option tags
				this.store = new DataList({}, srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native Select
				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						// remove getValue() for 2.0 (old dojo.data API)
						this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
					}
				}
			}
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label = query('label[for="' + this.id + '"]');
			if(label.length){
				if(!label[0].id){
					label[0].id = this.id + "_label";
				}
				this.domNode.setAttribute("aria-labelledby", label[0].id);

			}
			this.inherited(arguments);
			aspect.after(this, "onSearch", lang.hitch(this, "_openResultList"), true);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._lastInput);
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
			// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = regexp.escapeString(find); // escape regexp special chars
			//If < appears in label, and user presses t, we don't want to highlight the t in the escaped "&lt;"
			//first find out every occurrences of "find", wrap each occurrence in a pair of "\uFFFF" characters (which
			//should not appear in any string). then html escape the whole string, and replace '\uFFFF" with the
			//HTML highlight markup.
			return this._escapeHtml(label.replace(
				new RegExp((i == 0 ? "^" : "") + "(" + find + ")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'\uFFFF$1\uFFFF')).replace(
				/\uFFFF([^\uFFFF]+)\uFFFF/g, '<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: `&<>"'`
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;"); //balance"
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(item, store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// item: Object
			//		The item from the store
			// store: dojo/store/api/Store
			//		The store.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354).
			// Remove getValue() for 2.0 (old dojo.data API)
			return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) :
				item[this.labelAttr || this.searchAttr]).toString(); // String
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", item || null); // value not looked up in store
			if(value == null /* or undefined */){
				value = '';
			} // null translates to blank
			this.inherited(arguments);
		}
	});

	if(has("dojo-bidi")){
		AutoCompleterMixin.extend({
			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir, needed for the dropDown's textDir update.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private
				this.inherited(arguments);
				// update the drop down also (_ComboBoxMenuMixin)
				if(this.dropDown){
					this.dropDown._set("textDir", textDir);
				}
			}
		});
	}

	return AutoCompleterMixin;
});

},
'dijit/TitlePane':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set or get domAttr.remove
	"dojo/dom-class", // domClass.replace
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.getMarginBox
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER
	"./_CssStateMixin",
	"./_TemplatedMixin",
	"./layout/ContentPane",
	"dojo/text!./templates/TitlePane.html",
	"./_base/manager",    // defaultDuration
	"./a11yclick"	// template uses ondijitclick
], function(array, declare, dom, domAttr, domClass, domGeometry, fxUtils, has, kernel, keys,
			_CssStateMixin, _TemplatedMixin, ContentPane, template, manager){

	// module:
	//		dijit/TitlePane

	var TitlePane = declare("dijit.TitlePane", [ContentPane, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		A pane with a title on top, that can be expanded or collapsed.
		//
		// description:
		//		An accessible container with a title Heading, and a content
		//		section that slides open and closed. TitlePane is an extension to
		//		`dijit/layout/ContentPane`, providing all the useful content-control aspects from it.
		//
		// example:
		//	|	// load a TitlePane from remote file:
		//	|	var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
		//	|	foo.startup();
		//
		// example:
		//	|	<!-- markup href example: -->
		//	|	<div data-dojo-type="dijit/TitlePane" data-dojo-props="href: 'foobar.html', title: 'Title'"></div>
		//
		// example:
		//	|	<!-- markup with inline data -->
		//	|	<div data-dojo-type="dijit/TitlePane" title="Title">
		//	|		<p>I am content</p>
		//	|	</div>

		// title: String
		//		Title of the pane
		title: "",
		_setTitleAttr: { node: "titleNode", type: "innerHTML" }, // override default where title becomes a hover tooltip

		// open: Boolean
		//		Whether pane is opened or closed.
		open: true,

		// toggleable: Boolean
		//		Whether pane can be opened or closed by clicking the title bar.
		toggleable: true,

		// tabIndex: String
		//		Tabindex setting for the title (so users can tab to the title then
		//		use space/enter to open/close the title pane)
		tabIndex: "0",

		// duration: Integer
		//		Time in milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		// baseClass: [protected] String
		//		The root className to be placed on this widget's domNode.
		baseClass: "dijitTitlePane",

		templateString: template,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for TitlePane, since TitlePane
		//		is never a child of a layout container, nor should TitlePane try to control
		//		the size of an inner widget.
		doLayout: false,

		// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
		_setTooltipAttr: {node: "focusNode", type: "attribute", attribute: "title"}, // focusNode spans the entire width, titleNode doesn't

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.titleNode, false);
		},

		postCreate: function(){
			this.inherited(arguments);

			// Hover and focus effect on title bar, except for non-toggleable TitlePanes
			// This should really be controlled from _setToggleableAttr() but _CssStateMixin
			// doesn't provide a way to disconnect a previous _trackMouseState() call
			if(this.toggleable){
				this._trackMouseState(this.titleBarNode, this.baseClass + "Title");
			}

			// setup open/close animations
			var hideNode = this.hideNode, wipeNode = this.wipeNode;
			this._wipeIn = fxUtils.wipeIn({
				node: wipeNode,
				duration: this.duration,
				beforeBegin: function(){
					hideNode.style.display = "";
				}
			});
			this._wipeOut = fxUtils.wipeOut({
				node: wipeNode,
				duration: this.duration,
				onEnd: function(){
					hideNode.style.display = "none";
				}
			});
		},

		_setOpenAttr: function(/*Boolean*/ open, /*Boolean*/ animate){
			// summary:
			//		Hook to make set("open", boolean) control the open/closed state of the pane.
			// open: Boolean
			//		True if you want to open the pane, false if you want to close it.

			array.forEach([this._wipeIn, this._wipeOut], function(animation){
				if(animation && animation.status() == "playing"){
					animation.stop();
				}
			});

			if(animate){
				var anim = this[open ? "_wipeIn" : "_wipeOut"];
				anim.play();
			}else{
				this.hideNode.style.display = this.wipeNode.style.display = open ? "" : "none";
			}

			// load content (if this is the first time we are opening the TitlePane
			// and content is specified as an href, or href was set when hidden)
			if(this._started){
				if(open){
					this._onShow();
				}else{
					this.onHide();
				}
			}

			this.containerNode.setAttribute("aria-hidden", open ? "false" : "true");
			this.focusNode.setAttribute("aria-pressed", open ? "true" : "false");

			this._set("open", open);

			this._setCss();
		},

		_setToggleableAttr: function(/*Boolean*/ canToggle){
			// summary:
			//		Hook to make set("toggleable", boolean) work.
			// canToggle: Boolean
			//		True to allow user to open/close pane by clicking title bar.

			this.focusNode.setAttribute("role", canToggle ? "button" : "heading");
			if(canToggle){
				this.focusNode.setAttribute("aria-controls", this.id + "_pane");
				this.focusNode.setAttribute("tabIndex", this.tabIndex);
				this.focusNode.setAttribute("aria-pressed", this.open);
			}else{
				domAttr.remove(this.focusNode, "aria-controls");
				domAttr.remove(this.focusNode, "tabIndex");
				domAttr.remove(this.focusNode, "aria-pressed");
			}

			this._set("toggleable", canToggle);

			this._setCss();
		},

		_setContentAttr: function(/*String|DomNode|Nodelist*/ content){
			// summary:
			//		Hook to make set("content", ...) work.
			//		Typically called when an href is loaded.  Our job is to make the animation smooth.

			if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
				// we are currently *closing* the pane (or the pane is closed), so just let that continue
				this.inherited(arguments);
			}else{
				if(this._wipeIn && this._wipeIn.status() == "playing"){
					this._wipeIn.stop();
				}

				// freeze container at current height so that adding new content doesn't make it jump
				domGeometry.setMarginBox(this.wipeNode, { h: domGeometry.getMarginBox(this.wipeNode).h });

				// add the new content (erasing the old content, if any)
				this.inherited(arguments);

				// call _wipeIn.play() to animate from current height to new height
				if(this._wipeIn){
					this._wipeIn.play();
				}else{
					this.hideNode.style.display = "";
				}
			}
		},

		toggle: function(){
			// summary:
			//		Switches between opened and closed state
			// tags:
			//		private

			this._setOpenAttr(!this.open, true);
		},

		_setCss: function(){
			// summary:
			//		Set the open/close css state for the TitlePane
			// tags:
			//		private

			var node = this.titleBarNode || this.focusNode;
			var oldCls = this._titleBarClass;
			this._titleBarClass = this.baseClass + "Title" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
			domClass.replace(node, this._titleBarClass, oldCls || "");

			// Back compat, remove for 2.0
			domClass.replace(node, this._titleBarClass.replace("TitlePaneTitle", ""), (oldCls || "").replace("TitlePaneTitle", ""));

			this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
		},

		_onTitleKey: function(/*Event*/ e){
			// summary:
			//		Handler for when user hits a key
			// tags:
			//		private

			if(e.keyCode == keys.DOWN_ARROW && this.open){
				this.containerNode.focus();
				e.preventDefault();
			}
		},

		_onTitleClick: function(){
			// summary:
			//		Handler when user clicks the title bar
			// tags:
			//		private
			if(this.toggleable){
				this.toggle();
			}
		},

		setTitle: function(/*String*/ title){
			// summary:
			//		Deprecated.  Use set('title', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use set('title', ...) instead.", "", "2.0");
			this.set("title", title);
		}
	});

	if(has("dojo-bidi")){
		TitlePane.extend({
			_setTitleAttr: function(/*String*/ title){
				// Override default where title becomes a hover tooltip
				this._set("title", title);
				this.titleNode.innerHTML = title;
				this.applyTextDir(this.titleNode);
			},

			_setTooltipAttr: function(/*String*/ tooltip){
				this._set("tooltip", tooltip);
				if(this.textDir){
					tooltip = this.enforceTextDirWithUcc(null, tooltip);
				}
				domAttr.set(this.focusNode, "title", tooltip);			// focusNode spans the entire width, titleNode doesn't
			},

			_setTextDirAttr: function(textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this.set("title", this.title);
					this.set("tooltip", this.tooltip);
				}
			}
		});
	}

	return TitlePane;
});

},
'curam/layout/EmptyContentPane':function(){
/*
 * Copyright 2010-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define(["dojo/_base/declare",
        "dijit/layout/ContentPane"
        ], function(declare) {

  /*
   * Modification History
   * --------------------
   * 26-Oct-2011 MV [CR00289694] Added required comments.
   */

  /**
   * @name curam.layout.EmptyContentPane
   * @namespace Empty content pane implementation.
   * 
   */
  var EmptyContentPane = declare(
      "curam.layout.EmptyContentPane", dijit.layout.ContentPane,
  /**
   * @lends curam.layout.EmptyContentPane.prototype
   */
  {
    baseClass: "",
    _layoutChildren: function(){},
    resize: function(){}
  });
  
  return EmptyContentPane;
});

},
'dijit/place':function(){
define([
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"./Viewport", // getEffectiveBox
	"./main"	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, Viewport, dijit){

	// module:
	//		dijit/place


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = Viewport.getEffectiveBox(node.ownerDocument);

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to <body>.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff.)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body(node.ownerDocument).appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				}[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				}[corner.charAt(0)]
			};

			// Clear left/right position settings set earlier so they don't interfere with calculations,
			// specifically when layoutNode() (a.k.a. Tooltip.orient()) measures natural width of Tooltip
			var s = node.style;
			s.left = s.right = "auto";

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var bb = domGeometry.position(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - bb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (bb.w >> 1)) - bb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - bb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (bb.h >> 1)) - bb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + bb.w),
				endY = Math.min(view.t + view.h, startYpos + bb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (bb.w - width) + (bb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).

		var top = best.y,
			side = best.x,
			body = win.body(node.ownerDocument);

		if(/relative|absolute/.test(domStyle.get(body, "position"))){
			// compensate for margin on <body>, see #16148
			top -= domStyle.get(body, "marginTop");
			side -= domStyle.get(body, "marginLeft");
		}

		var s = node.style;
		s.top = top + "px";
		s.left = side + "px";
		s.right = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	var reverse = {
		// Map from corner to kitty-corner
		"TL": "BR",
		"TR": "BL",
		"BL": "TR",
		"BR": "TL"
	};

	var place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding, layoutNode){
			// summary:
			//		Positions node kitty-corner to the rectangle centered at (pos.x, pos.y) with width and height of
			//		padding.x * 2 and padding.y * 2, or zero if padding not specified.  Picks first corner in corners[]
			//		where node is fully visible, or the corner where it's most visible.
			//
			//		Node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit/place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners of the node in, like ["TR", "BL"].
			//		Possible values are:
			//
			//		- "BL" - bottom left
			//		- "BR" - bottom right
			//		- "TL" - top left
			//		- "TR" - top right
			// padding: dijit/place.__Position?
			//		Optional param to set padding, to put some buffer around the element you want to position.
			//		Defaults to zero.
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.  This adjusts the popup based on orientation.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = {
					corner: corner,
					aroundCorner: reverse[corner],	// so TooltipDialog.orient() gets aroundCorner argument set
					pos: {x: pos.x,y: pos.y}
				};
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices, layoutNode);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode|dijit/place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			// anchor:
			//		Either a DOMNode or a rectangle (object with x, y, width, height).
			// positions:
			//		Ordered list of positions to try matching up.
			//
			//		- before: places drop down to the left of the anchor node/widget, or to the right in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- after: places drop down to the right of the anchor node/widget, or to the left in the case
			//			of RTL scripts like Hebrew and Arabic; aligns either the top of the drop down
			//			with the top of the anchor, or the bottom of the drop down with bottom of the anchor.
			//		- before-centered: centers drop down to the left of the anchor node/widget, or to the right
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- after-centered: centers drop down to the right of the anchor node/widget, or to the left
			//			in the case of RTL scripts like Hebrew and Arabic
			//		- above-centered: drop down is centered above anchor node
			//		- above: drop down goes above anchor node, left sides aligned
			//		- above-alt: drop down goes above anchor node, right sides aligned
			//		- below-centered: drop down is centered above anchor node
			//		- below: drop down goes below anchor node
			//		- below-alt: drop down goes below anchor node, right sides aligned
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			//		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// If around is a DOMNode (or DOMNode id), convert to coordinates.
			var aroundNodePos;
			if(typeof anchor == "string" || "offsetWidth" in anchor || "ownerSVGElement" in anchor){
				aroundNodePos = domGeometry.position(anchor, true);

				// For above and below dropdowns, subtract width of border so that popup and aroundNode borders
				// overlap, preventing a double-border effect.  Unfortunately, difficult to measure the border
				// width of either anchor or popup because in both cases the border may be on an inner node.
				if(/^(above|below)/.test(positions[0])){
					var anchorBorder = domGeometry.getBorderExtents(anchor),
						anchorChildBorder = anchor.firstChild ? domGeometry.getBorderExtents(anchor.firstChild) : {t:0,l:0,b:0,r:0},
						nodeBorder =  domGeometry.getBorderExtents(node),
						nodeChildBorder = node.firstChild ? domGeometry.getBorderExtents(node.firstChild) : {t:0,l:0,b:0,r:0};
					aroundNodePos.y += Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t + nodeChildBorder.t);
					aroundNodePos.h -=  Math.min(anchorBorder.t + anchorChildBorder.t, nodeBorder.t+ nodeChildBorder.t) +
						Math.min(anchorBorder.b + anchorChildBorder.b, nodeBorder.b + nodeChildBorder.b);
				}
			}else{
				aroundNodePos = anchor;
			}

			// Compute position and size of visible part of anchor (it may be partially hidden by ancestor nodes w/scrollbars)
			if(anchor.parentNode){
				// ignore nodes between position:relative and position:absolute
				var sawPosAbsolute = domStyle.getComputedStyle(anchor).position == "absolute";
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true),
						pcs = domStyle.getComputedStyle(parent);
					if(/relative|absolute/.test(pcs.position)){
						sawPosAbsolute = false;
					}
					if(!sawPosAbsolute && /hidden|auto|scroll/.test(pcs.overflow)){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}
					if(pcs.position == "absolute"){
						sawPosAbsolute = true;
					}
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit/place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						}[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						}[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after-centered":
						ltr = !ltr;
						// fall through
					case "before-centered":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "TL" : "TR", ltr ? "TR" : "TL");
						push(ltr ? "BL" : "BR", ltr ? "BR" : "BL");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.  Remove for 2.0.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	};

	/*=====
	place.__Position = {
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body
	};
	place.__Rectangle = {
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" for backwards-compatibility.
	};
	=====*/

	return dijit.place = place;	// setting dijit.place for back-compat, remove for 2.0
});

},
'dijit/form/ComboBox':function(){
define([
	"dojo/_base/declare", // declare
	"./ValidationTextBox",
	"./ComboBoxMixin"
], function(declare, ValidationTextBox, ComboBoxMixin){

	// module:
	//		dijit/form/ComboBox

	return declare("dijit.form.ComboBox", [ValidationTextBox, ComboBoxMixin], {
		// summary:
		//		Auto-completing text box
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.
	});
});

},
'dijit/layout/_LayoutWidget':function(){
define([
	"dojo/_base/lang", // lang.mixin
	"../_Widget",
	"../_Container",
	"../_Contained",
	"../Viewport",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style" // domStyle.getComputedStyle
], function(lang, _Widget, _Container, _Contained, Viewport,
	declare, domClass, domGeometry, domStyle){

	// module:
	//		dijit/layout/_LayoutWidget


	return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title property (used to specify
		// tab labels) to be set as an attribute on this.domNode... otherwise a tooltip shows up over the
		// entire widget.
		_setTitleAttr: null,

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under <body>.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent();
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		####Change size mode:
			//
			//		When changeSize is specified, changes the marginBox of this widget
			//		and forces it to re-layout its contents accordingly.
			//		changeSize may specify height, width, or both.
			//
			//		If resultSize is specified it indicates the size the widget will
			//		become after changeSize has been applied.
			//
			//		####Notification mode:
			//
			//		When changeSize is null, indicates that the caller has already changed
			//		the size of the widget, or perhaps it changed because the browser
			//		window was resized.  Tells widget to re-layout its contents accordingly.
			//
			//		If resultSize is also specified it indicates the size the widget has
			//		become.
			//
			//		In either mode, this method also:
			//
			//		1. Sets this._borderBox and this._contentBox to the new size of
			//			the widget.  Queries the current domNode size if necessary.
			//		2. Calls layout() to resize contents (and maybe adjust child widgets).
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				domGeometry.setMarginBox(node, changeSize);
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = lang.mixin(domGeometry.getMarginBox(node), mb);	// just use domGeometry.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling domGeometry.getContentBox() since that may fail if size was recently set)
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var be = domGeometry.getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = domGeometry.getPadExtents(node, cs);
			this._contentBox = {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit/_WidgetBase*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			domClass.add(child.domNode, cls);
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			domClass.remove(child.domNode, cls);

			this.inherited(arguments);
		}
	});
});

},
'dojo/cldr/supplemental':function(){
define(["../_base/lang", "../i18n"], function(lang, i18n){

// module:
//		dojo/cldr/supplemental


var supplemental = {
	// summary:
	//		TODOC
};
lang.setObject("dojo.cldr.supplemental", supplemental);

supplemental.getFirstDayOfWeek = function(/*String?*/locale){
	// summary:
	//		Returns a zero-based index for first day of the week
	// description:
	//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		bd:5,mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,iq:6,ir:6,jo:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,sy:6,ye:6,
		ag:0,ar:0,as:0,au:0,br:0,bs:0,bt:0,bw:0,by:0,bz:0,ca:0,cn:0,
		co:0,dm:0,'do':0,et:0,gt:0,gu:0,hk:0,hn:0,id:0,ie:0,il:0,'in':0,
		jm:0,jp:0,ke:0,kh:0,kr:0,la:0,mh:0,mm:0,mo:0,mt:0,mx:0,mz:0,
		ni:0,np:0,nz:0,pa:0,pe:0,ph:0,pk:0,pr:0,py:0,sg:0,sv:0,th:0,
		tn:0,tt:0,tw:0,um:0,us:0,ve:0,vi:0,ws:0,za:0,zw:0
	};

	var country = supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

supplemental._region = function(/*String?*/locale){
	locale = i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {
			aa:"et", ab:"ge", af:"za", ak:"gh", am:"et", ar:"eg", as:"in", av:"ru", ay:"bo", az:"az", ba:"ru",
			be:"by", bg:"bg", bi:"vu", bm:"ml", bn:"bd", bo:"cn", br:"fr", bs:"ba", ca:"es", ce:"ru", ch:"gu",
			co:"fr", cr:"ca", cs:"cz", cv:"ru", cy:"gb", da:"dk", de:"de", dv:"mv", dz:"bt", ee:"gh", el:"gr",
			en:"us", es:"es", et:"ee", eu:"es", fa:"ir", ff:"sn", fi:"fi", fj:"fj", fo:"fo", fr:"fr", fy:"nl",
			ga:"ie", gd:"gb", gl:"es", gn:"py", gu:"in", gv:"gb", ha:"ng", he:"il", hi:"in", ho:"pg", hr:"hr",
			ht:"ht", hu:"hu", hy:"am", ia:"fr", id:"id", ig:"ng", ii:"cn", ik:"us", "in":"id", is:"is", it:"it",
			iu:"ca", iw:"il", ja:"jp", ji:"ua", jv:"id", jw:"id", ka:"ge", kg:"cd", ki:"ke", kj:"na", kk:"kz",
			kl:"gl", km:"kh", kn:"in", ko:"kr", ks:"in", ku:"tr", kv:"ru", kw:"gb", ky:"kg", la:"va", lb:"lu",
			lg:"ug", li:"nl", ln:"cd", lo:"la", lt:"lt", lu:"cd", lv:"lv", mg:"mg", mh:"mh", mi:"nz", mk:"mk",
			ml:"in", mn:"mn", mo:"ro", mr:"in", ms:"my", mt:"mt", my:"mm", na:"nr", nb:"no", nd:"zw", ne:"np",
			ng:"na", nl:"nl", nn:"no", no:"no", nr:"za", nv:"us", ny:"mw", oc:"fr", om:"et", or:"in", os:"ge",
			pa:"in", pl:"pl", ps:"af", pt:"br", qu:"pe", rm:"ch", rn:"bi", ro:"ro", ru:"ru", rw:"rw", sa:"in",
			sd:"in", se:"no", sg:"cf", si:"lk", sk:"sk", sl:"si", sm:"ws", sn:"zw", so:"so", sq:"al", sr:"rs",
			ss:"za", st:"za", su:"id", sv:"se", sw:"tz", ta:"in", te:"in", tg:"tj", th:"th", ti:"et", tk:"tm",
			tl:"ph", tn:"za", to:"to", tr:"tr", ts:"za", tt:"ru", ty:"pf", ug:"cn", uk:"ua", ur:"pk", uz:"uz",
			ve:"za", vi:"vn", wa:"be", wo:"sn", xh:"za", yi:"il", yo:"ng", za:"cn", zh:"cn", zu:"za",
			ace:"id", ady:"ru", agq:"cm", alt:"ru", amo:"ng", asa:"tz", ast:"es", awa:"in", bal:"pk",
			ban:"id", bas:"cm", bax:"cm", bbc:"id", bem:"zm", bez:"tz", bfq:"in", bft:"pk", bfy:"in",
			bhb:"in", bho:"in", bik:"ph", bin:"ng", bjj:"in", bku:"ph", bqv:"ci", bra:"in", brx:"in",
			bss:"cm", btv:"pk", bua:"ru", buc:"yt", bug:"id", bya:"id", byn:"er", cch:"ng", ccp:"in",
			ceb:"ph", cgg:"ug", chk:"fm", chm:"ru", chp:"ca", chr:"us", cja:"kh", cjm:"vn", ckb:"iq",
			crk:"ca", csb:"pl", dar:"ru", dav:"ke", den:"ca", dgr:"ca", dje:"ne", doi:"in", dsb:"de",
			dua:"cm", dyo:"sn", dyu:"bf", ebu:"ke", efi:"ng", ewo:"cm", fan:"gq", fil:"ph", fon:"bj",
			fur:"it", gaa:"gh", gag:"md", gbm:"in", gcr:"gf", gez:"et", gil:"ki", gon:"in", gor:"id",
			grt:"in", gsw:"ch", guz:"ke", gwi:"ca", haw:"us", hil:"ph", hne:"in", hnn:"ph", hoc:"in",
			hoj:"in", ibb:"ng", ilo:"ph", inh:"ru", jgo:"cm", jmc:"tz", kaa:"uz", kab:"dz", kaj:"ng",
			kam:"ke", kbd:"ru", kcg:"ng", kde:"tz", kdt:"th", kea:"cv", ken:"cm", kfo:"ci", kfr:"in",
			kha:"in", khb:"cn", khq:"ml", kht:"in", kkj:"cm", kln:"ke", kmb:"ao", koi:"ru", kok:"in",
			kos:"fm", kpe:"lr", krc:"ru", kri:"sl", krl:"ru", kru:"in", ksb:"tz", ksf:"cm", ksh:"de",
			kum:"ru", lag:"tz", lah:"pk", lbe:"ru", lcp:"cn", lep:"in", lez:"ru", lif:"np", lis:"cn",
			lki:"ir", lmn:"in", lol:"cd", lua:"cd", luo:"ke", luy:"ke", lwl:"th", mad:"id", mag:"in",
			mai:"in", mak:"id", man:"gn", mas:"ke", mdf:"ru", mdh:"ph", mdr:"id", men:"sl", mer:"ke",
			mfe:"mu", mgh:"mz", mgo:"cm", min:"id", mni:"in", mnk:"gm", mnw:"mm", mos:"bf", mua:"cm",
			mwr:"in", myv:"ru", nap:"it", naq:"na", nds:"de", "new":"np", niu:"nu", nmg:"cm", nnh:"cm",
			nod:"th", nso:"za", nus:"sd", nym:"tz", nyn:"ug", pag:"ph", pam:"ph", pap:"bq", pau:"pw",
			pon:"fm", prd:"ir", raj:"in", rcf:"re", rej:"id", rjs:"np", rkt:"in", rof:"tz", rwk:"tz",
			saf:"gh", sah:"ru", saq:"ke", sas:"id", sat:"in", saz:"in", sbp:"tz", scn:"it", sco:"gb",
			sdh:"ir", seh:"mz", ses:"ml", shi:"ma", shn:"mm", sid:"et", sma:"se", smj:"se", smn:"fi",
			sms:"fi", snk:"ml", srn:"sr", srr:"sn", ssy:"er", suk:"tz", sus:"gn", swb:"yt", swc:"cd",
			syl:"bd", syr:"sy", tbw:"ph", tcy:"in", tdd:"cn", tem:"sl", teo:"ug", tet:"tl", tig:"er",
			tiv:"ng", tkl:"tk", tmh:"ne", tpi:"pg", trv:"tw", tsg:"ph", tts:"th", tum:"mw", tvl:"tv",
			twq:"ne", tyv:"ru", tzm:"ma", udm:"ru", uli:"fm", umb:"ao", unr:"in", unx:"in", vai:"lr",
			vun:"tz", wae:"ch", wal:"et", war:"ph", xog:"ug", xsr:"np", yao:"mz", yap:"fm", yav:"cm", zza:"tr"
		}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

supplemental.getWeekend = function(/*String?*/locale){
	// summary:
	//		Returns a hash containing the start and end days of the weekend
	// description:
	//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
	//		or by default in the user's locale.
	//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
			'in':0,
			af:4,dz:4,ir:4,om:4,sa:4,ye:4,
			ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
		},

		weekendEnd = {/*default is 0=Sunday*/
			af:5,dz:5,ir:5,om:5,sa:5,ye:5,
			ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
		},

		country = supplemental._region(locale),
		start = weekendStart[country],
		end = weekendEnd[country];

	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

return supplemental;
});

},
'dijit/layout/_ContentPaneResizeMixin':function(){
define([
	"dojo/_base/array", // array.filter array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.contains domClass.toggle
	"dojo/dom-geometry", // domGeometry.contentBox domGeometry.marginBox
	"dojo/dom-style",
	"dojo/_base/lang", // lang.mixin
	"dojo/query", // query
	"../registry", // registry.byId
	"../Viewport",
	"./utils" // marginBox2contextBox
], function(array, declare, domClass, domGeometry, domStyle, lang, query,
			registry, Viewport, layoutUtils){

	// module:
	//		dijit/layout/_ContentPaneResizeMixin

	return declare("dijit.layout._ContentPaneResizeMixin", null, {
		// summary:
		//		Resize() functionality of ContentPane.   If there's a single layout widget
		//		child then it will call resize() with the same dimensions as the ContentPane.
		//		Otherwise just calls resize on each child.
		//
		//		Also implements basic startup() functionality, where starting the parent
		//		will start the children

		// doLayout: Boolean
		//		- false - don't adjust size of children
		//		- true - if there is a single visible child widget, set it's size to however big the ContentPane is
		doLayout: true,

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget will call resize() on it's child widgets
		//		when they become visible.
		isLayoutContainer: true,

		startup: function(){
			// summary:
			//		See `dijit/layout/_LayoutWidget.startup()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			if(this._started){
				return;
			}

			var parent = this.getParent();
			this._childOfLayoutWidget = parent && parent.isLayoutContainer;

			// I need to call resize() on my child/children (when I become visible), unless
			// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
			this._needLayout = !this._childOfLayoutWidget;

			this.inherited(arguments);

			if(this._isShown()){
				this._onShow();
			}

			if(!this._childOfLayoutWidget){
				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				// This is more for subclasses of ContentPane than ContentPane itself, although it
				// could be useful for a ContentPane if it has a single child widget inheriting ContentPane's size.
				this.own(Viewport.on("resize", lang.hitch(this, "resize")));
			}
		},

		_checkIfSingleChild: function(){
			// summary:
			//		Test if we have exactly one visible widget as a child,
			//		and if so assume that we are a container for that widget,
			//		and should propagate startup() and resize() calls to it.
			//		Skips over things like data stores since they aren't visible.

			if(!this.doLayout){ return; }

			var candidateWidgets = [],
				otherVisibleNodes = false;

			query("> *", this.containerNode).some(function(node){
				var widget = registry.byNode(node);
				if(widget && widget.resize){
					candidateWidgets.push(widget);
				}else if(!/script|link|style/i.test(node.nodeName) && node.offsetHeight){
					otherVisibleNodes = true;
				}
			});

			this._singleChild = candidateWidgets.length == 1 && !otherVisibleNodes ?
				candidateWidgets[0] : null;

			// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
			domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		See `dijit/layout/_LayoutWidget.resize()` for description.
			//		Although ContentPane doesn't extend _LayoutWidget, it does implement
			//		the same API.

			this._resizeCalled = true;

			this._scheduleLayout(changeSize, resultSize);
		},

		_scheduleLayout: function(changeSize, resultSize){
			// summary:
			//		Resize myself, and call resize() on each of my child layout widgets, either now
			//		(if I'm currently visible) or when I become visible
			if(this._isShown()){
				this._layout(changeSize, resultSize);
			}else{
				this._needLayout = true;
				this._changeSize = changeSize;
				this._resultSize = resultSize;
			}
		},

		_layout: function(changeSize, resultSize){
			// summary:
			//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
			//		Also, since I am an isLayoutContainer widget, each of my children expects me to
			//		call resize() or layout() on it.
			//
			//		Should be called on initialization and also whenever we get new content
			//		(from an href, or from set('content', ...))... but deferred until
			//		the ContentPane is visible

			delete this._needLayout;

			// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
			// never called directly, so resize() is our trigger to do the initial href download (see [20099]).
			// However, don't load href for closed TitlePanes.
			if(!this._wasShown && this.open !== false){
				this._onShow();
			}

			// Set margin box size, unless it wasn't specified, in which case use current size.
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// Compute content box size of containerNode in case we [later] need to size our single child.
			var cn = this.containerNode;
			if(cn === this.domNode){
				// If changeSize or resultSize was passed to this method and this.containerNode ==
				// this.domNode then we can compute the content-box size without querying the node,
				// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
				var mb = resultSize || {};
				lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
				if(!("h" in mb) || !("w" in mb)){
					mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
				}
				this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
			}else{
				this._contentBox = domGeometry.getContentBox(cn);
			}

			this._layoutChildren();
		},

		_layoutChildren: function(){
			// Call _checkIfSingleChild() again in case app has manually mucked w/the content
			// of the ContentPane (rather than changing it through the set("content", ...) API.
			this._checkIfSingleChild();

			if(this._singleChild && this._singleChild.resize){
				var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

				// note: if widget has padding this._contentBox will have l and t set,
				// but don't pass them to resize() or it will doubly-offset the child
				this._singleChild.resize({w: cb.w, h: cb.h});
			}else{
				// All my child widgets are independently sized (rather than matching my size),
				// but I still need to call resize() on each child to make it layout.
				var children = this.getChildren(),
					widget,
					i = 0;
				while(widget = children[i++]){
					if(widget.resize){
						widget.resize();
					}
				}
			}
		},

		_isShown: function(){
			// summary:
			//		Returns true if the content is currently shown.
			// description:
			//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
			//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
			//		tree every call, and at least solves the performance problem on page load by deferring loading
			//		hidden ContentPanes until they are first shown

			if(this._childOfLayoutWidget){
				// If we are TitlePane, etc - we return that only *IF* we've been resized
				if(this._resizeCalled && "open" in this){
					return this.open;
				}
				return this._resizeCalled;
			}else if("open" in this){
				return this.open;		// for TitlePane, etc.
			}else{
				var node = this.domNode, parent = this.domNode.parentNode;
				return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
			}
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does layout/resize of child widget(s)

			// Need to keep track of whether ContentPane has been shown (which is different than
			// whether or not it's currently visible).
			this._wasShown = true;

			if(this._needLayout){
				// If a layout has been scheduled for when we become visible, do it now
				this._layout(this._changeSize, this._resultSize);
			}

			this.inherited(arguments);
		}
	});
});

},
'curam/util/DatePicker':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022
 *
 */

/**
 * @name curam.util.DatePicker
 * @namespace Provides the capability to update a dropdown form control on
 * a page.
 * 
 * <p/>
 * The important API functions that can be called on your page are:<ul>
 * <li><code>{@link curam.util.DatePicker.setDate}</code> to update the date in a DatePicker.</li>
 */
define(["dojo/_base/declare"], function(declare) {

  /*
   * Modification History
   * --------------------
   * 16-Nov-2022  BD [SPM126083] Initial Version.
   */
    
  /**
   * Creating a new instance of the DatePicker.
   */ 
    
   var DatePicker = declare("curam.util.DatePicker", null,
  /**
   * @lends curam.util.DatePicker.prototype
   */
  {
  
    /**
     * Constructor that is empty and take no arguments.
     */
    constructor: function() {
    },
    
  
	/**
    * Sets the date value on a datepicker.
    * @param {String} dateID The specified ID which identifies the datepicker.
    * @param {String} valueChanged The date restored to be updated.
    */
   setDate:function(dateID, valueRestored){
	  if (dateID) {
	    var targetDateID = dateID.lastIndexOf("_wrapper") != -1 ? dateID.substring(0, dateID.lastIndexOf("_wrapper")) : dateID;
      curam.util.getTopmostWindow().dojo.publish('/curam/datePicker/setDate', [targetDateID, valueRestored]);
	  }
	}
    

});
return DatePicker;
});




},
'dijit/form/_ButtonMixin':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/has",
	"../registry"        // registry.byNode
], function(declare, dom, has, registry){

	// module:
	//		dijit/form/_ButtonMixin

	var ButtonMixin = declare("dijit.form._ButtonMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		A mixin to add a thin standard API wrapper to a normal HTML button
		// description:
		//		A label should always be specified (through innerHTML) or the label attribute.
		//
		//		Attach points:
		//
		//		- focusNode (required): this node receives focus
		//		- valueNode (optional): this node's value gets submitted with FORM elements
		//		- containerNode (optional): this node gets the innerHTML assignment for label
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// label: HTML String
		//		Content to display in button.
		label: "",

		// type: [const] String
		//		Type of button (submit, reset, button, checkbox, radio)
		type: "button",

		__onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to divert the real click onto the hidden INPUT that has a native default action associated with it
			// type:
			//		private
			e.stopPropagation();
			e.preventDefault();
			if(!this.disabled){
				// cannot use on.emit since button default actions won't occur
				this.valueNode.click(e);
			}
			return false;
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions
			if(this.disabled){
				e.stopPropagation();
				e.preventDefault();
				return false;
			}
			if(this.onClick(e) === false){
				e.preventDefault();
			}
			var cancelled = e.defaultPrevented;

			// Signal Form/Dialog to submit/close.  For 2.0, consider removing this code and instead making the Form/Dialog
			// listen for bubbled click events where evt.target.type == "submit" && !evt.defaultPrevented.
			if(!cancelled && this.type == "submit" && !(this.valueNode || this.focusNode).form){
				for(var node = this.domNode; node.parentNode; node = node.parentNode){
					var widget = registry.byNode(node);
					if(widget && typeof widget._onSubmit == "function"){
						widget._onSubmit(e);
						e.preventDefault(); // action has already occurred
						cancelled = true;
						break;
					}
				}
			}

			return !cancelled;
		},

		postCreate: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		onClick: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Callback for when button is clicked.
			//		If type="submit", return true to perform submit, or false to cancel it.
			// type:
			//		callback
			return true;		// Boolean
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			this._set("label", content);
			var labelNode = this.containerNode || this.focusNode;
			labelNode.innerHTML = content;
		}
	});

	if(has("dojo-bidi")){
		ButtonMixin = declare("dijit.form._ButtonMixin", ButtonMixin, {
			_setLabelAttr: function(){
				this.inherited(arguments);
				var labelNode = this.containerNode || this.focusNode;
				this.applyTextDir(labelNode);
			}
		});
	}

	return ButtonMixin;
});

},
'curam/pagination/StateController':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2010,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 28-May-2019 SK [RTC241554] Updates accessibility readings upon page size changing.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 13-Jan-2012 JY [CR00300682] Fixed the default page size overriding issue.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 20-Apr-2010 MV [CR00193983] Make the model API's row indexes 1-based as per the design.
 * 16-Apr-2010 MV [???] Update GUI properly when the page size is changed.
 * 13-Apr-2010 MV [CR00192550] Update page size options, fixed a bug
 *                              with the last page number.
 * 18-Mar-2010 MV [CR00136536] Initial version.
 */

/**
 * @name curam.pagination.StateController
 *
 */
define(["dojo/_base/declare",
        "curam/pagination",
        "curam/debug"
        ], function(declare) {
  
var StateController = declare("curam.pagination.StateController", null, 
  /** @lends curam.pagination.StateController.prototype */ {
  
  /** Holds the current page size. */
  pageSize: undefined,

  /** Holds the currently displayed page number. Zero means no page displayed. */
  currentPage: 0,

  _listModel: undefined,

  _gui: undefined,

  constructor: function(listModel, gui) {
    this.pageSize = curam.pagination.defaultPageSize;
    this._listModel = listModel;

    this.pageSize = curam.pagination.defaultPageSize;
    // initialize GUI
    this._gui = gui;
    var state = {};
    state.pageSizeOptions = [15, 30, 45];
    state.pageSizeOptions.contains = function(val) {
      for(var i = 0; i < state.pageSizeOptions.length; i++) {
        if (state.pageSizeOptions[i] == val) {
          return true; 
        }
      }
      return false;
    };
    if (!state.pageSizeOptions.contains(curam.pagination.defaultPageSize)) {
      // include the configured default page size 
      state.pageSizeOptions.push(curam.pagination.defaultPageSize);
      state.pageSizeOptions.sort(function(a,b){return a - b});
    }
    state.currentPageSize = this.pageSize;
    state.directLinkRangeWidth = 3;
    state.lastPage = this._getLastPageNumber();
    this._gui.updateState(state);
    
    var handlers = {};
    handlers.first = dojo.hitch(this, this.gotoFirst);
    handlers.last = dojo.hitch(this, this.gotoLast);
    handlers.previous = dojo.hitch(this, this.gotoPrevious);
    handlers.next = dojo.hitch(this, this.gotoNext);
    handlers.page = dojo.hitch(this, this.gotoPage);
    handlers.pageSize = dojo.hitch(this, this.changePageSize);
    this._gui.setHandlers(handlers);
  },

  /**
   * Resets the pagination to default state.
   *
   * Keeps the current page size, but goes back to the first page.
   */
  reset: function() {
    // hide all rows - we need to do that, because the rows have been shuffled
    // underneath us and the pagination algorithms would not be able to update
    // the list correctly.
    this._listModel.hideRange(1, this._listModel.getRowCount());
    
    // reset the current page number
    this.currentPage = 0;
    
    this._gui.reset();
    
    this.gotoFirst();
  },

  gotoFirst: function() {
    if (this.currentPage != 1) {
      this.gotoPage(1);
    }
    // else do nothing - already on the first page
  },

  gotoLast: function() {
    var lastPageNumber = this._getLastPageNumber();
    if (this.currentPage != lastPageNumber) {
      this.gotoPage(lastPageNumber);
    }
    // else do nothing - already on the last page
  },

  gotoPrevious: function() {
    if (this.currentPage > 1) {
      this.gotoPage(this.currentPage - 1);
    }
    // else do nothing, already on the first page
  },

  gotoNext: function() {
    curam.debug.log("curam.pagination.StateController.gotoNext");
    var lastPageNumber = this._getLastPageNumber();
    if (this.currentPage < lastPageNumber) {
      this.gotoPage(this.currentPage + 1);
    }
    // else do nothing, already on the last page
  },

  gotoPage: function(pageNumber) {
    curam.debug.log("curam.pagination.StateController.gotoPage: ", 
                    pageNumber);
    if (this.currentPage != 0) {
      this._listModel.hideRange(this._calcRangeStart(this.currentPage),
          this._calcRangeEnd(this.currentPage));
    }
    
    this._listModel.showRange(this._calcRangeStart(pageNumber),
        this._calcRangeEnd(pageNumber));
    
    this.currentPage = pageNumber;

    this._updateGui();
  },

  changePageSize: function(newPageSize) {
    curam.debug.log("curam.pagination.StateController.changePageSize: ", 
      newPageSize);
    this.pageSize = newPageSize;
    
    var state = {};
    state.currentPageSize = newPageSize;
    state.lastPage = this._getLastPageNumber();
    this._gui.updateState(state);
    dojo.publish('curam/update/readings/pagination',
    		           [this._listModel.getId(), newPageSize]);
    
    this.reset();
  },

  _calcRangeStart: function(pageNumber) {
    return (pageNumber * this.pageSize) - this.pageSize + 1;
  },

  _calcRangeEnd: function(pageNumber) {
    if (pageNumber != this._getLastPageNumber()) {
      return pageNumber * this.pageSize;
    
    } else {
      return this._listModel.getRowCount();
    }
  },

  _getLastPageNumber: function() {
    var numRows = this._listModel.getRowCount();
    var mod = numRows % this.pageSize;
    return ((numRows - mod) / this.pageSize) + (mod > 0 ? 1 : 0);
  },

  _updateGui: function() {
    var state = {};

    state.first = this.currentPage > 1;
    state.previous = state.first;
    state.next = this.currentPage < this._getLastPageNumber();
    state.last = state.next;
    state.currentPage = this.currentPage;
    state.rowInfo = [this._calcRangeStart(this.currentPage),
                     this._calcRangeEnd(this.currentPage),
                     this._listModel.getRowCount()];
    
    this._gui.updateState(state);
  }
});

return StateController;
});

},
'curam/util/TabActionsMenu':function(){
/*
 * IBM Confidential
 *
 * OCO Source Materials
 *
 * Copyright IBM Corporation 2010,2023.
 *
 * The source code for this program is not published or otherwise divested of
 * its trade secrets, irrespective of what has been deposited with the US
 * Copyright Office.
 */
define(["dijit/registry",
        "dojo/query",
        "curam/inspection/Layer",
        "curam/tab",
        "curam/debug",
        "curam/define",
        "curam/util",
        "curam/util/Refresh"
        ], function(registry, query, layer, tab, debug) {
  
  /*
   * Modification History
   * --------------------
   * 07-Feb-2023BOS  [SPM-126725] Checking if new items need to hidden in oveflow menu.
   * 20-Jan-2023 BOS [SPM-126673] Seeting diabled to blank attribute to be HTML compliant.
   * 12-Jan-2023 BOS [SPM-126560] Remove aria-disabled in leui of
   * diabled in HTML.
   * 06-Jan-2023 BOS [SPM-126610] Added utility functions.
   * 19-Dec-2022 BOS [SPM-126480] Updated for updating inline actions menu item 
   * state.
   * 17-Oct-2014  MV  [CR00447421] Remove logic for refreshing on a tab load.
   *                               Moved to refresh controller.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 15-Apr-2013  SB  [CR00378721] Added aria-disabled attribute for disabled menuitems.
   * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
   * 22-Oct-2012  SK  [CR00346419] Now cleans-up the dynamic menu item related 
   *    objects on tab close to avoid memory leak.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 27-Oct-2010  SK  [CR00224193] Changed function for opening the menu item
        in modal dialog.
   * 26-Oct-2010  SJ  [CR00226152] Added File down load support for menu bar.
   * 15-Sep-2010  MV [CR00220152] Properly handle updates of lazily created menus.
   *    Also renamed and moved to comply with coding standards.
   * 26-Aug-2010 MV  [CR00217499] Replace the use of escape() with the proper
   *      function to encode URL parameters.
   * 19-Aug-2010 SJ  [CR00213476] Removed the support that parses page parameter in URL
   *                              from here and moved the same functionality to renderer.
   * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
   *                    tab-app-controller.js and tab-app-common.js.
   * 20-Jul-2010 MV  [CR00211031] Moved JavaScript code away from the renderer.
   * 12-Jul-2010 MV  [CR00210064] Do the visual styling using classes, rather than
   *                  manipulating styles directly.
   * 07-Jul-2010 MV  [CR00180694] Refactor to unify dynamic updates with
   *                  tab navigation. Move JavaScript code from renderer to here.
   * 19-May-2010 MV  [CR00166999] Check for dynamic menu bar data presence
   *                    and do nothing if there is no data.
   * 29-Apr-2010 MV  [CR00195109] Add debug output on refresh.
   * 01-Dec-2009 MV  [CR00180704] Move dynamicMenuBarData from global scope
   *                                      to a specific namespace.
   * 27-Nov-2009 MV  [CR00180379] Fix dynamic menu bar refresh when multiple
   *                                 tabs of the same type are open
   * 27-Nov-2009 MV  [CR00180297] Scope the dynamic menu bar data properly.
   * 16-Nov-2009 MV  [CR00172452] Style the disabled menu items as grayed out.
   * 06-Aug-2009 MLB [CR00163869] Renaming handleOnloadPage to refresh.
   * 25-Jun-2009 MV  [CR00161033] Documenting the code.
   * 24-Jun-2009 MV  [CR00160877] Implemented the code to update the menu bar
   *                              based on data returned by server.
   * 15-Jun-2009 MV  [CR00160095] Initial version.
   */
  
  /**
   * Contains functions for the menu bar.
   */
  curam.define.singleton("curam.util.TabActionsMenu", {
    /** Holds the tab widget ids for menus that have been created. */
    _tabMenuStates: {},

    maxNumToDisplayInline: 2,
    
    inlineMenuConfig: {contentPanelID: "", numItemsDisplayedInline: "", inlineItemsDisplayed: [], numOverflowItemsDisplayed: null},
    
    classNameHidden : "bx--btn-hidden",

    /**
     * Fresh data for the menu item enabled/disabled state is requested and based
     * on the response from the server the menu bar is updated.
     */
    getRefreshParams: function(tabWidgetId) {
      curam.debug.log("curam.util.TabActionsMenu.getRefreshParams(%s)",
          tabWidgetId);

      if (!curam.util.TabActionsMenu.dynamicMenuBarData[tabWidgetId]) {
        curam.debug
          .log(debug.getProperty("curam.util.TabActionsMenu.no.dynamic"));
        return null;
      }

      // create the parameters required by the loaders code on the server side
      var params = "menuId="
          + curam.util.TabActionsMenu.dynamicMenuBarData[tabWidgetId].menuBarId;
      params += "&menuItemIds="
          + curam.util.toCommaSeparatedList(
              curam.util.TabActionsMenu.dynamicMenuBarData[tabWidgetId]
                                                           .dynamicMenuItemIds);

      params += "&menuLoaders="
          + curam.util.toCommaSeparatedList(
              curam.util.TabActionsMenu.dynamicMenuBarData[tabWidgetId]
                                                           .dynamicMenuLoaders);

      params += "&menuPageParameters="
          + curam.util.TabActionsMenu.dynamicMenuBarData[tabWidgetId]
                                                         .pageParameters;

      return params;
    },

    /**
     * Loops through the menu items in the result structure and updates
     * the corresponding widgets.
     */
     updateMenuItemStates: function(tabWidetId, data) {
      var result = data.menuData;
 
      for (var i = 0; i < result.itemStates.length; i++) {
        var menuItem = result.itemStates[i];
        dojo.publish("/curam/tabactions/menuitemstate", [tabWidetId, menuItem.id, menuItem.enabled, menuItem.visible]);
      }
      
      // update the state by hiding any surplus ones
      curam.util.TabActionsMenu.manageInlineTabMenuStates(tabWidetId);
      
      var updateFunc = function() {
        for (var i = 0; i < result.itemStates.length; i++) {
          curam.util.TabActionsMenu.updateMenuItemState(result.itemStates[i],
              tabWidetId);
        }
      };

      if (curam.util.TabActionsMenu._isMenuCreated(tabWidetId)) {
        updateFunc();

      } else {
        // defer the update until the menu exists
        var topWin = curam.util.getTopmostWindow();
        var unsubToken = topWin.dojo.subscribe(
            "/curam/menu/created", this, function(tabId) {
              debug.log("Received /curam/menu/created " 
                + debug.getProperty("curam.util.ExpandableLists.load.for"), 
                  tabId);
              if (tabId == tabWidetId) {
                debug
                  .log(debug.getProperty("curam.util.TabActionsMenu.match"));
                // mark as created
                curam.util.TabActionsMenu._tabMenuStates[tabId] = true;
                // update
                updateFunc();
                // from now on the menu exists so we don't need to listen anymore
                topWin.dojo.unsubscribe(unsubToken);
              }
            });
         curam.tab.unsubscribeOnTabClose(unsubToken, tabWidetId);
      }
    },

    /**
     * @returns {Boolean} True if actions menu for the specified tab exists,
     *    otherwise False.
     */
    _isMenuCreated: function(tabId) {
      return curam.util.TabActionsMenu._tabMenuStates[tabId] == true;
    },

    /**
     * Updates the widget corresponding to the specified menuItem structure.
     */
     updateMenuItemState: function(menuItem, tabWidgetId) {
      var widgetmenuItem = registry.byId("menuItem_" + tabWidgetId + "_" + menuItem.id);
      var widget = widgetmenuItem != null ? widgetmenuItem : registry.byId("overflowItem_" + tabWidgetId + "_" + menuItem.id);
      if (widget != null) {
        widget.disabled = !menuItem.enabled;
        curam.util.swapState(widget.domNode,
            menuItem.enabled, "enabled", "disabled");
       
        curam.util.swapState(widget.domNode,
            menuItem.visible, "visible", "hidden");
        if(widget.disabled){
          widget.domNode.setAttribute("aria-disabled", "true");
        }
      }
    },


    /**
     * Setup the necessary handlers. The call to this function is generated
     * in the menu bar renderer.
     *
     * @param tabWidgetId ID of the tab for this menu.
     */
    setupHandlers: function(tabWidgetId) {

      curam.util.Refresh.setMenuBarCallbacks(
          curam.util.TabActionsMenu.updateMenuItemStates,
          curam.util.TabActionsMenu.getRefreshParams);

    },

    handleOnClick: function(url,fileDownLoadTypeInd) {
      if(fileDownLoadTypeInd){
        curam.tab.getTabController().handleDownLoadClick(url);
      
      } else {
        curam.tab.getTabController().handleLinkClick(url);
      }
    },

    handleOnClickModal: function(url, modalOptions) {
      var modalObject = {dialogOptions:modalOptions};
      curam.tab.getTabController().handleLinkClick(url, modalObject);
    },
    
    /**
     * Updates the state of inline tab acttion menus.
     */
     updateInlineTabMenuState: function() {
      dojo.subscribe("/curam/tabactions/menuitemstate", this, function(tabWidgetId, id, isEnabled, isVisible) {
        var inlinedItemID = "inlinedItem_" + tabWidgetId + "_" + id;
        var domNode = document.getElementById("inlinedItem_" + tabWidgetId + "_" + id);
        if (domNode) {
          if (isEnabled) {
            debug.log("curam.util.TabActionsMenu.updateInlineTabMenuState() - ENABLING inlined item: " 
              + inlinedItemID);
            if (domNode.classList.contains("disabled")) {
              domNode.classList.remove("disabled");
            }
            if (domNode.hasAttribute("disabled")) {
              domNode.removeAttribute("disabled");
            }
          } else {
            debug.log("curam.util.TabActionsMenu.updateInlineTabMenuState() - DISABLING inlined item: " 
              + inlinedItemID);
            if (!domNode.classList.contains("disabled")) {
              domNode.classList.add("disabled");  
            }
            domNode.setAttribute("disabled", "");
          }
          
          if (isVisible) {
            debug.log("curam.util.TabActionsMenu.updateInlineTabMenuState() - DISPLAYING inlined item: " 
              + inlinedItemID);
            if (domNode.classList.contains(curam.util.TabActionsMenu.classNameHidden)) {
              domNode.classList.remove(curam.util.TabActionsMenu.classNameHidden);
            }
          } else {
            debug.log("curam.util.TabActionsMenu.updateInlineTabMenuState() - HIDING inlined item: " 
              + inlinedItemID);
            if (!domNode.classList.contains(curam.util.TabActionsMenu.classNameHidden)) {
              domNode.classList.add(curam.util.TabActionsMenu.classNameHidden);  
            }
          }
       }  
     });
   },
  
   /**
    * Get the displayed inline tab menu items.
    */
   _getTabMenuItemsDisplayedInline: function(tabWidgetId) {
     return query("#" + tabWidgetId + " .bx--btn-tab-menu:not(." + curam.util.TabActionsMenu.classNameHidden + ")");
   },
  
   /**
    * Sets the inlined tab menu items object.
    */
   setInlinedTabMenuItemsDisplayed: function(tabWidgetId, inlineItemsDisplayed) {
     var currentInlinedItemsDisplayed;
     var inlineMenuConfig = curam.util.TabActionsMenu.inlineMenuConfig;
     if (inlineMenuConfig && inlineMenuConfig.contentPanelID != tabWidgetId) {
       currentInlinedItemsDisplayed = inlineItemsDisplayed ? inlineItemsDisplayed 
         : curam.util.TabActionsMenu._getTabMenuItemsDisplayedInline(tabWidgetId);
       if (currentInlinedItemsDisplayed && currentInlinedItemsDisplayed.length > 0) {
         var inlineTabMenuConfigObj = {};
         inlineTabMenuConfigObj.contentPanelID = tabWidgetId;
         inlineTabMenuConfigObj.numItemsDisplayedInline = currentInlinedItemsDisplayed.length;
         var inlinedItemIDs = [];
         for (var i =0; i < currentInlinedItemsDisplayed.length; i++) {
           var id = currentInlinedItemsDisplayed[i].id;
           inlinedItemIDs.push(id);
         }
         inlineTabMenuConfigObj.inlineItemsDisplayed = inlinedItemIDs;
         var inlineMenuConfig = curam.util.TabActionsMenu.inlineMenuConfig;
         curam.util.TabActionsMenu.inlineMenuConfig = inlineTabMenuConfigObj;
       }
     }  
   },
   
   /**
    * Hide the items in the overflow menu that are not applicable.
    */
   hideTabMenuOverflowItems: function(tabWidgetID, domNode) {
     var inlineTabMenuConfig = curam.util.TabActionsMenu.inlineMenuConfig;
     if (inlineTabMenuConfig && inlineTabMenuConfig.contentPanelID == tabWidgetID) {
       var visbleOverflowItems = query("tr::not(.dijitMenuSeparator):not(.hidden)", domNode);
       var numOverflowItemsDisplayed = inlineTabMenuConfig.numOverflowItemsDisplayed;
       var incorrectNumOverflowItemsDisplayed = numOverflowItemsDisplayed && numOverflowItemsDisplayed != visbleOverflowItems.length;
       var overFlowItemsNeedsUpdate = !numOverflowItemsDisplayed || incorrectNumOverflowItemsDisplayed;
       if (visbleOverflowItems && visbleOverflowItems.length > 0 && overFlowItemsNeedsUpdate) {
         if (incorrectNumOverflowItemsDisplayed) {
            var inlineItemsDisplayed = inlineTabMenuConfig.inlineItemsDisplayed;
           if (inlineItemsDisplayed) {
             for (var x =0; x < inlineItemsDisplayed.length; x++) {
               var inlineItemId = inlineItemsDisplayed[x];
               var inlineItemIdWithoutPrefix = inlineItemId.substring(inlineItemId.indexOf(tabWidgetID), inlineItemId.length);
               var overflowItem =  document.getElementById("overflowItem_" + inlineItemIdWithoutPrefix);
               if (overflowItem && !overflowItem.classList.contains("hidden")) {
                debug.log("curam.util.TabActionsMenu.hideTabMenuOverflowItems() - HIDING oveflow item: " 
                + "overflowItem_" + inlineItemIdWithoutPrefix);
                curam.util.swapState(overflowItem, false, "visible", "hidden");
               }
             }
           }
         } else {
           for (var i = 0; i < inlineTabMenuConfig.numItemsDisplayedInline; i++) {
             var overflowItem = visbleOverflowItems[i];
             if (overflowItem) {
              debug.log("curam.util.TabActionsMenu.hideTabMenuOverflowItems() - dynamic update recored");
              debug.log("curam.util.TabActionsMenu.hideTabMenuOverflowItems() - HIDING oveflow item: " 
                + "overflowItem_" + inlineItemIdWithoutPrefix);
               curam.util.swapState(overflowItem, false, "visible", "hidden");
             }
           } 
         }
         visbleOverflowItems = query("tr::not(.dijitMenuSeparator):not(.hidden)", domNode);
         debug.log("curam.util.TabActionsMenu.hideTabMenuOverflowItems() - setting number of overflow items to be: " 
           + visbleOverflowItems.length);
         curam.util.TabActionsMenu.inlineMenuConfig.numOverflowItemsDisplayed = visbleOverflowItems.length;
       }   
     }
   },

   /**
    * Manage the state of inline tab menu items.
    */
   manageInlineTabMenuStates: function(tabWidgetId) {
     var maxNumToDisplayInline = +curam.util.TabActionsMenu.maxNumToDisplayInline;
     var actualNumToDisplayInline = maxNumToDisplayInline;
     curam.util.TabActionsMenu.inlineMenuItemIds = [];
    
     var numInlinedButtons = curam.util.TabActionsMenu._getTabMenuItemsDisplayedInline(tabWidgetId);
     var numInlinedButtonsValidResult = numInlinedButtons && numInlinedButtons.length > 0;
     var inlineMenuItems = [];
    
     // if the inlined menu list exceeds the number set to be displayed then
     // ensure that the rest are hidden from view
     if (numInlinedButtonsValidResult) {
       var menuNode = numInlinedButtons[0].parentNode;
  
       // put a mask on the menu node until all content is ready to be diplayed!
       if (numInlinedButtons.length > maxNumToDisplayInline) {
         for (var i = maxNumToDisplayInline; i < numInlinedButtons.length; i++) {
           debug.log("curam.util.TabActionsMenu.manageInlineTabMenuStates() - HIDING inlined tab action item: " 
            + numInlinedButtons[i].id);
           numInlinedButtons[i].classList.add(curam.util.TabActionsMenu.classNameHidden);  
         }
       } else {
         // the number of tab menu items is less or same as max
         actualNumToDisplayInline = numInlinedButtons.length;
      
         // now we need to hide the overflow icon as nothing to appear there
         if (actualNumToDisplayInline > 0) {
           var overflowIconElement = query("img", menuNode);
           if (overflowIconElement && overflowIconElement.length > 0) {
             overflowIconElement[0].classList.add(curam.util.TabActionsMenu.classNameHidden);    
           }
         }
       }
      
       // remove mask
       debug.log("curam.util.TabActionsMenu.manageInlineTabMenuStates() - REMOVING mask for action items on tab menu bar: " 
         + menuNode.id);
       menuNode.classList.remove(curam.util.TabActionsMenu.classNameHidden); 
    
       // the menu items that are displayed
       for (var i = 0; i < actualNumToDisplayInline; i++) {
         inlineMenuItems.push(numInlinedButtons[i]);
       }
       curam.util.TabActionsMenu.setInlinedTabMenuItemsDisplayed(tabWidgetId, inlineMenuItems);
     }
   }  
  });
  layer.register("curam/util/TabActionsMenu", this);
 
  return curam.util.TabActionsMenu;
});

},
'curam/util/AutoRecoveryAPI':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022,2023
 *
 */
define(["dojo/request/xhr",
	"curam/define",
	"dojo/_base/declare",
	"curam/debug"
], function(xhr, define, declare, debug) {

	/*
	 * Modification History
	 * --------------------
	 * 19-Jan-2023  COC [SPM-126270] Renaming of functions and file name from FormEventsAPI to CuramFormsAPI.
	 * 13-Dec-2022 COC [SPM-126228] Reusing the one instance of the TabSessionManager() which fixes the 
	 * multiple tab scenarios which were broken. 
	 * 12-Dec-2022 AT [SPM-126340] Pass the frameID as part of the form-change event.
	 * 08-Dec-2022 AT  [SPM-126340] Autorecovery refactor, move restoreModalData logic to initialize.
	 * 06-Dec-2022 AT  [SPM-126293] Timing autorecovery events to work in the correct sequence. 
	 * 02-Dec-2022 COC [SPM-126118] Multiple modal changes. 
	 * 01-Dec-2022 COC [SPM-126072] Session Timeout warning modal changes to ensure it doesnt create an
	 * auto recovery for this type of modal.
	 * 29-Nov-2022 COC [SPM-125684] Updates for the multi browser tab flows.
	 * 24-Nov-2022 AT [SPM-126128] Throttle save requests.
	 * 24-Nov-2022 COC [SPM-126222] Moved the auto recovery functionality from the CuramCarbonModal.js here.
	 * 22-Nov-2022 COC [SPM-125684] Updates to store the correct backgroundTD for modal
	 * and added debug logging.
	 * 17-Nov-2022 COC [SPM-125684] Updates based on changes for the multiple tab flows.
	 * 05-Sept-2022 COC [JIRA 125744] Initial version.
	 */

	/**
	 * Creating Resource Bundle Object to access localized resources.
	 */
	var CuramAutoRecovery = declare(
		"curam.util.AutoRecoveryAPI", null,
		/** @lends curam.util.AutoRecoveryAPI.prototype */
		{

			_pageID: '',

			_pageParams: '',

			_iFrameID: '',

			_unsubscribes: [],

			_unsubscribesFormEvent: [],

			_subscribeCloseModal: null,

			_throttle: [],

			/**
			 * Constructor used to unset and subscribe to multiple events required for the auto recovery feature.
			 */
			constructor: function() {
				this._unset();
				this._unsubscribes.push(dojo.subscribe("curam/tab/restoreModal", this, function() {
					this._getAutoRecoveryService();
				}));
				// To ensure the subscription is not called multiple times because for this _unsubscribes is not
				// used on this subscription due to closing a modal and then when opening of modal we need to still
				// have this subscription or else this event wont be called.  
				if (!this._subscribeCloseModal) {
					dojo.subscribe("/curam/dialog/BeforeClose", this._beforeCloseHandler.bind(this));
				}			
				this._throttle = {
					enabled: AUTORECOVERY_THROTTLE_INTERVAL > 0,
					gateOpen: true,
					queuedPost: []
				};
				this.tabSessionManager = new curam.tab.TabSessionManager();
			},

			/**
			 * Initialize the Auto Recovery for the page opened and either create a new autorecovery
			 * record or restore as required. When there are multiple modal windows opened, we do not 
			 * want to set the page details for these modals as auto recovery will only be performed for 
			 * the initial modal window.
			 * 
			 * @param {String} url 
			 *		  A string that contains the url of the frame that 
			 *		  instantiated this function.
			 */
			initialize: function(wRef) {

				// Store the iFrameID on the very first initialization of the modal 
				var requestFrameID = wRef.frameElement.id.replace('iframe-', '')
				if (!this._iFrameID) {
					this._iFrameID = requestFrameID;	

				} 

				var isMainModal = this._iFrameID === requestFrameID;
				var isValidationErrorReload = wRef.location.href.includes("Action.do");
				var process = isMainModal && !isValidationErrorReload;

				if (process) {					

					this._uninstall(this._unsubscribesFormEvent);

					var _pageRequest = new curam.ui.PageRequest(wRef.location.href);										
					this._pageParams = _pageRequest.parameters;
					this._pageID = _pageRequest.pageID;
					var selectedTD = this.tabSessionManager._getPrevSelectedTab();
					this._updateTabContent(selectedTD);

					if(!selectedTD.restoreModalInd) {
						// Create autorecovery record						
						this._createAutorecoveryHandler(selectedTD)
					} else {
						// Retrieve autorecovery record
						this._getAutoRecoveryService(wRef);
					}
					var handler = this._registerFormChangeHandler.bind(this);
					this._unsubscribesFormEvent.push(dojo.subscribe("curam/util/CuramFormsAPI/formChange", handler));
				}				
			},
			
			/**
			 * Handler for when modal windows close for auto recovery. As there can be scenarios
			 * where multiple modal's can be opened on top of the initial modal and when each
			 * modal closes we need to ensure we are only performing an deletion of the auto
			 * recovery record for the initial modal window opened. 
			 */
			_beforeCloseHandler: function(iFrameID) {
				if (this._iFrameID === iFrameID) {
				  this._deleteAutoRecoveryService();
				  this._unset();
				  this._unsetSelectedTD();
				}
			},
			
			/**
			 * Retrieves the previously select tab descriptor. Sets the foregroundTabContent
			 * to null and the restoreModalInd to false and updates the local storage cache 
			 * for the selected tab descriptor.
			 */
			_unsetSelectedTD: function() {
				// Get the previous selected tab details
	      	    var selectedTD = this.tabSessionManager._getPrevSelectedTab();
	          	selectedTD.foregroundTabContent = null;
	          	selectedTD.restoreModalInd = false;
	          	curam.debug.log("curam.modal.CuramCarbonModal: " 
	          		+ debug.getProperty("curam.modal.CuramCarbonModal.foreground.removed"),
	                    selectedTD);
	            localStorage[curam.tab.TabSessionManager.SELECTED_TAB_KEY] = selectedTD.toJson();
			},

			/**
			 * The create auto recovery function which sets the foregroundPage details and 
			 * calls the post auto recovery request.
			 *
			 * @param {Object} selectedTD 
			 *		  The selected tab descriptor from the local storage.
			 */
			_createAutorecoveryHandler: function(selectedTD) {
				var foregroundPage = {
					pageID: this._pageID,
					params: this._pageParams
				}
				var foregroundPageData = '';
				// Specified that no form data changed and its the initial auto recovery creation
				var hasAutoRecoveryChanged = false;
				this._postAutoRecoveryService(foregroundPage, foregroundPageData, hasAutoRecoveryChanged, selectedTD);
			},

			/**
			 * When the foregroundTabContent is empty set it in the selected tab descriptor.
			 * If the foreground pageID is not the same as the current page set the restoreModalInd
			 * to false so it will create a new auto recovery record for the new page being opened. 
			 *
			 * @param {Object} selectedTD 
			 *		  The selected tab descriptor from the local storage.
			 */
			_updateTabContent: function(selectedTD) {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.foreground.added"), selectedTD);

				if (!selectedTD.foregroundTabContent) {
					this._updateForegroundTabContent(selectedTD);
				} else if (selectedTD.foregroundTabContent.pageID !== this._pageID) {
					selectedTD.restoreModalInd = false;
					this._updateForegroundTabContent(selectedTD);
				}
			},

			/**
			 * Set the foregroundTabContent with the page details for the modal
			 * and update the local storage selected tab descriptor to include it. 
			 *
			 * @param {Object} selectedTD 
			 *		  The selected tab descriptor from the local storage.
			 */
			_updateForegroundTabContent: function(selectedTD) {
				var foregroundTabContent = {
					"pageID": this._pageID,
					"pageParams": this._pageParams
				}
				selectedTD.foregroundTabContent = foregroundTabContent;
				localStorage[curam.tab.TabSessionManager.SELECTED_TAB_KEY] =
					selectedTD.toJson();
			},

			/**
			 * Reset the variables and remove subscribes for the Auto recovery.
			 */
			_unset: function() {
				this._uninstall(this._unsubscribes, this._unsubscribesFormEvent);
				this._pageID = '';
				this._pageParams = '';
				this._iFrameID = '';
				this._unsubscribes = [];
				this._unsubscribesFormEvent = [];
			},

			/**
			* Uninstall the handler linked with the current window. 
			* @param _unsubscribes array with the subscribes added during the instantiation of the
			* auto recovery
			* @param _unsubscribesFormEvent array with the subscribes added during the initialization of the
			* auto recovery.
			*
			* @param _unsubscribes The array of _unsubscribes.
			* @param _unsubscribesFormEvent The array of _unsubscribesFormEvent.
			*/
			_uninstall: function(_unsubscribes, _unsubscribesFormEvent) {
				_unsubscribes && _unsubscribes.forEach(function(hh) { hh.remove(); });
				_unsubscribesFormEvent && _unsubscribesFormEvent.forEach(function(hh) { hh.remove(); });
			},

			/**
			 * The register form change handler calls the post request to save the auto recovery details 
			 * passing in the form data from the event change on the modal page. When a modal is opened
			 * on top of another modal, auto recovery will not be performed for the top level modal or
			 * for timeout warning modals.
			 *
			 * @param {Object} event 
			 * 		  The event which was published.
			 */
			_registerFormChangeHandler: function(event) {
				if (this._iFrameID === event.frameID) {
					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.register.form.change.handler"));
					var foregroundPageData = event.data;
					var foregroundPage = {
						pageID: this._pageID,
						params: this._pageParams
					}
					// Specified that form data changed for a modal already open
					var hasAutoRecoveryChanged = true;
					this._postAutoRecoveryService(foregroundPage, foregroundPageData, hasAutoRecoveryChanged);
				}
			},

			/**
			 * Retrieves the background tab descriptor for the modal page. 
			 * 
			 * For the initial creation of the auto recovery, the selectedTD will have the correct 
			 * background selectedTD associated to the foreground page. As the previously selected 
			 * tab uses only one instance and changes on each navigation which can cause the 
			 * incorrect background being associated with the foreground page especially if the user
			 * has multiple browser tabs open. To resolve this, a new localStorage property was created
			 * to store the previously selected modal which will only get updated if a new modal is opened.
			 * 
			 * For the initial auto recovery creation when hasAutoRecoveryChanged is set to false, 
			 * the backgroundTD is taken from the localStorage from the previously selected tab 
			 * and the local storage key for previously selected modal is set to be the same so it 
			 * can be used later if changes are made on the modal page and if multiple tabs were open and 
			 * the selectedTD instance gets overridden with different backgroundTD details. This 
			 * new local storage key for the previously selected modal key allows for us to retrieve
			 * the correct background details for the modal page. 
			 *
			 * If the auto recovery has changed when hasAutoRecoveryChanged is set to true,
			 * the backgroundTD will be taken from the previously selected modal.  
			 *
			 * @param {Boolean} hasAutoRecoveryChanged
			 * 		  The indicator to specify whether the auto recovery form items have changed.
			 * @param {Object} selectedTD
			 * 		  The selected tab descriptor.
			 */
			_getSelectedTD: function(hasAutoRecoveryChanged, selectedTD) {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.previous.modal.background"));
				var backgroundTD = '';
				if (hasAutoRecoveryChanged) {
					backgroundTD = this.tabSessionManager._getPrevSelectedModal();
				} else {
					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.previous.modal.background.set"));
					backgroundTD = !selectedTD ? this.tabSessionManager._getPrevSelectedTab() : selectedTD;
					backgroundTD.restoreModalInd = true;
					localStorage[curam.tab.TabSessionManager.PREVIOUSLY_SELECTED_MODAL_KEY] =
						backgroundTD.toJson();
				}
				return backgroundTD;
			},

			/**
			 * Implements a throttling strategy when posting the form data to the autorecovery service to be saved.
			 *
			 * @param {String} foregroundPage
			 * 		  The foreground page.
			 * @param {String} foregroundPageData
			 * 		  The foreground page data.
			 * @param {boolean} hasAutoRecoveryChanged
			 *        flag whether the data has changed.
			 */
			_postAutoRecoveryService: function(foregroundPage, foregroundPageData, hasAutoRecoveryChanged) {

				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle"));

				if (this._throttle.enabled === false) {

					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.disabled"));

					this._postAutoRecoveryServiceUnthrottled(
						foregroundPage, foregroundPageData, this._getSelectedTD(hasAutoRecoveryChanged));
					return;
				}

				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.gateStatus") + this._throttle.gateOpen);

				var postToServer = this._throttle.gateOpen;
				this._throttle.gateOpen = false;

				// arguments will be empty when calling back recursively from the timeout.
				if (arguments.length > 0) {

					this._throttle.queuedPost = {
						foregroundPage: foregroundPage,
						foregroundPageData: foregroundPageData,
						backgroundSelectedTD: this._getSelectedTD(hasAutoRecoveryChanged)
					};

					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.storeRequest")
						+ ", foregroundPage: " + this._throttle.queuedPost.foregroundPage.pageID
						+ ", foregroundPageData: " + this._throttle.queuedPost.foregroundPageData
						+ ", backgroundSelectedTD: " + this._throttle.queuedPost.backgroundSelectedTD.tabID);
				}

				if (postToServer === true) {

					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.post")
						+ ", foregroundPage: " + this._throttle.queuedPost.foregroundPage.pageID
						+ ", foregroundPageData: " + this._throttle.queuedPost.foregroundPageData
						+ ", backgroundSelectedTD: " + this._throttle.queuedPost.backgroundSelectedTD.tabID);

					// Create local copies so we can reset the object to tell if more requests came in while the gate was closed.
					var foregroundPage = this._throttle.queuedPost.foregroundPage;
					var foregroundPageData = this._throttle.queuedPost.foregroundPageData;
					var backgroundSelectedTD = this._throttle.queuedPost.backgroundSelectedTD;
					this._throttle.queuedPost = [];

					// Post the data to the server
					this._postAutoRecoveryServiceUnthrottled(foregroundPage, foregroundPageData, backgroundSelectedTD);

					curam.debug.log("curam.util.AutoRecoveryAPI: "
						+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.setTimer")
						+ AUTORECOVERY_THROTTLE_INTERVAL);

					// Set the timer for gate reopening
					this._throttle.timeoutID = setTimeout(function() {

						curam.debug.log("curam.util.AutoRecoveryAPI: "
							+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.timerElapsed"));

						this._throttle.gateOpen = true;

						// The latest request received while the gate was closed will be 
						// in _throttle.queuedPost, if there is one, process it.
						if (Object.keys(this._throttle.queuedPost).length !== 0) {

							curam.debug.log("curam.util.AutoRecoveryAPI: "
								+ debug.getProperty("curam.util.AutoRecoveryAPI.post.throttle.processQueuedRequest"));

							this._postAutoRecoveryService();
						}
					}.bind(this), AUTORECOVERY_THROTTLE_INTERVAL);

				}

			},

			/**
			 * Creates a Ajax post request using the dojo api. Any parameters to be sent
			 * with the request are included as per a normal post request. It calls the 
			 * Auto Recovery Save Servlet to perform the saving of the record on the 
			 * server side. 
			 *
			 * @param {String} foregroundPage
			 * 		  The page details included with the post.
			 * @param {String} foregroundPageData
			 * 		  The page data to be included with the post. 
			 * @param {Boolean} hasAutoRecoveryChanged
			 *        A boolean used to get the background selected tab descriptor which
			 * 		  will be included in the post.
			 * @param {Object} selectedTD
			 * 		  The selected tab descriptor.
			 */
			_postAutoRecoveryServiceUnthrottled: function(foregroundPage, foregroundPageData, backgroundSelectedTD) {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.post"));

				var servletPath = 'servlet/autorecovery?command=save';

				xhr.post(servletPath, {
					data: {
						foregroundPage: JSON.stringify(foregroundPage),
						foregroundPageData: foregroundPageData,
						backgroundTD: JSON.stringify(backgroundSelectedTD),
						requestSentTimeStamp: Date.now()
					}
				}).then(
					function(resp) {
						try {
							if (resp != "OK") {
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.post.error"));
								return;
							} else {
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.post.success"));
							}
						} catch (e) {
							curam.debug.log("curam.util.AutoRecoveryAPI: "
								+ debug.getProperty("curam.util.AutoRecoveryAPI.post.catch.error")
								+ " '" + e + "'.");
						}
					},
					function(error) {
						curam.debug.log("curam.util.AutoRecoveryAPI: "
							+ debug.getProperty("curam.util.AutoRecoveryAPI.post.function.error")
							+ " '" + error + "'.");
					}
				);
			},

			/**
			 * Performs a Ajax post request to delete the Auto Recovery record using the dojo api. 
			 * It will only perform the post request if am auto record record exists which will be 
			 * populated as part of the _postAutoRecoveryService. It calls the  Auto Recovery 
			 * Delete Command Servlet to perform the deletion of the record on the server side. 
			 *
			 */
			_deleteAutoRecoveryService: function() {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.delete"));

				// Clear any throttled requests to prevent them saving after the delete.
				clearTimeout(this._throttle.timeoutID);

				var servletPath = 'servlet/autorecovery?command=delete';

				xhr.post(servletPath, {
				}).then(
					function(resp) {
						try {
							if (resp != "OK") {
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.delete.error"));
								return;
							} else {
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.delete.complete"));
							}
						} catch (e) {
							curam.debug.log("curam.util.AutoRecoveryAPI: "
								+ debug.getProperty("curam.util.AutoRecoveryAPI.delete.catch.error")
								+ " '" + e + "'.");
						}
					},
					function(error) {
						curam.debug.log("curam.util.AutoRecoveryAPI: "
							+ debug.getProperty("curam.util.AutoRecoveryAPI.delete.function.error")
							+ " '" + error + "'.");
					}
				);
			},

			/**
			 * Load the modal page for the foreground page details passed in.
			 *
			 * @param {String} foregroundPage
			 * 		  The foreground page details.
			 * @param {Object} backgroundTD
			 * 		  The background tab descriptor. 
			 */
			_loadModal: function(foregroundPage, backgroundTD) {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI._loadModal"));

				localStorage[curam.tab.TabSessionManager.SELECTED_TAB_KEY] =
					backgroundTD;

				var pageID = foregroundPage.pageID;
				var pageParams = foregroundPage.params;
				curam.util.UimDialog.open(pageID + 'Page.do', pageParams);
			},

			/**
			 * Creates a Ajax post request using the dojo api. Any parameters to be sent
			 * with the request are included as per a normal get|post request.
			 *
			 * @param {Object} windowRef
			 * 		  The window reference used to load the data on the modal page in the 
			 * 		  correct iFrame.
			 *
			 */
			_getAutoRecoveryService: function(windowRef) {
				curam.debug.log("curam.util.AutoRecoveryAPI: "
					+ debug.getProperty("curam.util.AutoRecoveryAPI.get"));

				var self = this;
				var servletPath = 'servlet/autorecovery?command=load';

				xhr.post(servletPath, {}).then(
					function(resp) {
						try {
							if (resp && resp.length > 0) {
								var savedData = JSON.parse(resp);
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.get.success"));
								var formPageID = JSON.parse(savedData.foregroundPage);

								// Check to see if there are autorecovery details for the user
								// if so load the modal page
								if (!windowRef) {
									var backgroundTD = JSON.parse(savedData.backgroundTD);
									self._loadModal(formPageID, JSON.stringify(backgroundTD));
								} else {								
									// Otherwise the load autorecovery data flow is being executed
									var page = "Curam_" + formPageID.pageID;
									if (windowRef.document.getElementById(page)) {
										if (savedData.foregroundPageData) {
										
										  curam.debug.log("curam.util.AutoRecoveryAPI: "
												+ debug.getProperty("curam.util.AutoRecoveryAPI.get.setFormFields"));
										  var formData = JSON.parse(savedData.foregroundPageData);
										  windowRef.curam.util.ui.form.CuramFormsAPI.setFormFields(formPageID, formData);				
											
										}
									} else {
										self._createAutorecoveryHandler();
									}
								}
							} else {
								curam.debug.log("curam.util.AutoRecoveryAPI: "
									+ debug.getProperty("curam.util.AutoRecoveryAPI.get.no.record"));
							}
						} catch (e) {
							curam.debug.log("curam.util.AutoRecoveryAPI: "
								+ debug.getProperty("curam.util.AutoRecoveryAPI.get.catch.error")
								+ " '" + e + "'.");
						}
					},
					function(error) {
						curam.debug.log("curam.util.AutoRecoveryAPI: "
							+ debug.getProperty("curam.util.AutoRecoveryAPI.get.function.error")
							+ " '" + error + "'.");
					}
				);
			}
		});
	return CuramAutoRecovery;
});		
},
'dijit/tree/TreeStoreModel':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.indexOf array.some
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.hitch
], function(array, aspect, declare, lang){

	// module:
	//		dijit/tree/TreeStoreModel

	return declare("dijit.tree.TreeStoreModel", null, {
		// summary:
		//		Implements dijit/Tree/model connecting to a dojo.data store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo/data/api/Read
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

		// root: [readonly] dojo/data/Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		//		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		//		(rather than one for each child).
		//		This relies on partial loading of the children items; each children item of a
		//		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			lang.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.tree.TreeStoreModel: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					aspect.after(store, "onNew", lang.hitch(this, "onNewItem"), true),
					aspect.after(store, "onDelete", lang.hitch(this, "onDeleteItem"), true),
					aspect.after(store, "onSet", lang.hitch(this, "onSetItem"), true)
				]);
			}
		},

		destroy: function(){
			var h;
			while(h = this.connects.pop()){ h.remove(); }
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						if(items.length != 1){
							throw new Error("dijit.tree.TreeStoreModel: root query returned " + items.length +
								" items, but must return exactly one");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo/data/Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return array.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo/data/Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			//		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = lang.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				array.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				array.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			// summary:
			//		Given the identity of an item, this method returns the item that has
			//		that identity through the onItem callback.  Conforming implementations
			//		should return null if there is no item with the given identity.
			//		Implementations of fetchItemByIdentity() may sometimes return an item
			//		from a local cache and may sometimes fetch an item from a remote server.
			// tags:
			//		extension
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dijit/tree/dndSource.__Item */ args, /*dojo/data/api/Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo/data/api/Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if(LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if(LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				array.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = array.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*===== parent, newChildrenList =====*/){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// parent: dojo/data/Item
			// newChildrenList: dojo/data/Item[]
			// tags:
			//		callback
		},

		onDelete: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo/data/Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, lang.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(item, attribute /*===== , oldValue, newValue =====*/){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// item: Item
			// attribute: attribute-name-string
			// oldValue: Object|Array
			// newValue: Object|Array
			// tags:
			//		extension

			if(array.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, lang.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});
});

},
'curam/layout/ScrollingTabController':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.layout.ScrollingTabController
 * @namespace Customized dijit.layout.ScrollingTabController class that adds
 *    rounded corners to tabs.
 * 
 */
define(["dojo/_base/declare",
        "dojo/dom-class",
        "dijit/layout/ScrollingTabController",
        "curam/inspection/Layer",
        "curam/debug",
        "curam/widget/_HasDropDown",
        "dojo/text!curam/layout/resources/ScrollingTabController.html"
        ], function(declare, domClass, ScrollingTabController, layer, debug, _HasDropDown, tabControllerTemplate) {

/*
 * Modification History
 * --------------------
 * 14-May-2019  JD  [RTC242058]  _ScrollingTabControllerMenuButton to use 
 * 								 curam/widget/_HasDropDown
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 10-Jan-2011  KW  [CR00240897] Curam Logo is now hard-coded. Also added new
 *                    element to application banner to accommodate new styling.
 * 18-Nov-2010  MV [CR00231387] Replaced the compressed version with the proper
 *    source.
 */

var CuramScrollingTabController = declare("curam.layout.ScrollingTabController", ScrollingTabController,
/**
 * @lends curam.layout.ScrollingTabController.prototype
 */
{
  templateString: tabControllerTemplate,
	
  onStartup: function(){
	  
    this.inherited(arguments);
    layer.register("curam/layout/ScrollingTabController", this);
  },
  
  updateTabStyle:function() {
    var kids = this.getChildren();
    curam.debug
      .log("curam.layout.ScrollingTabController.updateTabStyle kids = ", 
          this.domNode);
    
    dojo.forEach(kids , function(button,index,array) {
      domClass.remove(button.domNode, ["first-class", "last-class"] );
      
      if (index == 0) {
        domClass.add(button.domNode,"first");
      
      } else if(index == array.length - 1) {
        domClass.add(button.domNode,"last");
      }
    });
    
    //Apply new classes and elements related to the updated v6
    //banner style
    var newBanner = dojo.query(".nowrapTabStrip", this.domNode)[0];
    domClass.replace(newBanner, "nowrapSecTabStrip", "nowrapTabStrip");
    
    var bannerEnding = document.createElement("div");
    domClass.add(bannerEnding, "block-slope");
    domClass.add(bannerEnding, "dijitTab");
    bannerEnding.innerHTML="&#x200B;";
    
    newBanner.appendChild(bannerEnding);
    }
  });

  // Class used in template
  declare("curam.layout._ScrollingTabControllerMenuButton", [dijit.layout._ScrollingTabControllerMenuButton, _HasDropDown], {

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
				this._popupStateNode.removeAttribute("aria-owns");	// remove ref to node that we are about to delete
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}

  });

  return CuramScrollingTabController;  
});

},
'dojo/dnd/TimedMoveable':function(){
define(["../_base/declare", "./Moveable" /*=====, "./Mover" =====*/], function(declare, Moveable /*=====, Mover =====*/){
	// module:
	//		dojo/dnd/TimedMoveable

	/*=====
	var __TimedMoveableArgs = declare([Moveable.__MoveableArgs], {
		// timeout: Number
		//		delay move by this number of ms,
		//		accumulating position changes during the timeout
		timeout: 0
	});
	=====*/

	// precalculate long expressions
	var oldOnMove = Moveable.prototype.onMove;

	return declare("dojo.dnd.TimedMoveable", Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.

		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps

		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: __TimedMoveableArgs
			//		object with additional parameters.

			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},

		onMoveStop: function(/*Mover*/ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer);
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop);
			}
			Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/*Mover*/ mover, /*Object*/ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});
});

},
'dijit/a11yclick':function(){
define([
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/mouse",
	"dojo/on",
	"dojo/touch" // touch support for click is now there
], function(keys, mouse, on, touch){

	// module:
	//		dijit/a11yclick

	/*=====
	return {
		// summary:
		//		Custom press, release, and click synthetic events
		//		which trigger on a left mouse click, touch, or space/enter keyup.

		click: function(node, listener){
			// summary:
			//		Logical click operation for mouse, touch, or keyboard (space/enter key)
		},
		press: function(node, listener){
			// summary:
			//		Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.
		},
		release: function(node, listener){
			// summary:
			//		Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.
		},
		move: function(node, listener){
			// summary:
			//		Mouse cursor or a finger is dragged over the given node.
		}
	};
	=====*/

	function clickKey(/*Event*/ e){
		// Test if this keyboard event should be tracked as the start (if keydown) or end (if keyup) of a click event.
		// Only track for nodes marked to be tracked, and not for buttons or inputs,
		// since buttons handle keyboard click natively, and text inputs should not
		// prevent typing spaces or newlines.
		if((e.keyCode === keys.ENTER || e.keyCode === keys.SPACE) && !/input|button|textarea/i.test(e.target.nodeName)){

			// Test if a node or its ancestor has been marked with the dojoClick property to indicate special processing
			for(var node = e.target; node; node = node.parentNode){
				if(node.dojoClick){ return true; }
			}
		}
	}

	var lastKeyDownNode;

	on(document, "keydown", function(e){
		//console.log("a11yclick: onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e)){
			// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
			lastKeyDownNode = e.target;

			// Prevent viewport scrolling on space key in IE<9.
			// (Reproducible on test_Button.html on any of the first dijit/form/Button examples)
			e.preventDefault();
		}else{
			lastKeyDownNode = null;
		}
	});

	on(document, "keyup", function(e){
		//console.log("a11yclick: onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
		if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
			//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
			lastKeyDownNode = null;

			on.emit(e.target, "click", {
				cancelable: true,
				bubbles: true,
				ctrlKey: e.ctrlKey,
				shiftKey: e.shiftKey,
				metaKey: e.metaKey,
				altKey: e.altKey,
				_origType: e.type
			});
		}
	});

	// I want to return a hash of the synthetic events, but for backwards compatibility the main return value
	// needs to be the click event.   Change for 2.0.

	var click = function(node, listener){
		// Set flag on node so that keydown/keyup above emits click event.
		// Also enables fast click processing from dojo/touch.
		node.dojoClick = true;

		return on(node, "click", listener);
	};
	click.click = click;	// forward compatibility with 2.0

	click.press =  function(node, listener){
		var touchListener = on(node, touch.press, function(evt){
			if(evt.type == "mousedown" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keydown", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.release =  function(node, listener){
		var touchListener = on(node, touch.release, function(evt){
			if(evt.type == "mouseup" && !mouse.isLeft(evt)){
				// Ignore right click
				return;
			}
			listener(evt);
		}), keyListener = on(node, "keyup", function(evt){
			if(evt.keyCode === keys.ENTER || evt.keyCode === keys.SPACE){
				listener(evt);
			}
		});
		return {
			remove: function(){
				touchListener.remove();
				keyListener.remove();
			}
		};
	};

	click.move = touch.move;	// just for convenience

	return click;
});

},
'curam/cdsl/_base/FacadeMethodResponse':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 21-Oct-2014  VT  [CR00446323] Implement CDSL - JSON Hijacking Prevention
 * 10-Oct-2014  MV  [CR00446578] Add support for development mode.
 * 07-Oct-2014  MV  [CR00446356] Fix getError() function.
 * 26-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 */

define(['dojo/_base/declare',
        'curam/cdsl/Struct',
        'dojo/json',
        'dojo/string'
        ], function(
            declare, Struct, json, string) {
  
  /**
   * Prepend 'junk' to the JSON request to prevent <script > injection
   * (the junk will freeze the browser in an infinite loop if an attacker 
   *  attempts to execute JSON as JavaScript.)
   *
   */
  var jsonPrependJunk = "for(;;);";

  /**
   * Converts the list of errors from the server into a printable string.
   * 
   * @param errors The array of error objects to print.
   * @param nestLevel Nesting level of the given error list.
   * 
   * @return Printable string representing the error objects.
   */
  var errorToString = function(errors, nestLevel) {
    var ret = [],
        indent = nestLevel ? Array(nestLevel + 1).join('  ') : '';
    
    dojo.forEach(errors, function(e) {
      ret.push(string.substitute(
          '${indent}Type: ${type}\n'
          + '${indent}Message: ${msg}\n'
          + '${indent}Stack trace:\n'
          + '${indent}  ${stackTrace}', {
        type: e.type,
        msg: e.message,
        stackTrace: e.stackTrace,
        indent: indent 
      }));
      
      if (e.nestedError) {
        ret.push('\n-- nested error --');
        ret.push(errorToString([e.nestedError], nestLevel ? nestLevel + 1 : 1));
      }
    });
    
    return ret.join('\n');
  };
  
  /**
   * @name curam.cdsl.request.FacadeMethodResponse
   * @namespace Represents a response to a Curam facade method call. 
   */
  var FacadeMethodResponse = declare(null,
  /**
   * @lends curam.cdsl.request.FacadeMethodResponse.prototype
   */
  {
    _request: null,
    
    _data: null,
    
    _metadataRegistry: null,

    /**
     * Creates an instance.
     *
     * @param {String or Object} responseJsonStringOrObject The response data.
     */
    constructor: function(methodCall, responseJsonStringOrObject, metadataRegistry) {
      if (!methodCall || !responseJsonStringOrObject) {
        throw new Error('Missing parameter.');
      }

      if (typeof responseJsonStringOrObject == 'string') {
        this._data = json.parse(responseJsonStringOrObject.substr(
        jsonPrependJunk.length, responseJsonStringOrObject.length));
		
      } else if (typeof responseJsonStringOrObject == 'object') {
        this._data = responseJsonStringOrObject;
		
      } else {
        throw new Error('Wrong parameter type: ' + typeof methodCall +
        ', '
        + typeof responseJsonStringOrObject);
      }

      this._request = methodCall;
      this._metadataRegistry = metadataRegistry;
      
    },
    
    returnValue: function() {
      // the data property of the JSON contains the returned struct
      return new Struct(this._data.data, {
        bareInput: true,
        fixups: this._data.metadata && this._data.metadata.fixups
                    ? this._data.metadata.fixups
                    : null, 
        metadataRegistry: this._metadataRegistry,
        dataAdapter: this._request.dataAdapter()
      });
    },

    failed: function() {
      return this._data.code !== 0;
    },
    
    getError: function() {
      var errors = this._data.errors;
      if (errors) {
        var e = new Error('Server returned ' + errors.length
            + (errors.length == 1 ? ' error' : ' errors') + '.');
        e.errors = errors;
        
        // override toString() so that we get decent output in console
        e.toString = function() {
          return errorToString(errors);
        };
        
        return e;
      }
      
      return null;
    },
    
    hasCodetables: function() {
      return this._data.metadata
          && this._data.metadata.codetables
          && this._data.metadata.codetables.length > 0;
    },
    
    getCodetablesData: function() {
      return this._data.metadata.codetables;
    },
    
    devMode: function() {
      var dm = false;
      
      if (this._data.metadata && this._data.metadata.devMode) {
        dm = (this._data.metadata.devMode === true);
      }
      
      return dm;
    },
    
    request: function() {
      return this._request;
    }
  });
  
  return FacadeMethodResponse;
});

},
'dojo/request/registry':function(){
define([
	'require',
	'../_base/array',
	'./default!platform',
	'./util'
], function(require, array, fallbackProvider, util){
	var providers = [];

	function request(url, options){
		var matchers = providers.slice(0),
			i = 0,
			matcher;

		while(matcher=matchers[i++]){
			if(matcher(url, options)){
				return matcher.request.call(null, url, options);
			}
		}

		return fallbackProvider.apply(null, arguments);
	}

	function createMatcher(match, provider){
		var matcher;

		if(provider){
			if(match.test){
				// RegExp
				matcher = function(url){
					return match.test(url);
				};
			}else if(match.apply && match.call){
				matcher = function(){
					return match.apply(null, arguments);
				};
			}else{
				matcher = function(url){
					return url === match;
				};
			}

			matcher.request = provider;
		}else{
			// If only one argument was passed, assume it is a provider function
			// to apply unconditionally to all URLs
			matcher = function(){
				return true;
			};

			matcher.request = match;
		}

		return matcher;
	}

	request.register = function(url, provider, first){
		var matcher = createMatcher(url, provider);
		providers[(first ? 'unshift' : 'push')](matcher);

		return {
			remove: function(){
				var idx;
				if(~(idx = array.indexOf(providers, matcher))){
					providers.splice(idx, 1);
				}
			}
		};
	};

	request.load = function(id, parentRequire, loaded, config){
		if(id){
			// if there's an id, load and set the fallback provider
			require([id], function(fallback){
				fallbackProvider = fallback;
				loaded(request);
			});
		}else{
			loaded(request);
		}
	};

	util.addCommonMethods(request);

	return request;
});

},
'curam/cdsl/_base/PreferenceMap':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 13-Oct-2014  SC [CR00446751] Initial version.
 */

define(['dojo/_base/declare',
        'dojo/_base/lang'
        ], function(declare, lang) {

  /**
   * A map of name value pairs of user and global preferences.
   * 
   * @name curam.cdsl._base.PreferenceMap
   * @namespace 
   */
  var PreferenceMap = declare(null,

  /**
   * @lends curam.cdsl._base.PreferenceMap.prototype
   */
  {    
    _preferences : null,
    _preferenceNames : null,
    
    constructor: function() {
      this._preferences = {};
      this._preferenceNames = [];
    },
    
    /**
     * Return the value of a specific preference.
     * @param {String} name The name of the preference.
     * @returns {String} The preference value.
     */
    getPreference: function(name) {
      return this._preferences[name];
    },
    
    /**
     * Return an array of preference names.
     * @returns {Array} The list of preference names.
     */
    getPreferenceNames: function() {
      return this._preferenceNames;
    },

    /**
     * Return a list of the names of all preferences.
     * @param {String} name The name of the preference.
     * @param {String} value The value of the preference.
     */
    addPreference: function(name, value) {
      this._preferences[name] = value;
      this._preferenceNames[this._preferenceNames.length] = name;
    }
    
  });
  
  return PreferenceMap;
});
},
'dijit/hccss':function(){
define(["dojo/dom-class", "dojo/hccss", "dojo/domReady", "dojo/_base/window"], function(domClass, has, domReady, win){

	// module:
	//		dijit/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode, and sets `dijit_a11y` flag on `<body>` if it is.
		//		Deprecated, use ``dojo/hccss`` instead.
	};
	=====*/

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dijit_a11y");
		}
	});

	return has;
});

},
'dojo/behavior':function(){
define(["./_base/kernel", "./_base/lang", "./_base/array", "./_base/connect", "./query", "./domReady"],
function(dojo, lang, darray, connect, query, domReady){

// module:
//		dojo/behavior

dojo.deprecated("dojo.behavior", "Use dojo/on with event delegation (on.selector())");

var Behavior = function(){
	// summary:
	//		Deprecated.   dojo/behavior's functionality can be achieved using event delegation using dojo/on
	//		and on.selector().
	// description:
	//		A very simple, lightweight mechanism for applying code to
	//		existing documents, based around `dojo/query` (CSS3 selectors) for node selection,
	//		and a simple two-command API: `add()` and `apply()`;
	//
	//		Behaviors apply to a given page, and are registered following the syntax
	//		options described by `add()` to match nodes to actions, or "behaviors".
	//
	//		Added behaviors are applied to the current DOM when .apply() is called,
	//		matching only new nodes found since .apply() was last called.

	function arrIn(obj, name){
		if(!obj[name]){ obj[name] = []; }
		return obj[name];
	}

	var _inc = 0;

	function forIn(obj, scope, func){
		var tmpObj = {};
		for(var x in obj){
			if(typeof tmpObj[x] == "undefined"){
				if(!func){
					scope(obj[x], x);
				}else{
					func.call(scope, obj[x], x);
				}
			}
		}
	}

	// FIXME: need a better test so we don't exclude nightly Safari's!
	this._behaviors = {};
	this.add = function(/* Object */behaviorObj){
		// summary:
		//		Add the specified behavior to the list of behaviors, ignoring existing
		//		matches.
		// behaviorObj: Object
		//		The behavior object that will be added to behaviors list. The behaviors
		//		in the list will be applied the next time apply() is called.
		// description:
		//		Add the specified behavior to the list of behaviors which will
		//		be applied the next time apply() is called. Calls to add() for
		//		an already existing behavior do not replace the previous rules,
		//		but are instead additive. New nodes which match the rule will
		//		have all add()-ed behaviors applied to them when matched.
		//
		//		The "found" method is a generalized handler that's called as soon
		//		as the node matches the selector. Rules for values that follow also
		//		apply to the "found" key.
		//
		//		The "on*" handlers are attached with `dojo.connect()`, using the
		//		matching node
		//
		//		If the value corresponding to the ID key is a function and not a
		//		list, it's treated as though it was the value of "found".
		//
		//		dojo/behavior.add() can be called any number of times before
		//		the DOM is ready. `dojo/behavior.apply()` is called automatically
		//		by `dojo.addOnLoad`, though can be called to re-apply previously added
		//		behaviors anytime the DOM changes.
		//
		//		There are a variety of formats permitted in the behaviorObject
		//
		// example:
		//		Simple list of properties. "found" is special. "Found" is assumed if
		//		no property object for a given selector, and property is a function.
		//
		//	|	behavior.add({
		//	|		"#id": {
		//	|			"found": function(element){
		//	|				// node match found
		//	|			},
		//	|			"onclick": function(evt){
		//	|				// register onclick handler for found node
		//	|			}
		//	|		},
		// 	|		"#otherid": function(element){
		//	|			// assumes "found" with this syntax
		//	|		}
		//	|	});
		//
		// example:
		//		 If property is a string, a dojo.publish will be issued on the channel:
		//
		//	|	behavior.add({
		//	|		// topic.publish() whenever class="noclick" found on anchors
		//	|		"a.noclick": "/got/newAnchor",
		//	|		"div.wrapper": {
		//	|			"onclick": "/node/wasClicked"
		//	|		}
		//	|	});
		//	|	topic.subscribe("/got/newAnchor", function(node){
		//	|		// handle node finding when dojo/behavior.apply() is called,
		//	|		// provided a newly matched node is found.
		//	|	});
		//
		// example:
		//		Scoping can be accomplished by passing an object as a property to
		//		a connection handle (on*):
		//
		//	|	behavior.add({
		//	|		 	"#id": {
		//	|				// like calling dojo.hitch(foo,"bar"). execute foo.bar() in scope of foo
		//	|				"onmouseenter": { targetObj: foo, targetFunc: "bar" },
		//	|				"onmouseleave": { targetObj: foo, targetFunc: "baz" }
		//	|			}
		//	|	});
		//
		// example:
		//		Behaviors match on CSS3 Selectors, powered by dojo/query. Example selectors:
		//
		//	|	behavior.add({
		//	|		// match all direct descendants
		//	|		"#id4 > *": function(element){
		//	|			// ...
		//	|		},
		//	|
		//	|		// match the first child node that's an element
		//	|		"#id4 > :first-child": { ... },
		//	|
		//	|		// match the last child node that's an element
		//	|		"#id4 > :last-child":  { ... },
		//	|
		//	|		// all elements of type tagname
		//	|		"tagname": {
		//	|			// ...
		//	|		},
		//	|
		//	|		"tagname1 tagname2 tagname3": {
		//	|			// ...
		//	|		},
		//	|
		//	|		".classname": {
		//	|			// ...
		//	|		},
		//	|
		//	|		"tagname.classname": {
		//	|			// ...
		//	|		}
		//	|	});
		//

		forIn(behaviorObj, this, function(behavior, name){
			var tBehavior = arrIn(this._behaviors, name);
			if(typeof tBehavior["id"] != "number"){
				tBehavior.id = _inc++;
			}
			var cversion = [];
			tBehavior.push(cversion);
			if((lang.isString(behavior))||(lang.isFunction(behavior))){
				behavior = { found: behavior };
			}
			forIn(behavior, function(rule, ruleName){
				arrIn(cversion, ruleName).push(rule);
			});
		});
	};

	var _applyToNode = function(node, action, ruleSetName){
		if(lang.isString(action)){
			if(ruleSetName == "found"){
				connect.publish(action, [ node ]);
			}else{
				connect.connect(node, ruleSetName, function(){
					connect.publish(action, arguments);
				});
			}
		}else if(lang.isFunction(action)){
			if(ruleSetName == "found"){
				action(node);
			}else{
				connect.connect(node, ruleSetName, action);
			}
		}
	};

	this.apply = function(){
		// summary:
		//		Applies all currently registered behaviors to the document.
		//
		// description:
		//		Applies all currently registered behaviors to the document,
		//		taking care to ensure that only incremental updates are made
		//		since the last time add() or apply() were called.
		//
		//		If new matching nodes have been added, all rules in a behavior will be
		//		applied to that node. For previously matched nodes, only
		//		behaviors which have been added since the last call to apply()
		//		will be added to the nodes.
		//
		//		apply() is called once automatically by `dojo.addOnLoad`, so
		//		registering behaviors with `dojo/behavior.add()` before the DOM is
		//		ready is acceptable, provided the dojo.behavior module is ready.
		//
		//		Calling appy() manually after manipulating the DOM is required
		//		to rescan the DOM and apply newly .add()ed behaviors, or to match
		//		nodes that match existing behaviors when those nodes are added to
		//		the DOM.
		//
		forIn(this._behaviors, function(tBehavior, id){
			query(id).forEach(
				function(elem){
					var runFrom = 0;
					var bid = "_dj_behavior_"+tBehavior.id;
					if(typeof elem[bid] == "number"){
						runFrom = elem[bid];
						if(runFrom == (tBehavior.length)){
							return;
						}
					}
					// run through the versions, applying newer rules at each step

					for(var x=runFrom, tver; tver = tBehavior[x]; x++){
						forIn(tver, function(ruleSet, ruleSetName){
							if(lang.isArray(ruleSet)){
								darray.forEach(ruleSet, function(action){
									_applyToNode(elem, action, ruleSetName);
								});
							}
						});
					}

					// ensure that re-application only adds new rules to the node
					elem[bid] = tBehavior.length;
				}
			);
		});
	};
};

dojo.behavior = new Behavior();

domReady( function(){ dojo.behavior.apply(); } );

return dojo.behavior;
});

},
'dijit/popup':function(){
define("dijit/popup", [
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class",
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("config-bgIframe")
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./place",
	"./BackgroundIframe",
	"./Viewport",
	"./main",    // dijit (defining dijit.popup to match API doc)
	"dojo/touch"		// use of dojoClick
], function(array, aspect, declare, dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, keys, lang, on,
			place, BackgroundIframe, Viewport, dijit){

	// module:
	//		dijit/popup

	/*=====
	 var __OpenArgs = {
		 // popup: Widget
		 //		widget to display
		 // parent: Widget
		 //		the button etc. that is displaying this popup
		 // around: DomNode
		 //		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		 // x: Integer
		 //		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // y: Integer
		 //		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		 // orient: Object|String
		 //		When the around parameter is specified, orient should be a list of positions to try, ex:
		 //	|	[ "below", "above" ]
		 //		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		 //		(around-node-corner, popup-node-corner), ex:
		 //	|	{ "BL": "TL", "TL": "BL" }
		 //		where BL means "bottom left" and "TL" means "top left", etc.
		 //
		 //		dijit/popup.open() tries to position the popup according to each specified position, in order,
		 //		until the popup appears fully within the viewport.
		 //
		 //		The default value is ["below", "above"]
		 //
		 //		When an (x,y) position is specified rather than an around node, orient is either
		 //		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		 //		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		 //		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		 //		and the top-right corner.
		 // onCancel: Function
		 //		callback when user has canceled the popup by:
		 //
		 //		1. hitting ESC or
		 //		2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		 //		   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		 // onClose: Function
		 //		callback whenever this popup is closed
		 // onExecute: Function
		 //		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		 // padding: place.__Position
		 //		adding a buffer around the opening position. This is only useful when around is not set.
		 // maxHeight: Integer
		 //		The max height for the popup.  Any popup taller than this will have scrollbars.
		 //		Set to Infinity for no max height.  Default is to limit height to available space in viewport,
		 //		above or below the aroundNode or specified x/y position.
	 };
	 =====*/

	function destroyWrapper(){
		// summary:
		//		Function to destroy wrapper when popup widget is destroyed.
		//		Left in this scope to avoid memory leak on IE8 on refresh page, see #15206.
		if(this._popupWrapper){
			domConstruct.destroy(this._popupWrapper);
			delete this._popupWrapper;
		}
	}

	var PopupManager = declare(null, {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).

		// _stack: dijit/_WidgetBase[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_repositionAll: function(){
			// summary:
			//		If screen has been scrolled, reposition all the popups in the stack.
			//		Then set timer to check again later.

			if(this._firstAroundNode){	// guard for when clearTimeout() on IE doesn't work
				var oldPos = this._firstAroundPosition,
					newPos = domGeometry.position(this._firstAroundNode, true),
					dx = newPos.x - oldPos.x,
					dy = newPos.y - oldPos.y;

				if(dx || dy){
					this._firstAroundPosition = newPos;
					for(var i = 0; i < this._stack.length; i++){
						var style = this._stack[i].wrapper.style;
						style.top = (parseFloat(style.top) + dy) + "px";
						if(style.right == "auto"){
							style.left = (parseFloat(style.left) + dx) + "px";
						}else{
							style.right = (parseFloat(style.right) - dx) + "px";
						}
					}
				}

				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), dx || dy ? 10 : 50);
			}
		},

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div", {
					"class": "dijitPopup",
					style: { display: "none"},
					role: "region",
					"aria-label": widget["aria-label"] || widget.label || widget.name || widget.id
				}, widget.ownerDocumentBody);
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", destroyWrapper, true);
			    // Workaround iOS problem where clicking a Menu can focus an <input> (or click a button) behind it.
				// Need to be careful though that you can still focus <input>'s and click <button>'s in a TooltipDialog.
				// Also, be careful not to break (native) scrolling of dropdown like ComboBox's options list.
				if("ontouchend" in document) {
					on(wrapper, "touchend", function (evt){
						if(!/^(input|button|textarea)$/i.test(evt.target.tagName)) {
							evt.preventDefault();
						}
					});
				}
				// Calling evt.preventDefault() suppresses the native click event on most browsers.  However, it doesn't
				// suppress the synthetic click event emitted by dojo/touch.  In order for clicks in popups to work
				// consistently, always use dojo/touch in popups.  See #18150.
				wrapper.dojoClick = true;
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			// Besides setting visibility:hidden, move it out of the viewport, see #5776, #10111, #13604
			var ltr = domGeometry.isBodyLtr(widget.ownerDocument),
				style = {
					visibility: "hidden",
					top: "-9999px",
					display: ""
				};
			style[ltr ? "left" : "right"] = "-9999px";
			style[ltr ? "right" : "left"] = "auto";
			domStyle.set(wrapper, style);

			return wrapper;
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			//		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			/* CURAM-FIX:
			 * This is an IE11 specific accessibility fix. When a popup is hidden after selecting a menuitem,
			 * the screenreader virtual cursor is not moving to the input field of the page that's then opened.
			 * It appears to be related to the "display:none" styling applied to the menu.
			 * This fix visually hides the menu and after 200ms, sets the original dojo styling.
			 * This gives the screenreader a chance for the virtual cursor to move to the new field.
			 */
			if (dojo.hasClass(wrapper, "dijitMenuPopup") && (has('trident') || has('edge') || has('ie'))) {
				
				// Visually hide popup
				domAttr.set(wrapper, "aria-hidden", "true");
				domStyle.set(wrapper, {
					position: "absolute",
					overflow: "hidden",
					clip: "rect(0 0 0 0)",
					height: "1px",
					width: "1px",
					margin: "-1px",
					padding: "0",
					border: "0"
				});
				
				setTimeout(function(){
					// Only apply the original stylings if menu is visually hidden.
					if(domAttr.get(wrapper, "aria-hidden", "true")){
						domStyle.set(wrapper, {
						display: "none",
						height: "auto",
						overflowY: "visible",
						border: "",
						position: "",
						overflow: "",
						clip: "",
						width: "",
						margin: "",
						padding: ""
					  });
					}
					
				}, 200, wrapper);
			} else {
				// use original styling for other browsers.
				domStyle.set(wrapper, {
					display: "none",
					height: "auto",		// Open may have limited the height to fit in the viewport
					overflowY: "visible",	// and set overflowY to "auto".
					border: ""			// Open() may have moved border from popup to wrapper.
				});
			}
			/* END CURAM-FIX */

			// Open() may have moved border from popup to wrapper.  Move it back.
			var node = widget.domNode;
			if("_originalStyle" in node){
				node.style.cssText = node._originalStyle;
			}
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi = stack.length - 1; pi > 0 && stack[pi].parent === stack[pi - 1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit/popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				node = widget.domNode,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(widget.ownerDocument),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id + "_dropdown") : ("popup_" + this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length - 1].widget.domNode))){
				this.close(stack[stack.length - 1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist.  Remove display:none (but keep
			// off screen) so we can do sizing calculations.
			var wrapper = this.moveOffScreen(widget);

			if(widget.startup && !widget._started){
				widget.startup(); // this has to be done after being added to the DOM
			}

			// Limit height to space available in viewport either above or below aroundNode (whichever side has more
			// room), adding scrollbar if necessary. Can't add scrollbar to widget because it may be a <table> (ex:
			// dijit/Menu), so add to wrapper, and then move popup's border to wrapper so scroll bar inside border.
			var maxHeight, popupSize = domGeometry.position(node);
			if("maxHeight" in args && args.maxHeight != -1){
				maxHeight = args.maxHeight || Infinity;	// map 0 --> infinity for back-compat of _HasDropDown.maxHeight
			}else{
				var viewport = Viewport.getEffectiveBox(this.ownerDocument),
					aroundPos = around ? domGeometry.position(around, false) : {y: args.y - (args.padding||0), h: (args.padding||0) * 2};
				maxHeight = Math.floor(Math.max(aroundPos.y, viewport.h - (aroundPos.y + aroundPos.h)));
			}
			if(popupSize.h > maxHeight){
				// Get style of popup's border.  Unfortunately domStyle.get(node, "border") doesn't work on FF or IE,
				// and domStyle.get(node, "borderColor") etc. doesn't work on FF, so need to use fully qualified names.
				var cs = domStyle.getComputedStyle(node),
					borderStyle = cs.borderLeftWidth + " " + cs.borderLeftStyle + " " + cs.borderLeftColor;

				domStyle.set(wrapper, {
					overflowY: "scroll",
					/* CURAM-FIX: Dojo bug here. Border size is excluded from the maximum height set on the popup wrapper,
	                                 * which causes the popup a bit truncated. Also in IE11, the borderLeftWidth got there is incorrect (0.5px instead of 1px).
	                                 * This is fixed using the CSS rules "border-width: 1px !important" given the fact that the border width in Curam is set
	                                 * to "1px". therefore, here we can determine to minus 2 from maxHeight to set for the wrapper's height.
	                                 */
					height: (maxHeight-2) + "px",
					/* END CURAM-FIX */
					border: borderStyle	// so scrollbar is inside border
				});
				node._originalStyle = node.style.cssText;
				node.style.border = "none";
			}

			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] + "Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});
			
			/* CURAM-FIX:
			 * This is an IE11 specific accessibility fix. If the popup was visually hidden
			 * but a user chooses to open the popup again while it's still visually hidden,
			 * revert those specific stylings.
			 */
			if (dojo.hasClass(wrapper, "dijitMenuPopup") && (has('trident') || has('edge') || has('ie'))) {
				
				if(domAttr.get(wrapper, "aria-hidden") === "true"){
					
					domStyle.set(wrapper, {
					 	position: "",
					 	clip: "",
					 	width: "",
					 	margin: "",
					 	padding: "",
					 	border: ""
					 });
				}
				
				domAttr.set(wrapper, "aria-hidden", "false");
			}
			/* END CURAM-FIX */

			if(stack.length == 0 && around){
				// First element on stack. Save position of aroundNode and setup listener for changes to that position.
				this._firstAroundNode = around;
				this._firstAroundPosition = domGeometry.position(around, true);
				this._aroundMoveListener = setTimeout(lang.hitch(this, "_repositionAll"), 50);
			}

			if(has("config-bgIframe") && !widget.bgIframe){
				// setting widget.bgIframe triggers cleanup in _WidgetBase.destroyRendering()
				widget.bgIframe = new BackgroundIframe(wrapper);
			}

			// position the wrapper node and make it visible
			var layoutFunc = widget.orient ? lang.hitch(widget, "orient") : null,
				best = around ?
					place.around(wrapper, around, orient, ltr, layoutFunc) :
					place.at(wrapper, args, orient == 'R' ? ['TR', 'BR', 'TL', 'BL'] : ['TL', 'BL', 'TR', 'BR'], args.padding,
						layoutFunc);

			wrapper.style.visibility = "visible";
			node.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, "keydown", lang.hitch(this, function(evt){
				if(evt.keyCode == keys.ESCAPE && args.onCancel){
					evt.stopPropagation();
					evt.preventDefault();
					/* CURAM-FIX: add evt param here*/
					args.onCancel(evt);
					/* END CURAM-FIX*/
				}else if(evt.keyCode == keys.TAB){
					evt.stopPropagation();
					evt.preventDefault();
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						/* CURAM-FIX: add evt param here*/
						topPopup.onCancel(evt);
						/* END CURAM-FIX*/
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				wrapper: wrapper,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){
				return elem.widget == popup;
			})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if (widget.bgIframe) {
					// push the iframe back onto the stack.
					widget.bgIframe.destroy();
					delete widget.bgIframe;
				}

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here).
					// Actually, StackContainer also calls onClose(), but to mean that the pane is being deleted
					// (i.e. that the TabContainer's tab's [x] icon was clicked)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){
					h.remove();
				}

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}
			
			if(stack.length == 0 && this._aroundMoveListener){
				clearTimeout(this._aroundMoveListener);
				this._firstAroundNode = this._firstAroundPosition = this._aroundMoveListener = null;
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/layout/TabContainer':function(){
define([
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/declare", // declare
	"./_TabContainerBase",
	"./TabController",
	"./ScrollingTabController"
], function(lang, declare, _TabContainerBase, TabController, ScrollingTabController){

	// module:
	//		dijit/layout/TabContainer


	return declare("dijit.layout.TabContainer", _TabContainerBase, {
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.
		//
		//		See `StackContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `TabContainer`.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: Class
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			// "string" branch for back-compat, remove for 2.0
			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = typeof this.controllerWidget == "string" ? lang.getObject(this.controllerWidget) :
						this.controllerWidget;

			return new TabController({
				id: this.id + "_tablist",
				ownerDocument: this.ownerDocument,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							ScrollingTabController : TabController;
			}
		}
	});
});

},
'curam/cdsl/request/CuramService':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 10-Oct-2014  MV  [CR00446578] Add support for development mode.
 * 26-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 */

define(['dojo/_base/declare',
        'curam/cdsl/Struct',
        'curam/cdsl/_base/FacadeMethodResponse',
        'dojo/_base/lang',
        'curam/cdsl/_base/_Connection',
        'curam/cdsl/_base/FacadeMethodCall'
        ], function(
            declare, Struct, FacadeMethodResponse, lang) {

  var DEFAULT_OPTIONS = {
    dataAdapter: null
  },
    
  processOptions = function(options) {
    var o = lang.clone(DEFAULT_OPTIONS);
    o = lang.mixin(o, options);
    return o;
  },
  
  rule = '********************************************************',
    
  /**
   * @name curam.cdsl.request.CuramService
   * @namespace API for making requests to Curam facade layer from JavaScript.
   */
  CuramService = declare(null,
  /**
   * @lends curam.cdsl.request.CuramService.prototype
   */
  {
    /** The connection to use for accessing server. */
    _connection: null,
    
    _dataAdapter: null,
    
    /**
     * Instantiates a data service API object.
     * 
     * @param {curam/cdsl/_base/_Connection} connection The connection object
     *  to be used. Use an instance of curam/cdsl/connection/CuramConnection
     *  class.
     * @param {Object} [options] An object containing optional parameters
     *  for the service. The supported options are: dataAdapter - allows
     *  making custom modifications to the data passed through the CDSL API
     *  from and to the server. More information on this in
     *  curam/cdsl/request/FacadeMethodCall.
     */
    constructor: function(connection, opts) {
      var options = processOptions(opts);
      
      this._connection = connection;
      this._dataAdapter = options.dataAdapter;
    },

    /**
     * Makes a request to the Curam facade layer for the specified server
     * interface method calls.
     * Note that currently making multiple method calls within the same request
     * is not supported.
     *
     * @param {[curam/cdsl/_base/FacadeMethodCall]} methodCalls An array
     *     of facade method calls to make.
     * @param {Number} timeout Number of milliseconds to wait for the response
     *  before timeout is signalled (Error will be thrown).
     *
     * @returns {dojo/Promise::[curam/cdsl/Struct]} A promise for the array
     *  of Struct objects returned from the server call.
     */
    call: function(methodCalls, timeout) {
      // FIXME: add support for multiple method calls
      var methodCall = methodCalls[0];
      
      if (!methodCall.dataAdapter()) {
        methodCall.dataAdapter(this._dataAdapter);
      }
      
      var promise = this._connection.invoke(methodCall, timeout);

      return promise.then(lang.hitch(this, function(jsonString) {
        var response = new FacadeMethodResponse(
            methodCall, jsonString, this._connection.metadata());
        
        if (response.failed()) {
          var e = response.getError();
          
          // in dev mode report the error to the console.
          if (response.devMode()) {
            console.log(rule);
            console.log(e.toString());
            console.log(rule);
          }
          
          // and then throw to fail the request
          throw e;
        }

        // process and cache any metadata sent by server
        this._connection.updateMetadata(response);

        // FIXME: support results from multiple server calls
        return [ response.returnValue() ];
      }));
    }
  });
  
  return CuramService;
});

},
'dijit/form/_FormValueWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

	// module:
	//		dijit/form/_FormValueWidget

	return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<input>` or `<select>`
		//		that have user changeable values.
		// description:
		//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
		// directly in the template as read by the parser in order to function. IE is known to specifically
		// require the 'name' attribute at element creation time.  See #8484, #8660.

		_layoutHackIE7: function(){
			// summary:
			//		Work around table sizing bugs on IE7 by forcing redraw

			if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
				var domNode = this.domNode;
				var parent = domNode.parentNode;
				var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
				var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
				var _this = this;
				while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
					(function ping(){
						var disconnectHandle = _this.connect(parent, "onscroll",
							function(){
								_this.disconnect(disconnectHandle); // only call once
								pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
								_this.defer(function(){
									pingNode.style.filter = origFilter;
								}); // restore custom filter, if any
							}
						);
					})();
					parent = parent.parentNode;
				}
			}
		}
	});
});

},
'dijit/_BidiSupport':function(){
define(["dojo/has", "./_WidgetBase", "./_BidiMixin"], function(has, _WidgetBase, _BidiMixin){

	// module:
	//		dijit/_BidiSupport

	/*=====
	return function(){
		// summary:
		//		Deprecated module for enabling textdir support in the dijit widgets.   New code should just define
		//		has("dojo-bidi") to return true, rather than manually requiring this module.
	};
	=====*/

	_WidgetBase.extend(_BidiMixin);

	// Back-compat with version 1.8: just including _BidiSupport should trigger bidi support in all the widgets.
	// Although this statement doesn't do much because the other widgets have likely already been loaded.
	has.add("dojo-bidi", true);

	return _WidgetBase;
});

},
'curam/util/UimDialog':function(){
/*
 * Copyright 2010-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.   
 * 06-Jul-2011  KW  [CR00275353] Correctly set the o3rpu value in openUrl()
 *                                function.
 * 01-Feb-2011  MV  [CR00250399] Fix the call to openModalDialog() function.
 * 21-Jan-2011  MV  [CR00243263] Fix the new openUrl function to return
 *    the dialog object. 
 * 14-Jan-2011  MK  [CR00240138] Added the openUrl() function. 
 * 13-Jan-2011  MV  [CR00241667] Added ready() function, updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the get() function.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */

define(["curam/util/RuntimeContext",
        "curam/util/external",
        "curam/util",
        "curam/define",
        "curam/dialog",
        "curam/util/DialogObject"
        ], function(RuntimeContext, external) {
  
  /**
   * @name curam.util.UimDialog
   * @namespace Provides the ability to open UIM content in a Curam dialog
   * and interact with the dialog window.<p/>
   * 
   * The API provides support for both opening a UIM page in a new dialog
   * and for accessing a dialog which is already open. See the <code>open()</code>
   * and <code>get()</code> functions.<p/>
   *  
   * It is required that the UIM page you are opening in the dialog resides
   * on the same Internet domain as the page the API is used from.<p/>
   * 
   * Example:<p/>
   * <pre>
   * dojo.require('curam.util.UimDialog');
   * 
   * var dialogObject = curam.util.UimDialog.open(
   *   'MyPage.do', { myParam:'1' }, {width:500,height:300});
   * 
   * dialogObject.registerBeforeCloseHandler(function() { alert("test"); });
   * dialogObject.registerOnDisplayHandler(function() {
   *   setTimeout(1000, function() { dialogObject.close() });
   * });
   * </pre><p/>
   *
   * It is possible to execute custom code on dialog open and/or close.<p/>
   * 
   * To add a customised handler function to a supported event:<ul>
   * <li>Make the UimDialog API call to open or get the dialog, which will
   *  return a {@link curam.util.DialogObject} object.
   * <li>This object will let you register handlers for the supported
   * <code>OnDisplay</code> and <code>BeforeClose</code> events.</li></ul>
   * <p/>
   * 
   * Lastly you can close the dialog by calling the <code>close()</code>
   * function.<p/>
   */





















  curam.define.singleton("curam.util.UimDialog",
  /**
   * @lends curam.util.UimDialog.prototype
   */
  {
    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, without
     *              the query string.
     * @param {Object} pageParameters An object containing the required page
     *      parameters, or null if no page parameters are required.
     *      The following format is expected:
     *                        <code>{ param1Name:"value", param2Name:248 }</code>
     *      The infrastructure handles URL-encoding the values so do NOT encode
     *      them yourself.
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *      
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    open: function(path, pageParameters, dialogSize) {    
      var url = path + curam.util.makeQueryString(pageParameters);    
      return this.openUrl(url, dialogSize);
    },

    /**
     * Opens the specified UIM page in a Curam dialog.
     * 
     * @param {String} path URL path to the page to display in the dialog, including
     *              the query string.
     *              
     * @param {Object} [dialogSize] An object representing the required size
     *    of the dialog in pixels. The following form is required:
     *        <code>{ width:500, height:300 }</code> If size is not specified
     *      the default size will be used instead.
     *
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    openUrl: function(url, dialogSize) {












      // generate a unique token, this is to be used to retrieve the
      // correct dialogID
      var uimToken = curam.util.getCacheBusterParameter();

      // create dialog object to be returned to the user
      var myDialogObject = new curam.util.DialogObject(uimToken);

      var windowOptions = null;
      if (dialogSize) {
        windowOptions = "width=" + dialogSize.width
        + ",height=" + dialogSize.height;
      }

      // call into modal logic with unique token
      curam.util.openModalDialog({ href: this._addRpu(url) },
          windowOptions, null, null, uimToken);

      return myDialogObject;
    },
    
    _addRpu: function(url) {
      var newUrl = url;
      
      if (curam.tab.inTabbedUI()) {
        // we are in tabbed UI, set RPU to the active tab content iframe
        var iframe = curam.tab.getContentPanelIframe();
        if (iframe) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(iframe.contentWindow));
        }

      } else if (external.inExternalApp()) {
        // we are in the external application, try to get parent UIM iframe
        var parent = external.getUimParentWindow();
        if (parent) {
          newUrl = curam.util.setRpu(
              url, new RuntimeContext(parent));
        }
      }
      // else - unable to set RPU, this is valid for example in ext app fragment
      // scenarios

      return newUrl;
    },
    
    /**
     * Returns a dialog object corresponding to the runtime context
     * of the calling page.
     * 
     * If the calling page is not loaded in a dialog or the dialog infrastructure
     * is not yet initialized then exception will be thrown. In this case use the
     * ready() function to execute your code at the right point in time. 
     * 
     * @returns {curam.util.DialogObject} An object, representing the dialog.
     */
    get: function() {
      if (curam.dialog._id == null) {
        throw "Dialog infrastructure not ready.";
      }
      return new curam.util.DialogObject(null, curam.dialog._id);
    },

    /**
     * Executes the callback function when the dialog infrastructure
     * in the current runtime context becomes ready. If the infrastructure
     * is ready by the time this function is called, then the callback function
     * is executed immediately.
     * 
     * @param {Function} callback
     *    The function to run.
     */
    ready: function(callback) {
      if (curam.dialog._id == null) {
        // Dialog infrastructure not ready.
        dojo.subscribe("/curam/dialog/ready", callback);

      } else {
        // infrastructure ready - call the code now
        callback();
      }
    },

    /**
     * @private
     */
    _getDialogFrameWindow: function(dialogId) {
      var dialogWidget = window.top.dijit.byId(dialogId);
      return dialogWidget.uimController.getIFrame().contentWindow;
    }
  });
  
  return curam.util.UimDialog;
});

},
'dijit/tree/_dndContainer':function(){
define([
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/touch"
], function(aspect, declare, domClass, lang, on, touch){

	// module:
	//		dijit/tree/_dndContainer

	/*=====
	 var __Args = {
	 // summary:
	 //		A dict of parameters for Tree source configuration.
	 // isSource: Boolean?
	 //		Can be used as a DnD source. Defaults to true.
	 // accept: String[]
	 //		List of accepted types (text strings) for a target; defaults to
	 //		["text", "treeNode"]
	 // copyOnly: Boolean?
	 //		Copy items, if true, use a state of Ctrl key otherwise,
	 // dragThreshold: Number
	 //		The move delay in pixels before detecting a drag; 0 by default
	 // betweenThreshold: Integer
	 //		Distance from upper/lower edge of node to allow drop to reorder nodes
	 };
	 =====*/

	return declare("dijit.tree._dndContainer", null, {

		// summary:
		//		This is a base class for `dijit/tree/_dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo/dnd/Container`.
		// tags:
		//		protected

		/*=====
		 // current: TreeNode
		 //		The currently hovered TreeNode.  Not set to anything for keyboard operation.  (TODO: change?)
		 current: null,
		 =====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: __Args
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			lang.mixin(this, params);

			// states
			this.containerState = "";
			domClass.add(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// Mouse (or touch) enter/leave on Tree itself
				on(this.node, touch.enter, lang.hitch(this, "onOverEvent")),
				on(this.node, touch.leave, lang.hitch(this, "onOutEvent")),

				// switching between TreeNodes
				aspect.after(this.tree, "_onNodeMouseEnter", lang.hitch(this, "onMouseOver"), true),
				aspect.after(this.tree, "_onNodeMouseLeave", lang.hitch(this, "onMouseOut"), true),

				// cancel text selection and text dragging
				on(this.node, "dragstart, selectstart", function(evt){
					evt.preventDefault();
				})
			];
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			var h;
			while(h = this.events.pop()){
				h.remove();
			}

			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(widget /*===== , evt =====*/){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*===== widget, evt =====*/){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//domClass.replace(this.node, prefix + newState, prefix + this[state]);
			domClass.replace(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.add(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.remove(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
	});
});

},
'dijit/focus':function(){
define([
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-class",
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"./main"		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domClass, domConstruct, Evented, lang, on, domReady, has, Stateful, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus

	// Time of the last focusin event
	var lastFocusin;

	// Time of the last touch/mousedown or focusin event
	var lastTouchOrFocusin;

	var FocusManager = declare([Stateful, Evented], {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit/_WidgetBase[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the `<iframe>` itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			// Listen for blur and focus events on targetWindow's document.
			var _this = this,
				body = targetWindow.document && targetWindow.document.body;

			if(body){
				// Listen for touches or mousedowns... could also use dojo/touch.press here.
				var event = has("pointer-events") ? "pointerdown" : has("MSPointer") ? "MSPointerDown" :
					has("touch-events") ? "mousedown, touchstart" : "mousedown";
				var mdh = on(targetWindow.document, event, function(evt){
					// workaround weird IE bug where the click is on an orphaned node
					// (first time clicking a Select/DropDownButton inside a TooltipDialog).
					// actually, strangely this is happening on latest chrome too.
					if(evt && evt.target && evt.target.parentNode == null){
						return;
					}

					_this._onTouchNode(effectiveNode || evt.target, "mouse");
				});

				var fih = on(body, 'focusin', function(evt){
					// When you refocus the browser window, IE gives an event with an empty srcElement
					if(!evt.target.tagName) { return; }

					// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
					// ignore those events
					var tag = evt.target.tagName.toLowerCase();
					if(tag == "#document" || tag == "body"){ return; }

					if(a11y.isFocusable(evt.target)){
						_this._onFocusNode(effectiveNode || evt.target);
					}else{
						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						_this._onTouchNode(effectiveNode || evt.target);
					}
				});

				var foh = on(body, 'focusout', function(evt){
					_this._onBlurNode(effectiveNode || evt.target);
				});

				return {
					remove: function(){
						mdh.remove();
						fih.remove();
						foh.remove();
						mdh = fih = foh = null;
						body = null;	// prevent memory leak (apparent circular reference via closure)
					}
				};
			}
		},

		_onBlurNode: function(/*DomNode*/ node){
			// summary:
			//		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive

			var now = (new Date()).getTime();

			// IE9+ and chrome have a problem where focusout events come after the corresponding focusin event.
			// For chrome problem see https://bugs.dojotoolkit.org/ticket/17668.
			// IE problem happens when moving focus from the Editor's <iframe> to a normal DOMNode.
			if(now < lastFocusin + 100){
				return;
			}

			// If the blur event isn't followed by a focus event, it means the user clicked on something unfocusable,
			// so clear focus.
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
			}
			this._clearFocusTimer = setTimeout(lang.hitch(this, function(){
				this.set("prevNode", this.curNode);
				this.set("curNode", null);
			}), 0);

			// Unset timer to zero-out widget stack; we'll reset it below if appropriate.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}

			if(now < lastTouchOrFocusin + 100){
				// This blur event is coming late (after the call to _onTouchNode() rather than before.
				// So let _onTouchNode() handle setting the widget stack.
				// See https://bugs.dojotoolkit.org/ticket/17668
				return;
			}

			// If the blur event isn't followed (or preceded) by a focus or touch event then mark all widgets as inactive.
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
			}), 0);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or touched.
			//		Note that _onFocusNode() calls _onTouchNode().
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// Keep track of time of last focusin or touch event.
			lastTouchOrFocusin = (new Date()).getTime();

			if(this._clearActiveWidgetsTimer){
				// forget the recent blur event
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// if the click occurred on the scrollbar of a dropdown, treat it as a click on the dropdown,
			// even though the scrollbar is technically on the popup wrapper (see #10631)
			if(domClass.contains(node, "dijitPopup")){
				node = node.firstChild;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			// Keep track of time of last focusin event.
			lastFocusin = (new Date()).getTime();

			// There was probably a blur event right before this event, but since we have a new focus,
			// forget about the blur
			if(this._clearFocusTimer){
				clearTimeout(this._clearFocusTimer);
				delete this._clearFocusTimer;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("prevNode", this.curNode);
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack, lastOldIdx = oldStack.length - 1, lastNewIdx = newStack.length - 1;

			if(newStack[lastNewIdx] == oldStack[lastOldIdx]){
				// no changes, return now to avoid spurious notifications about changes to activeStack
				return;
			}

			this.set("activeStack", newStack);

			var widget, i;

			// for all elements that have gone out of focus, set focused=false
			for(i = lastOldIdx; i >= 0 && oldStack[i] != newStack[i]; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i++; i <= lastNewIdx; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	domReady(function(){
		var handle = singleton.registerWin(winUtils.get(document));
		if(has("ie")){
			on(window, "unload", function(){
				if(handle){	// because this gets called twice when doh.robot is running
					handle.remove();
					handle = null;
				}
			});
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.   Remove for 2.0.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'curam/util/ExpandableLists':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012-2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/dom",
	    "dojo/dom-construct",
	    "dojo/_base/window",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/query",
        "dojo/sniff",
        "dijit/registry",
        "curam/inspection/Layer",
        "curam/util",
        "curam/debug",
        "curam/UIMController",
        "curam/util/ui/refresh/RefreshEvent",
        "curam/define",
        "curam/contentPanel"
        ], function(dom, domConstruct, win, domStyle, domClass, domAttr, query, has, registry, layer, util, debug) {
  
  /*
   * Modification History
   * --------------------
   * 14-Dec-2022  CMC [SPM-105222] Updated listRowFrameLoaded() to check for addOnUnloadTriggeredByFileDownload session storage object. 
   * 19-Jun-2020  FN  [RTC247839]  Updated setDetailsRowExpandedState to render the toggle button image for expandable lists.
   *                               Also fixing property resolver for debug message defined in curam.util.ExpandableLists.even
   *                               called from setupToggleHandler().
   * 31-Jan-2020  JD  [RTC257128]  Add additional pixels to the height of iframe in expandable list when printing if
   *                               context panel is present and case owner scroll height is greater than 20px.
   * 19-Nov-2019  JD  [RTC253552]  Reduced transform scale for Chrome styling in _addMediaPrintToIframe to prevent
   *                               context panels being cut off.
   * 23-Oct-2019  JD  [RTC253937]  Updated _addMediaPrintToIframe to cater for additional context panel types.
   * 04-Apr-2019  CM  [RTC240102]  Added changes to setDetailsRowExpandedState() to allow for screen readers to
   * 							   notify users of toggle states.
   * 23-Jan-2019  CMC [RTC239346]  Updated _addMediaPrintToIframe so extra spacing will not be included on the
   * 							   iFrame containing person information on the Person Search page.
   * 30-Nov-2018  BD  [RTC238774]  Included 300px on the media print style for iframes that are included inside the 
   *                               expandable list.
   * 17-Aug-2018  BD  [RTC204061]  Ensured nested iFrames in Evidence tab can be printed.
   * 10-May-2016  SK  [CR00479312] Replaced outdated dom method invocations 
   *                  with Dojo methods.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 12-Sep-2014  MV  [CR00444603] Replace dojox/storage with HTML5 local storage.  
   * 28-Sep-2013  BOS [CR00396277] Initial version.
   */
  
  /**
   * @namespace Functions specific to expandable lists.
   */
  curam.define.singleton("curam.util.ExpandableLists", {
    /**
     * Holds the minimum allowed height of an expanded details row for each
     * individual list. The values are put in this array by the page generator
     * and are taken from the UIM where the app developer can set
     * the MINIMUM_EXPANDED_HEIGHT attribute of the DETAILS_ROW element.
     * @private
     */
    _minimumExpandedHeight: [],

    /** Holds state data for lists in the current runtime context. **/
    stateData: [],
    
    /** @private */
    _LIST_ID_PREFIX: "list-id-",

    /** @private */
    _ROW_ID_PREFIX: "row-id-",
    
    /** @private */
    _EVENT_TOGGLE: "/curam/list/row/toggle",

    /** @private */
    _EVENT_TYPE_EXPANDED: "Expanded",
    
    /** @private */
    _EVENT_TYPE_COLLAPSED: "Collapsed",
    
    /**
     * Handles toggle events on all lists. The event received contains
     * the list-specific information.
     */
    setupToggleHandler: function() {
      dojo.ready(function() {
        var _this = curam.util.ExpandableLists;

        var handler = function(listId, rowId, eventType) {
          // types: Expanded | Collapsed
          if (listId) {
            curam.debug.log(debug
              .getProperty("curam.util.ExpandableLists.event1", 
                         [eventType, listId, rowId]));
          } else {
          // We are just logging the state of expandable lists as this is the only parameter passed from lists on modal pages.
            curam.debug.log(debug
               .getProperty("curam.util.ExpandableLists.event2", 
                         [eventType]));
          }
          
          if (eventType == _this._EVENT_TYPE_EXPANDED) {
            var listData = _this._getListData(listId);

            var rowFound = dojo.filter(listData.expandedRows, function(item) {
              return item == rowId;
            });
            if (rowFound.length == 0) {
              listData.expandedRows.push(rowId);
            }
          
          } else {
            // if Collapsed
            var listData = _this._getListData(listId);
            
            // remove the row from the list
            listData.expandedRows =
                dojo.filter(listData.expandedRows, function(item) {
                  return item != rowId;
                });
            
            if (listData.expandedRows.length == 0) {
              _this._removeListData(listId);
            }
          }

          curam.debug
            .log("curam.util.ExpandableLists.setupToggleHandler stateData: ",
                 _this.stateData);
        };
        // no need to unsubscribe explicitly - handler will be scraped on page
        // refresh 
        dojo.subscribe(_this._EVENT_TOGGLE, this, handler);
        
        // no need to unsubscribe explicitly - handler will be scraped on page
        // refresh 
        dojo.subscribe("/curam/page/refresh", this, _this._saveStateData);
      });
    },
    
    /**
     * Saves the current state data to persistent storage.
     * @private
     */
    _saveStateData: function() {
      var _this = curam.util.ExpandableLists;

      // save the data
      curam.debug.log("/curam/page/refresh" + debug
        .getProperty("curam.util.ExpandableLists.refresh"), _this.stateData);
      
      try {
        dojo.forEach(_this.stateData, function(item) {
          var data = dojo.toJson(item);
          curam.debug.log(
            debug.getProperty("curam.util.ExpandableLists.exception"), data);
          localStorage[_this._sanitizeKey(item.listId)] = data;
        });

      } catch (e) {
        curam.debug.log(
            debug.getProperty("curam.util.ExpandableLists.exception"), e);
      }
    },
    
    /**
     * Ensures the key value conforms to the rules required by the underlying
     * storage mechanism.
     * @private
     * @return The key value changed in such a way that it can be used
     *    as a storage key.
     */
    _sanitizeKey: function(key) {
      return key.replace("-", "_");
    },
    
    /**
     * Loads state for the specified list from the persistent storage.
     * 
     * The call to this function is generated into the page by gen-jsp.xsl
     * or the corresponding DUIM renderer.
     * 
     * @param listId
     *    ID of the list to load state for.
     */
    loadStateData: function(listId) {
      if (typeof(window.curamDialogRedirecting) != "undefined") {
        curam.debug.log("curam.util.ExpandableLists.loadStateData " 
          + debug.getProperty("curam.util.ExpandableLists.load.exit"));
        return;
      }
      var _this = curam.util.ExpandableLists;

      var loadFunction = function() {
        curam.debug.log("curam.util.ExpandableLists.loadStateData " +
          + debug.getProperty("curam.util.ExpandableLists.load.for"), listId);

        var stateDataJson = localStorage[_this._sanitizeKey(listId)];
        if(stateDataJson && stateDataJson != "") {
          var stateData = dojo.fromJson(stateDataJson);
          var listNodes = query("table." + _this._LIST_ID_PREFIX + listId);
          
          dojo.forEach(stateData.expandedRows, function(item) {
            curam.debug.log(debug
              .getProperty("curam.util.ExpandableLists.load.row"), item);
            // only look in the context of the corresponding list - covers
            // scenarios with multiple lists on the same page that have rows
            // with identical ID (technically possible)
            var rowNodes = query("tr." + _this._ROW_ID_PREFIX + item,
                listNodes[0]);
            
            if (rowNodes.length > 0) {
              var crtlRowSet = rowNodes[0].prev("tr").children();
              var crtlBtn = crtlRowSet.children("a.list-details-row-toggle")[0];
              if (crtlBtn) {
                _this._toggleDetailsRow(crtlBtn);
              } else {
                curam.debug.log(debug
                  .getProperty("curam.util.ExpandableLists.load.button" 
                    + ".disabled"));
              }
            
            } else {
              curam.debug.log(debug
                .getProperty("curam.util.ExpandableLists.load.row.disabled"));
            }
          });
          
          // Wipe the saved data for the specified list
          localStorage.removeItem(_this._sanitizeKey(listId));
        
        } else {
          curam.debug.log(debug
            .getProperty("curam.util.ExpandableLists.load.no.data"));
        }
      };
      
      // execute the load action
      dojo.ready(function() { loadFunction(); });
    },
    
    /**
     * Returns the list state data object for the specified list.
     * The data object is created if it doesn't yet exist.
     * @private
     * 
     * @param listId Id of the list to get data for.
     */
    _getListData: function(listId) {
      var allData = curam.util.ExpandableLists.stateData;
      
      var listData = dojo.filter(allData, function(item) {
        return item.listId == listId;
      });
      
      if (listData.length == 0) {
        listData.push({ listId: listId, expandedRows: [] });
        allData.push(listData[0]);
      }

      return listData[0];
    },
    
    /**
     * Removes the list state data object for the specified list.
     * @private
     * 
     * @param listId
     *    ID of the list for which to remove data
     */
    _removeListData: function(listId) {
      var _this = curam.util.ExpandableLists;
      _this.stateData = dojo.filter(_this.stateData, function(item) {
        return item.listId != listId;
      });
    },
    
    /**
     * Handler triggered on click of expand/collapse button in advanced lists.
     * @param event
     *    The click event object.
     */
    toggleListDetailsRow: function(event) {
      if (event) {
        // event that standardizes the event object across browsers
        event = dojo.fixEvent(event);
        dojo.stopEvent(event);

        // This is the element with the onlick handler, an anchor element
        // generated in gen-jsp.xsl.
        var expandCollapseButton = event.currentTarget;
        
        curam.util.ExpandableLists._toggleDetailsRow(expandCollapseButton);
      }
    },

    /**
     * This function improves the performance of expandable lists, especially
     * those lists containing a large number of rows. This is achieved by lazy 
     * loading the UIMController widget for the row to be expanded.
     * 
     * The details needed to create the UIMController are first created in the 
     * ExpandableListRowRenderer and stored within a <div> tag within the hidden
     * row. This <div> is deleted after the UimController widget is created.
     * 
     */
    _generateUimController: function(detailsRow) {
      // retrieve relevant variables from within the hidden details row
      var detailsRowContent = query("td", detailsRow)[0];
      var hiddenRowDetails = query("div", detailsRow)[0];

      // construct the widget
      var uimController = new curam.UIMController({
        uid:                domAttr.get(hiddenRowDetails, "uid"),
        url:                domAttr.get(hiddenRowDetails, "url"),
        iframeId:           domAttr.get(hiddenRowDetails, "iframeId"),
        iframeClassList:    domAttr.get(hiddenRowDetails, "iframeClassList"),
        loadFrameOnCreate:  domAttr.get(hiddenRowDetails, "loadFrameOnCreate")
      });
      
      // add generated widget content to hidden details row
      detailsRowContent.appendChild(uimController.domNode);
      
      // remove original node containing widget setup details, the data is no 
      //longer needed
      if (hiddenRowDetails && detailsRowContent) {
        detailsRowContent.removeChild(hiddenRowDetails);
      }
      
      return uimController;
    },
    
    /**
     * Toggles the details row for the specified button.
     * @private
     *
     * @param expandCollapseButton
     *    The toggle button for the row that should be toggled.
     */
    _toggleDetailsRow: function(expandCollapseButton) {
      curam.debug.log("curam.util.ExpandableLists._toggleDetailsRow " 
        + debug.getProperty("curam.util.ExpandableLists.load.for"), 
          expandCollapseButton);
      
      var _this = curam.util.ExpandableLists;

      // get the main row - it is the parent row of the expand\collapse node
      var tableRow = query(expandCollapseButton).closest("tr")[0];
      
      // get the hidden details row which is assumed to be the previous sibling
      // of the main row.
      var detailsRow = query(tableRow).next("tr")[0];
      
      var expand = !_this.isDetailsRowExpanded(detailsRow);

      _this._handleStripingAndRoundedCorners(tableRow, detailsRow, expand);

      //var iframeNodeList = query("iframe", detailsRow);
      var divNodeList = query("div.uimController", detailsRow);
      var uimControllerNode = null;
      var uimController = null;
      
      // lazy load uimController widget if it does not already exist (this will 
      // occur the first time the hidden row is expanded)
      if (divNodeList == null || divNodeList.length == 0) {
        uimController = _this._generateUimController(detailsRow);
        
      } else {
        uimControllerNode = divNodeList[0];
        uimController = registry.byNode(uimControllerNode);
      }

      if (typeof(uimController) == "undefined" || uimController == null) {
        throw "UIMController Dijit not found for node: " + uimControllerNode;
      }      
      var iframeSrc = domAttr.get(uimController.frame, "src");
      var triggerResize = false;
      
      // toggle the row expanded state, do that before loading page
      _this.setDetailsRowExpandedState(tableRow, detailsRow, expand,
          expandCollapseButton);
      
      var def = new dojo.Deferred();
      // only set it if it doesn't exist already.
      if (!iframeSrc || iframeSrc == null || iframeSrc == "") {
        uimController.loadPage(def);

      } else {
        triggerResize = true;
        def.callback();
      }
      
      def.addCallback(function() {
        var inPageNav = uimController.hasInPageNavigation();
        
        // this is being determined after the page is loaded
        triggerResize = triggerResize || inPageNav;
        
        if (inPageNav) {
          // explicitly hide the in-page navigation tabs
          // this is to ensure the nav tabs are hidden when the row is collapsed 
          uimController.showTabContainer(expand);
        }
        
        // now resize to accomodate in-page nav tabs
        if (triggerResize) {
          curam.util.ExpandableLists.resizeExpandableListAncestors(window);
        }

        // publish the corresponding toggle event to drive remembering state across
        // page refreshes
        var eventType = expand ? _this._EVENT_TYPE_EXPANDED
            : _this._EVENT_TYPE_COLLAPSED;
        var listId = _this._findListId(detailsRow);
        var rowId = curam.util.getSuffixFromClass(detailsRow, _this._ROW_ID_PREFIX);
        dojo.publish(_this._EVENT_TOGGLE, [ listId, rowId, eventType ]);

        // Publish the row expanded/collapsed state to the parent.
        if (!curam.util.ExpandableLists._isExternalApp(window)) {
          var eventType =
              expand ? "ListDetailsRow.Expand" : "ListDetailsRow.Collapse";
          var onClickDetails = {
            url: domAttr.get(uimController.frame, "src"),
            eventType: eventType
          };
  
          var sourceTab = curam.tab.getSelectedTab();
          
          if (sourceTab) {
            var tabWidgetId = curam.tab.getTabWidgetId(sourceTab);
  
            curam.util.getTopmostWindow().dojo.publish("expandedList.toggle",
              [window.frameElement, onClickDetails, tabWidgetId]);  
          } 
        }
      });
    },
    
    _handleStripingAndRoundedCorners: function(tableRow, detailsRow, isExpanding) {
      var odd       = "odd";
      var even      = "even";
      var no_border = "row-no-border";
      var odd_last  = "odd-last-row";
      var even_last = "even-last-row";
      
      if(!curam.util.ExpandableLists._isLastRow(tableRow, detailsRow)) {
        // copy striping classes onto the details row 
        if (domClass.contains(tableRow, odd)) {
          domClass.add(detailsRow, odd);
        
        } else if (domClass.contains(tableRow, even)) {
          domClass.add(detailsRow, even);
        }
      
      } else {
        // on last row - handle rounded corners
        if (isExpanding) {
          if (domClass.contains(tableRow, odd_last)) {
            domClass.remove(tableRow, odd_last);
            domClass.add(tableRow, odd);
            
            domClass.add(detailsRow, odd);
            domClass.add(detailsRow, odd_last);
          
          } else if (domClass.contains(tableRow, even_last)) {
            domClass.remove(tableRow, even_last);
            domClass.add(tableRow, even);

            domClass.add(detailsRow, even);
            domClass.add(detailsRow, even_last);
          }
          
        } else { // is collapsing
          if (domClass.contains(tableRow, odd)) {
            domClass.remove(tableRow, odd);
            domClass.add(tableRow, odd_last);
            
            // details row hidden, remove all classes
            domClass.remove(detailsRow, odd_last);
            domClass.remove(detailsRow, odd);
          
          } else if (domClass.contains(tableRow, even)) {
            domClass.remove(tableRow, even);
            domClass.add(tableRow, even_last);

            // details row hidden, remove all classes
            domClass.remove(detailsRow, even);
            domClass.remove(detailsRow, even_last);
          }
        }
      }
      
      // set border
      if (isExpanding) {
        domClass.add(tableRow, no_border);

      } else {
        domClass.remove(tableRow, no_border);
      }
      
      // When the table row is expanded,class " collapsed" should be
      // removed from details row
      if (domClass.contains(tableRow, no_border)) {
       domClass.remove(detailsRow, "collapsed");
      } else {
      domClass.add(detailsRow, "collapsed");
      }
    },

    /**
     * Sets the appropriate CSS classes to style the details row accordingly
     * as well as the toggle image for the button next to the lists.
     */
    setDetailsRowExpandedState: function(mainRowNode, detailsRowNode, expand,
        /*optional*/expandCollapseButton) {
      
      // Now we have the button and the row element, toggle the appropriate CSS
      // styles on them.
    
      // By default the row will have the "collapsed" style on it when first
      // displayed. See commons.css for details plus an explanation for why this
      // is done the opposite way to the button below (Summary: we couldn't get
      // a reliable way to override "display:none;" on the table row)
      
      // The value returned from isDetailsRowExpanded is used as there is an issue when 
      // Pagesize is changed and  collapsed class is not removed and added back 
      // properly on toggle :CR00387473
      var expanded = curam.util.ExpandableLists.isDetailsRowExpanded(detailsRowNode);
      domClass.remove(detailsRowNode, "collapsed");
      if (!expanded) {
        domClass.add(detailsRowNode, "collapsed");
      }

      // When theres any other page of list displayed,the expanded details row
      // should be hidden inheriting the table row.
      if(mainRowNode.style.display=="none"){
        detailsRowNode.setAttribute("style","display:none");
      }else{
        detailsRowNode.removeAttribute("style");
      }
      
      // By default the button will *not* have the "expanded" style. See
      // commons.css for details.
      if (expandCollapseButton) {
        var imageElement = query('img', expandCollapseButton)[0];
        if (expand) {
          domClass.add(expandCollapseButton, "expanded");
          domAttr.set(expandCollapseButton, "aria-expanded", "true");
          if (imageElement) {
            domAttr.set(imageElement, "src", require.toUrl("../themes/curam/images/chevron--down20-enabled.svg"));
          }
        } else {
          domClass.remove(expandCollapseButton, "expanded");
          domAttr.set(expandCollapseButton, "aria-expanded", "false");
          if (imageElement && curam.util.isRtlMode()) {
            // Right-To-Left image
            domAttr.set(imageElement, "src", require.toUrl("../themes/curam/images/chevron--left20-enabled.svg"));
          }else{
            domAttr.set(imageElement, "src", require.toUrl("../themes/curam/images/chevron--right20-enabled.svg"));
          }
        }
      }
    },
    
    _isLastRow: function(tableRow, detailsRow) {
      return domClass.contains(tableRow, "even-last-row")
      || domClass.contains(tableRow, "odd-last-row")
      || domClass.contains(detailsRow, "even-last-row")
      || domClass.contains(detailsRow, "odd-last-row");
    },

    /**
     * Determines the state of the specified details row.
     * 
     * @param detailsRowNode
     *    The details row to examine.
     * 
     * @return True if expanded, False if collapsed. 
     */
    isDetailsRowExpanded: function(detailsRowNode) {
      return !domClass.contains(detailsRowNode, "collapsed");
    },
    
    /**
     * Invoked in response to the load event from the page in the
     * expandable list panel's iframe. It is hooked into the standardized page
     * load event system (onLoad.js) in ExpandableListRowRenderer.java.
     *
     * @param iframeID
     *    The iframe's ID.
     * @param context
     *    The context object containing the page height.
     */
    listRowFrameLoaded: function(iframeID, context) {
      curam.debug.log("========= " 
        + debug.getProperty("curam.util.ExpandableLists.page.load") 
          + " =======");
      curam.debug.log(iframeID);
      curam.debug.log(dojo.toJson(context));
      var iframe = dom.byId(iframeID);
      if (!iframe) {
        throw "List Row Expanded: No iframe found";
      }

      if (!iframe._spExpListPageLoadListener) {
        // The first time a page is loaded in the frame, setup a listener to
        // subsequent page loads.
        //curam.contentPanel.initSmartPanelExpListPageLoadListener();

        // the first time a frame is loaded we don't want to fire an event.
        iframe._spExpListPageLoadListener = "true";

        dojo.addOnUnload(function() {
          if (sessionStorage.getItem("addOnUnloadTriggeredByFileDownload") == null) {
            // If this addOnUnload was not triggered by a file download we release 
            // the iframe content to avoid memory leaks.
            domAttr.set(iframe, "src", "");
          }
        });

      } else {
        if (!curam.util.ExpandableLists._isExternalApp(window)) {
          curam.contentPanel.publishSmartPanelExpListPageLoad(iframe);
        }
      }
      
      // guard the minimum allowed height of the expanded details panel
      var listId = curam.util.ExpandableLists._findListId(iframe);
      var minExpHeight =
          curam.util.ExpandableLists.getMinimumExpandedHeight(listId);
      var height = context.height;
      if (height < minExpHeight) {
        curam.debug.log(debug
          .getProperty("curam.util.ExpandableLists.min.height", 
                       [minExpHeight]));
        height = minExpHeight;

      } else {
        curam.debug.log(debug
          .getProperty("curam.util.ExpandableLists.height", [height]));
      }
      
      // set the height
      curam.util.ExpandableLists._resizeIframe(iframe, height);

      // now that this panel has changed, we have to trigger a resize in any
      // ancestors (if this is a nested expandable list).
      curam.util.ExpandableLists.resizeExpandableListAncestors(window);
      
      curam.util.ExpandableLists._setFrameTitle(iframe, context);
      
      // this processing should not occur for an external application.
      if (!curam.util.ExpandableLists._isExternalApp(window)) {
        // notify the refresh mechanism that the inline page has been loaded.
        var sourceTab = curam.tab.getSelectedTab();
        if (sourceTab) {
          var tabWidgetId = curam.tab.getTabWidgetId(sourceTab);
          var topWin = curam.util.getTopmostWindow();
          topWin.curam.util.Refresh.getController(tabWidgetId).pageLoaded(
            context.pageID,
            curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_INLINE);  
        }
      }
      curam.debug.log("================================================");
    },
    
    /**
     * Resizes the iframe to have the specified height.
     *
     * @private
     *
     * @param iframe
     *    The iframe to resize.
     * @param height
     *    The new height for the iframe.
     */
    _resizeIframe: function(iframe, height) {
      domStyle.set(iframe, { height: height + "px" });      
      curam.util.ExpandableLists._addMediaPrintToIframe(iframe, height);
    },
      
    /**
     * Add to the media print style to the high parent the parameter min-height.
     * @param iframe
     *    The iframe to resize.
     * @param height
     *    The new height for the iframe.
     */
    _addMediaPrintToIframe: function(iframe, height){
      // Add min-height attribute so the iFrame prints correctly
      var iframeID = iframe.id;
      // Get the parent
      var parentIframe = iframe.contentWindow.frames.parent;
      var additionalHeightPixels = 0;
      var iFrameHasContextPanel = false;
      var isApplicationCase = false;
      var iFrameInnerDoc = iframe.contentWindow.document;
      win.withDoc(iFrameInnerDoc, function() {
        var personContainerPanel = dojo.query(".person-container-panel")[0];
        if (personContainerPanel) {
        iFrameHasContextPanel = true;
          // Add overflow hidden to body on IE to remove scroll bar from person panel container
          if (has('ie') || has('trident')) {
            var body = iFrameInnerDoc.body;
            body.setAttribute('style','overflow: hidden !important');
          }
        }
          
        // Check if a non-person context panel is present.
        if (dojo.query(".context-panel-wrapper")[0]) {
          iFrameHasContextPanel = true; 
        }
        
        if (iFrameHasContextPanel) {
          // Add additional height to iframe if there are multiple participants on case.
          var participantIconPanes = dojo.query(".pane");
          var caseOwner = dojo.query(".intake-user")[0] || dojo.query(".pd-case-owner")[0] || dojo.query(".ic-case-owner")[0];
          
          if (participantIconPanes.length > 1) {
            additionalHeightPixels = participantIconPanes[0].scrollHeight * (participantIconPanes.length - 1);
          } else if (caseOwner){
            if (caseOwner.scrollHeight > 20){
              additionalHeightPixels = caseOwner.scrollHeight;
            }
          }
          
          // If case is an application case, set flag to true.
          if (dojo.query(".Intakecontainer-panel")[0]) {
            isApplicationCase = true;
          }
          
        }
          
          
      }, this);
      
      if (iFrameHasContextPanel) {
      
        var css = "";
        
        // If an application case is present, apply the following style.
        if (isApplicationCase) {
          css="@media print { ."+iframeID+" {" +
          "min-height: calc( "+additionalHeightPixels+"px + "+height+"px) !important;  " +
          "min-width: 1300px !important;  " +
          "-ms-transform: scale(0.85);" +
          "-ms-transform-origin: 0 0;" +
          "-moz-transform: scale(0.85);" +
          "-moz-transform-origin: 0 0;" +
          "-webkit-transform: scale(0.70);" +
          "-webkit-transform-origin: 0 0;} }";
        } else {
          // If it is an non application case, apply the following style.
          css="@media print { ."+iframeID+" {" +
          "min-height: calc( "+additionalHeightPixels+"px + "+height+"px) !important;  " +
          "min-width: 1200px !important;  " +
          "-ms-transform: scale(0.9);" +
          "-ms-transform-origin: 0 0;" +
          "-moz-transform: scale(0.9);" +
          "-moz-transform-origin: 0 0;" +
          "-webkit-transform: scale(0.85);" +
          "-webkit-transform-origin: 0 0;} }";
        }
      } else {
          var css="@media print { ."+iframeID+" { min-height: calc( 300px + "+height+"px) !important;  } }";
      }
         
      var frameDoc = parentIframe.window.document;
      // Change context from current window to iframe
      win.withDoc(frameDoc, function() {
        //if the ID is created, change the css. Otherwise, create the element on the window.
        if (query("#" + iframe.id + "_print").length > 0) {
          dom.byId(iframe.id + "_print").innerHTML = css;
        } else {
          domConstruct.create('style', {id:iframe.id + "_print", innerHTML:css }, win.body());
        }
      });
      
    },
    
    /**
     * Set iframe title for expanded row.
     *
     * @private
     *
     * @param iframe
     *    The iframe.
     * @param context
     *    The context object containing the page title.
     */
    _setFrameTitle: function(iframe, context) {
      iframe.title = iframe.title + " " + context.title;
    },
    
    /**
     * Finds list ID of the list that contains the specified element.
     *
     * @private
     *
     * @param element
     *    The element to find the list id for.
     * 
     * @return ID of the list that contains the specified element.
     */
    _findListId: function(element) {
      return curam.util.getSuffixFromClass(
          query(element).closest("table")[0],
            curam.util.ExpandableLists._LIST_ID_PREFIX);
    },
    
    /**
     * When an expandable list changes size, call this method to trigger
     * a re-size in its ancestors.
     *
     * TODO: This is a recursive method which re-sizes ancestor iframe elements.
     * It is called from both "listRowFrameLoaded", in response to page load
     * events, and "setDetailsRowExpandedState", in response to a panel being
     * expanded or collapses (i.e. **not** a page load).
     * Can we implement a generic "page re-sized" event system similar to 
     * "onLoad.js"? How would it interact with onLoad.js? 
     * For now this method will stick to re-cursively re-sizing ancestor iframes.
     * 
     * @param theWindow
     *    The window on which the resize operation should be applied.
     */
    resizeExpandableListAncestors: function(theWindow) {
      curam.debug.log(
          "curam.util.ExpandableLists.resizeExpandableListAncestors: ", 
            theWindow.location.href);
      
      // Check if the current window is loaded in an expandable list iframe.
      // ExpandableListRowRenderer adds the "expanded_row_iframe" class which is
      // used as the indicator of a nested expandable list here.
      if (theWindow
          && theWindow !== window.top
          && typeof(theWindow.frameElement) != "undefined" 
          && (domClass.contains(theWindow.frameElement, "expanded_row_iframe")
              || curam.util.ExpandableLists.isNestedUIM(theWindow))) {
        
        // The frame which is contained in "theWindow" has already be re-sized by
        // "listRowFrameLoaded", which in turn means that this window's (theWindow)
        // height has also changed. As this window is also in an expandable list,
        // we need to get it's height and then update it's containing frame.
        var newPageHeight = theWindow.curam.util.getPageHeight();
        curam.debug.log("curam.util.ExpandableLists" 
            + ".resizeExpandableListAncestors: " 
            + debug.getProperty("curam.util.ExpandableLists.resize.height"), 
              newPageHeight);
        curam.util.ExpandableLists._resizeIframe(
            theWindow.frameElement, newPageHeight);
        
        curam.util.ExpandableLists.resizeExpandableListAncestors(
            theWindow.parent);
      
      } else {
        curam.debug.log("curam.util.ExpandableLists" 
            + ".resizeExpandableListAncestors: "  
            + debug.getProperty("curam.util.ExpandableLists.resize.end"));
        return;
      }
    },
    
    /**
     * Utility method to check the supplied window object has a Nested UIM
     * context.
     * @param theWindow A instance of a window object.
     */
    isNestedUIM: function(theWindow) {
      if (theWindow && theWindow.jsScreenContext) {
        return theWindow.jsScreenContext.hasContextBits("NESTED_UIM");

      } else {
        return false;
      }
    },
    
    /**
     * Utility method to check the supplied window object has a EXTAPP
     * context.
     * @param theWindow A instance of a window object.
     */
    _isExternalApp: function(theWindow) {
      if (theWindow && theWindow.jsScreenContext) {
        return theWindow.jsScreenContext.hasContextBits("EXTAPP");
      } else {
        return false;
      }
    },
    
    /**
     * Sets the minimum allowed height for the expanded rows in the specified
     * list.
     *
     * @param listId
     *    The list to set the height for.
     * @param minExpHeight
     *    The height value in pixels.
     */
    setMinimumExpandedHeight: function(listId, minExpHeight) {
      curam.util.ExpandableLists._minimumExpandedHeight.push({
          listId: listId,
          minExpHeight: minExpHeight
      });
    },
    
    /**
     * Retrieves the minimum allowed height of the expanded details row
     * for the specified list. If no data is found for the list,
     * the function returns default minimum height of 30 pixels.
     *
     * @param listId
     *    The list to set the height for.
     * @return The minimum allowed height of the expanded details row in pixels
     *    or 50 if no data is found.
     */
    getMinimumExpandedHeight: function(listId) {
      var data = dojo.filter(
          curam.util.ExpandableLists._minimumExpandedHeight, function(item) {
            return item.listId == listId;
          });
      if (data.length == 1) {
        return data[0].minExpHeight;

      } else {
        curam.debug.log(debug
          .getProperty("curam.util.ExpandableLists.default.height"), listId);
        return 30;
      }
    }
  });
  layer.register("curam/util/ExpandableLists", this);


  return curam.util.ExpandableLists;
});

},
'curam/cdsl/_base/_Connection':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 13-Oct-2014  SC  [CR00446751] Support for preferences.
 * 08-Oct-2014  MV  [CR00446578] Increasing default timeout.
 */

define(['dojo/_base/declare',
        './MetadataRegistry',
        './PreferenceMap'
        ], function(
            declare, MetadataRegistry, PreferenceMap) {

  /**
   * @name curam.cdsl._base._Connection
   * @namespace Represents a connection to Curam server. This abstraction
   *    allows for variation in connection methods used for accessing the Curam
   *    server.
   */
  var _Connection = declare(null,
  /**
   * @lends curam._base._Connection.prototype
   */
  {
    /** Number of milliseconds to wait for server response by default. */
    _DEFAULT_REQUEST_TIMEOUT: 60000,

    /** Metadata related to this connection instance. */
    _metadata: null,

    /** Preferences related to this connection instance. */
    _preferences: null,

    constructor: function() {
      this._metadata = new MetadataRegistry();
      this._preferences = new PreferenceMap();
    },
    
    /**
     * Invokes a specific facade method on the server.
     * 
     * @param {curam.cdsl.request.FacadeMethodCall} methodCall
     *    The method call instance.
     * @param {Number} timeout Timeout value for the call.
     * @return {dojo.Promise} A promise for the result of invocation.
     */
    invoke: function(methodCall, timeout) {
      // set flags around metadata to be requested
      this._metadata.setFlags(methodCall);
    },
    
    updateMetadata: function(response) {
      this._metadata.update(response);
    },
    
    metadata: function() {
      return this._metadata;
    },
    
    /**
     * Provides access to the preferences associated with the connection.
     * 
     * @returns {PreferenceMap} The name value preference map.
     */
    preferences: function() {
      return this._preferences;
    }
  });
  
  return _Connection;
});

},
'curam/tab':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  Copyright IBM Corporation 2009,2022. All Rights Reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dijit/registry",
        "dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/dom-class",
        "curam/inspection/Layer",
        "curam/define",      
        "curam/util",
        "curam/util/ScreenContext"
        ], function(registry, dom, domAttr, domConstruct, domClass, layer) {
  
  /*
   * Modification History
   * --------------------
   * 09-Jun-2022  CM  [RTC277941] Remove code from previous defect fix on RTC277941.
   * 12-Apr-2022  CM  [RTC277107] Allow section tabs with a listed default page-id 
   *                  to be refreshed correctly on the non default page. 
   * 11-Aug-2021  SK  [RTC272800] refreshMainContentPanel now uses decoupled 
   *                              progress spinner invocation.
   * 20-Nov-2020  FG  [RTC231001] Changes due to the removal of IEG1.  
   * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 25-Mar-2014  MV  [CR00423311] Add function to detect internal application.  
   * 28-Sep-2013  BOS [CR00396277] Modified getSelectedTab() and 
   *                    onSectionSelected() functions to ensure an undefined. 
   *                    tab container handled correctly.
   * 28-Sep-2011  MV  [CR00288956] Refactored code to get separate
   *      getCurrentSectionId function.
   * 29-Jul-2011  MV  [CR00269970] Added missing semicolons.
   * 14-Feb-2011  PK  [CR00251730] Added "refreshMainContentPanel" method.
   * 14-Jan-2011  DG  [CR00242400] Changed "getContainerTab" to do a bottom-up
   *                    search. This is much, much simpler.
   * 12-Jan-2011  DG  [CR00238642] Fixed "getContainerTab" to find the tab for an
   *                    node even if the tab is not in the currently selected
   *                    section. Added copyright notice.
   * 17-Nov-2010  DG  [CR00217921] Clean-up of selected tab retrieval.
   * 27-Oct-2010  SK  [CR00224193] the situation where the content panel frame
   *                    is not present is now allowed.
   * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
   *                    tab-app-controller.js.
   * 21-Jul-2010  PK  [CR00211095] Added methods for handling default pages in a
   *                    section.
   * 16-Jul-2010  MV  [CR00210541] Fixed the getTabContainer() function to also
   *                    work in contexts other than the main window.
   * 28-Jun-2010  SD  [CR00204622] Smart Panel additions.
   * 02-Jul-2010  PK  [CR00203531] Updated to support section tab container.
   * 04-Jun-2010  MV  [CR00202412] Generalize the code that executes functions
   *                    on tab close.
   * 11-Feb-2010  MV  [CR00188844] Code format cleanup.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 24-Nov-2009  MV  [CR00175837] Remove debug output from getTabCOntainer.
   * 20-Nov-2009  MV  [CR00175581] Fix getSelectedTab function, remove
   *                    refreshCurrentTab function, add getTabController function.
   * 18-Nov-2009  MV  [CR00172452] Add more tab related functions.
   * 03-Sep-2009  MLB [CR00164883] Added function to refresh the current tab.
   * 06-Aug-2009  MV  [CR00164029] Initial version.
   * 24-Jun-2010 BD  [CR00204119] Updated how the content panel iframe is returned
   */
  /**
   * Contains functions of general use for the tabbed UI.
   */
  curam.define.singleton("curam.tab", {
    SECTION_TAB_CONTAINER_ID: "app-sections-container-dc",
    SMART_PANEL_IFRAME_ID: "curam_tab_SmartPanelIframe",
    toBeExecutedOnTabClose: [],
    
    /**
     * @private
     *
     * Used for testing: when this is set by the test code the value
     * will be returned from the getSelectedTab() function instead of the real
     * selected tab.
     */
    _mockSelectedTab: null,

    // Returns the currently selected tab widget.
    getSelectedTab: function(sectionID) {
      // supports testing code that uses curam.tab API
      if (curam.tab._mockSelectedTab) {
        return curam.tab._mockSelectedTab;
      }

      if (curam.tab.getTabContainer(sectionID)) {
        return curam.tab.getTabContainer(sectionID).selectedChildWidget;
      }    
    },

    getTabContainer: function(sectionID) {
      return curam.tab.getTabContainerFromSectionID(sectionID
          || curam.tab.getCurrentSectionId());
    },
    
    /**
     * Determines ID of the currently selected section.
     * By default throws an error when no current section is found.
     * 
     * @param {boolean} [suppressNotFoundError] If this option is set to true
     *          the function will not throw err when no current section
     *          is found.
     * 
     * @return ID of the currently selected section or null
     *          if "suppressNotFoundError" parameter is true.
     */
    getCurrentSectionId: function(suppressNotFoundError) {
      var sectionTabContainer = curam.util.getTopmostWindow().dijit.byId(
          curam.tab.SECTION_TAB_CONTAINER_ID);
      if (sectionTabContainer) {
        // children of the curam.tab.SECTION_TAB_CONTAINER_ID have id's that
        // start with the section ID and have a 4 character suffix. See
        // the ApplicationSectionRenderer.
        var childID = sectionTabContainer.selectedChildWidget.domNode.id;
        return childID.substring(0, childID.length - 4);

      } else {
        if (!suppressNotFoundError) {
          throw new Error(
              "curam.tab.getCurrentSectionId() - application section"
                + " tab container not found");
        }
      }

      return null;
    },
    
    /**
     * Determines whether we are running within a tabbed UI (internal
     * application) or not.
     * 
     * @return True if we are in tabbed UI, otherwise false.
     */
    inTabbedUI: function() {
      return curam.tab.getCurrentSectionId(true) != null;
    },

    getTabContainerFromSectionID: function(sectionID) {
      var tabContainer = registry.byId(sectionID + "-stc");
      // TODO: not sure what this should do now that sections have been
      // introduced
      if (!tabContainer && window.parent && window.parent != window) {
        tabContainer =
          curam.util.getTopmostWindow().dijit.byId(sectionID + "-stc");
      }
      return tabContainer;
    },

    // Returns the unique widget ID for the specified tab.
    getTabWidgetId: function(tab) {
      return tab.id;
    },

    // Returns the unique widget ID for the currently selected tab.
    getSelectedTabWidgetId: function() {
      return curam.tab.getTabWidgetId(curam.tab.getSelectedTab());
    },

    /**
     * Gets the tab that contains the given node. The node is typically the
     * "iframe" element (or its parent element) within the tab, but it can be
     * any other descendant node of the tab widget.
     *
     * @param {Node} node The node within the tab to be identified.
     * @return The tab content pane containing the given node.
     */
    getContainerTab: function(node) {
      var widget = dijit.getEnclosingWidget(node);

      if (widget && !widget.tabDescriptor) {
        // A valid tab has a "curam.tab.TabDescriptor" object. This is probably
        // a different widget nested within the tab. Look further up the tree.
        widget = curam.tab.getContainerTab(widget.domNode.parentNode);
      }

      if (!widget || !widget.tabDescriptor) {
        throw "Containing tab widget could not be found for node: " + node;
      }
      return widget;
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getContentPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab(),
          iframe = null;
      
      if (targetTab) {
        iframe = dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              // is-cp-iframe output by "ContentPanelRenderer".
              return domAttr.get(item,"iscpiframe") == "true";
            })[0];
      }
      return iframe ? iframe : null;
    },
    
    /**
     * Refreshes the main content panel for the specified tab. If the tab is not
     * specified, the currently selected one will be used.
     * @tab The tab to reload the main content panel for. 
     */
    refreshMainContentPanel: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab();
      curam.util.getTopmostWindow().dojo.publish('/curam/progress/display', [targetTab.domNode]);
      
      var iframe = curam.tab.getContentPanelIframe(tab);
      iframe.contentWindow.curam.util.publishRefreshEvent();
      // specifically pass false so that browser uses cached resources
      // where possible
      iframe.contentWindow.location.reload(false);
    },

    // Returns the iframe corresponding to the main content panel
    // of the specified tab.
    // If the tab parameter is not provided the selected tab will be used instead.
    getSmartPanelIframe: function(tab) {
      var targetTab = tab ? tab : curam.tab.getSelectedTab();
      var iframe =
        dojo.query("iframe", targetTab.domNode).filter(
            function(item) {
              return item.id == curam.tab.SMART_PANEL_IFRAME_ID;
            })[0];

      return iframe;
    },

    unsubscribeOnTabClose: function(unsubscribeToken, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          dojo.unsubscribe(unsubscribeToken);
          return true;
        }

        return false;
      });
    },

    executeOnTabClose: function(func, tabWidgetId) {
      curam.tab.toBeExecutedOnTabClose.push(function(actualTabWidgetId) {
        if (tabWidgetId == actualTabWidgetId) {
          func();
          return true;
        }

        return false;
      });
    },

    doExecuteOnTabClose: function(tabWidgetId) {
      var remainingFuncs = new Array();
      for (var i = 0; i < curam.tab.toBeExecutedOnTabClose.length; i ++) {
        var func = curam.tab.toBeExecutedOnTabClose[i];
        if (!func(tabWidgetId)) {
          remainingFuncs.push(func);
        }
      }

      curam.tab.toBeExecutedOnTabClose = remainingFuncs;
    },

    // Returns a handler function that handles the /curam/main-content/page/loaded events,
    // but only for the specified tab.
    getHandlerForTab: function(handler, tabWidgetId) {
      return function(pageId, actualTabWidgetId) {
        if (actualTabWidgetId == tabWidgetId) {
          handler(pageId, tabWidgetId);
        } else {
          // no action - event was for a different tab
        }
      };
    },

    getTabController: function() {
      return curam.util.getTopmostWindow().curam.ui.UIController;
    },

    initTabLinks: function(tabWindow) {
      dojo.query("a").forEach(
        function(link) {
          if (link.href.indexOf('#') != 0
              && link.href.indexOf('javascript:') != 0
              && (link.href.indexOf('Page.do') > -1
                        || link.href.indexOf('Frame.do') > -1)) {
            if (link.href.indexOf('&o3ctx') < 0
              && link.href.indexOf('?o3ctx') < 0) {
              var separator = (link.href.indexOf('?') > -1) ? "&" : "?";
          link.href += separator + jsScreenContext.toRequestString();
            }
          }
       });
      elements = document.forms;
      for (var i = 0; i < elements.length; ++i) {
        elem = elements[i];
        var ctxField = dom.byId('o3ctx');
        if (!ctxField) {
          var ctx = new curam.util.ScreenContext();
          ctx.setContextBits('ACTION');
          domConstruct.create("input", {"type": "hidden", "name": "o3ctx",
                                 "value": ctx.getValue()
                               }, elem);
        }
        domConstruct.create("input", {"type": "hidden", "name": "o3prv",
              "value": jsPageID}, elem);
      }

      if (elements.length > 0) {
        curam.util.getTopmostWindow().dojo.publish("curam.fireNextRequest", []);
      }
    },

    initContent: function(window, pageId) {
      var contentDiv = dom.byId('content');
      domClass.remove(contentDiv, "hidden-panel");
      return;
    },

    /**
     * This setups a listener on the SECTION_TAB_CONTAINER_ID tab container to
     * handle when a section tab is selected. This method is invoked from
     * JavaScript output from the ApplicationsSectionsRenderer Java class.
     */
    setupSectionSelectionListener: function() {
      dojo.subscribe(curam.tab.SECTION_TAB_CONTAINER_ID + "-selectChild",
          curam.tab.onSectionSelected) ;
    },

    /**
     * Checks if a section has a default page specified and if the section is
     * currently "empty" (i.e. nothing displayed in it). If so, it loads the
     * default default in the section.
     *
     * This function responds to the standard "selectChild" event provided by the
     * Dijit TabContainer and is setup by the setupSectionSelectionListener method
     * above.
     */
    onSectionSelected: function(section) {
      // The curamDefaultPageID attribute is added by the setSectionDefaultPage
      // method below. The Dijit TabContainer selectChild event passes the
       // selected child to the listener.
      if (section.curamDefaultPageID) {
        // The section has a default page. Check if anything has been opened up
        // in this section already. If not, then we trigger a request for that
        // page.

        // The tab container containing the "object" tabs will either be a direct
        // child of the sections tab container, or it will be nested within
        // a border container.
        var objectTabContainer;
        if (section.id.substring(
              section.id.length - 4, section.id.length) == "-sbc") {
          // This means it's a border container so extract the section ID and
          // find the nested tab container.
          var sectionID = section.id.substring(0, section.id.length - 4);
          objectTabContainer = curam.tab.getTabContainer(sectionID);
        } else {
          // This means the object tab container is a direct child of the section
          // tab container, so it's passed in by the "selectChild" event of the
          // section tab container.
          objectTabContainer = section;
        }

        // If the tab container does not have any children, then load the
        // default page.
        if (objectTabContainer 
          && objectTabContainer.getChildren().length == 0) {
              

       	      curam.tab.getTabController().handleUIMPageID(
        	    section.curamDefaultPageID, true);
          	
        
         // TODO: now that the page has been loaded, can we set a flag on the
         // section so the code *before* the getChildren().length == 0 above
         // is not executed again. Just a minor optimization.
        }
        return true;
      }
      return false;
    },

    /**
     * Sets the section's default pageID as a custom attribute on the Dijit
     * container. The container can be either a border container or a tab
     * container which has a specific naming convention which is the section ID
     * plus a suffix of "-sbc" for a border container and "-stc" for a tab
     * container. The ApplicationSectionsRenderer generates the call to this
     * function and will set the containers ID appropriately.
     */
    setSectionDefaultPage: function(sectionDijitContainerID, defaultPageID) {
      var dijitContainer = registry.byId(sectionDijitContainerID);
      if (dijitContainer) {
        // The "curamDefaultPageID" custom attribute is used by the
        // onSectionSelected method above.
        dijitContainer.curamDefaultPageID = defaultPageID;
      } else {
        throw "curam.tab.setSectionDefaultPage() - cannot find section dijit ID:"
              + sectionDijitContainerID;
      }
    },
    
    /**
     * Notifies the Smart Panel that its content page is loaded and ready to
     * receive updates from the tab's content page. This is done by publishing
     * an event, or, if the listeners are not set up yet, an attribute set on
     * the Smart Panel frame is used.
     */
    publishSmartPanelContentReady: function() {
            var rendererLoadedEvent = "smartpanel.content.loaded";
            //use the window object as cannot assume the currently selected tab is
            //the tab containing the Smart Panel of interest.
            var smartPanel = window.frameElement; 
            smartPanel.setAttribute("_SPContentLoaded", "true");
            curam.util.getTopmostWindow().dojo.publish(rendererLoadedEvent, [smartPanel]);
    }
    
  });
  layer.register("curam/tab", curam.tab);
 
  return curam.tab;
});

},
'dojo/text':function(){
define(["./_base/kernel", "require", "./has", "./request"], function(dojo, require, has, request){
	// module:
	//		dojo/text

	var getText;
	if( 1 ){
		getText= function(url, sync, load){
			request(url, {sync:!!sync, headers: { 'X-Requested-With': null } }).then(load);
		};
	}else{
		// Path for node.js and rhino, to load from local file system.
		// TODO: use node.js native methods rather than depending on a require.getText() method to exist.
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache = {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {};

	dojo.cache = function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		// summary:
		//		A getter and setter for storing the string content associated with the
		//		module and url arguments.
		// description:
		//		If module is a string that contains slashes, then it is interpretted as a fully
		//		resolved path (typically a result returned by require.toUrl), and url should not be
		//		provided. This is the preferred signature. If module is a string that does not
		//		contain slashes, then url must also be provided and module and url are used to
		//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
		//		If value is specified, the cache value for the moduleUrl will be set to
		//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
		//		in its internal cache and return that cached value for the URL. To clear
		//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
		//		the URL contents, only modules on the same domain of the page can use this capability.
		//		The build system can inline the cache values though, to allow for xdomain hosting.
		// module: String||Object
		//		If a String with slashes, a fully resolved path; if a String without slashes, the
		//		module name to use for the base part of the URL, similar to module argument
		//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
		//		generates a valid path for the cache item. For example, a dojo._Url object.
		// url: String
		//		The rest of the path to append to the path derived from the module argument. If
		//		module is an object, then this second argument should be the "value" argument instead.
		// value: String||Object?
		//		If a String, the value to use in the cache for the module/url combination.
		//		If an Object, it can have two properties: value and sanitize. The value property
		//		should be the value to use in the cache, and sanitize can be set to true or false,
		//		to indicate if XML declarations should be removed from the value and if the HTML
		//		inside a body tag in the value should be extracted as the real value. The value argument
		//		or the value property on the value argument are usually only used by the build system
		//		as it inlines cache content.
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
		//		of call is used to avoid an issue with the build system erroneously trying to intern
		//		this example. To get the build system to intern your dojo.cache calls, use the
		//		"dojo.cache" style of call):
		//		| //If template.html contains "<h1>Hello</h1>" that will be
		//		| //the value for the text variable.
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html");
		// example:
		//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
		//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
		//		erroneously trying to intern this example. To get the build system to intern your
		//		dojo.cache calls, use the "dojo.cache" style of call):
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
		// example:
		//		Same example as previous, but demonstrates how an object can be passed in as
		//		the first argument, then the value argument can then be the second argument.
		//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
		//		| //text variable will contain just "<h1>Hello</h1>".
		//		| //Note: This is pre-AMD, deprecated syntax
		//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});

		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return {
		// summary:
		//		This module implements the dojo/text! plugin and the dojo.cache API.
		// description:
		//		We choose to include our own plugin to leverage functionality already contained in dojo
		//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
		//		Also, this allows foreign AMD loaders to be used without their plugins.
		//
		//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
		//		loader. This feature is outside the scope of the CommonJS plugins specification.

		// the dojo/text caches it's own resources because of dojo.cache
		dynamic: true,

		normalize: function(id, toAbsMid){
			// id is something like (path may be relative):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var parts= id.split("!"),
				url= parts[0];
			return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
		},

		load: function(id, require, load){
			// id: String
			//		Path to the resource.
			// require: Function
			//		Object that include the function toUrl with given id returns a valid URL from which to load the text.
			// load: Function
			//		Callback function which will be called, when the loading finished.

			// id is something like (path is always absolute):
			//
			//	 "path/to/text.html"
			//	 "path/to/text.html!strip"
			var
				parts= id.split("!"),
				stripFlag= parts.length>1,
				absMid= parts[0],
				url = require.toUrl(parts[0]),
				requireCacheUrl = "url:" + url,
				text = notFound,
				finish = function(text){
					load(stripFlag ? strip(text) : text);
				};
			if(absMid in theCache){
				text = theCache[absMid];
			}else if(require.cache && requireCacheUrl in require.cache){
				text = require.cache[requireCacheUrl];
			}else if(url in theCache){
				text = theCache[url];
			}
			if(text===notFound){
				if(pending[url]){
					pending[url].push(finish);
				}else{
					var pendingList = pending[url] = [finish];
					getText(url, !require.async, function(text){
						theCache[absMid]= theCache[url]= text;
						for(var i = 0; i<pendingList.length;){
							pendingList[i++](text);
						}
						delete pending[url];
					});
				}
			}else{
				finish(text);
			}
		}
	};

});


},
'curam/i18n':function(){
define(["curam/define"
        ], function() {
  
  curam.define.singleton("curam.i18n", {
    values: {},

    set: function(key, value){
      curam.i18n.values[key]=value; 
    },
    
    get: function(key){
      return curam.i18n.values[key];
    }

   });
  
  return curam.i18n;
});

},
'dojo/i18n':function(){
define(["./_base/kernel", "require", "./has", "./_base/array", "./_base/config", "./_base/lang", "./_base/xhr", "./json", "module"],
	function(dojo, require, has, array, config, lang, xhr, json, module){

	// module:
	//		dojo/i18n

	has.add("dojo-preload-i18n-Api",
		// if true, define the preload localizations machinery
		1
	);

	 1 || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	var
		thisModule = dojo.i18n =
			{
				// summary:
				//		This module implements the dojo/i18n! plugin and the v1.6- i18n API
				// description:
				//		We choose to include our own plugin to leverage functionality already contained in dojo
				//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
				//		allows foreign AMD loaders to be used without their plugins.
			},

		nlsRe =
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales = function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// summary:
			//		return a vector of module ids containing all available locales with respect to the target locale
			//		For example, assuming:
			//
			//		- the root bundle indicates specific bundles for "fr" and "fr-ca",
			//		-  bundlePath is "myPackage/nls"
			//		- bundleName is "myBundle"
			//
			//		Then a locale argument of "fr-ca" would return
			//
			//			["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			//
			//		Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			//		If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			//		therefore, assume everything is available and get 404 errors that indicate a particular localization is not available

			for(var result = [bundlePath + bundleName], localeParts = locale.split("-"), current = "", i = 0; i<localeParts.length; i++){
				current += (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
					result.specificity = current;
				}
			}
			return result;
		},

		cache = {},

		getBundleName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		getL10nName = dojo.getL10nName = function(moduleName, bundleName, locale){
			return moduleName = module.id + "!" + getBundleName(moduleName, bundleName, locale);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// summary:
			//		get the root bundle which instructs which other bundles are required to construct the localized bundle
			require([bundlePathAndName], function(root){
				var current = lang.clone(root.root || root.ROOT),// 1.6 built bundle defined ROOT
					availableLocales = getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i = 1; i<availableLocales.length; i++){
						current = lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target = bundlePathAndName + "/" + locale;
					cache[target] = current;
					current.$locale = availableLocales.specificity;
					load();
				});
			});
		},

		normalize = function(id, toAbsMid){
			// summary:
			//		id may be relative.
			//		preload has form `*preload*<path>/nls/<module>*<flattened locales>` and
			//		therefore never looks like a relative
			return /^\./.test(id) ? toAbsMid(id) : id;
		},

		getLocalesToLoad = function(targetLocale){
			var list = config.extraLocale || [];
			list = lang.isArray(list) ? list : [list];
			list.push(targetLocale);
			return list;
		},

		load = function(id, require, load){
			// summary:
			//		id is in one of the following formats
			//
			//		1. <path>/nls/<bundle>
			//			=> load the bundle, localized to config.locale; load all bundles localized to
			//			config.extraLocale (if any); return the loaded bundle localized to config.locale.
			//
			//		2. <path>/nls/<locale>/<bundle>
			//			=> load then return the bundle localized to <locale>
			//
			//		3. *preload*<path>/nls/<module>*<JSON array of available locales>
			//			=> for config.locale and all config.extraLocale, load all bundles found
			//			in the best-matching bundle rollup. A value of 1 is returned, which
			//			is meaningless other than to say the plugin is executing the requested
			//			preloads
			//
			//		In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see
			//		normalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.
			//
			//		To load a bundle means to insert the bundle into the plugin's cache and publish the bundle
			//		value to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key
			//
			//			<path>/nls/<bundle>/<locale>
			//
			//		will hold the value. Similarly, then plugin will publish this value to the loader by
			//
			//			define("<path>/nls/<bundle>/<locale>", <bundle-value>);
			//
			//		Given this algorithm, other machinery can provide fast load paths be preplacing
			//		values in the plugin's cache, which is public. When a load is demanded the
			//		cache is inspected before starting any loading. Explicitly placing values in the plugin
			//		cache is an advanced/experimental feature that should not be needed; use at your own risk.
			//
			//		For the normal AMD algorithm, the root bundle is loaded first, which instructs the
			//		plugin what additional localized bundles are required for a particular locale. These
			//		additional locales are loaded and a mix of the root and each progressively-specific
			//		locale is returned. For example:
			//
			//		1. The client demands "dojo/i18n!some/path/nls/someBundle
			//
			//		2. The loader demands load(some/path/nls/someBundle)
			//
			//		3. This plugin require's "some/path/nls/someBundle", which is the root bundle.
			//
			//		4. Assuming config.locale is "ab-cd-ef" and the root bundle indicates that localizations
			//		are available for "ab" and "ab-cd-ef" (note the missing "ab-cd", then the plugin
			//		requires "some/path/nls/ab/someBundle" and "some/path/nls/ab-cd-ef/someBundle"
			//
			//		5. Upon receiving all required bundles, the plugin constructs the value of the bundle
			//		ab-cd-ef as...
			//
			//				mixin(mixin(mixin({}, require("some/path/nls/someBundle"),
			//		  			require("some/path/nls/ab/someBundle")),
			//					require("some/path/nls/ab-cd-ef/someBundle"));
			//
			//		This value is inserted into the cache and published to the loader at the
			//		key/module-id some/path/nls/someBundle/ab-cd-ef.
			//
			//		The special preload signature (case 3) instructs the plugin to stop servicing all normal requests
			//		(further preload requests will be serviced) until all ongoing preloading has completed.
			//
			//		The preload signature instructs the plugin that a special rollup module is available that contains
			//		one or more flattened, localized bundles. The JSON array of available locales indicates which locales
			//		are available. Here is an example:
			//
			//			*preload*some/path/nls/someModule*["root", "ab", "ab-cd-ef"]
			//
			//		This indicates the following rollup modules are available:
			//
			//			some/path/nls/someModule_ROOT
			//			some/path/nls/someModule_ab
			//			some/path/nls/someModule_ab-cd-ef
			//
			//		Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.
			//		For example, assume someModule contained the bundles some/bundle/path/someBundle and
			//		some/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:
			//
			//			define({
			//				some/bundle/path/someBundle:<value of someBundle, flattened with respect to locale ab>,
			//				some/bundle/path/someOtherBundle:<value of someOtherBundle, flattened with respect to locale ab>,
			//			});
			//
			//		E.g., given this design, preloading for locale=="ab" can execute the following algorithm:
			//
			//			require(["some/path/nls/someModule_ab"], function(rollup){
			//				for(var p in rollup){
			//					var id = p + "/ab",
			//					cache[id] = rollup[p];
			//					define(id, rollup[p]);
			//				}
			//			});
			//
			//		Similarly, if "ab-cd" is requested, the algorithm can determine that "ab" is the best available and
			//		load accordingly.
			//
			//		The builder will write such rollups for every layer if a non-empty localeList  profile property is
			//		provided. Further, the builder will include the following cache entry in the cache associated with
			//		any layer.
			//
			//			"*now":function(r){r(['dojo/i18n!*preload*<path>/nls/<module>*<JSON array of available locales>']);}
			//
			//		The *now special cache module instructs the loader to apply the provided function to context-require
			//		with respect to the particular layer being defined. This causes the plugin to hold all normal service
			//		requests until all preloading is complete.
			//
			//		Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case
			//		where the target locale has a single segment and a layer depends on a single bundle:
			//
			//		Without Preloads:
			//
			//		1. Layer loads root bundle.
			//		2. bundle is demanded; plugin loads single localized bundle.
			//
			//		With Preloads:
			//
			//		1. Layer causes preloading of target bundle.
			//		2. bundle is demanded; service is delayed until preloading complete; bundle is returned.
			//
			//		In each case a single transaction is required to load the target bundle. In cases where multiple bundles
			//		are required and/or the locale has multiple segments, preloads still requires a single transaction whereas
			//		the normal path requires an additional transaction for each additional bundle/locale-segment. However all
			//		of these additional transactions can be done concurrently. Owing to this analysis, the entire preloading
			//		algorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.

			if(has("dojo-preload-i18n-Api")){
				var split = id.split("*"),
					preloadDemand = split[1] == "preload";
				if(preloadDemand){
					if(!cache[id]){
						// use cache[id] to prevent multiple preloads of the same preload; this shouldn't happen, but
						// who knows what over-aggressive human optimizers may attempt
						cache[id] = 1;
						preloadL10n(split[2], json.parse(split[3]), 1, require);
					}
					// don't stall the loader!
					load(1);
				}
				if(preloadDemand || waitForPreloads(id, require, load)){
					return;
				}
			}

			var match = nlsRe.exec(id),
				bundlePath = match[1] + "/",
				bundleName = match[5] || match[4],
				bundlePathAndName = bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale =	localeSpecified || dojo.locale || "",
				loadTarget = bundlePathAndName + "/" + targetLocale,
				loadList = localeSpecified ? [targetLocale] : getLocalesToLoad(targetLocale),
				remaining = loadList.length,
				finish = function(){
					if(!--remaining){
						load(lang.delegate(cache[loadTarget]));
					}
				};
			array.forEach(loadList, function(locale){
				var target = bundlePathAndName + "/" + locale;
				if(has("dojo-preload-i18n-Api")){
					checkForLegacyModules(target);
				}
				if(!cache[target]){
					doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, finish);
				}else{
					finish();
				}
			});
		};

	if(has("dojo-unit-tests")){
		var unitTests = thisModule.unitTests = [];
	}

	if(has("dojo-preload-i18n-Api") ||  1 ){
		var normalizeLocale = thisModule.normalizeLocale = function(locale){
				var result = locale ? locale.toLowerCase() : dojo.locale;
				return result == "root" ? "ROOT" : result;
			},

			isXd = function(mid, contextRequire){
				return ( 1  &&  1 ) ?
					contextRequire.isXdUrl(require.toUrl(mid + ".js")) :
					true;
			},

			preloading = 0,

			preloadWaitQueue = [],

			preloadL10n = thisModule._preloadLocalizations = function(/*String*/bundlePrefix, /*Array*/localesGenerated, /*boolean?*/ guaranteedAmdFormat, /*function?*/ contextRequire){
				// summary:
				//		Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)
				// description:
				//		Only called by built layer files. The entire locale hierarchy is loaded. For example,
				//		if locale=="ab-cd", then ROOT, "ab", and "ab-cd" are loaded. This is different than v1.6-
				//		in that the v1.6- would only load ab-cd...which was *always* flattened.
				//
				//		If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm
				//		and the extra possible extra transaction.

				// If this function is called from legacy code, then guaranteedAmdFormat and contextRequire will be undefined. Since the function
				// needs a require in order to resolve module ids, fall back to the context-require associated with this dojo/i18n module, which
				// itself may have been mapped.
				contextRequire = contextRequire || require;

				function doRequire(mid, callback){
					if(isXd(mid, contextRequire) || guaranteedAmdFormat){
						contextRequire([mid], callback);
					}else{
						syncRequire([mid], callback, contextRequire);
					}
				}

				function forEachLocale(locale, func){
					// given locale= "ab-cd-ef", calls func on "ab-cd-ef", "ab-cd", "ab", "ROOT"; stops calling the first time func returns truthy
					var parts = locale.split("-");
					while(parts.length){
						if(func(parts.join("-"))){
							return;
						}
						parts.pop();
					}
					func("ROOT");
				}

					function preloadingAddLock(){
						preloading++;
					}

					function preloadingRelLock(){
						--preloading;
						while(!preloading && preloadWaitQueue.length){
							load.apply(null, preloadWaitQueue.shift());
						}
					}

					function cacheId(path, name, loc, require){
						// path is assumed to have a trailing "/"
						return require.toAbsMid(path + name + "/" + loc)
					}

					function preload(locale){
						locale = normalizeLocale(locale);
						forEachLocale(locale, function(loc){
							if(array.indexOf(localesGenerated, loc) >= 0){
								var mid = bundlePrefix.replace(/\./g, "/") + "_" + loc;
								preloadingAddLock();
								doRequire(mid, function(rollup){
									for(var p in rollup){
										var bundle = rollup[p],
											match = p.match(/(.+)\/([^\/]+)$/),
											bundleName, bundlePath;
											
											// If there is no match, the bundle is not a regular bundle from an AMD layer.
											if (!match){continue;}

											bundleName = match[2];
											bundlePath = match[1] + "/";

										// backcompat
										if(!bundle._localized){continue;}

										var localized;
										if(loc === "ROOT"){
											var root = localized = bundle._localized;
											delete bundle._localized;
											root.root = bundle;
											cache[require.toAbsMid(p)] = root;
										}else{
											localized = bundle._localized;
											cache[cacheId(bundlePath, bundleName, loc, require)] = bundle;
										}

										if(loc !== locale){
											// capture some locale variables
											function improveBundle(bundlePath, bundleName, bundle, localized){
												// locale was not flattened and we've fallen back to a less-specific locale that was flattened
												// for example, we had a flattened 'fr', a 'fr-ca' is available for at least this bundle, and
												// locale==='fr-ca'; therefore, we must improve the bundle as retrieved from the rollup by
												// manually loading the fr-ca version of the bundle and mixing this into the already-retrieved 'fr'
												// version of the bundle.
												//
												// Remember, different bundles may have different sets of locales available.
												//
												// we are really falling back on the regular algorithm here, but--hopefully--starting with most
												// of the required bundles already on board as given by the rollup and we need to "manually" load
												// only one locale from a few bundles...or even better...we won't find anything better to load.
												// This algorithm ensures there is nothing better to load even when we can only load a less-specific rollup.
												//
												// note: this feature is only available in async mode

												// inspect the loaded bundle that came from the rollup to see if something better is available
												// for any bundle in a rollup, more-specific available locales are given at localized.
												var requiredBundles = [],
													cacheIds = [];
												forEachLocale(locale, function(loc){
													if(localized[loc]){
														requiredBundles.push(require.toAbsMid(bundlePath + loc + "/" + bundleName));
														cacheIds.push(cacheId(bundlePath, bundleName, loc, require));
													}
												});

												if(requiredBundles.length){
													preloadingAddLock();
													contextRequire(requiredBundles, function(){
														// requiredBundles was constructed by forEachLocale so it contains locales from 
														// less specific to most specific. 
														// the loop starts with the most specific locale, the last one.
														for(var i = requiredBundles.length - 1; i >= 0 ; i--){
															bundle = lang.mixin(lang.clone(bundle), arguments[i]);
															cache[cacheIds[i]] = bundle;
														}
														// this is the best possible (maybe a perfect match, maybe not), accept it
														cache[cacheId(bundlePath, bundleName, locale, require)] = lang.clone(bundle);
														preloadingRelLock();
													});
												}else{
													// this is the best possible (definitely not a perfect match), accept it
													cache[cacheId(bundlePath, bundleName, locale, require)] = bundle;
												}
											}
											improveBundle(bundlePath, bundleName, bundle, localized);
										}
									}
									preloadingRelLock();
								});
								return true;
							}
							return false;
						});
					}

				preload();
				array.forEach(dojo.config.extraLocale, preload);
			},

			waitForPreloads = function(id, require, load){
				if(preloading){
					preloadWaitQueue.push([id, require, load]);
				}
				return preloading;
			},

			checkForLegacyModules = function()
				{};
	}

	if( 1 ){
		// this code path assumes the dojo loader and won't work with a standard AMD loader
		var amdValue = {},
			evalBundle =
				// use the function ctor to keep the minifiers away (also come close to global scope, but this is secondary)
				new Function(
					"__bundle",				   // the bundle to evalutate
					"__checkForLegacyModules", // a function that checks if __bundle defined __mid in the global space
					"__mid",				   // the mid that __bundle is intended to define
					"__amdValue",

					// returns one of:
					//		1 => the bundle was an AMD bundle
					//		a legacy bundle object that is the value of __mid
					//		instance of Error => could not figure out how to evaluate bundle

					  // used to detect when __bundle calls define
					  "var define = function(mid, factory){define.called = 1; __amdValue.result = factory || mid;},"
					+ "	   require = function(){define.called = 1;};"

					+ "try{"
					+		"define.called = 0;"
					+		"eval(__bundle);"
					+		"if(define.called==1)"
								// bundle called define; therefore signal it's an AMD bundle
					+			"return __amdValue;"

					+		"if((__checkForLegacyModules = __checkForLegacyModules(__mid)))"
								// bundle was probably a v1.6- built NLS flattened NLS bundle that defined __mid in the global space
					+			"return __checkForLegacyModules;"

					+ "}catch(e){}"
					// evaulating the bundle was *neither* an AMD *nor* a legacy flattened bundle
					// either way, re-eval *after* surrounding with parentheses

					+ "try{"
					+		"return eval('('+__bundle+')');"
					+ "}catch(e){"
					+		"return e;"
					+ "}"
				),

			syncRequire = function(deps, callback, require){
				var results = [];
				array.forEach(deps, function(mid){
					var url = require.toUrl(mid + ".js");

					function load(text){
						var result = evalBundle(text, checkForLegacyModules, mid, amdValue);
						if(result===amdValue){
							// the bundle was an AMD module; re-inject it through the normal AMD path
							// we gotta do this since it could be an anonymous module and simply evaluating
							// the text here won't provide the loader with the context to know what
							// module is being defined()'d. With browser caching, this should be free; further
							// this entire code path can be circumvented by using the AMD format to begin with
							results.push(cache[url] = amdValue.result);
						}else{
							if(result instanceof Error){
								console.error("failed to evaluate i18n bundle; url=" + url, result);
								result = {};
							}
							// nls/<locale>/<bundle-name> indicates not the root.
							results.push(cache[url] = (/nls\/[^\/]+\/[^\/]+$/.test(url) ? result : {root:result, _v1x:1}));
						}
					}

					if(cache[url]){
						results.push(cache[url]);
					}else{
						var bundle = require.syncLoadNls(mid);
						// need to check for legacy module here because there might be a legacy module for a
						// less specific locale (which was not looked up during the first checkForLegacyModules
						// call in load()).
						// Also need to reverse the locale and the module name in the mid because syncRequire
						// deps parameters uses the AMD style package/nls/locale/module while legacy code uses
						// package/nls/module/locale.
						if(!bundle){
							bundle = checkForLegacyModules(mid.replace(/nls\/([^\/]*)\/([^\/]*)$/, "nls/$2/$1"));
						}
						if(bundle){
							results.push(bundle);
						}else{
							if(!xhr){
								try{
									require.getText(url, true, load);
								}catch(e){
									results.push(cache[url] = {});
								}
							}else{
								xhr.get({
									url:url,
									sync:true,
									load:load,
									error:function(){
										results.push(cache[url] = {});
									}
								});
							}
						}
					}
				});
				callback && callback.apply(null, results);
			};

		checkForLegacyModules = function(target){
			// legacy code may have already loaded [e.g] the raw bundle x/y/z at x.y.z; when true, push into the cache
			for(var result, names = target.split("/"), object = dojo.global[names[0]], i = 1; object && i<names.length-1; object = object[names[i++]]){}
			if(object){
				result = object[names[i]];
				if(!result){
					// fallback for incorrect bundle build of 1.6
					result = object[names[i].replace(/-/g,"_")];
				}
				if(result){
					cache[target] = result;
				}
			}
			return result;
		};

		thisModule.getLocalization = function(moduleName, bundleName, locale){
			var result,
				l10nName = getBundleName(moduleName, bundleName, locale);
			load(
				l10nName,

				// isXd() and syncRequire() need a context-require in order to resolve the mid with respect to a reference module.
				// Since this legacy function does not have the concept of a reference module, resolve with respect to this
				// dojo/i18n module, which, itself may have been mapped.
				(!isXd(l10nName, require) ? function(deps, callback){ syncRequire(deps, callback, require); } : require),

				function(result_){ result = result_; }
			);
			return result;
		};

		if(has("dojo-unit-tests")){
			unitTests.push(function(doh){
				doh.register("tests.i18n.unit", function(t){
					var check;

					check = evalBundle("{prop:1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("({prop:1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({prop:1}, check); t.is(undefined, check[1]);

					check = evalBundle("{'prop-x':1}", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is({'prop-x':1}, check); t.is(undefined, check[1]);

					check = evalBundle("define({'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("define('some/module', {'prop-x':1})", checkForLegacyModules, "nonsense", amdValue);
					t.is(amdValue, check); t.is({'prop-x':1}, amdValue.result);

					check = evalBundle("this is total nonsense and should throw an error", checkForLegacyModules, "nonsense", amdValue);
					t.is(check instanceof Error, true);
				});
			});
		}
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:cache,
		getL10nName: getL10nName
	});
});

},
'curam/widget/ProgressSpinner':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2022. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.widget.ProgressSpinner
 * @namespace API for using the Progress widget within Curam.
 * 
 * Public API for using the Curam Progress widget to interact with the web tier
 * to show | hide the spinner for loading screens.
 */
define([
        "dojox/widget/Standby", 
        "dojo/dom-construct",
        "curam/debug",
        "curam/util",
        "curam/tab"], function(Standby, domConstruct, debug) {

 /*
 * Modification History
 * --------------------
 * 14-Jun-2022  BOS [RTC278134] Adding configuration for maximum timeout for spinner.
 * 22-Sep-2021  SK  [RTC273131] Added auxiliary methods to account for rouge invocations in IEG.
 * 10-Sep-2021  TD  [RTC273411] Reverse underscore name change to methods
 * 02-Sep-2021  SK  [RTC273131] Corrected the problem with the missing UI Controller and adjusted API to satisfy the
 *                             Node based JavaScript unit tests.
 * 11-Aug-2021  SK  [RTC272800] Tidying up memory manegement, timeout to avoid the non-dismissing spinner; displaying just 
 * one spinner at the moment.
 */
  var _PS = dojo.setObject('curam.widget.ProgressSpinner', {
    
    PROGRESS_WIDGET_ENABLED: true,

    /**
     * Default Threshold value to wait before the overlay and text / image is
     * displayed.
     */
    PROGRESS_WIDGET_DEFAULT_THRESHOLD: 2000,

    /**
     * Default color that will be used in the background.
     */
    PROGRESS_WIDGET_COLOR: "white",

    /**
     * Default text that will be used in the title/tooltip attributes of the overlay.
     */
    PROGRESS_WIDGET_TITLE: "Please wait...",
        
    /**
     * Maximum period of time (in seconds) for progress when waiting for a http response
     */
    PROGRESS_WIDGET_TIMEOUT_MAX: 90000,

    /**
     * An interval in milliseconds after which a spinner will auto-destroy to avoid
     * indefinitely running cases.
     */
    LOAD_MASK_TIMEOUT: 15000, // duplicate of the UIController prop when it is not available.
    
    /**
     * Tokens of requested spinners.
     */
    _spinnerTokens: [],
    
    /** Show delay tokens. */
    _launcherTokens: [],
    
    /** Autoremove tokens. */
    _forcedTimeouts: [],
    
    /**
     * Internal indicator if the Progress Spinner functionality has been enabled in the application.
     */
    _enabled: false,
    
    /**
     * Event listener reference to avoid repeated initialization.
     */
    _eHandler:false,
    
    /**
     * Once-off initialized reference to the Dojo library on the top level window. 
     */
    _tDojo:null,
    
    /**
     * Initialize progress topics.
     */
    init: function() {
      debug.log("PROGRESS SPINNER: isEnabled: " + _PS.PROGRESS_WIDGET_ENABLED);
      debug.log("PROGRESS SPINNER: threshold: " + _PS.PROGRESS_WIDGET_DEFAULT_THRESHOLD);
      debug.log("PROGRESS SPINNER: max timeout: " + _PS.PROGRESS_WIDGET_TIMEOUT_MAX);    
      _PS._enabled = _PS._isEnabled(); // hold to avoid reparsing
      _PS.tDojo.subscribe('/curam/progress/unload', function() {
    	_PS._enabled && _PS.dismissSpinner();
      });
      _PS.tDojo.subscribe('/curam/progress/display', function(canvas, delay) {
    	// only one spinner should be running at the moment!
    	if (_PS._enabled) {
    	  var isNext = _PS.dismissSpinner();
    	  canvas && _PS.launch(canvas, (isNext ? 0 :delay));
    	}
      });
    },

    /**
     * Private method returning true if the spinner is enabled, false otherwise.
     */
    _isEnabled: function() {
      return (_PS.PROGRESS_WIDGET_ENABLED && 
             (_PS.PROGRESS_WIDGET_ENABLED === true || 
        	    _PS.PROGRESS_WIDGET_ENABLED.toString().toLowerCase() === "true"));
    },
    
    /**
     * Creates and launches the progress spinned for the specified canvas and after the
     * optionally specified delay.
     * @param canvas DOM object for which this spinner is being requested.
     * @param delay optional grace interval to avoid showing spinner
     *                unnecessarily for fast connections.
     */
    launch: function(canvas, delay) {
      var newSpinner = _PS._getSpinner(canvas);
      newSpinner && _PS.show(newSpinner, delay);
    },
    /**
     * _getSpinner for external invocations still relying on the
     * immediate invocation of the old API.
     * @param target
     *                the domNode target.
     */
    getSpinner: function(target) {
      return _PS._getSpinner(target);
    },
    /**
     * Instantiates the Standby dojox component and populate the attributes that
     * we need. It will also call the startup() method of the pageSpinner
     * reference that is needed by the Standby component. 
     * 
     * @param target
     *                the domNode target.
     */
    _getSpinner: function(target) {
      if (target != null && _PS._enabled) {
        debug.log(debug.getProperty("curam.widget.ProgressSpinner.load", [target]));
        var adjustedTarget = dojo.isString(target) ? _PS.adjustTarget(target) : target;
        var pageSpinner = new Standby({
          target : adjustedTarget,
          centerIndicator : 'text',
          zIndex:999999999,
          color : _PS.PROGRESS_WIDGET_COLOR,
          text : "<div class='curam-spinner curam-h1'></div>",
          title : _PS.PROGRESS_WIDGET_TITLE,
          duration: 250,
          onHide: function() {
              curam.util.getTopmostWindow().document.querySelectorAll('.standby').forEach(domConstruct.destroy);
          }
        });
        pageSpinner.domNode.classList.add('standby');
        curam.util.getTopmostWindow().document.body.appendChild(pageSpinner.domNode);
        _PS._spinnerTokens.push(pageSpinner);
        pageSpinner.startup();
        return pageSpinner;
      }
      return null;
    },
    /**
     * Helper method to workaround the IEG invocations where the string id is passed in 
     * instead of dom node. This does not work and no spinner gets displayed at the best,
     * with errors thrown in the worst case.
     * The method chooses the right canvas instead of the string passed or falls back
     * to the original string if no proper display object could be found.
     *
     * @param idString the string id passed in instead of the DOM node. 
     */
    adjustTarget:function(idString) {
      var canvas = idString;
      var wid = curam.tab.getSelectedTabWidgetId();
      if (wid) {
        var realCanvas = curam.util.getTopmostWindow().dijit.byId(wid);
        realCanvas && (canvas = realCanvas.containerNode);
      }
      return canvas;
    },

    /**
     * Displays the spinner (Standby component) to the user after the Threshold
     * amount.
     * 
     * @param pageSpinner
     *                The reference to the spinner that will be used.
     * @param threshold
     *                The amount of time to wait before the spinner is
     *                displayed.
     */
   show: function(pageSpinner, threshold) {
      !!threshold && (threshold = _PS.PROGRESS_WIDGET_DEFAULT_THRESHOLD);
      var tOut = setTimeout(function() {
        pageSpinner.show();
        var forced = setTimeout(function() {
         _PS.tDojo.publish('/curam/progress/unload');
        }, _PS.PROGRESS_WIDGET_TIMEOUT_MAX);
        _PS._forcedTimeouts.push(forced);
      }, threshold);
      _PS._launcherTokens.push(tOut);
      return tOut;
    },

    /**
     * Hides the spinner (Standby component) from the user.
     * s
     * @param pageSpinner
     *                The reference to the spinner that will be used.
     */
    hide: function(pageSpinner) {
      pageSpinner.hide();
    },
    /**
     * Old method for spinner dismiss. Left for the external invocations still
     * relying on direct API invocations.
     */
    dismissSpinner: function() {
	  return _PS._dismissSpinner();
    },
    /**
     * Removes ALL the spinners from the DOM hierarchy.
     */
    _dismissSpinner: function() {
      // Cancel spinner timeouts.
      var res = _PS._spinnerTokens.length; 
      _PS._forcedTimeouts.forEach(function(forced) {  clearTimeout(forced); });
      _PS._forcedTimeouts.splice(0, _PS._forcedTimeouts.length);
      // Cancel spinner requests.
      _PS._launcherTokens.forEach(function(token) {  clearTimeout(token); });
      _PS._launcherTokens.splice(0,_PS._launcherTokens.length);
  
      // If a spinner token exists, attempt to stop it first, before removing from DOM.
      _PS._spinnerTokens.forEach(function(token) { token.hide();  });
      _PS._spinnerTokens.splice(0, _PS._spinnerTokens.length);
      curam.debug.log("PROGRESS SPINNER: " + 
          debug.getProperty("curam.widget.ProgressSpinner.unload"));
      return (res > 0);
    }
    
  });
  
  _PS.tDojo = curam.util.getTopmostWindow().dojo;
  if (!_PS.eHandler) {
    _PS.tDojo.subscribe('/curam/progress/unload', function() {
	  _PS._enabled && _PS.dismissSpinner();
    });
    _PS.eHandler = 
      _PS.tDojo.subscribe('/curam/progress/display', function(canvas, delay) {
        // only one spinner should be running at the moment!
      if (_PS._enabled) {
        var isNext = _PS.dismissSpinner();
	    canvas && _PS.launch(canvas, (isNext ? 0 :delay));
      }
    });
  }
  

  return curam.widget.ProgressSpinner;

});

},
'dojo/store/Cache':function(){
define(["../_base/lang","../when" /*=====, "../_base/declare", "./api/Store" =====*/],
function(lang, when /*=====, declare, Store =====*/){

// module:
//		dojo/store/Cache

var Cache = function(masterStore, cachingStore, options){
	options = options || {};
	return lang.delegate(masterStore, {
		query: function(query, directives){
			var results = masterStore.query(query, directives);
			results.forEach(function(object){
				if(!options.isLoaded || options.isLoaded(object)){
					cachingStore.put(object);
				}
			});
			return results;
		},
		// look for a queryEngine in either store
		queryEngine: masterStore.queryEngine || cachingStore.queryEngine,
		get: function(id, directives){
			return when(cachingStore.get(id), function(result){
				return result || when(masterStore.get(id, directives), function(result){
					if(result){
						cachingStore.put(result, {id: id});
					}
					return result;
				});
			});
		},
		add: function(object, directives){
			return when(masterStore.add(object, directives), function(result){
				// now put result in cache
				cachingStore.add(result && typeof result == "object" ? result : object, directives);
				return result; // the result from the add should be dictated by the masterStore and be unaffected by the cachingStore
			});
		},
		put: function(object, directives){
			// first remove from the cache, so it is empty until we get a response from the master store
			cachingStore.remove((directives && directives.id) || this.getIdentity(object));
			return when(masterStore.put(object, directives), function(result){
				// now put result in cache
				cachingStore.put(result && typeof result == "object" ? result : object, directives);
				return result; // the result from the put should be dictated by the masterStore and be unaffected by the cachingStore
			});
		},
		remove: function(id, directives){
			return when(masterStore.remove(id, directives), function(result){
				return cachingStore.remove(id, directives);
			});
		},
		evict: function(id){
			return cachingStore.remove(id);
		}
	});
};
lang.setObject("dojo.store.Cache", Cache);

/*=====
var __CacheArgs = {
	// summary:
	//		These are additional options for how caching is handled.
	// isLoaded: Function?
	//		This is a function that will be called for each item in a query response to determine
	//		if it is cacheable. If isLoaded returns true, the item will be cached, otherwise it
	//		will not be cached. If isLoaded is not provided, all items will be cached.
};

Cache = declare(Store, {
	// summary:
	//		The Cache store wrapper takes a master store and a caching store,
	//		caches data from the master into the caching store for faster
	//		lookup. Normally one would use a memory store for the caching
	//		store and a server store like JsonRest for the master store.
	// example:
	//	|	var master = new Memory(data);
	//	|	var cacher = new Memory();
	//	|	var store = new Cache(master, cacher);
	//
	constructor: function(masterStore, cachingStore, options){
		// masterStore:
		//		This is the authoritative store, all uncached requests or non-safe requests will
		//		be made against this store.
		// cachingStore:
		//		This is the caching store that will be used to store responses for quick access.
		//		Typically this should be a local store.
		// options: __CacheArgs?
		//		These are additional options for how caching is handled.
	},
	query: function(query, directives){
		// summary:
		//		Query the underlying master store and cache any results.
		// query: Object|String
		//		The object or string containing query information. Dependent on the query engine used.
		// directives: dojo/store/api/Store.QueryOptions?
		//		An optional keyword arguments object with additional parameters describing the query.
		// returns: dojo/store/api/Store.QueryResults
		//		A QueryResults object that can be used to iterate over.
	},
	get: function(id, directives){
		// summary:
		//		Get the object with the specific id.
		// id: Number
		//		The identifier for the object in question.
		// directives: Object?
		//		Any additional parameters needed to describe how the get should be performed.
		// returns: dojo/store/api/Store.QueryResults
		//		A QueryResults object.
	},
	add: function(object, directives){
		// summary:
		//		Add the given object to the store.
		// object: Object
		//		The object to add to the store.
		// directives: dojo/store/api/Store.AddOptions?
		//		Any additional parameters needed to describe how the add should be performed.
		// returns: Number
		//		The new id for the object.
	},
	put: function(object, directives){
		// summary:
		//		Put the object into the store (similar to an HTTP PUT).
		// object: Object
		//		The object to put to the store.
		// directives: dojo/store/api/Store.PutDirectives?
		//		Any additional parameters needed to describe how the put should be performed.
		// returns: Number
		//		The new id for the object.
	},
	remove: function(id){
		// summary:
		//		Remove the object with the specific id.
		// id: Number
		//		The identifier for the object in question.
	},
	evict: function(id){
		// summary:
		//		Remove the object with the given id from the underlying caching store.
		// id: Number
		//		The identifier for the object in question.
	}
});
=====*/

return Cache;
});

},
'dojo/data/util/simpleFetch':function(){
define(["../../_base/lang", "../../_base/kernel", "./sorter"],
  function(lang, kernel, sorter){
	// module:
	//		dojo/data/util/simpleFetch
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.

var simpleFetch = {};
lang.setObject("dojo.data.util.simpleFetch", simpleFetch);

simpleFetch.errorHandler = function(/*Object*/ errorData, /*Object*/ requestObject){
	// summary:
	//		The error handler when there is an error fetching items.  This function should not be called
	//		directly and is used by simpleFetch.fetch().
	if(requestObject.onError){
		var scope = requestObject.scope || kernel.global;
		requestObject.onError.call(scope, errorData, requestObject);
	}
};

simpleFetch.fetchHandler = function(/*Array*/ items, /*Object*/ requestObject){
	// summary:
	//		The handler when items are successfully fetched.  This function should not be called directly
	//		and is used by simpleFetch.fetch().
	var oldAbortFunction = requestObject.abort || null,
		aborted = false,

		startIndex = requestObject.start?requestObject.start: 0,
		endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

	requestObject.abort = function(){
		aborted = true;
		if(oldAbortFunction){
			oldAbortFunction.call(requestObject);
		}
	};

	var scope = requestObject.scope || kernel.global;
	if(!requestObject.store){
		requestObject.store = this;
	}
	if(requestObject.onBegin){
		requestObject.onBegin.call(scope, items.length, requestObject);
	}
	if(requestObject.sort){
		items.sort(sorter.createSortFunction(requestObject.sort, this));
	}
	if(requestObject.onItem){
		for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
			var item = items[i];
			if(!aborted){
				requestObject.onItem.call(scope, item, requestObject);
			}
		}
	}
	if(requestObject.onComplete && !aborted){
		var subset = null;
		if(!requestObject.onItem){
			subset = items.slice(startIndex, endIndex);
		}
		requestObject.onComplete.call(scope, subset, requestObject);
	}
};

simpleFetch.fetch = function(/* Object? */ request){
	// summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	// description:
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object --
	//		or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo/data/api/Read.fetch()
	//
	// request:
	//		The keywordArgs parameter may either be an instance of
	//		conforming to dojo/data/api/Request or may be a simple anonymous object
	//		that may contain any of the following:
	// |	{
	// |		query: query-object or query-string,
	// |		queryOptions: object,
	// |		onBegin: Function,
	// |		onItem: Function,
	// |		onComplete: Function,
	// |		onError: Function,
	// |		scope: object,
	// |		start: int
	// |		count: int
	// |		sort: array
	// |	}
	//		All implementations should accept keywordArgs objects with any of
	//		the 9 standard properties: query, onBegin, onItem, onComplete, onError
	//		scope, sort, start, and count.  Some implementations may accept additional
	//		properties in the keywordArgs object as valid parameters, such as
	//		{includeOutliers:true}.
	//
	//		####The *query* parameter
	//
	//		The query may be optional in some data store implementations.
	//		The dojo/data/api/Read API does not specify the syntax or semantics
	//		of the query itself -- each different data store implementation
	//		may have its own notion of what a query should look like.
	//		However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	//		and dojox.data support an object structure query, where the object is a set of
	//		name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	//		dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	//		when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	//		widgets the recommended query parameter is a key/value object.  That does not mean that the
	//		the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	//		or a mix of such.  Ultimately, The dojo/data/api/Read API is agnostic about what the query
	//		format.
	//
	//		Further note:  In general for query objects that accept strings as attribute
	//		value matches, the store should also support basic filtering capability, such as *
	//		(match any character) and ? (match single character).  An example query that is a query object
	//		would be like: { attrFoo: "value*"}.  Which generally means match all items where they have
	//		an attribute named attrFoo, with a value that starts with 'value'.
	//
	//		####The *queryOptions* parameter
	//
	//		The queryOptions parameter is an optional parameter used to specify options that may modify
	//		the query in some fashion, such as doing a case insensitive search, or doing a deep search
	//		where all items in a hierarchical representation of data are scanned instead of just the root
	//		items.  It currently defines two options that all datastores should attempt to honor if possible:
	// |	{
	// |		ignoreCase: boolean, // Whether or not the query should match case sensitively or not.  Default behaviour is false.
	// |		deep: boolean	// Whether or not a fetch should do a deep search of items and all child
	// |						// items instead of just root-level items in a datastore.  Default is false.
	// |	}
	//
	//		####The *onBegin* parameter.
	//
	//		function(size, request);
	//		If an onBegin callback function is provided, the callback function
	//		will be called just once, before the first onItem callback is called.
	//		The onBegin callback function will be passed two arguments, the
	//		the total number of items identified and the Request object.  If the total number is
	//		unknown, then size will be -1.  Note that size is not necessarily the size of the
	//		collection of items returned from the query, as the request may have specified to return only a
	//		subset of the total set of items through the use of the start and count parameters.
	//
	//		####The *onItem* parameter.
	//
	//		function(item, request);
	//
	//		If an onItem callback function is provided, the callback function
	//		will be called as each item in the result is received. The callback
	//		function will be passed two arguments: the item itself, and the
	//		Request object.
	//
	//		####The *onComplete* parameter.
	//
	//		function(items, request);
	//
	//		If an onComplete callback function is provided, the callback function
	//		will be called just once, after the last onItem callback is called.
	//		Note that if the onItem callback is not present, then onComplete will be passed
	//		an array containing all items which matched the query and the request object.
	//		If the onItem callback is present, then onComplete is called as:
	//		onComplete(null, request).
	//
	//		####The *onError* parameter.
	//
	//		function(errorData, request);
	//
	//		If an onError callback function is provided, the callback function
	//		will be called if there is any sort of error while attempting to
	//		execute the query.
	//		The onError callback function will be passed two arguments:
	//		an Error object and the Request object.
	//
	//		####The *scope* parameter.
	//
	//		If a scope object is provided, all of the callback functions (onItem,
	//		onComplete, onError, etc) will be invoked in the context of the scope
	//		object.  In the body of the callback function, the value of the "this"
	//		keyword will be the scope object.   If no scope object is provided,
	//		the callback functions will be called in the context of dojo.global().
	//		For example, onItem.call(scope, item, request) vs.
	//		onItem.call(dojo.global(), item, request)
	//
	//		####The *start* parameter.
	//
	//		If a start parameter is specified, this is a indication to the datastore to
	//		only start returning items once the start number of items have been located and
	//		skipped.  When this parameter is paired with 'count', the store should be able
	//		to page across queries with millions of hits by only returning subsets of the
	//		hits for each query
	//
	//		####The *count* parameter.
	//
	//		If a count parameter is specified, this is a indication to the datastore to
	//		only return up to that many items.  This allows a fetch call that may have
	//		millions of item matches to be paired down to something reasonable.
	//
	//		####The *sort* parameter.
	//
	//		If a sort parameter is specified, this is a indication to the datastore to
	//		sort the items in some manner before returning the items.  The array is an array of
	//		javascript objects that must conform to the following format to be applied to the
	//		fetching of items:
	// |	{
	// |		attribute: attribute || attribute-name-string,
	// |		descending: true|false;   // Optional.  Default is false.
	// |	}
	//		Note that when comparing attributes, if an item contains no value for the attribute
	//		(undefined), then it the default ascending sort logic should push it to the bottom
	//		of the list.  In the descending order case, it such items should appear at the top of the list.

	request = request || {};
	if(!request.store){
		request.store = this;
	}

	this._fetchItems(request, lang.hitch(this, "fetchHandler"), lang.hitch(this, "errorHandler"));
	return request;	// Object
};

return simpleFetch;
});

},
'curam/util':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 10-Jan-2023 BOS [SPM-126610] Moved updateInlineTabMenuState() and manageInlineTabMenuStates()
 * function to curam.util.TabActionsMenu.js
 * 09-Jan-2023 LS [SPM-1260841] Skip to Main Content Link not accessible by keyboard.
 * 03-Jan-2023 JD [SPM-125865] Updated span to h1 in dojo query in _findAppropriateDynamicTitle.
 * 19-Dec-2022 BOS [SPM-126480] Added updateInlineTabMenuState() function for inline tab actions.
 * 14-Dec-2022 CMC[SPM-105222] Updated file download logic in clickHandlerForListActionMenu(). 
 * 13-Oct-2022 FN [SPM125042] Added _addContextToWidgetForScreenReader to pick up cluster context in java widget render ListBodyRendererConcernMember.
 * 09-Jun-2022 CM [RTC277941] Remove code around the session storage localRefresh key.
 * 06-May-2022 LS  [RTC277951] Date picker for received date is displayed open blocking content when new evidence is opened.
 * 21-Apr-2022 GB  [RTC277797] Added a new parameter to insertAriaLiveLabelRecordSearchItem related to the heading id to be used. 
 * 06-Apr-2022 LS [RTC277567] Check Boxes - selecting checkbox on various screen  is causing the screen to align the focus to the top of the screen.
 * 30-Mar-2022 JD  [RTC270575] Updated URLs for search widget so params are ignored by secure URLs solution.
 * 29-Mar-2022 CM  [RTC277374] Updated setupPreferencesLink() and setupLocaleLink() to remove outdated css class 
 * and _curamDisable attribute.
 * 25-Mar-2022 CM  [RTC277060] Updated _doRedirectWindow() to allow application to be refreshed from an ActionPage,
 * when the LOCALE_REFRESH parameter is set to true.
 * 23-Mar-2022 CM  [RTC277294] Updated openLocaleNew() to allow dialog to open correctly.
 * 21-Mar-2022 CM  [RTC277294] Added openLocaleNew() function to open the new Language modal.
 * 09-Mar-2022 CM  [RTC276771] Updated _doRedirectWindow() function to add check for LOCALE_REFRESH, and 
 * refresh the entire application if parameter is found. 
 * 14-Oct-2021 LS  [RTC274183] Focus doesn't start in right place on the page
 * 07-Oct-2021 FN  [RTC255412] Added _addAccessibilityMarkupInAddressClustersWhenContextIsMissing function.
 * 06-Oct-2021 BOS [RTC273988] Updated the addCarbonModalButton() function to put the dataTestID into
 * object rather than separate argument.
 * 06-Oct-2021 GB  [RTC273983] Adding the new parameter to returnFocusToPopupActionAnchorElement function.
 * 29-Sep-2021  GB [RTC273619] Added data-testid to the carbon modal buttons.
 * 09-Sep-2021  FN  [RTC268445] Refactor toClipboard() since IE11 drop to make it work on supported modern browsers.
 * 16-Aug-2021  LS  [RTC272772] Move focus to tab warning or error modal when opened
 * 11-Aug-2021  SK [RTC272800] Progress spinner invocation has changed to the decoupled version.
 * 15-Jun-2021  SK [RTC272800] Memory leak prevention.
 * 03-Jun-2021  BD [RTC271240] Added returnFocusToPopupActionAnchorElement and addPlaceholderFocusClassToEventOrAnchorTag 
 * functions.
 * 18-May-2021  FN [RTC265093] Updated loadInformationalMsgs and setFocusOnField to set element attributes and focus
 * on container-messages-ul.
 * 13-May-2021  BD [RTC266250] Updated loadInformationalMsgs, setFocus and doSetFocus to return container-messages-ul or
 * error-messages element.
 * 04-May-2021  LS [RTC270554] Remove css-vars-ponyfill package to improve performance.
 * 26-Apr-2021  ZV [RTC270145] Update word dialog to Carbon.
 * 31-Mar-2021  FN [RTC265093] Updated loadInformationalMsgs() to explicitly focus on the correct page where the error message
 * details should be announced by the screen-reader. Also updated setFocusOnField() to fix Shift+Tab issue on error messages
 * in IE11 with screen reader.
 * 15-Mar-2021 BOS [RTC269160] Handling buttons configured as JSON object rather than HTML string.
 * 11-Mar-2021  FN [RTC265093] Updated loadInformationalMsgs() to explicitly focus on the correct page where the error message
 * details should be announced by the screen-reader.
 * 09-Mar-2021  JD [RTC268623] Updated loadInformationalMsgs() to keep focus on navigation tab instead of info
 * message if the navigation tab was the last element selected.
 * 18-Feb-2021  BD [RTC268079] Update method setFocus to set the tabindex and focus on the current iframe. Fix 
 * condition to check for Edge Chromium browser.
 * 05-Feb-2021  JD [RTC265373] Updated insertAriaLiveLabelRecordSearchItem so text is announced by screen reader
 * when search results are returned.
 * 28-Jan-2021  BD [RTC265376] Changed from label to span the element that contains the css class fileuploadButton.
 * 02-Dec-2020 BOS [RTC266982] Added functions to handle the addition of button to CuramDialog.
 * 11-Nov-2020  DM [RTC266277] Load css-vars-ponyfill to implement custom css properties in IE11.
 * 08-May-2020  JD [RTC259879] Adjusted timeouts when setting focus in IE11, added setFocusOnField() and _createHiddenInputField().
 * 01-Apr-2020  FN [RTC250370] Updated updateListControlReadings in order to get links in lists read out by a screen-reader.
 * 31-Mar-2020  FN [RTC257127] Updated _setBrowserTabTitle() to fix issue on embedded pages with in-page navigation
 *                             tabs throwing error message(s).
 * 05-Feb-2020  FN [RTC254720] Added logic in _findAppropriateDynamicTitle() to fix issue on pages with 
 *                             error messages where browser tab title was not updating correctly to reflect the 
 *                             presence of an error message.
 * 29-Jan-2020  JD [RTC257000] Fixed issue in IE11 where main content area is printed twice when context panel
 *                             is collapsed.
 * 17-Jan-2020  SH [RTC255274] Don't return the tabButton if in a modal in doSetFocus.
 * 08-Jan-2020  SH [RTC255274] More updates to setFocus() for focusing on CKEditor fields.
 * 04-Dec-2019  AA [RTC255177] Updated setBrowserTabTitle to handle the scenario where title is undefined and 
 *                             curam.util._browserTabTitleData does not contain staticTabTitle, separator 
 *                             and appNameFirst.
 * 03-Dec-2019  SH [RTC255274] Prevent focus being moved in setFocus if the user has already 
 *                             focused on a form element manually.
 * 18-Nov-2019  CMC[RTC239509] Updated printPage() function.
 * 07-Nov-2019  GG [RTC251143] Added lastOpenedTabButton variable to store the last opened tab to manage the focus 
 * on just opened tabs and updated doSetFocus to exclude hidden fields and use lastOpenedTabButton to set focus.
 * 17-Oct-2019  FN [RTC251289] Added aria-hidden attribute to input elements with the attribute 'hidden-button'.
 * 14-Oct-2019  FN [RTC250878] Minor change in the curam.debug.log when returning the application section title.
 * 10-Oct-2019  CM [RTC253438] Added getter and setter methods for new variable exitingIEGScript variable.
 * 04-Oct-2019  FN [RTC250878] Fixing the default application section title to be reflected
 *                             in the browser tab. This default changes upon the user used for logging.
 * 03-Oct-2019  AA [RTC251481] Added tabButtonClicked variable to store the tab button clicked in the navigation
 *                             tab. Added set and get functions. Changed the doSetFocus function to return
 *                             the tab button when the user is navigating through tabs.
 * 20-Sep-2019  AA [RTC250096] Added function to remove a property from the session storage. Updated setFocus to 
 *                             set the focus on the search button when the property curamDefaultActionId 
 *                             is defined.
 * 29-Aug-2019	FN [RTC249991] Additional updates to _findAppropriateDynamicTitle() to update the browser 
 * 							   title to a widget title when a session timeout closes.
 * 08-Aug-2019  CM [RTC248363] Updated updateListControlReadings function to check for controls 
 *                             on lists when sorting is triggered, as some links were missing 
 *                             aria-labels due to not having any controls from the initial loading.
 * 29-Jul-2019	FN [RTC249991] Updated _findAppropriateDynamicTitle() to update the browser title to
 * 							   a modal title when a pop-up window closes.
 * 22-Jul-2019  JD [RTC250498] Updated doSetFocus function to cater for multi-select fields and
 * 							   action pop-up links.
 * 01-Jul-2019  GG [RTC245742] Added extendXHR to update session timeout time into sessionStorage.
 * 18-Jun-2019  CMC[RTC248518] Removing 'Select' from aria labels on links within sortable lists.
 * 05-Jun-2019  SK [RTC248394] Updates accessibility readings gradually for IE only.
 * 28-May-2019  CM [RTC242923] Added fileUploadOpenFileBrowser() function.
 * 27-May-2019  SH [RTC240305] Decode url params before comparing them in isSameUrl().
 * 26-Apr-2019  SK [RTC241554] Added methods for list control readings set up and
 *                             updating.
 * 11-Feb-2019  CM [RTC240091] Fixing accessibility issue on date time widget field. 
 *                             Function addLayoutStylingOnDateTimeWidgetOnZoom() adds
 *                             css styling.
 * 17-Jan-2019  CM [RTC241236] Fixing accessibility issue where page title was set to 
 *                             undefined on a UIM page with in-page navigation. Function
 *                             getPageTitleOnContentPanel() updates the page title for this
 *                             edge case.
 * 30-NOV-2018  BD [RTC238774] Added method to check if the window contains 
 * 							   when the user clicks to print the page. The method 
 * 							   _prepareContentPrint() creates the wrapper to include
 * 							   the content of iframe and disable the iframe on the page. 
 * 							   After prints the page, the method _deletePrintVersion()
 *                             removes the wrapper and enables the iframe again,
 *                             returning to the original.
 * 24-Oct-2018	CMC[RTC225885] Fixing accessibility issue where initial focus was not  
 * 							   being placed correctly on the first editable page element.
 * 23-Oct-2018   SK [RTC237984] Modified the focus setter to correctly handle the
 *                             select Dijit widget and to return field for focusing
 *                             rather than doing the focus inside.
 * 25-Sep-2018  SK [RTC235825] Corrected the key handling to take into account the 
 *                             potentially different registry entry for the
 *                             Select based dropdown. 
* 25-Sep-2018  SK [RTC235825] Corrected the key handling to take into account the 
 *                             potentially different registry entry for the
 *                             Select based dropdown.
 * 23-Aug-2018  BD [RTC229425]  Included publish to alert when the page will be redirected 
 *                               to the logout page. 
 * 21-Aug-2018  SK [RTC230487]   Optimization of the table striping code.
 * 09-May-2018  BD [RTC225963]   Fixed accessibility issues related with alerts the search results.
 * 11-Apr-2018  BD [RTC210785]  Removed scrolltop for ios devices.
 * 27-Mar-2018  JD [RTC224593]  Fixed issue where the CSS of each row in a list
 * 								was set to 'even' after sorting the list.
 * 11-OCT-2017  JD [RTC206743]  Added GENERIC_ERROR_MODAL_MAP so parameters can be
 * 								passed to generic-modal-error.jspx without using
 * 								appending them to the url.
 * 12-07-2017   SK [RTC201190]  Moved clipboard related JS from the old JS file and
 *                              the custom tag.
 * 31-Mar-2017  GB [RTC182027]  Encoding URL for openGenericErrorModalDialog and 
 * 								removing the parameters from the request.
 * 27-Mar-2017  FG [191880]     Removed references to portlets.
 * 23-Feb-2017  BD [188234]     Added method setParentFocusByChild
 * 25-Oct-2016  BD [180045]     Update the method showModalDialogWithRef to accept the 
 *                        windows options as parameter.     
 * 04-Aug-2016  CD [143055]     Logic fixed on iframeTitleFallBack.
 * 25-Jan-2016  AZ [CR00475431] Check-box does not receive focus, if it is the 
 *                              first item on a page.
 * 05-Nov-2015  AB [CR00472177] Toggle buttons are not visible in Windows
 *                              high-contrast mode.
 * 07-Sep-2015  AZ [CR00466289] clickButton() function could not locate submit
 *                              buttons.
 * 27-Aug-2015  AB [CR00465809] Dynamic browser tab titles.
 * 20-Aug-2015  AZ [CR00465719] Added an index to submit button ID for unique IDs
 * 08-Apr-2015  SK [CR00460103] Added internal modal dialog showing function with
 *                              dialog reference.
 * 27-Feb-2015  AB [CR00458854] TEC-17714 Added code related to opening an Ok/Cancel
 *                              modal dialog with a browser-specific message when
 *                              attempting to download a file
 * 24-Feb-2015  AZ [CR00458302] Refactor isShiftTab() and focusHelpIconOnTab()
 *                              into curam/ModalDialog
 * 17-Feb-2015  AZ [CR00458206] Update the doSetFocus() function to cater for
 *                              scenario where there is a from with no editable
 *                              fields. (Port CR00450079 from TI_60)
 * 10-Feb-2015  AZ [CR00457893] Avoid opening a modal dialog when tab has
 *                              not yet loaded (Port CR00455284 from TI_60)
 * 30-Sep-2014  MV [CR00436657] Fixed informational display problem after
 *              closing modal.
 * 22-Sep-2014  SK [CR00445339] Added inspection layer integration.
 * 12-Sep-2014  MV [CR00444603] Replace dojox/storage with HTML5 local storage.
 * 06-Jun-2014  AS [CR00428142] TEC-17091. Skiplink should become visible when focused
 * 03-Nov-2014  JY [CR00448474] Make the context panel print configurable.
 * 06-Oct-2014  MV [CR00446285] Use cache when reloading page.
 * 06-Jun-2014  AS [CR00428142] TEC-17091. Skiplink should become visible when focused
 * 03-Jun-2014 BOS [CR00434187] Added the getCookie() function and updated
 *                    replaceSubmitButton() to support timeout warning dialog.
 * 15-Apr-2014  JY [CR00425261] Refactored the print function to allow printing
 *                              the context panel.
 * 20-Feb-2014  AS [CR00414442] Skipped arrow and validation div of filtering
 *                              select in doSetFocus and added a new method to
 *                              focus the help icon on tab navigation after end
 *                              of modal dialog.
 * 28-Sep-2013  BOS [CR00396277] Added tests for undefined selected tab.
 * 07-Jun-2013 NLH  [CR00385557] Added highContrastModeType() funtion.
 * 11-Mar-2013  SB  [CR00372052] Added iframeTitleFallBack() function.
 * 21-Feb-2013  SB  [CR00369658] Updated setupGenericKeyHandler() to
                                        handle year field in Date Selector correctly.
 * 20-Feb-2013  MV  [CR00367727] Prevent opening multiple dialogs at once
 *      by clicking on link in quick succession.
 * 14-Dec-2012  SB  [CR00352283] Added removeRoleRegion() function to remove
 *                                      aria role from multiselect.
 * 14-Dec-2012  JY  [CR00360602] Remove the hardcoded height for the actions
 *                               panel.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 08-Nov-2012  SB  [CR00350381] Added focus setting code for error and
 *                  informational messages.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 03-Oct-2012  SB  [CR00344085] Updated openGenericErrorModalDialog() function
 *      to include boolean check for error or warning modal.
 * 01-Oct-2012  MV  [CR00345339] Improve a way to determine topmost window.
 * 24-Sep-2012  MV  [CR00345119] Handle mailto: links properly across browsers.
 * 17-Sep-2012  MK  [CR00344397] Updated incorrect calls to method called
 *              hasClass to reference correct method called contains instead.
 * 17-Sep-2012  SB  [CR00341890] Added title attribute for page level action
 *                                  menu of the type submit.
 * 11-Sep-2012  MV  [CR00339639] Use local storage API from topmost window to
 *      avoid loading storage for every page. Move a function to this module.
 * 06-Sep-2012  AF  [CR00330559] Added skip link focus method.
 * 31-Aug-2012  MK  [CR00339638] Reverted connect and disconnect functions back
 *              to previous versions. Added in searchButtonStatus that was
 *              missed in the merge from TI_60.
 * 23-Aug-2012  BOS [CR00338361] Added the openGenericErrorModalDialog fucntion.
 * 23-Jul-2012  MV  [CR00336202] Handle gracefully when no tab is open on dialog
 *              submit. Migrate to take on Dojo 1.7.3
 * 26-Jun-2012  SB  [CR00332545] Added searchButtonStatus() function.
 * 28-May-2012  MV  [CR00326704] Fix click event handling for row action menus.
 * 30-Apr-2012  MK  [CR00319243] Updated condition in isSameUrl function to
 *      check if the base string is the same.
 * 24-Apr-2012  AF  [CR00317721] Updated online help URL in openHelpPage method.
 * 14-Mar-2012  SB  [CR00312247] Added openAbout() function
 * 07-Feb-2012  MV  [CR00301458] Code cleanup - added comments,
 *      removed unused code.
 * 13-Dec-2011  BOS [CR00299497] Updating the getTopmostWindow() function
 *                    to check that the Screen Context is defined.
 * 02-Dec-2011  BOS [CR00298234] Updating the getTopmostWindow() function
 *                 in order to support portlets.
 * 05-Oct-2011  PK  [CR00289859] Dojo 1.6.1 upgrade and IE9+ support.
 * 06-Sep-2011  MV  [CR00286500] Don't fail when Preferences anchor not found.
 * 05-Aug-2011  MV  [CR00283589] Remove incorrect code from connect().
 * 02-Aug-2011  MV  [CR00283023] Some refactoring to allow unit testing.
 * 01-Aug-2011  MV  [CR00283020] Refactored redirectWindow() to allow unit
 *      testing.
 * 29-Jul-2011  MV  [CR00269970] Define curam.util using dojo.mixin to avoid
 *      overwriting other class definitions in the same package. Add support
 *      for new UI refresh handling implementation.
 * 28-Jul-2011  MV  [] Handle the FORCE_REFRESH case fully
 *      in redirectWindow()
 * 05-Jul-2011  KW  [CR00275353] Added setRpu() function and refactored
 *                                openLocaleSelector().
 * 18-Jul-2011  KW  [CR00277581] Connect() now strips '#' from end of event URL
 * 13-Jun-2011  MV  [CR00269902] Avoid 404 error coming from bad RPU.
 * 25-May-2011  MV  [CR00267843] Add function for setting up the Preferences
 *    link.
 * 29-Apr-2011  SC  [CR00264826] Modified page load event to include context.
 * 27-Apr-2011  MV [CR00265188] Added support for opening pages in new tab from
 *    dialog opened in the INLINE_PAGE context.
 * 11-Apr-2011  AF [CR00262956] Modified setupGenericKeyHandler method to
 *                              support device independence.
 * 01-Apr-2011  KW [CR00262936] Altered 'alterScrollableListBottomBorder' to
 *                              run after page has loaded
 * 25-Mar-2011  SK [TEC-6335] Removed jsModals indicator as modals are always
 *     on for v6
 * 25-Feb-2011  MV [CR00254937] Honour the RPU set by LinkTag when redirecting
 *     content panel.
 * 25-Feb-2011  MV [CR00254380] Prepare for fix: Honour the RPU set by LinkTag
 *    when redirecting content panel.
 * 18-Feb-2011  MV [CR00247527] Do not block submit when text field has focus.
 * 16-Feb-2011  MV [CR00252701] Fix the isSameUrl() function to work for action
 *    pages that take no parameters.
 * 07-Feb-2011  SJ [CR00247527]  Fixed dropdown submit issue.
 * 07-Jan-2011  MV  [CR00251284] Add support for button load mask.
 * 31-Jan-2011  MK [CR00250297]  Update the clickButton function to handle both
 *    an object and an id as an argument.
 * 28-Jan-2011  MV [CR00245381]  Remove obsolete help settings for dialogs.
 * 26-Jan-2011  MV  [CR00244801] Added another type of refresh behaviour. Strip
 *    o3rpu from RPU value.
 * 25-Jan-2011  MV  [CR00244623] Refactored the function for firing onsubmit
 *    events to work with the latest tab infrastructure changes.
 * 25-Jan-2011  PK  [CR00244773] Filtered all CDEJ parameters from comparison
 *                    in isSameURL. Previously only __o3rpu was filtered.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 21-Jan-2011  MV  [CR00243263] Add 1px to page height when in list row.
 *    Implement "force refresh" behaviour.
 * 20-Jan-2010  AF  [CR00243728] Added page toolbar button mouse effects.
 * 20-Jan-2010  MK  [CR00243648] Update getPageHeight function to take into
 *                    account the wizard progress bar.
 * 18-Jan-2010  AF  [CR00243204] Modified replaceSubmitButton function for the
 *                               agenda player.
 * 17-Jan-2010 MV [CR00242255] Remove the use of dijit.focus()
 * 16-Jan-2010  PK  [CR00242698] Changed file down load method for list row
 *                    menus so errors will be correctly reported.
 * 14-Jan-2011  MK  [CR00240138] Updated showModalDialog function to remove
 *                    contexts that were not needed in a modal.
 * 06-Jan-2011 KW [CR00240549] Added function to prevent overlapping of Action
 *                             set buttons of modals
 * 04-Jan-2011 MV [CR00240081] Fixes to the getPageHeight() function.
 * 15-Dec-2010 KW [CR00238785] Stopped the refresh event when submit button
 *                             clicked
 * 10-Dec-2010  AF  [CR00233054] Added button mouse event functions that will
 *                               add specific CSS class names when modal and
 *                               cluster buttons are clicked or rolled over.
 * 07-Dec-2010  MV  [CR00233442] Adjustments to the getPageHeight() function
 *    to bring the expandable list detail row more in line with
 *    the specification.
 * 08-Dec-2010  SJ  [CR00229344] Added the print functionality.
 * 03-Dec-2010  MV  [CR00232963] Optimize swapState() function.
 * 30-Nov-2010  MV  [CR00232623] Remove extra height when in-page navigation
 *    is present.
 * 24-Nov-2010  PK  [TEC-XXXX] Added NESTED_UIM context.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 18-Nov-2010  SJ [CR00228391]Fixed the issue with OPEN_NEW attribute on
 *                   List Row Actions Menu links.
 * 01-Nov-2010  SD  [CR00225331] An extra parameter has been added to both
 *                     openModalDialog and showModalDialog functions for
 *                     UIMDialog API.
 * 27-Oct-2010  SK   [CR00224193] Changed the redirection of the window so that
       the absence of the content panel not caused failure.
 * 14-Oct-2010  MV [CR00223441] Move functions to different namespaces.
 *    Add getSuffixFromClass function.
 * 29-Sep-2010  MV  [CR00221605] Enable submitting by pressing Enter. Check
 *    for existence of dijit before accesing it.
 * 18-Sep-2010  PK  [CR00204622] Ensure when a page loads for the first time
 *                    in an expandable list, only the "expandedList.toggle"
 *                    event is processed.
 * 17-Sep-2010  MV  [CR00220607] Set page focus only when the whole page
 *                    is loaded. Use dijit.focus() instead of plain element
 *                    focus().
 * 14-Sep-2010  MV  [CR00220152] Add the getLastPathSegmentWithQueryString
 *                    function and also use it where appropriate in this file.
 * 10-Sep-2010  MV  [CR00219824] The focus setting function now indicates
 *                    the result via its return value.
 * 14-Sep-2010  PK  [CR00219843] Fixed expandable list sizing.
 * 08-Sep-2010  MV  [CR00219540] Add support for loading pages in the same
 *                    dialog from the list actions menu.
 * 27-Aug-2010  MV  [CR00217499] Added the makeQueryString() function. Replaced
 *                  the use of escape() with the correct function.
 * 05-Jul-2010 BD [CR00204119]  Introduced use of UIMController in place of
 *                              iframe for expandable lists to cater for
 *                              In Page Navigation tabs.
 * 28-Jul-2010  PK  [CR00211736] Updated due to re-factoring of
 *                    tab-app-controller.js.
 * 27-Jul-2010  MK  [CR00211743] Optional display the help icon on a modal
 *                    dialog.
 * 22-Jul-2010  MV  [CR00211225] Fix page height calculation for inline row
 *                    pages.
 * 22-Jul-2010  JY  [CR00210937] add 10px spacing at the top of the actions
 *                    panel.
 * 20-Jul-2010  MV  [CR00211031] doSetFocus(): handle pages with no HTML form.
 * 15-Jul-2010  MV  [CR00210541] Moved focus handling for modals to
 *                    ModalDialog.js
 * 12-Jul-2010  MV  [CR00210064] Added swapState() function.
 * 10-Jul-2010  OK  [CR00209714] Added setupRemovePageMask function.
 * 06-Jul-2010  MV  [CR00180694] Added toCommaSeparatedList() function.
 * 05-Jul-2010  SOS [CR00209386] Added try/catch to getPageHeight() for when
 *                    it's called in a hidden iframe.
 * 02-Jul-2010  PK  [CR00203531] Extra null check added to listRowFrameLoaded
 *                    method.
 * 26-Jun-2010  MV  [CR00204069] Added getPageHeight() function. Used Curam
 *                    debug logger throughout the file.
 * 18-Jun-2010  MV  [CR00203864] Remove the code for automatically resizing the
 *                    details panel.
 * 17-Jun-2010  MV  [CR00202490] Create the iframe for expandable lists on
 *                    demand only.
 * 15-Jun-2010  FG  [CR00202535] Added in some further functions required by the
 *                    application search functionality.
 * 01-Jun-2010  FG  [CR00200968] Added in some functions required by the
 *                    application search functionality.
 * 11-May-2010  SJ  [CR00198617] Implemented caching on expandable list row
 *                    level actions. As a fix CACHE_BUSTER,
 *                    CACHE_BUSTER_PARAM_NAME parameters are added and the same
 *                    are appended to the iframe source.
 * 11-May-2010  MV  [CR00196066] Added stripeTable() function.
 * 22-Apr-2010  AF  [CR00194043] Added 3 pixels to autoSizeDetailsPane's frame
 *                    height which removes an unwanted vertical scroll bar from
 *                    appearing on the details panel.
 * 23-Apr-2010  MV  [CR00194352] Avoid adding extra ampersand in
 *                    addUrlParameter() if there are no more parameters to add.
 * 07-Apr-2010  BD  [CR00191597] Renamed resizeDetailsPanel() function to
 *                    autoSizeDetailsPanel() to better reflect its function.
 *                    Refactored to handle new html structure.
 * 18-Mar-2010  PK  [CR00191211] Added toggleListDetailsRow.
 * 24-Feb-2010  MV  [CR00189738] Re-enable focus on the first editable field in
 *                    modals.
 * 23-Feb-2010  AF  [CR00189289] Added iframe title as a parameter in the iframe
 *                    upload publish event.
 * 16-Feb-2010  BD  [CR00183006] Add try/catch block to addContentWidthListener
 *                    function. Swallows an exception that does not effect the
 *                    application.
 * 08-Jan-2010  MV  [CR00182272] Added a localizable error message for the
 *                    language selector.
 * 11-Dec-2009  MV  [CR00173949] Remove the SrPopUp target from the modal
 *                    handler form.
 * 25-Nov-2009  MV  [CR00175955] Set focus to the first control when the
 *                    curam.modalDisplayed event happens.
 * 24-Nov-2009  MV  [CR00175837] Add new fireTabOpenedEvent function and a
 *                    missing require for curam.tab.
 * 20-Nov-2009  MV  [CR00175615] Fix the firePageSubmittedEvent function.
 * 20-Nov-2009  MV  [CR00175581] Fix the curam.tab.redirectContentPanel call.
 */

define(["dojo/dom",
        "dijit/registry",
        "dojo/dom-construct",
        "dojo/ready",
        "dojo/_base/window",
        "dojo/dom-style",
        "dojo/_base/array",
        "dojo/dom-class",
        "dojo/topic",
        "dojo/_base/event",
        "dojo/query",
        "dojo/Deferred",
        "dojo/has",
        "dojo/_base/unload",
        "dojo/dom-geometry",
        "dojo/_base/json",
        "dojo/dom-attr",
        "dojo/_base/lang",
        "dojo/on",
        "dijit/_BidiSupport",
        "curam/define",
        /* "dojox/storage", */
        "curam/debug",
        "curam/util/RuntimeContext",
        "curam/util/Constants",
        "dojo/_base/sniff",
        "cm/_base/_dom",
        "curam/util/ResourceBundle",
        "dojo/NodeList-traverse"

        ], function(dom, registry, domConstruct, ready, windowBase, style,
            array, domClass, topic, dojoEvent, query, Deferred, has, unload,
            geom, json, attr, lang, on, bidi, define, debug, runtimeCtx,
            Constants, sniff, _dom, resBundle) {

/**
 * @name      curam.util
 * @namespace Functions for generic utiltities across CDEJ.
 */
curam.define.singleton("curam.util",
/**
 * @lends curam.util.prototype
 */
{
  PREVENT_CACHE_FLAG: "o3pc",
  INFORMATIONAL_MSGS_STORAGE_ID: "__informationals__",
  ERROR_MESSAGES_CONTAINER: "error-messages-container",
  ERROR_MESSAGES_LIST: "error-messages",
  CACHE_BUSTER: 0,
  CACHE_BUSTER_PARAM_NAME: "o3nocache",
  PAGE_ID_PREFIX: "Curam_",
  msgLocaleSelectorActionPage: "$not-locaized$ Usage of the Language Selector is not permitted from an editable page that has previously been submitted.",
  GENERIC_ERROR_MODAL_MAP: {},
  wrappersMap : [],
  lastOpenedTabButton: false,
  tabButtonClicked: false,
  secureURLsExemptParamName: "suep",
  secureURLsExemptParamsPrefix: "spm",
  secureURLsHashTokenParam : "suhtp",
  
  /**
   * This function is used to record that the user is navigating 
   * through tabs so as to avoid the focus to move to the first editable field.
   * The tabButtonClicked stores the tabButton that will be used inside the
   * doSetFocus function to keep the focus on the tabButton.
   */
  setTabButtonClicked: function(tabButton){
          curam.util.getTopmostWindow().curam.util.tabButtonClicked = tabButton;
  },
  
  
  /**
   * Gets the tabButtonClicked and sets the variable to the default value.
   * 
   */
  getTabButtonClicked: function(){
          var tabButton = curam.util.getTopmostWindow().curam.util.tabButtonClicked;
          curam.util.getTopmostWindow().curam.util.tabButtonClicked = false;
          return tabButton;
  },

  /**
   * The lastOpenedTabButton stores the tabButton that will be used inside the
   * doSetFocus function to keep the focus on the tabButton if there are no editable 
   * fields.
   */
  setLastOpenedTabButton: function(tabButton){
    curam.util.getTopmostWindow().curam.util.lastOpenedTabButton = tabButton;
  },

  /**
   * Gets the lastOpenedTabButton and resets the variable to the default value.
   * 
   */
  getLastOpenedTabButton: function(){
        var tabButton = curam.util.getTopmostWindow().curam.util.lastOpenedTabButton;
        curam.util.getTopmostWindow().curam.util.lastOpenedTabButton = false;
        return tabButton;
  },
  
  insertCssText: function(cssString, styleNodeId) {
    var id = styleNodeId ? styleNodeId : "_runtime_stylesheet_";
      var styleSheetNode = dom.byId(id);
    var rmNode;

    if(styleSheetNode) {
      if(styleSheetNode.styleSheet) {
        cssString = styleSheetNode.styleSheet.cssText + cssString;
        rmNode = styleSheetNode;
        rmNode.setAttribute("id", "_nodeToRm");
      } else {
        styleSheetNode.appendChild(document.createTextNode(cssString));
        return;
      }
    }

    var pa = document.getElementsByTagName('head')[0];
      styleSheetNode = domConstruct.create("style", {
      type: "text/css",
      id: id
    });

    if(styleSheetNode.styleSheet) {
      styleSheetNode.styleSheet.cssText = cssString;
    }
    else{
      styleSheetNode.appendChild(document.createTextNode(cssString));
    }
    pa.appendChild(styleSheetNode);
    if(rmNode) {
      rmNode.parentNode.removeChild(rmNode);
    }
  },

  fireRefreshTreeEvent: function() {
      if (dojo.global.parent && dojo.global.parent.amIFrame) {
        var wpl = dojo.global.parent.loader;
    }
    if(wpl && wpl.dojo) {
      wpl.dojo.publish("refreshTree");
    }
  },

  /**
   * Invoked when a form is submitted on a page in any context.
   *
   * This event tracks submitting of pages anywhere in the application
   * to enable proper UI refresh handling.
   *
   * @param {String} context Specifies the context in which the submit
   *     happenned. The expected values are [main-content|dialog].
   */
  firePageSubmittedEvent: function(context) {
    require(["curam/tab"], function() {
      /*
       * This function is executed at onsubmit event and the call to
       * curam.tab.getContainerTab() below was failing in this scenario.
       * Using curam.tab.getSelectedTab() instead works fine.
       * Note that before refactoring to remove the use of getSelectedTab()
       * further changes will have to be made to make it work.
       */
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        var tabWidgetId = curam.tab.getTabWidgetId(sourceTab);

        var topWin = curam.util.getTopmostWindow();
        var ctx = (context == "dialog")
            ? curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_DIALOG
            : curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN;
        topWin.curam.util.Refresh.getController(tabWidgetId).pageSubmitted(
                dojo.global.jsPageID, ctx);
        topWin.dojo.publish("/curam/main-content/page/submitted",
                [dojo.global.jsPageID, tabWidgetId]);

      } else {
        curam.debug.log("/curam/main-content/page/submitted: " // don't localize
            + debug.getProperty("curam.util.no.open")); // FIXME: localize
      }
    });
  },

  fireTabOpenedEvent: function(tabWidgetId) {
    // Publish the tab opened event
    curam.util.getTopmostWindow().dojo.publish("curam.tabOpened",
          [dojo.global.jsPageID, tabWidgetId]);
  },

  /**
   * Setup the submit event publisher for the main content panel.
   */
  setupSubmitEventPublisher: function() {
      ready(function() {
        var form = dom.byId('mainForm');
      if (form) {
        curam.util.connect(form, 'onsubmit', function() {
          
          // Display Progress spinner
            curam.util.getTopmostWindow().dojo.publish('/curam/progress/display',
          		  [curam.util.PAGE_ID_PREFIX + dojo.global.jsPageID]);
          curam.util.firePageSubmittedEvent("main-content");
        });
      }
    });
  },

  getScrollbar: function(){
    //  summary
    //  returns the width of a scrollbar.

    //  set up the test nodes.
      var scroll = domConstruct.create("div", {}, windowBase.body());

      style.set(scroll, {
      width: "100px",
      height: "100px",
      overflow: "scroll",
      position: "absolute",
      top: "-300px",
      left: "0px"
    });

      var test = domConstruct.create("div", {}, scroll);

      style.set(test, {
      width: "400px",
      height: "400px"
    });

    var width = scroll.offsetWidth - scroll.clientWidth;
      domConstruct.destroy(scroll);

    //  we return an object because we may add additional info in the future.
    return { width: width };  //  object
  },

  // Returns true if the page is in a modal dialog, false otherwise.
  isModalWindow: function() {
    // the window.curamModal flag is set in curam.dialog.initModal()
      return (dojo.global.curamModal === undefined) ? false : true;
  },

  // Returns true if the page is in a modal dialog and running or existing 
  // an IEG script, otherwise returns false.
  isExitingIEGScriptInModalWindow: function(exitingIEGScript) {
    // the exitingIEGScript variable is set in ieg-modal.initDialog()
      return (curam.util.getTopmostWindow().exitingIEGScript === undefined) ? false : true;
  },
  
  // Set a global variable to true for a modal dialog and running or existing 
  // an IEG script.
  setExitingIEGScriptInModalWindowVariable: function() {
	  curam.util.getTopmostWindow().exitingIEGScript = true;
  },

  /**
   * Gets the top most window. The topmost window window is returned 
   * starting with the current window object.
   */
  getTopmostWindow: function() {

    // check topmost window cache and cache it if it is not yet cached
    if (typeof (dojo.global._curamTopmostWindow) == "undefined") {
      var parentWin = dojo.global;
      if (parentWin.__extAppTopWin) {
        dojo.global._curamTopmostWindow = parentWin;
      } else {
        while (parentWin.parent != parentWin) {
          parentWin = parentWin.parent;
          if (parentWin.__extAppTopWin) {
            // found the top window of a public facing app
            break;
          }
        }
        dojo.global._curamTopmostWindow = parentWin;
      }
    }

    // report cases of incorrect topmost window
    if (dojo.global._curamTopmostWindow.location.href.indexOf(
        "AppController.do") < 0
        && typeof(dojo.global._curamTopmostWindow.__extAppTopWin)
           == "undefined") {
      curam.debug.log(debug.getProperty("curam.util.wrong.window")
         + dojo.global._curamTopmostWindow.location.href);
    }

    return dojo.global._curamTopmostWindow;
  },

  getUrlParamValue: function(url, paramName) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return null;}
    var paramStr = url.substring(qPos + 1, url.length);

    function getVal(delim) {
      var params = paramStr.split(delim);

      paramName += "=";
      for(var i = 0; i < params.length; i++) {
        if(params[i].indexOf(paramName) == 0){
          return params[i].split("=")[1];
        }
      }
    }

    return getVal("&") || getVal("");
  },

  addUrlParam: function(href, paramName, paramValue, prepend) {
    var hasQ = href.indexOf("?") > -1;
    var doPrepend = prepend ? prepend : 'undefined';

    if (!hasQ || (doPrepend == false)) {
      return href + (hasQ ? "&" : "?") + paramName + "=" + paramValue;

    } else {
      var parts = href.split("?");
      href = parts[0] + "?" + paramName + "=" + paramValue + (parts[1] != "" ? ("&" + parts[1]) : "");
      return href;
    }
  },

  replaceUrlParam: function(href, paramName, newValue) {
    href = curam.util.removeUrlParam(href, paramName);
    return curam.util.addUrlParam(href, paramName, newValue);
  },

  removeUrlParam: function(url, paramName, /*optional*/paramValue) {
    var qPos = url.indexOf("?");
    if(qPos < 0) {return url;}
    if(url.indexOf(paramName + "=") < 0){return url;}//shortcut

    var paramStr = url.substring(qPos + 1, url.length);
    var params = paramStr.split("&");
    var value;
    var paramParts, doRemove;

    for(var i = 0; i < params.length; i++) {
      if (params[i].indexOf(paramName+"=") == 0) {
        doRemove = false;
        if(paramValue) {
          paramParts = params[i].split("=");
          if (paramParts.length > 1) {
            if (paramParts[1] == paramValue){
              doRemove = true;
            }

          } else if ( paramValue == "") {
            doRemove = true;
          }

        } else {
          doRemove = true;
        }

        if(doRemove) {
          //remove the parameter from the array
          params.splice(i, 1);
          //in case the param is in the url more than once, keep checking
          i--;
        }
      }
    }
    return url.substring(0, qPos + 1) + params.join("&");
  },

  //Remove the hash symbol, and everything that follows it, from a url.
  stripHash: function(url) {
    var idx = url.indexOf("#");
    if(idx < 0){return url;}
    return url.substring(0, url);
  },

  /**
   * Compares the specified URLs.
   *
   * This ignores the order of parameters - identical parameters in different
   * orders will still return true.
   *
   * If the second href is omitted, it defaults to the location
   * of the specified runtime context.
   *
   * @param href1 First HREF.
   * @param href2 Second HREF.
   * @param rtc current runtime context.
   *
   * @return True if the two urls are the same, false otherwise.
   */
  isSameUrl: function(href1, href2, rtc) {
    if (!href2) {
      href2 = rtc.getHref();
    }
    if (href1.indexOf("#") == 0) {
      return true;
    }

    // Remove the # symbols from the comparison.
    var hashIdx = href1.indexOf('#');
    if (hashIdx > -1) {
      //If the first URL starts with a #, then it is automatically equal to the
      //second URL
      if (hashIdx == 0) {
        return true;
      }

      var urlParts1 = href1.split("#");
      var hashIdx2 = href2.indexOf("#");

      //If the second URL has a hash symbol, remove it and everything after it,
      //then do the comparison
      if (hashIdx2 > -1) {
        if (hashIdx2 == 0) {
          return true;
        }
        href2 = href2.split("#")[0];
      }
      return urlParts1[0] == href2;
    }

    var stripPageOrActionFromUrl = function(url) {
      var idx = url.lastIndexOf("Page.do");
      var len = 7;
      if (idx < 0) {
        idx = url.lastIndexOf("Action.do");
        len = 9;
      }
      if (idx < 0) {
        idx = url.lastIndexOf("Frame.do");
        len = 8;
      }
      if (idx > -1 && idx == url.length - len) {
        return url.substring(0, idx);
      }
      return url;
    };

    var rp = curam.util.removeUrlParam;

    var here = curam.util.stripHash(rp(href2,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var there = curam.util.stripHash(rp(href1,
                    curam.util.Constants.RETURN_PAGE_PARAM));
    var partsThere = there.split("?");
    var partsHere = here.split("?");

    //Remove the Action.do or Page.do from the url
    partsHere[0] = stripPageOrActionFromUrl(partsHere[0]);
    partsThere[0] = stripPageOrActionFromUrl(partsThere[0]);

      // This check to see if the page names are the same assumes that the
      // functions above to strip parameters and page or actions from the url
      // have been run first. So the end of each string is only the name of
      // the page.
    var baseEqual = (partsHere[0] == partsThere[0]
          || partsHere[0].match(partsThere[0]+"$")==partsThere[0]);

    if (!baseEqual) {
      return false;
    }

    if (partsHere.length == 1 && partsThere.length == 1 && baseEqual) {
      //If the base URL is equal, and the parameter string is exactly equal,
      //then don't bother checking the unordered parameters. Just return true,
      //because they're equal
      return true;

    } else {
      //Check the values of all of the parameters, ignoring order of url
      //parameters
      var paramsHere;
      var paramsThere;
      if (typeof partsHere[1] != "undefined" && partsHere[1] != "") {
        paramsHere = partsHere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsHere = new Array();
      }

      if (typeof partsThere[1] != "undefined" && partsThere[1] != "") {
        paramsThere = partsThere[1].split("&");

      } else {
        // if there aren't any parameters create an empty array
        paramsThere = new Array();
      }

      // don't include CDEJ parameters in the comparison
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.before")
          + paramsHere.length);
        paramsHere = array.filter(paramsHere, curam.util.isNotCDEJParam);
      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.after")
          + paramsHere.length);

      curam.debug.log(
          "curam.util.isSameUrl: paramsHere "
          + debug.getProperty("curam.util.before")
          + paramsThere.length);
        paramsThere = array.filter(paramsThere, curam.util.isNotCDEJParam);
        curam.debug.log(
            "curam.util.isSameUrl: paramsHere "
            + debug.getProperty("curam.util.after")
          + paramsThere.length);

      if (paramsHere.length != paramsThere.length) {
        return false;
      }

      var paramMap = {};
      var param;
      for (var i = 0; i < paramsHere.length; i++) {
        param = paramsHere[i].split("=");
        // Decode the key and value before adding to the map.
        // This ensures a correct comparison in the following loop.
        param[0] = decodeURIComponent(param[0]);
        param[1] = decodeURIComponent(param[1]);
        paramMap[param[0]] = param[1];
      }
      for (var i = 0; i < paramsThere.length; i++) {
        param = paramsThere[i].split("=");
        // Decode the key and value before adding to the map.
        // This ensures a correct comparison in the next step.
        param[0] = decodeURIComponent(param[0]);
        param[1] = decodeURIComponent(param[1]);
        if (paramMap[param[0]] != param[1]) {
          curam.debug.log(debug.getProperty("curam.util.no.match",
              [param[0], param[1], paramMap[param[0]]]));
          return false;
        }
      }
    }

    //If the base url is the same, and all the parameters match, then
    //the urls are equal
    return true;
  },

  /**
   * Tests if the specified parameter name isn't a CDEJ parameter. It is used by
     * the array.filter used in the isSameUrl method.
   *
   * TODO: There is a similar method in PageRequest.js. Attempted to re-factor
   * but led to JavaScript errors in PageRequest.js when it was executed. Need
   * more time to work out dependency problem, for now duplicating the method.
   *
   * @return true if the specified parameter name is a CDEJ parameter, false
   *         otherwise.
   */
  isNotCDEJParam: function(paramName) {
    return !((paramName.charAt(0) == 'o' && paramName.charAt(1) == '3')
           || (paramName.charAt(0) == '_' && paramName.charAt(1) == '_'
               && paramName.charAt(2) == 'o' && paramName.charAt(3) == '3'));
  },

  //Sets one or more attributes on a DOM node. The map looks like:
  //{ type:'text', value:'This is text', style:'width:100px'}
  setAttributes: function(node, map) {
    for(var x in map) {
      node.setAttribute(x, map[x]);
    }
  },

  //This should be called if a pop up page has submitted a form, stating that
  //if this page is redirected to itself, rather than ignoring it, it should
  //refresh the browser.
  invalidatePage: function() {
    curam.PAGE_INVALIDATED = true;

      var parentWin = dojo.global.dialogArguments
          ? dojo.global.dialogArguments[0]:opener;

    if(parentWin && parentWin != dojo.global) {
      try {
        parentWin.curam.util.invalidatePage();

      } catch(e) {
        curam.debug.log(debug.getProperty("curam.util.error"), e);
      }
    }
  },

  /**
   * Sends the window to a new URL. This needs to be done differently depending
   * on whether or not the window is modal (IE only).
   * @param force
   *    If set to true, it does not matter if the href is the same as
   *    the current href or not, it will be refreshed.
   * @param ignoreFrame
   *    If true, then any other frames on the page are not refreshed.
   */
  redirectWindow: function(href, force, ignoreFrames) {
    var rtc = new curam.util.RuntimeContext(dojo.global);
    var redirectContentPanelInDifferentFrameRootContext =
      function(context, rootObject, href, forceLoad, justRefresh) {
        curam.util.getFrameRoot(context, rootObject)
            .curam.util.redirectContentPanel(href, forceLoad, justRefresh);
      };
      curam.util._doRedirectWindow(href, force, ignoreFrames,
          dojo.global.jsScreenContext, rtc, curam.util.publishRefreshEvent,
        redirectContentPanelInDifferentFrameRootContext);
  },

  _doRedirectWindow: function(href, force, ignoreFrames, screenContext, rtc,
      publishRefreshEvent, redirectContentPanelInDifferentFrameRootContext) {
    if (href && curam.util.isActionPage(href) && !curam.util.LOCALE_REFRESH) {
      // Avoid 404 error coming from bad RPU. This is temporary,
      // will be properly fixed by TEC-7123.
      curam.debug.log(debug.getProperty("curam.util.stopping"), href);
      return;
    }

    var rpl = curam.util.replaceUrlParam;
    //check if we are in the frameset context
    var inFrame = screenContext.hasContextBits('TREE')
                 || screenContext.hasContextBits('AGENDA')
                   || screenContext.hasContextBits('ORG_TREE');

    if (curam.util.LOCALE_REFRESH) {
     
      curam.util.publishRefreshEvent();
      // reload the entire application  
	  curam.util.getTopmostWindow().location.reload(); 
    
      return;
      
    } else if(curam.util.FORCE_REFRESH) {
      //If the FORCE_REFRESH parameter is set, in dialog.js, then ignore the
      //href parameter and just reload the page. This is done for the user
      //preferences dialog, so that it doesn't lose the __o3rpu parameter,
      //but can be used in other places too.
      href = rpl(rtc.getHref(), curam.util.PREVENT_CACHE_FLAG,
                 (new Date()).getTime());
      if(curam.util.isModalWindow() || inFrame) {
        publishRefreshEvent();
          dojo.global.location.href = href;

      } else {
        if (screenContext.hasContextBits('LIST_ROW_INLINE_PAGE')
            || screenContext.hasContextBits('NESTED_UIM')) {

          curam.util._handleInlinePageRefresh(href);

        } else {
          publishRefreshEvent();
          if (dojo.global.location !== curam.util.getTopmostWindow().location) {
            require(["curam/tab"], function() {
              redirectContentPanelInDifferentFrameRootContext(dojo.global,
                  curam.tab.getTabController().ROOT_OBJ, href, true, true);
            });
          }
        }
      }
      return;
    }

    var u = curam.util;
    //if the URL is identical, it's not a real redirect, so do nothing.
    //This solves the case of a Cancel button being clicked in a modal window.
    var rtc = new curam.util.RuntimeContext(dojo.global);
    if(!inFrame && !force && !curam.PAGE_INVALIDATED
        && u.isSameUrl(href, null, rtc)) {
      return;
    }

    //If in a modal dialog, then submit a form via a 'POST', as doing a normal
    //redirect
    if(curam.util.isModalWindow() || inFrame) {

      //make sure that the modal parameter is set, and that a timestamp is added
      //to prevent the resulting page from being cached.
      href = rpl(rpl(href, "o3frame", "modal"),
        curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
        var form = domConstruct.create("form", {
        action:href,
        method:"POST"
      });

      //modals launched from Agenda Player in modal do not need artificial post
      if (!inFrame) {

          if(!dom.byId("o3ctx")) {
          // The o3ctx may exist on the url passed into this method already.
          // So, remove it and reset the form action.
          // This is a last-minute fix for an issue found during JDE 009
          // testing.
          form.action =
            curam.util.removeUrlParam(form.action, "o3ctx");
            var input1 = domConstruct.create("input", {
            type: "hidden", id: "o3ctx", name:"o3ctx",
            value: screenContext.getValue()
          }, form);
        }
          windowBase.body().appendChild(form);
        publishRefreshEvent();
        form.submit();
      }
      if(!ignoreFrames) {
        if (inFrame) {
          curam.util.redirectFrame(href);
        }
      }

    } else {
      //The base context case; no frameset, these are not supported in the tab
      //content panel. Just change the href
      //BEGIN,RTC 194820,267326 COF
   	  var launchWordEditOp=sessionStorage.getItem("launchWordEdit");
      //END,RTC 194820,267326 COF
      if (!launchWordEditOp && (screenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || screenContext.hasContextBits("NESTED_UIM"))) {

        curam.util._handleInlinePageRefresh(href);

      } else {
    	//BEGIN,RTC 194820,267326 COF
	    if(launchWordEditOp){
           sessionStorage.removeItem("launchWordEdit");
   		}
         
      //END, RTC 194820,267326 COF
      publishRefreshEvent();
      if (dojo.global.location !== curam.util.getTopmostWindow().location) {
        if (screenContext.hasContextBits("EXTAPP")) {
          var topWindow = window.top;
          topWindow.dijit.byId("curam-app").updateMainContentIframe(href);
        } else {
          require(["curam/tab"], function() {
            curam.util.getFrameRoot(dojo.global,
              curam.tab.getTabController().ROOT_OBJ)
                .curam.util.redirectContentPanel(href, force);
          });
        }
      }
    }
  }
},

  /**
   * Closing modal dialog opened from expanded list row or nested UIM.
   * Either Redirect expanded row iframe or open the url in a new tab,
   * depending on whether the target page is mapped to some tab or not.
   */
  _handleInlinePageRefresh: function(href) {
    curam.debug.log(debug.getProperty("curam.util.closing.modal"), href);

    /*
     * The following code is based on assumption that inline pages are not
     * mapped to any tabs. If this is the case then the inline frame will
     * be refreshed. If the page is mapped to a tab then it will open in that
     * tab rather than in the inline frame.
     */
    var pageRequest = new curam.ui.PageRequest(href);
    require(["curam/tab"], function() {
      curam.tab.getTabController().checkPage(pageRequest, function(request) {
        // refresh the inline frame
        curam.util.publishRefreshEvent();
        // specifically pass false so that browser uses cached resources
        // where possible
        window.location.reload(false);
      });
    });
  },

  /**
   * @param url
   *    The URL to redirect to.
   * @param forceLoad
   *    Load the page even if the existing URL is the same.
   * @param justRefresh
   *    Do not change to a different URL, only refresh the existing page.
   */
  redirectContentPanel: function(url, forceLoad, justRefresh) {
    require(["curam/tab"], function() {
      // add the return page parameter
      var iframe = curam.tab.getContentPanelIframe();
      var newUrl = url;
      if (iframe != null) {
        var rpu = curam.util.Constants.RETURN_PAGE_PARAM;
        var o3rpuValue = null;
        if (url.indexOf(rpu + "=") >= 0) { // if the url has RPU param
          curam.debug.log("curam.util.redirectContentPanel: "
            + debug.getProperty("curam.util.rpu"));
          o3rpuValue = decodeURIComponent(curam.util.getUrlParamValue(url, rpu));
        }
        // or the specified URL has no __o3rpu parameter - just pass through

        if (o3rpuValue) {
          // strip the __o3rpu parameter form the RPU value
          o3rpuValue = curam.util.removeUrlParam(o3rpuValue, rpu);

          newUrl = curam.util.replaceUrlParam(url, rpu,
              encodeURIComponent(o3rpuValue));
        }
      }
      var uimPageRequest = new curam.ui.PageRequest(newUrl);
      if (forceLoad) {
        uimPageRequest.forceLoad = true;
      }
      if (justRefresh) {
        uimPageRequest.justRefresh = true;
      }
      curam.tab.getTabController().handlePageRequest(uimPageRequest);
    });
  },

  //Redirects a page in a frame, and refreshes all other frames.
  //If 'href' is not set, then the current window is not refreshed,
  //just the other frames.
  redirectFrame: function(href) {
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      var target = curam.util.getFrameRoot(dojo.global, "wizard").targetframe;
      target.curam.util.publishRefreshEvent();
      target.location.href = href;

      } else if (dojo.global.jsScreenContext.hasContextBits('ORG_TREE')) {//lazy tree
      var target = curam.util.getFrameRoot(dojo.global, "orgTreeRoot");
        /* FIXME: this code expects that curam.util and dojo are loaded
         * and avaialble in the target context. Instead it should call require()
         * to load the required module.
         */
      target.curam.util.publishRefreshEvent();
      target.dojo.publish("orgTree.refreshContent", [ href ]);

    } else { //tree frameset
      var treeRef = curam.util.getFrameRoot(dojo.global, "iegtree");
      var navigator = treeRef.navframe || treeRef.frames[0];
      var contents = treeRef.contentframe || treeRef.frames['contentframe'];
      contents.curam.util.publishRefreshEvent();
      if (curam.PAGE_INVALIDATED || navigator.curam.PAGE_INVALIDATED) {
        var newHref = curam.util.modifyUrlContext(href, 'ACTION');
        contents.location.href = newHref;

      } else {
        contents.location.href = href;
      }
    }

    //Return true, indicating that a redirect did take place.
    return true;
  },

  publishRefreshEvent: function() {
      topic.publish("/curam/page/refresh");
  },

  /**
   * Opens a basic error modal dialog using the href
   * <code>generic-modal-error.jspx</code>. The parameters are passed to a
   * Javascript object which can be retrieved in the JSP.
   *
   * @param windowOptions        The windows options to specifiy the width and
   *                             height of the dialog.
   * @param titleProp            The property key to be used when localizing
   *                             the text of the title on the dialog.
   * @param messageProp          The property key to be used when localizing
   *                             the message on the dialog.
   * @param messagePlaceholder1  The first placeholder to be within the message
   *                             on the dialog. THis will not be set if it is
   *                             undefined.
   * @param isErrorModal         The boolean value to indicate whether it is an
   *                             error modal or a warning modal.
   */
  openGenericErrorModalDialog: function(windowOptions, titleProp,
	      messageProp, messagePlaceholder1, isErrorModal) {
	  
	var topmostWin = curam.util.getTopmostWindow();
	
	// Add the GENERIC_ERROR_MODAL_MAP to the top most window so it can be
	// retrieved in the JSP.
	topmostWin.curam.util.GENERIC_ERROR_MODAL_MAP = {"windowsOptions": windowOptions,
          "titleInfo" : titleProp,
          "msg" : messageProp,
          "msgPlaceholder" : messagePlaceholder1,
          "errorModal" : isErrorModal,
          "hasCancelButton" : false};
	  
    var url ="generic-modal-error.jspx";
    // TODO: May also want to take into account whether window options are set
    // or not -- BOS
	curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton = true;
    curam.util.openModalDialog({href:encodeURI(url)}, windowOptions);

  },

  /**
   * Opens an Ok/Cancel modal dialog using the href
   * <code>generic-modal-error.jspx</code>. The parameters are passed to a
   * Javascript object which can be retrieved in the JSP. The Ok/Cancel buttons
   * pass 'confirm' or 'cancel' respectively to the "/curam/dialog/close"
   * event.
   *
   * @param windowOptions  The windows options to specifiy the width and
   *                       height of the dialog.
   * @param titleProp      The property key to be used when localizing
   *                       the text of the title on the dialog.
   * @param messageProp    The property key to be used when localizing
   *                       the message on the dialog.
   */
  openGenericErrorModalDialogYesNo: function(windowOptions, titleProp,
      messageProp) {
	
	// Parameters that are added to the URL for the JSP. 
	var sc = dojo.global.jsScreenContext;
    var topmostWin = curam.util.getTopmostWindow();    
    
    sc.addContextBits('MODAL');
        
	// Add the GENERIC_ERROR_MODAL_MAP to the top most window so it can be
	// retrieved in the JSP.
    topmostWin.curam.util.GENERIC_ERROR_MODAL_MAP = {"windowsOptions": windowOptions,
      "titleInfo" : titleProp,
      "msg" : messageProp,
      "msgPlaceholder" : "",
      "errorModal" : false,
      "hasCancelButton" : true};
            
    var url ="generic-modal-error.jspx?" + sc.toRequestString();

    // TODO: May also want to take into account whether window options are set
    // or not -- BOS
	      
	 curam.util.openModalDialog({href:encodeURI(url)}, windowOptions);
	 
  },

  /**
  * Appends placeholder-for-focus class to the element tag
  * and add the window to  to the PLACEHOLDER_WINDOW_LIST.
  * @param eventOrAnchorTag  The element to be added the placeholder-for-focus class.
  * @param window            The property window key to be used when returning the 
  *                          focus when the modal is closed.
  */
  addPlaceholderFocusClassToEventOrAnchorTag: function (eventOrAnchorTag, window){
	var topMostWindow = curam.util.getTopmostWindow();
	topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST = 
	  !topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST ? [] : topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST; 
	domClass.add(eventOrAnchorTag,"placeholder-for-focus");
	topMostWindow.curam.util.PLACEHOLDER_WINDOW_LIST.push(window);
  },

  /**
   * 
   * Returns the focus to a anchor element when the pop-up dialog is closed and
   * removes placeholder-for-focus appended to the anchor element class in the iframe content.
   */
   returnFocusToPopupActionAnchorElement: function(parentWindowRef) {
	 var focusList = parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST;
	 if (focusList && focusList.length > 0 ){
	   var parentWindow = focusList.pop();
       var iFrameContent = parentWindow && parentWindow.document.activeElement;
	
       var anchorElementToFocusOn = iFrameContent && dojo.query(".placeholder-for-focus", iFrameContent); 
       if(anchorElementToFocusOn && anchorElementToFocusOn.length == 1){
         anchorElementToFocusOn[0].focus();
         domClass.remove(anchorElementToFocusOn[0],"placeholder-for-focus");
       }
       parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST.splice(0, parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST.length);
       parentWindowRef.curam.util.PLACEHOLDER_WINDOW_LIST = null;
     }
   },

  // Opens a modal dialog.
  // This is the public API function.
  // The function can take an anchor tag or an event as its first parameter
  // The uimToken parameter is only used in conjunction with the UIMDialog API.
  openModalDialog: function(
    eventOrAnchorTag, windowOptions, left, top, uimToken) {
	
	eventOrAnchorTag.event && 
	  curam.util.addPlaceholderFocusClassToEventOrAnchorTag(eventOrAnchorTag.event, eventOrAnchorTag.event.ownerDocument.defaultView.window);

    var href;
    if(!eventOrAnchorTag || !eventOrAnchorTag.href) {
      // it is an event
        eventOrAnchorTag = dojoEvent.fix(eventOrAnchorTag);

      var target = eventOrAnchorTag.target;
        while(target.tagName != "A" && target != windowBase.body()){
        target = target.parentNode;
      }

      href = target.href;

      //Mark the anchor tag as a modal dialog opener, so that other listeners on
      //it, e.g. the List Context Menus in /jscript/curam/listMenu.js, ignore
      //clicks on it.
      target._isModal = true;

        dojoEvent.stop(eventOrAnchorTag);

    } else {
      // it is an anchorTag
      href = eventOrAnchorTag.href;
      eventOrAnchorTag._isModal = true;
    }

        require(["curam/dialog"]);
    var opts = curam.dialog.parseWindowOptions(windowOptions);
    curam.util.showModalDialog(href, eventOrAnchorTag,
          opts['width'], opts['height'], left, top,  false, null, null, uimToken);
    return true;

  },

  // Shows a modal dialog.
  // Internal function, used from the public openModalDialog() function above
  // and also from pop-up-related code (omega3-util.js).

  // The uimToken parameter is only used in conjunction with the UIMDialog API.

  // @param realParent
  //            The parent window the request to open modal originated from.
  showModalDialog: function(url, eventOrAnchorTag,
      width, height, left, top, resizable, status, realParent, uimToken) {

    // handling nested modals ->
    // if called from within modal, redirect call to the parent window.
    var topmostWindow = curam.util.getTopmostWindow();
    if (dojo.global != topmostWindow) {
      curam.debug.log(
          "curam.util.showModalDialog: "
            + debug.getProperty("curam.util.redirecting.modal"));
      topmostWindow.curam.util.showModalDialog(url, eventOrAnchorTag,
          width, height, left, top, resizable, status, dojo.global, uimToken);
      return;
    }

    var rup = curam.util.replaceUrlParam;
    url = rup(url, "o3frame","modal");
    url = curam.util.modifyUrlContext(url, 'MODAL', 'TAB|LIST_ROW_INLINE_PAGE|LIST_EVEN_ROW|NESTED_UIM');
    url = rup(url, curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
    curam.debug.log(debug.getProperty("curam.util.modal.url"), url);

    if (width) {
      width = typeof(width) == 'number' ? width : parseInt(width);
    }
    if (height) {
      height = typeof(height) == 'number' ? height : parseInt(height);
    }

    // Prevent multiple further requests for modal until this one is processed
    if (!curam.util._isModalCurrentlyOpening()) {
      // handle scenarios where user clicks on a modal link before main content
      // has finished loading
      if (url.indexOf('__o3rpu=about%3Ablank') >= 0 ) {
        alert(curam_util_showModalDialog_pageStillLoading);
        return;
      }

      curam.util._setModalCurrentlyOpening(true);

      if (jsScreenContext.hasContextBits("EXTAPP")) {
        require(["curam/ModalDialog"]);
        new curam.ModalDialog({href: url,
                               width: width,
                               height: height,
                               openNode: (eventOrAnchorTag && eventOrAnchorTag.target) ? eventOrAnchorTag.target : null,
                               parentWindow: realParent,
                               uimToken: uimToken});
      } else {
      	// Modal implemented in Carbon
        require(["curam/modal/CuramCarbonModal"]);
        new curam.modal.CuramCarbonModal({href: url,
                               width: width,
                               height: height,
                               openNode: (eventOrAnchorTag && eventOrAnchorTag.target) ? eventOrAnchorTag.target : null,
                               parentWindow: realParent,
                               uimToken: uimToken});
      }
      return true;
    }
  },
  // Shows a modal dialog and returns its reference.
  // Internal function, currently just used by the file edit widget.
  // @param realParent
  //            The parent window the request to open modal originated from.
  // @param windowsOptions
  //            The windows options to open a modal dialod.
  
  showModalDialogWithRef: function(modUrl, realParent, windowsOptions) {
    var topmostWindow = curam.util.getTopmostWindow();
    if (dojo.global != topmostWindow) {
      return topmostWindow.curam.util.showModalDialogWithRef(modUrl, dojo.global);
    }
    var rup = curam.util.replaceUrlParam;
    modUrl = curam.util.modifyUrlContext(modUrl, 'MODAL', 'TAB|LIST_ROW_INLINE_PAGE|LIST_EVEN_ROW|NESTED_UIM');
    modUrl = rup(modUrl, curam.util.PREVENT_CACHE_FLAG, (new Date()).getTime());
    if (!curam.util._isModalCurrentlyOpening()) {
      curam.util._setModalCurrentlyOpening(true);
      var dl;
      if (jsScreenContext.hasContextBits("EXTAPP")) {
        require(["curam/ModalDialog"]);
        if(windowsOptions){
            dl = new curam.ModalDialog({href: modUrl, width: windowsOptions.width, height: windowsOptions.height,  parentWindow: realParent});

        }else{
            dl = new curam.ModalDialog({href: modUrl,  parentWindow: realParent});
        }
      }else{
        require(["curam/modal/CuramCarbonModal"]);
        if(windowsOptions){
          dl = new curam.modal.CuramCarbonModal({href: modUrl, width: windowsOptions.width, height: windowsOptions.height,  parentWindow: realParent});
        }else{
          dl = new curam.modal.CuramCarbonModal({href: modUrl,  parentWindow: realParent});
        }
      }
      return dl;
    }
  },

  /**
   * Determine if a modal is being opened at this time.
   *
   * @returns True if modal open operation is in progress, otherwise false.
   */
  _isModalCurrentlyOpening: function() {
    return curam.util.getTopmostWindow().curam.util._modalOpenInProgress;
  },

  /**
   * Set the flag indicating if a modal is being opened at this time.
   *
   * @param isOpening {Boolean} Value for the flag, either true or false.
   */
  _setModalCurrentlyOpening: function(isOpening) {
    curam.util.getTopmostWindow().curam.util._modalOpenInProgress = isOpening;
  },

 setupPreferencesLink: function(href) {
      ready(function() {
        var prefsAnchor = query(".user-preferences")[0];
      if (prefsAnchor) {
        if (typeof(prefsAnchor._disconnectToken) == "undefined") {
          prefsAnchor._disconnectToken = curam.util.connect(prefsAnchor,
              "onclick", curam.util.openPreferences);
        }

        if (!href) {
            href = dojo.global.location.href;
        }

      } else {
        curam.debug.log(debug.getProperty("curam.util.no.setup"));
      }
    });
  },
  
  /**
   * Set up the link for the Language menu-item.
   *
   * @param href hyperlink
   *          
   */
  setupLocaleLink: function(href) {
      ready(function() {
        var localeAnchor = query(".user-locale")[0];
      if (localeAnchor) {
        if (typeof(localeAnchor._disconnectToken) == "undefined") {
        	localeAnchor._disconnectToken = curam.util.connect(localeAnchor,
              "onclick", curam.util.openLocaleNew);
        }
        if (!href) {
            href = dojo.global.location.href;
        }

      } else {
        curam.debug.log(debug.getProperty("curam.util.no.setup"));
      }
    });
  },
  
  openPreferences: function(event) {
      dojoEvent.stop(event);

    if (event.target._curamDisable) {
      // link disabled, do nothing
      return;
    }

    require(["curam/tab"], function() {
      curam.tab.getTabController().handleLinkClick(
          "user-prefs-editor.jspx", {dialogOptions:"width=605"});
    });
  },
  
  logout: function(event) {
          var topWin = curam.util.getTopmostWindow();
          topWin.dojo.publish("curam/redirect/logout");
          window.location.href = jsBaseURL + "/logout.jsp";
  },

  openAbout: function(event) {
      dojoEvent.stop(event);
      require(["curam/tab"], function() {
        curam.tab.getTabController().handleLinkClick(
            "about.jsp", {dialogOptions:"width=583,height=399"});
      });
  },

  addMinWidthCalendarCluster: function(id){

      var contentNode = dom.byId(id);
    var i = 0;

    function addWidth(evt){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "width", "97%");
          if(node.clientWidth < 700){
              style.set(node, "width", "700px");
          }
        }
      });
    }//end function addWidth

      if(has("ie") > 6){
        array.forEach(contentNode.childNodes, function(node){
          if(domClass.contains(node, "cluster")){
            style.set(node, "minWidth", "700px");
        }
      });
    } else {
        on(dojo.global, 'resize', addWidth);
        ready(addWidth);
    }
  },

  addPopupFieldListener: function(id){
      if(!has("ie") || has("ie") > 6){
      return;
    }
    if(!curam.util._popupFields) {
      function doResize(evt){
        var actionWidth=0;
        var j = 0;
        var x = 0;
        var arr = curam.util._popupFields;
          array.forEach(curam.util._popupFields, function(id){
            var fieldNode = dom.byId(id);
            query("> .popup-actions", fieldNode).forEach(function(node){
            actionWidth = node.clientWidth + 30;
          });

            query("> .desc", fieldNode).forEach(function(node){
              style.set(node, "width",
              Math.max(0, fieldNode.clientWidth - actionWidth) + "px");
          });
        });
      }// end doResize function
      curam.util._popupFields = [id];
        on(dojo.global, 'resize', doResize);
        ready(doResize);
    } else {
     curam.util._popupFields.push(id);
    }
  },

  /**
   * Sets the width and height (on IE6) of the main content area and sidebar
   * when the window is resized. The sidebar is not always included on a page.
   */
  addContentWidthListener: function(id) {
      if (has("ie") > 6) {
      // don't do if IE is 7 and higher
      return;
    }
      var setStyle = style.set;
      var hasClass = domClass.contains;

    function doResize(evt) {
      var i = 0;
        var contentNode = dom.byId("content");
      if (contentNode) {
        var width = contentNode.clientWidth;

        // Only set the height of the content if the footer is present,
        // and if the browser is Internet Explorer 6
          if (has("ie") == 6 && dom.byId("footer")) {
            var contentHeight = windowBase.body().clientHeight - 100;
          setStyle(contentNode, "height", contentHeight + "px");
            var sideNode = dom.byId("sidebar");
          if (sideNode) {
            setStyle(sideNode, "height", contentHeight + "px");
          }
        }

        try{
            query("> .page-title-bar", contentNode).forEach(function(node){
              var marginW = geom.getMarginSize(node).w
                  - geom.getContentBox(node).w;
              if (!has("ie")) {
              marginW +=1;
            }
            width =  contentNode.clientWidth - marginW;
              style.set(node, "width", width + "px");
          });
        }catch(e){
        // Do nothing. If the page-title-bar does not exist it won't need to be resized.
        }

          query("> .page-description", contentNode).style("width", width + "px");
          query("> .in-page-navigation", contentNode).style("width", width + "px");
      }
    }

    curam.util.subscribe("/clusterToggle", doResize);
    curam.util.connect(dojo.global, 'onresize', doResize);
      ready(doResize);
  },

  //depending on the final row and height of the visible scrollable area
  //we will have to add/remove the bottom border on the final row
  alterScrollableListBottomBorder: function(id, maxHeight){

    var visibleAreaHeight = maxHeight;
    var queryText = "#" + id + " table"; //to find the table contained in the div

    function alterBorder() {
        var scrollTable = query(queryText)[0];
      if (scrollTable.offsetHeight >= visibleAreaHeight) { //scrollbar visible & active
        //dont want a border on final row, if an odd row
          var lastRow = query(".odd-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "no-bottom-border");
        }
      }
      else if (scrollTable.offsetHeight < visibleAreaHeight) { //scrollbar visible & inactive
        //we want a border on final row, if an even row
          var lastRow = query(".even-last-row", scrollTable)[0];
        if (typeof lastRow != "undefined") {
            domClass.add(lastRow, "add-bottom-border");
        }
      }
      else {
        curam.debug.log("curam.util.alterScrollableListBottomBorder: "
          + debug.getProperty("curam.util.code"));
      }
    }
    //added onLoad event to stop IE7 reading table heght before it is fully loaded
      ready(alterBorder);

  },

  //Set the width (on IE6) of the file upload button and its associated textfield,
  // and it will be auto resized when the window is resized.
  addFileUploadResizeListener:function(code){

    function fileUploadResize(evt){

        if(query(".widget")){

                query(".widget").forEach(function(widgetNode){
                var width = widgetNode.clientWidth;
                    if(query(".fileUpload", widgetNode)){

                        query(".fileUpload", widgetNode).forEach(function(fileUploadNode){
                        fileUploadWidth = width/30;
                        if(fileUploadWidth < 4){
                          fileUploadNode.size= 1;
                        }
                        else{
                          fileUploadNode.size= fileUploadWidth;
                        }
                      });
                  }
              });
          }
    }
      on(dojo.global, 'resize', fileUploadResize);
      ready(fileUploadResize);
  },


  //Opens a pop up dialog, non-modal, in the centre of the screen.
  openCenteredNonModalWindow: function(url, width, height, name) {
    // Fudge factors for window decoration space.
    width = Number(width);
    height = Number(height);
    var offsetLeft = (screen.width - width) / 2;
    var offsetTop = (screen.height - height) / 2;

    height = offsetTop < 0 ? screen.height : height;
    offsetTop = Math.max(0, offsetTop);

    width = offsetLeft < 0 ? screen.width : width;
    offsetLeft = Math.max(0, offsetLeft);

    var left = "left", top = "top";
      if(has("ff")) {
       left = "screenX", top = "screenY";
    }
    var defaultOptions = "location=no, menubar=no, status=no, toolbar=no, "
                         + "scrollbars=yes, resizable=no";

      var newWin = dojo.global.open(url, name || "name",
      'width=' + width + ', height=' + height + ', ' +
      left + '=' + offsetLeft + ',' + top + '=' + offsetTop + ',' +
            defaultOptions );
    // Enforce the size of the window.
    newWin.resizeTo(width, height);

    // Enforce the position of the window
    newWin.moveTo(offsetLeft, offsetTop);
    newWin.focus();
  },

  adjustTargetContext: function(win, href) {
      if (win && win.dojo.global.jsScreenContext) {
        var oldContext = win.dojo.global.jsScreenContext;
        oldContext.updateStates(dojo.global.jsScreenContext);
      return curam.util.replaceUrlParam(href, "o3ctx", oldContext.getValue());
    }
    return href;
    // TO DO: what context is needed to return here if the conditional
    // returns false?
    // Will be looked at in TEC-7946
  },

  modifyUrlContext: function(url, addBits, clearBits) {
    var newUrl = url;
    var ctx = new curam.util.ScreenContext();
    var valueInUrl = curam.util.getUrlParamValue(url, "o3ctx");
    if (valueInUrl) {
      ctx.setContext(valueInUrl);
    } else {
      ctx.clear();
    }
    if (addBits) {
      ctx.addContextBits(addBits);
    }
    if (clearBits) {
      ctx.clear(clearBits);
    }
    newUrl = curam.util.replaceUrlParam(url, "o3ctx", ctx.getValue());
    return newUrl;
  },

  updateCtx: function(initialValue) {
  var valueInUrl = curam.util.getUrlParamValue(initialValue, "o3ctx");
  if (!valueInUrl) {
    return initialValue;
  }
    return curam.util.modifyUrlContext(initialValue, null, 'MODAL');
  },

  getFrameRoot: function(thisWindow, rootObjectName) {
    var found = false;
    var topRef = thisWindow;
    if (topRef) {
      while (topRef != top && !topRef.rootObject) {
        topRef = topRef.parent;
      }
      if (topRef.rootObject) {
        found = (topRef.rootObject == rootObjectName);
      }
    }

    return found ? topRef : null;
  },

  //Saves HTML for informational messages locally on the clients machine.
  //This is used by modal windows to store informational messages before they
  //shut down. The parent page then loads these messages using
  //curam.util.loadInformationalMsgs, and clears the local
  //stored versions, so they are only loaded once.
  saveInformationalMsgs: function(callback) {
      try {
        localStorage[curam.util.INFORMATIONAL_MSGS_STORAGE_ID] =
              json.toJson({
              //Store the page ID, so these messages are only loaded back onto
              //the same page as the one on which they were saved.
                pageID: windowBase.body().id,

              //Store the entire set of messages, including the header, the
              //<ul> element and it's contents. This will be used in most cases.
                total: dom.byId(curam.util.ERROR_MESSAGES_CONTAINER).innerHTML,

              //Save just the <li> elements. If the parent page already has
              //informational messages, these are appended to the existing list.
              //This should not happen really, but is possible. I think...
              //Either way, this doesn't hurt.
                listItems: dom.byId(curam.util.ERROR_MESSAGES_LIST).innerHTML
        });

      callback();

      } catch (e) {
        curam.debug.log(debug.getProperty("curam.util.exception"), e);
      }
    },

  //Disables the loading of informational messages on the current page.
  //This prevents the messages being cleared for a modal dialog's parent page
  //if the loadInformationalMsgs function runs on the page after the messages
  //are saved using the saveInformationalMsgs function.
  disableInformationalLoad: function() {
    curam.util._informationalsDisabled = true;
  },

  redirectDirectUrl: function() {
      ready(function(){
        if (dojo.global.parent == dojo.global) {
        var url = document.location.href;
        var idx=url.lastIndexOf("/");
        if (idx > -1) {
          if (idx <= url.length) {
           url = url.substring(idx + 1);
         }
        }

        dojo.global.location = jsBaseURL + "/AppController.do?o3gtu=" + encodeURIComponent(url);
      }
    });
  },

  //Loads any informational messages from local storage, and puts them
  //on the page. If they exist, they are wiped out, so that they only show once.
  loadInformationalMsgs: function() {
    ready(function() {
      // no informational messages are to be displayed within the context panel
        if(dojo.global.jsScreenContext.hasContextBits('CONTEXT_PANEL')) {
          return;
        }

      if(curam.util._informationalsDisabled) {
        return;
      }

      var msgs = localStorage[curam.util.INFORMATIONAL_MSGS_STORAGE_ID];

        // If informational messages are stored locally, insert them into the
        // page
        if(msgs && msgs != "") {
          //Deserialize the messages from text to a JSON object
            msgs = json.fromJson(msgs);

          //Wipe out the messages so they are only loaded once
          //We could use the dojox.storage.remove method here, but it is not
          //supported by all storage implementations, so just make it an empty
          //string.
          localStorage.removeItem(curam.util.INFORMATIONAL_MSGS_STORAGE_ID);
            var div = dom.byId(curam.util.ERROR_MESSAGES_CONTAINER);
            var list = dom.byId(curam.util.ERROR_MESSAGES_LIST);

          //Only load the messages on the same page as they were saved.
          //The body of each page has it's ID set, which is the name of the
          //UIM file, more or less, and is therefore unique.
            if(msgs.pageID != windowBase.body().id) {
            return;
          }

          // If there are somehow messages already on the page, do not override
          // them, just append to them.
          if(list) {
            //Don't append duplicate informational messages.
              var tempUL = domConstruct.create("ul", {
              innerHTML: msgs.listItems
            });

            //Create an array of the LI elements already in the list.
            var currentLIs = [];
            for(var i = 0; i < list.childNodes.length; i++) {
              if(list.childNodes[i].tagName == "LI"){
                currentLIs.push(list.childNodes[i]);
              }
            }

            //Go through the existing messages to check for duplicates
            //If no duplicate informational message exists, then append the
            //message to the existing list of messages.
            var skip = false;
            var nodes = tempUL.childNodes;
            for(var i = 0; i < nodes.length; i++) {
              skip = false;
              for(var j = 0; j < currentLIs.length; j++) {
                if(nodes[i].innerHTML == currentLIs[j].innerHTML) {
                  skip = true;
                  break;
                }
              }
              if(!skip) {
                list.appendChild(nodes[i]);
                i--;
              }
            }
          } else if(div){
            div.innerHTML = msgs.total;
          }
        }
        
        var informationalMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') : dom.byId('error-messages');
        if (informationalMessage && !dojo.global.jsScreenContext.hasContextBits("MODAL")) {
        
        // Keep focus on the tab if it was the last element selected, otherwise focus
        // on the informational message.
        if (curam.util.getTopmostWindow().curam.util.tabButtonClicked) {
          curam.util.getTopmostWindow().curam.util.getTabButtonClicked().focus();
          setTimeout(function() {
            // For accessibility purposes, the info message should still be announced
            // even when not focussed on. This triggers the screen reader to announce
            // the content
            informationalMessage.innerHTML = informationalMessage.innerHTML + " ";
          }, 500);
        } else {
            informationalMessage.focus();
          }
        }

        // A wrapper div element for an error message only exists for modals as defined in gen-jsp.
        // The explicit focus on this div is necessary for IE11 to fix an issue on an edge case
        // where both a non-modal page and a modal page have respectively error messages. This forces the
        // screen reader to announce the correct error message to the user.
        var informationalMessageOnModal = dom.byId('error-messages-container-wrapper');
        if (informationalMessageOnModal) {
          var modalErrorMessagesElement = query("#container-messages-ul", informationalMessageOnModal)[0];
          if (modalErrorMessagesElement){
            modalErrorMessagesElement.focus();
          }
        }
      });
  },
  /**
   * Sets the attribute tabindex for the currrent iframe and set the
   * focus. Created timeout to remove the attribute tabindex
   * after 10 miliseconds. Method called to allow JAWS sets forms mode 
   * on Edge Chromium browser.
   */
  _setFocusCurrentIframe: function(){
	var isEdge = /Edg/.test(navigator.userAgent);
	if(isEdge){
	  var currentIframe = window.frameElement;
      if(currentIframe){
	    currentIframe.setAttribute("tabindex", "0");
	    currentIframe.focus();
	    setTimeout(function(){
          currentIframe.removeAttribute("tabindex");
        },10);
      }

	}
  },

  /** 
   * sets focus to the input field with the biggest value
   * of tabindex property.
   */
	setFocus: function() {
		
    var setFocusTimeout;		   		
    if(window.document.getElementsByClassName("skeleton").length>0){			   
              setFocusTimeout=setTimeout(function (){curam.util.setFocus();},300);            
    }else{
	if(setFocusTimeout){
	  clearTimeout(setFocusTimeout);
     }
		   		
    var isFocusSetOn =curam.util.getTopmostWindow().dojo.global.focusSetOnCancelButton;
	if (isFocusSetOn) {
	 return;
	}
	curam.util._setFocusCurrentIframe();
    var isModal = 
        curam.util.getUrlParamValue(dojo.global.location.href, "o3frame") == "modal" || 
        (curam.util.getUrlParamValue(dojo.global.location.href, "o3modalprev") !== null && 
        curam.util.getUrlParamValue(dojo.global.location.href, "o3modalprev") !== undefined); //IE11
    if (!isModal) {
      // for pages in main content call setFocus here, modals will
      // do it differently in ModalDialog.js
        ready(function(){
          var errorMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') : dom.byId('error-messages');
          var curamDefaultActionId = sessionStorage.getItem('curamDefaultActionId');
          var focusField = null;
          if (!errorMessage && curamDefaultActionId) {
            sessionStorage.removeItem('curamDefaultActionId');
            focusField =  dojo.query(".curam-default-action")[0].previousSibling;
          } else {
            focusField = curam.util.doSetFocus();
          }
          if (focusField) {
            // Call util.setFocusOnField() function where browser specific focus handling occurs.
            // For example, if IE11/Edge is the current browser, there will be a delay before
            // the focus is set. If Chrome is the current browser, the field receives focus immediately.
            curam.util.setFocusOnField(focusField, false);
          } else {
            window.focus();
          }
        });
   	 }
   }
  },
  
  /**
   * Browser specific focus handling occurs here. For example, if IE11/Edge is the current browser,
   * there will be a delay before the focus is set. If Chrome is the current browser, the field
   * receives focus immediately.
   * 
   *  @param focusField The field to focus on.
   *  @param isModal Flag indicating whether the page is a modal or not.
   *  @param localizedModalFrameTitle Localized modal frame title text that's
   *  used when the current page is open in a modal.
   */
  setFocusOnField: function(focusField, isModal, localizedModalFrameTitle) {
    
    // If the browser is not IE11 or Edge, focus on the field immediately.
	  if (has('IE') || has('trident')) {
      
      // Constants for setting focus timeout threshold.
      // Textareas require a longer delay as JAWs forms mode is not triggered consistently with anything less.
      // Text input fields/combo boxes require a different timeout depending on whether the field is
      // present in a modal or tabbed page in order to help trigger forms mode in JAWs.
      var textAreaFocusDelayThreshold = 1000;
      var inputFocusDelayThreshold = isModal ? 200 : 500;
      
      // Creating a visually hidden input and focussing on that initially before focussing on the
      // actual focusField helps the screenreader switch to forms mode for the appropriate fields in IE11.
      curam.util._createHiddenInputField(focusField);

      // Function to execute after timeout threshold has been reached.
      var fnFocus = function(ff){
        return function() {

          var currentNode = ff.ownerDocument.activeElement;
          // do nothing if already focused on a form element
          if (currentNode.tagName === 'INPUT' && !currentNode.classList.contains('hidden-focus-input') 
              || currentNode.tagName === 'TEXTAREA'
              || (currentNode.tagName === 'SPAN' && currentNode.className == 'fileUploadButton')
              || (currentNode.tagName === 'A' && currentNode.className == 'popup-action')
              || (currentNode.tagName === 'IFRAME' && currentNode.classList.contains('cke_wysiwyg_frame'))) {
            return;
          } else {
            ff.focus();
          }
        
        } 
      };
      
      if(isModal) {
	  
        // Only update the aria-label when setting focus within a modal.
        var ownAria = attr.get(focusField, 'aria-label');
        var localizedTitle = "";
        // Cases for combo boxes where a subcomponent value is dependent on its main component's (component) selected value.
        // Both components have ojbid attributes respectively set as "component" and "subComponent".
        // Added case for stand-alone combo box.
        var componentObjId = attr.get(focusField,"objid");
        if (componentObjId && componentObjId.indexOf("component") == 0
            || domClass.contains(focusField,"dijitReset dijitInputInner")){
          localizedTitle = focusField.title;
        } else {
          localizedTitle = localizedModalFrameTitle
                             || 'Modal Dialog';
        }

        // Prevent aria-label with localizedTitle from being added to error-messages as it prevents the screen reader from
        // announcing the contents of the error messages list.
        if (focusField && focusField.id !== "container-messages-ul") {
          attr.set(focusField, 'aria-label', localizedTitle);
        }
        
        var restorer = function(oldAria) {
          return function(e) {
            query('input|select[aria-label=' + localizedTitle + ']')
              .forEach(function(entry) {
              oldAria && attr.set(entry, 'aria-label', oldAria);
              !oldAria && attr.remove(entry, 'aria-label');
              });
          }
        }
        on(focusField, 'blur', restorer(ownAria));
      }
      
      // Only fields that require user interaction need a delay in setting focus.
      // Textareas require a longer delay as forms mode is not triggered consistently with anything less.
      // Text input fields, comboboxes and select elements require a shorter delay to help trigger forms mode.
      // Any other element that receives focus and does not require forms mode in order for the user to interact
      // with it, will receive focus without any delay.
      if (focusField.tagName === 'TEXTAREA') {
        setTimeout(fnFocus(focusField), textAreaFocusDelayThreshold);
      } else if (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && attr.get(focusField, "type") === "text")) {
        setTimeout(fnFocus(focusField), inputFocusDelayThreshold);
      } else {
        focusField.focus();
      }
    } else {
      focusField.focus();
    }
  },
  
  /**
   * Creating a visually hidden input and focussing on that initially before focussing on the
   * actual focusField helps the screenreader switch to forms mode for the appropriate fields in IE11.
   * This is destroyed as soon as focus leaves the field.
   * 
   * @param focusField The field to focus on.
   */
  _createHiddenInputField: function(focusField) {
    
    var mainForm = focusField.ownerDocument.forms['mainForm'];
    // Only create the hidden input for fields that require forms mode to be automatically switched on.
    if (mainForm && (focusField.tagName === 'SELECT' || (focusField.tagName === 'INPUT' && attr.get(focusField, "type") === "text"))) {
      // Visually hide the input field.
      var hiddenInput = domConstruct.create("input", 
                        {"class": "hidden-focus-input", 
                         "style": "position: absolute; height: 1px; width: 1px; overflow: hidden; clip: rect(1px, 1px, 1px, 1px); white-space: nowrap;", 
                         "type": "text", 
                         "aria-hidden": "true", 
                         "tabindex": "-1"});
      domConstruct.place(hiddenInput, mainForm, "before");
      hiddenInput.focus();
      on(hiddenInput, 'blur', function(){domConstruct.destroy(hiddenInput)});
    }
  },

  /**
   * Set focus on the first editable field in the page. If there are no editable
   * fields, the function does not do anything. In case the first editable field
   * is a FilteringSelect widget than it skips the arrow and validation container
   * and sets the focus on the input container of FilteringSelect widget.
   *
   * @returns {Object} the field to focus on, or boolean false if no such
   * field was found. 
   */
  doSetFocus: function() {
	try {
    //return the tab button if the user is navigating through tabs
	  var tabButton = curam.util.getTopmostWindow().curam.util.getTabButtonClicked();
	  if(tabButton != false && !curam.util.isModalWindow()){
	    return tabButton;
	  }

	  var errorMessage = dom.byId('container-messages-ul') ? dom.byId('container-messages-ul') :  dom.byId('error-messages');
	  if (errorMessage) {
	    return errorMessage;
      }
        
	  var form = document.forms[0];
	  if (!form) {
	    return false; //no editable fields - nothing to do
	  }
      
	  
	  var fields = form.querySelectorAll(
	  'button, output, input:not([type="image"]), select, object, textarea, fieldset, a.popup-action, span.fileUploadButton');
	  var focusField = false;
	  var l = fields.length, el;
	  for (var i = 0; i < l; i++) {
	    el = fields[i];
	    // exception: draw focus on the dijit select if that happens to
	    // be first editable field (and not overridden).
	    if (!focusField && /selectHook/.test(el.className)){
	      focusField = query(el).closest('table')[0];
	    }
        if (!focusField && !(el.style.visibility=="hidden") && (
	      /select-one|select-multiple|checkbox|radio|text/.test(el.type)
	        || el.tagName == "TEXTAREA" || /popup-action|fileUploadButton/.test(el.className))
	        && !/dijitArrowButtonInner|dijitValidationInner/.test(el.className)) {
	       focusField = el;
	    }
	    if (el.tabIndex == '1') {
	      // reset the tab index to prevent it having an effect on
	      // screen tabbing.
	      el.tabIndex = 0;
	      focusField = el;
	      break; // once we've found an override, no need to keep looping.
	    }
      }
      //if the is no form field to put the focus on, the focus should go on the last opened tab.
      lastOpenedTabButton = curam.util.getTopmostWindow().curam.util.getLastOpenedTabButton();
      if(!focusField && lastOpenedTabButton) {            
          return lastOpenedTabButton;       
      }
      var dataPickerInputFirst = focusField.classList.contains("bx--date-picker__input");

      if(dataPickerInputFirst){
			
			var modalBody = document.querySelector(".bx--uim-modal");
			
			if(modalBody){
			   focusField = modalBody;
            }      
       }
	  return focusField;
	} catch(e) {
	  debug.log(debug.getProperty("curam.util.error.focus"), e.message);
	  return false;
	}
	return false;
  },

  openLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
    var target = event.target;
    while(target && target.tagName != "A") {
      target = target.parentNode;
    }
    var loc = target.href;
    var rpu = curam.util.getUrlParamValue(loc, "__o3rpu");
    // strip the __o3rpu parameter form the RPU value
    rpu = curam.util.removeUrlParam(rpu, "__o3rpu");
    var href="user-locale-selector.jspx" + "?__o3rpu=" + rpu;

      if (!curam.util.isActionPage(dojo.global.location.href)) {
      openModalDialog({href:href},"width=500,height=300",200,150);

    } else {
      alert(curam.util.msgLocaleSelectorActionPage);
    }

    return false;
  },
  
  /**
   * Opens the new Language selector modal.
   *
   * @param event 
   *          the click event on the Language menu-item. 
   */
  openLocaleNew: function(event) {
    dojoEvent.stop(event);

    if (event.target._curamDisable) {
      // link disabled, do nothing
      return;
    }

    require(["curam/tab"], function() {
      curam.tab.getTabController().handleLinkClick(
          "user-locale-selector.jspx", {dialogOptions:"width=300"});
    });
  },

  isActionPage: function(url) {
    var pageAndQuery = curam.util.getLastPathSegmentWithQueryString(url);
    var pageName = pageAndQuery.split("?")[0];
    return pageName.indexOf("Action.do") > -1;
  },

  closeLocaleSelector: function(event) {
      event = dojoEvent.fix(event);
      dojoEvent.stop(event);

      dojo.global.close();
    return false;
  },

  /**
   * Retrieves the remaining part of a class name which has the specified prefix.
   * E.g. for <theNode class="class1 class2 thePrefix-remaining-part-of-name" />
   * the call to curam.util.getSuffixFromClass(theNode, "thePrefix-")
   * will return "remaining-part-of-name".
   *
   * @param node
   *          The note to get the class from.
   * @param prefix
   *          The prefix to find the class by.
   * @returns
   *    If the class with the prefix is found it returns the remaining
   *    part of the class name. If the class is not found, returns null.
   *    If more than one class is found, it returns the first occurrence.
   */
  getSuffixFromClass: function(node, prefix) {
      var classes = attr.get(node, "class").split(" ");
      var namesFound = array.filter(classes, function(className) {
      return className.indexOf(prefix) == 0;
    });
    if (namesFound.length > 0) {
      return namesFound[0].split(prefix)[1];

    } else {
      return null;
    }
  },

  getCacheBusterParameter : function() {
    return this.CACHE_BUSTER_PARAM_NAME + "=" + new Date().getTime() + "_"
        + this.CACHE_BUSTER++;
  },

  /**
   * Add classes to table rows to allow striping in appearance.
   * Handles expandable and paginated lists in a specific way.
   */
  stripeTable: function(table, isExpandableList, lastVisibleRowIndex) {
    var tbody = table.tBodies[0];
    var mainRowStep = (isExpandableList ? 2 : 1);

    // for a list with one row do nothing
    if (tbody.rows.length < mainRowStep) {
      return;
    }

    var rows = tbody.rows;
    var oddRows = [], evenRows = [], isLast = false, lastRows = [], lastClass='';
    for (var i = 0, l = rows.length; i < l; i += mainRowStep) {
      //curam.debug.log("curam.util.stripeTable(%s, %s): i = %s", table, isExpandableList, i);
      var isEven = (i % (2 * mainRowStep) == 0), targetArray =  isEven ? evenRows : oddRows;
      domClass.remove(rows[i], ['odd-last-row','even-last-row']);
      targetArray.push(rows[i]);
      if (i == lastVisibleRowIndex) {
        lastRows.push(rows[i]);
        lastClass = isEven ? 'odd':'even';
        isLast = true;
      }
      if (isExpandableList && rows[i + 1]) {
        domClass.remove(rows[i+1], ['odd-last-row','even-last-row']);
    	targetArray.push(rows[i+1]);
    	isLast && lastRows.push(rows[i+1]);
      }
      isLast = false;
     }
     evenRows.forEach(function(evenRow){
       domClass.replace(evenRow, 'odd', 'even'); 
     });
     oddRows.forEach(function(oddRow){
       domClass.replace(oddRow, 'even', 'odd'); 
     });
     lastRows.forEach(function(lastRow){
       domClass.add(lastRow, lastClass+'-last-row');
     });
  },

  fillString: function(fillChar, count) {
    // summary:
    //  Creates a string of 'x' repeating characters
    var string = "";
    while (count > 0) {
      string += fillChar;
      count-=1;
    }
    return string;
 },

  updateHeader: function(qId, newHeader, answer, source) {
      var header = dom.byId('header_' + qId);
    header.firstChild.nextSibling.innerHTML = newHeader;
      answerCell = dom.byId('chosenAnswer_' + qId);
    answerCell.innerHTML = answer;
      sourceCell = dom.byId('chosenSource_' + qId);
    sourceCell.innerHTML = source;
  },

  search: function(textWidgetID, typeWidgetID){
     // summary:
     //              Invokes the required search page for an application search as
     //              specified by the associated configuration data. How this
     //              is done is described below:
     //
     // description:
     //              <ol>
     //                <li>
     //                  Retrieving the value of the business object select drop
     //                  down. This value includes a business object code and
     //                  also a page identifier.
     //                </li>
     //                <li>
     //                  Retrieving the value of the input text control which
     //                  specifies the search text to be used.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has been
     //                  specified in the associated configuration data, the
     //                  page identifier specified by the selected option will
     //                  be used to construct a URL using the
     //                  <code>searchText</code> and <code>searchType</code>
     //                  page parameters and that page is invoked.
     //                </li>
     //                <li>
     //                  If the drop list of business objects has not been
     //                  specified in the associated configuration data, the
     //                  default search page specified will be used to construct
     //                  a URL using the <code>searchText</code> page parameter
     //                  only and then that page is invoked.
     //                </li>
     //              </ol>
     //              <P>
     //              The data used here is generated by a renderer so therefore
     //              no validations are performed and it is assumed that the
     //              data is in the correct format for parsing.
     // textWidgetID:
     //              The identifier of the text input control for the application
     //              search which is used to retrieve the text to be used in the
     //              application search. The value taken from this field is
     //              associated with the <code>searchText</code> page parameter
     //              of the search page being invoked.
     // typeWidgetID:
     //              The identifier of the drop down control for the application
     //              search which is used to retrieve the business object type
     //              to be used in the application search. The value taken from
     //              this field is associated with the <code>searchType</code>
     //              page parameter of the search page being invoked. Note that
     //              this is optional as the list of business objects to search
     //              for is an optional element of an application search.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

        // Retrieve the search text from the input control.
      var searchText = registry.byId(textWidgetID).get("value");
    // The search type, if specified, from the drop down list of business
    // objects. This is a combination of the type and the page identifier
    // so split these out here.
      var searchTypeWidget = registry.byId(typeWidgetID);
          if (searchTypeWidget == null) {
                  searchTypeWidget = dom.byId(typeWidgetID);
          }
          var currentlySelectedItem = null;
          if(searchTypeWidget != null) {
                  if (searchTypeWidget.tagName == null) {
                        currentlySelectedItem
                  = searchTypeWidget ? searchTypeWidget.get("value"): null;
                  } else {
                        if (searchTypeWidget.tagName == 'SELECT') {
                          var options = query('.multiple-search-banner select option');
                          array.forEach(options, function(elem){
                                  if (elem.selected) {
                                          currentlySelectedItem = elem.value;
                                  }
                          });
                        }
                  }
          }
    var searchType = "";
    var pageIDFromSearchOptions;
    var tokens;

    if(currentlySelectedItem){
      // The currently selected item consists of the search type and the page
      // identifier to use in the search.
      tokens = currentlySelectedItem.split("|");
      searchType = tokens[0];
      pageIDFromSearchOptions = tokens[1];
    }

    var defaultSearchPageID = curam.util.defaultSearchPageID;

    // If the select box has not been specified, then the page identifier is
    // the default page identifier. Construct the page to be invoked.
    var searchPageURL = "";
    
    // Should the secure URLs exempt param be appended?
	if (sessionStorage.getItem('appendSUEP') === "true") {
	
	    if (searchType==="") {
	      searchPageURL = defaultSearchPageID + "Page.do?searchText="
	                                              + encodeURIComponent(searchText) 
	                                              + "&" + curam.util.secureURLsExemptParamName 
	                                              + "=" + encodeURIComponent(curam.util.secureURLsExemptParamsPrefix + "_ST1");
	    } else {
	      searchPageURL = pageIDFromSearchOptions + "Page.do?searchText="
	                          + encodeURIComponent(searchText) + "&searchType="
	                            + encodeURIComponent(searchType) + "&" 
	                            + curam.util.secureURLsExemptParamName 
	                            + "=" + encodeURIComponent(curam.util.secureURLsExemptParamsPrefix 
	                            + "_ST1,"+ curam.util.secureURLsExemptParamsPrefix +"_ST2");
	    }
    } else {
	
	    if (searchType==="") {
	      searchPageURL = defaultSearchPageID + "Page.do?searchText="
	                                              + encodeURIComponent(searchText);
	    } else {
	      searchPageURL = pageIDFromSearchOptions + "Page.do?searchText="
	                          + encodeURIComponent(searchText) + "&searchType="
	                            + encodeURIComponent(searchType);
	    }
    }
    // Call the function that will load the search page.
    var searchPageRequest = new curam.ui.PageRequest(searchPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(searchPageRequest);
    });
  },

  updateDefaultSearchText: function(typeWidgetID, textWidgetID){
    // summary:
    //              Updates the search text input control in the application
    //              search widget with some initial text from the item selected
    //              in the associated list of search business objects.
    //
    // description:
    //              Retrieves the initial text from the item selected in the list
    //              of business objects drop down and sets the place holder
    //              attribute of the application search text input control with
    //              this initial text. This is called from the
    //              <code>onChange()</code> event of the application search drop
    //              down list.
    // typeWidgetID:
    //              The identifier of the drop down control for the application
    //              search which is used to retrieve the initial text that is
    //              set in the place holder attribute of the associated text
    //              input control each time the value of the drop down list
    //              is changed. This initial text acts as an aid to the user
    //              when performing the search as it offers them a hint as to
    //              what should be entered into the text area for the type of
    //              search being performed.
    // textWidgetID:
    //              The identifier of the text input control whose place
    //              holder attribute will be set with initial text to aid the
    //              user perform the search.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

      var searchTypeWidget = registry.byId(typeWidgetID);
      var textWidget = registry.byId(textWidgetID);
      var currentlySelectedItem = searchTypeWidget ? 
    		  searchTypeWidget.get("value"): null;
      // The initial text is the third token in the string.
      var str = currentlySelectedItem.split("|")[2];

      textWidget.set("placeHolder", str);
      topic.publish('curam/application-search/combobox-changed', 
    		  currentlySelectedItem);
  },

  updateSearchBtnState: function(textWidgetID, btnID){
    // summary:
    //              Enables or disables the search anchor for an application
    //              search depending on whether this is text specified for the
    //              search.
    //
    // description:
    //              The search anchor specified for an application search is
    //              disabled if no text has been specified in the text input
    //              control. This function is called on the
    //              <code>onKeyPress</code> of the text input control so that when
    //              a user enters some text, the search anchor is enabled to allow
    //              that user perform the search.
    // textWidgetID:
    //              The identifier of the text input control for the application
    //              search which is used to determine if that text box contains
    //              any text. If it does, then the search anchor is enabled,
    //              otherwise it is disabled.
    // btnID:
    //              The identifier of the search anchor for the application search
    //              and this is used to retrieve the control to enable or disable
    //              depending on whether there is text in the associated search
    //              text input control.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.
      var widget = registry.byId(textWidgetID);
      var btn = dom.byId(btnID);
      var value = widget.get("value");

      if(!value || lang.trim(value).length < 1){
        domClass.add(btn, "dijitDisabled");
      } else {
        domClass.remove(btn, "dijitDisabled");
    }
  },

  furtherOptionsSearch: function() {

    // summary:
    //              Invokes the page specified for the further options link
    //              in an application search.
    //
    // description:
    //               The further options search page is invoked by retrieving
    //               the page identifier specified in the configuration
    //               data, constructing a page request for that URL and
    //               calling the function to handle that request.
    //               <P>
    //               Validations performed elsewhere should ensure that the
    //               data is specified in the correct fashion and hence there
    //               are no validations invoked here.

    // TODO: Move this function into the application view JavaScript file when
    // it becomes available -- FG.

    // Retrieve the page identifier for the further options link.
    var furtherOptionsPageURL = curam.util.furtherOptionsPageID + "Page.do";

    // Call the function that will load the search page.
    var furtherSearchOptionsPageRequest
        = new curam.ui.PageRequest(furtherOptionsPageURL);
    require(["curam/tab"], function() {
      curam.tab.getTabController().handlePageRequest(
          furtherSearchOptionsPageRequest);
    });
  },

  searchButtonStatus: function(btnID){
    // summary:
        //              Returns true if the button is not disabled
        //
        // description:
        //              The search anchor specified for an application search is
        //              disabled if no text has been specified in the text input
        //              control. This function is called on the
        //              <code>onKeyPress</code> of the text input control if this function returns true.
        // btnID:
        //              The identifier of the search anchor for the application search
        //              and this is used to retrieve the control to enable or disabled
        var btn = dom.byId(btnID);
        if(!domClass.contains(btn,"dijitDisabled")){
          return true;
        }
  },

  /**
  * Return the height of the page contents for the current width.
  * Note that if the width changes, the contents height might change as well.
  *
  * Note: this algorithm is dependent on the structure of the
  * DOM. Changes to the page layout will probably break this.
  *
  * @return page height.
  */
  getPageHeight: function() {
    var defaultHeight = 400;
    var resultingHeight = 0;

      if (query("frameset").length > 0) {
      /* Detect framesets and use default height for them.
      * Normally frameset windows should have fixed height specified
      * by the developer, but this is for the cases in which the developer
      * forgets to specify the height.
      */
      curam.debug.log(
        "curam.util.getPageHeight() "
          + debug.getProperty("curam.util.default.height"),
      defaultHeight);
      resultingHeight = defaultHeight;

    } else {
      // create function for determinning bottom coordinate of an element
      var bottom = function(node) {
        if (!node) {
          curam.debug.log(debug.getProperty("curam.util.node"));
          return 0;
        }

        // Use getMarginBoxSimple if it's available
          var mb = geom.getMarginSize(node);
          var pos = geom.position(node);

        return pos.y + mb.h;
      };

        if (dojo.global.jsScreenContext.hasContextBits('LIST_ROW_INLINE_PAGE')) {

        // if we are in list details row, just use the content div
        var contentDiv = query("div#content")[0];
        var contentBottom = bottom(contentDiv);
        curam.debug.log(debug.getProperty("curam.util.page.height"), contentBottom);
        resultingHeight = contentBottom;

      } else {
          var contentObj = dom.byId("content") || dom.byId("wizard-content");

        // find the bottom-most node
          var nodes = query("> *", contentObj).filter(function(n) {
          // leave out script and hidden nodes
          return n.tagName.indexOf("SCRIPT") < 0
            && style.get(n, "visibility") != "hidden"
            && style.get(n, "display") != "none";
        });
        var bottomNode = nodes[0];
        for (var i = 1; i < nodes.length; i++) {
          if(bottom(nodes[i]) >= bottom(bottomNode)) {
            bottomNode = nodes[i];
          }
        }
        // first count in the main contents height
        resultingHeight = bottom(bottomNode);
        curam.debug.log("curam.util.getPageHeight() "
            + debug.getProperty("curam.util.base.height"), resultingHeight);

        // count in modal dialog action set, if present
        var doesActionSetExist = query(".actions-panel", windowBase.body());

        if (doesActionSetExist.length > 0) {
          // Only one actions panel exists in one modal, we can get the height
          // of this panel dynamically.
          var actionsPanelHeight = geom.getMarginBox(doesActionSetExist[0]).h;

          curam.debug.log("curam.util.getPageHeight() "
              + debug.getProperty("curam.util.panel.height"));

          // Add the actions panel height to the total page height, here we
          // presume the actions panel is always positioned at the bottom of
          // the page.
          resultingHeight += actionsPanelHeight;

          // Then add additional 10px spacing at the top of the actions panel.
          resultingHeight += 10;
        }

        // in case we are in the details panel, count in the title bar height
          var detailsPanel = query("body.details");
        if (detailsPanel.length > 0) {
          curam.debug.log("curam.util.getPageHeight() "
              + debug.getProperty("curam.util.bar.height"));
            resultingHeight += 20;
        }
      }
    }

      curam.debug.log("curam.util.getPageHeight() "
          + debug.getProperty("curam.util.returning"), resultingHeight);
    return resultingHeight;
  },

  /**
  * Takes an array and from its elements it creates a comma separated
  * string of values, which is then returned.
  */
  toCommaSeparatedList: function(inputArray) {
    var result = "";
    for (var i = 0; i < inputArray.length; i++) {
      result += inputArray[i];
      if (i < inputArray.length -1) {
        result += ",";
      }
    }
    return result;
  },


  

  /**
  * Registers a handler for submitting a form when Enter key is pressed.
  *
  * Called from the PageTag - will be called on every page in any context,
  * main content, dialog, etc.
  */
  setupGenericKeyHandler: function() {
      ready(function() {
      // The handler is never explicitly deregistered - disappears when
      // the runtime context is destroyed (new page loaded)
      var f = function(event) {

        // On ESC key handling: When ESC key is pressed and in a modal,
        // the modal will close automatically.
        if (dojo.global.jsScreenContext.hasContextBits('MODAL')
            && event.keyCode == 27) {
          var ev = dojoEvent.fix(event);
          var dropdown = registry.byId(ev.target.id);
          var isDropdown =
            typeof dropdown != "undefined" && dropdown.baseClass == "dijitTextBox dijitComboBox";
          if (!isDropdown) {
            curam.dialog.closeModalDialog();
          }
        }

        // On ENTER key handle the event
        if (event.keyCode == 13) {
            var ev = dojoEvent.fix(event);

        // only submit form when certain input fields have focus. This allows
        // for normal keyboard selection (example: pressing enter on date
        // selector icon) to happen without the form submitting.

    var isText = ev.target.type == "text";
    var isRadio = ev.target.type == "radio";
    var isCheckbox = ev.target.type == "checkbox";
    var isMultiSelect = ev.target.type == "select-multiple";
    var isPassword = ev.target.type == "password";

    var combo = registry.byId(ev.target.id);
    // Added a check so that form is not submitted when "Enter" key
    // is pressend in open state of dropdown.
    if (typeof combo != "undefined") {
      var comboWidget = registry.byId(ev.target.id);
      if (!comboWidget) {
        comboWidget = registry.byNode(dom.byId("widget_" + ev.target.id));
      }
      if(comboWidget && comboWidget.enterKeyOnOpenDropDown) {
        comboWidget.enterKeyOnOpenDropDown = false;
        return false;
      }
    }
    
    var carbonAttachPoint = ev.target.getAttribute("data-carbon-attach-point");
    if (carbonAttachPoint && carbonAttachPoint === 'carbon-menu') {
    	return false;
    }

    var isCombo =
    typeof combo != "undefined" && combo.baseClass == "dijitComboBox";
    if ((!isText && !isRadio && !isCheckbox && !isMultiSelect
    && !isPassword) || isCombo ) {
      return true;
    }
    var defaultSubmitButton = null;
      var explicitDefaultBtnArray = query(".curam-default-action");
    // take the default button if set
    if (explicitDefaultBtnArray.length > 0) {
      defaultSubmitButton = explicitDefaultBtnArray[0];

    } else {
      // otherwise take the first found submit button
        var submitButtonsArr = query("input[type='submit']");
      if (submitButtonsArr.length > 0) {
        defaultSubmitButton = submitButtonsArr[0];
      }
    }
    // now click the button found
    if (defaultSubmitButton != null) {
        dojoEvent.stop(dojoEvent.fix(event));
      curam.util.clickButton(defaultSubmitButton);
      return false;
    }
      //Focus remains in the date selector on ENTER
      require(["curam/dateSelectorUtil"], function(selectorUtil) {
        var isInputyear = dom.byId("year");
        if (isInputyear) {
          dojo.stopEvent(dojo.fixEvent(event));

          //Enter key updates the calendar
          selectorUtil.updateCalendar();
        }
     });

     }

     // otherwise let the event continue
       return true;
     };

     // event must be onKeyUp, as the ESC key event is not fired during an
     // onKeyPress event.
     curam.util.connect(windowBase.body(), "onkeyup", f);
  });
  },

  /**
  * Returns true is key press event is triggered by the enter key.
  * Used by context panel toggle icon and list/cluster toggle icons.
  */
  enterKeyPress: function(event) {
    if(event.keyCode == 13) {
      return true;
    }
  },

  /**
  * Given a DOM node, boolean state and class names for true and false
  * alternatives, the function sets the appropriate classes on the node.
  */
  swapState: function(node, state, classTrue, classFalse) {
    if (state) {
        domClass.replace(node, classTrue, classFalse);

    } else {
        domClass.replace(node, classFalse, classTrue);
    }
  },

  /**
  * Creates a URL query string including the leading question mark
  * from the specified page parameters.
  * The function handles URL-encoding of the values so do NOT encode them.
  *
  * @param params Object in the following format:
  *                { param1Name:"value", param2Name:248 }
  */
  makeQueryString: function(params) {
    if (!params || params.length == 0) {
      return "";
    }

    var result = [];
    for (var paramName in params) {
      result.push(paramName + "=" + encodeURIComponent(params[paramName]));
    }

    return "?" + result.join("&");
  },

  /**
   * Handles the onClick event for file download anchor tags.
   *
   * Subscribes to the window close event, opens a yes/no dialog, then when publish happens
   * it checks the chosen option and if 'confirm' it calls the clickHandlerForListActionMenu
   * function. The url parameter is passed to clickHandlerForListActionMenu function.
   *
   * @param url
   *          The URL of the file download servet.
   */
  fileDownloadAnchorHandler: function(url) {
    // Subscribe downloadOnConfirm function to the window closing event
    var topmostWin = curam.util.getTopmostWindow();
    var unsToken = topmostWin.dojo.subscribe("/curam/dialog/close", function(id, option) {
      if(option === 'confirm') {
        curam.util.clickHandlerForListActionMenu(url, false, false);
      }
      topmostWin.dojo.unsubscribe(unsToken);
    });

    // Get the dialog window width and height from properties file
    var bundle = new resBundle("GenericModalError");
    var width = bundle.getProperty("file.download.warning.dialog.width");
    var height = bundle.getProperty("file.download.warning.dialog.height");
    if(!width) {
      width = 500; // Default value
    }
    if(!height) {
      height = 225; // Default value
    }

    // Show an ok/cancel dialog with browser-specific security steps
    var browserName = curam.util._getBrowserName();
    curam.util.openGenericErrorModalDialogYesNo(
        "width="+width+",height="+height,
        "file.download.warning.title",
        "file.download.warning."+browserName);

    return false; // Return false so that initial onclick event does not download the file
  },

  /**
   * Handles the onClick event for file download list action menu items.
   *
   * Subscribes to the window close event, opens a yes/no dialog, then when publish happens
   * it checks the chosen option and if 'confirm' it calls the clickHandlerForListActionMenu
   * function. The method parameters are all passed to clickHandlerForListActionMenu function.
   *
   * @param url
   *          The URL of the file download servet.
   */
  fileDownloadListActionHandler: function(url, sameDialog, newWindow, event) {
    // Subscribe downloadOnConfirm function to the window closing event
    var topmostWin = curam.util.getTopmostWindow();
    var unsToken = topmostWin.dojo.subscribe("/curam/dialog/close", function(id, option) {
      if(option === 'confirm') {
        curam.util.clickHandlerForListActionMenu(url, sameDialog, newWindow, event);
      }
      topmostWin.dojo.unsubscribe(unsToken);
    });

    // Get the dialog window width and height from properties file
    var bundle = new resBundle("GenericModalError");
    var width = bundle.getProperty("file.download.warning.dialog.width");
    var height = bundle.getProperty("file.download.warning.dialog.height");
    if(!width) {
      width = 500; // Default value
    }
    if(!height) {
      height = 225; // Default value
    }

    // Show an ok/cancel dialog with browser-specific security steps
    var browserName = curam.util._getBrowserName();
    curam.util.openGenericErrorModalDialogYesNo(
        "width="+width+",height="+height,
        "file.download.warning.title",
        "file.download.warning."+browserName);
  },

  /**
   * Gets the browser name. Returns a string, e.g. "ie8", "ie11", "firefox", etc.
   */
  _getBrowserName: function() {
    var tridentVersion = has("trident");
    var ffBrowserVersion = dojo.isFF;
    var chromeBrowserVersion = dojo.isChrome;
    var safariBrowserVersion = dojo.isSafari;
    var topmostWin = curam.util.getTopmostWindow();
    var isExternalApp = curam.util.ExpandableLists._isExternalApp(topmostWin);

    if (tridentVersion != undefined) {
      /*
       * We are assuming here that Microsoft will keep to the pattern of Trident
       * being 4 versions behind IE, i.e. IE8 = Trident 4, IE9 = Trident 5, etc.
       * If they change this pattern then we will need to modify the conditional
       * statements below.
       */
      var ieVersion = tridentVersion + 4;
      if(ieVersion < 8) {
        return "unknown.browser"; // IE7 and below are not supported
      } else {
        return "ie" + ieVersion;
      }
    } else if (ffBrowserVersion != undefined && isExternalApp) {
      return "firefox";
    } else if (chromeBrowserVersion != undefined) {
      return "chrome";
    } else if (safariBrowserVersion != undefined && isExternalApp) {
      return "safari";
    }
    return "unknown.browser"; // Unknown or unsupported browser
  },

 /**
  * Handles the onClick event for the list action menu items.
  *
  * @param url
  *          The URL of the required page.
  * @param sameDialog
  *          True if we re in a dialog and the page flow should stay
  *          in the same dialog.
  */
    clickHandlerForListActionMenu: function(url, sameDialog, newWindow, event) {
    // TODO: This handler was intended only for the list row actions menu but
    // is now being used for page level actions menus also, so re-name
    // appropriately. Also, *some* of the code in this method is duplicated
    // in the "clickHandler" method of UIMPageAdaptor.js. AS LONG AS THESE
    // METHODS ARE SEPARATE, ANY UPDATES TO THE LOGIC BELOW MUST BE ANALYZED
    // TO SEE IF THEY NEED TO BE APPLIED IN THE "UIMPageAdaptor" CLASS.
    if (sameDialog) {
      var href = curam.util.replaceUrlParam(url, "o3frame", "modal");
        var ctx = dojo.global.jsScreenContext;
      ctx.addContextBits('MODAL');
      href = curam.util.replaceUrlParam(href, "o3ctx", ctx.getValue());
      curam.util.redirectWindow(href);
      return;
    }

    // create a dummy anchor object
    var anchor = { href: url };

    require(["curam/ui/UIMPageAdaptor"]);
    if (curam.ui.UIMPageAdaptor.allowLinkToContinue(anchor)) {
      // In the case of a list action menu the click event is no longer coming
      // from an anchor element, instead it's a Diji MenuItem. Explicitly
      // setting window.location fakes the same behaviour as clicking the anchor
      // element. This will handle the sceanrios tested by allowLinkToContinue,
      // which are file downloads and the mailto link.
      // TODO: Can this method just return and let the event continue without
      // setting window.location....??? Seems to be other event handers
      // supressing this, so going with this approach for now.
      if (anchor.href.indexOf("/servlet/FileDownload")) {
        // When downloading a file, setting dojo.global.location will trigger the
        // addOnUnload event for each iframe with a addOnUnload attached. In this  
        // file downloading scenario we do not want these addOnUnload events to clear 
        // the contents of these iframes.
        sessionStorage.setItem("addOnUnloadTriggeredByFileDownload", "true");
        dojo.global.location = url;
        sessionStorage.removeItem("addOnUnloadTriggeredByFileDownload");
      } else {
        dojo.global.location = url; 
      }
      return;
    }

    // if we have an anchor, stop the click event and perform standard tab
    // processing (i.e. should it open in a new tab etc.)
    if (anchor != null) {
        if (event) {
          dojoEvent.fix(event);
          dojoEvent.stop(event);
      }

      if (!anchor.href || anchor.href.length == 0) {
        // the event has been stopped, just return if it has no href.
        // any onclick handlers attached to the link will have executed by now.
        return;
      }
      if (newWindow && !curam.util.isInternal(url)) {
          dojo.global.open(url);

      } else if (curam.ui.UIMPageAdaptor.isLinkValidForTabProcessing(anchor)) {
        var uimPageRequest = new curam.ui.PageRequest(anchor.href);
        if (dojo.global.jsScreenContext.hasContextBits("LIST_ROW_INLINE_PAGE")
          || dojo.global.jsScreenContext.hasContextBits("NESTED_UIM")) {
          uimPageRequest.pageHolder = dojo.global;
        }
        require(["curam/tab"], function() {
          var tabController = curam.tab.getTabController();
          if(tabController) {
            tabController.handlePageRequest(uimPageRequest);
          }
        });
      }
    }
    // Otherwise we let the event continue uninterrupted.
  },

  /**
     * Gets browser to action a mailto: link in a separate iframe.
     * This is to avoid issues with page unloading when mailto link is clicked
     * on some browsers.
     *
     * @param event The onclick DOM event.
     * @param url The URL of the link, including the mailto: protocol.
     */
    clickHandlerForMailtoLinks: function(event, url) {
      // stop anchor click from propagating and changing page
      dojo.stopEvent(event);

      // is there existing iframe to reuse?
      var iframe = dojo.query("#mailto_frame")[0];
      if (!iframe) {
        // no frame to reuse - create a new one
        iframe = dojo.io.iframe.create("mailto_frame", "");
      }

      // get browser to action the mailto: link in separate frame
      iframe.src = url;

      // return false as per convention for DOM click handlers
      return false;
    },

    /**
  * Decides whether or not the URL is internal.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns true if the URL is internal false it it is external.
  */
  isInternal: function(url) {
    var path = url.split("?")[0];
    // Occurrence of Page.do determines whether or not it is internal URL.
    // It is assumed that, the external URL's would not have Page.do as it
    // fixed internal action call for curam.
    // TODO : Determining the URL is internal based on Page.do is a
    // brittle solution.Implement the improved solution.
    var occurrence = path.match("Page.do");
    if (occurrence!= null) {
      return true;
    }
    return false;
  },

  /**
  * Takes a URL and extracts its last path segment with the query string.
  *
  * @param {String} url
  *            URL to extract data from.
  *
  * @returns The last path segment of the URL with the query string,
  *      if it is part of the URL.
  */
  getLastPathSegmentWithQueryString: function(url) {
    var pathAndParams = url.split("?");
    var pathComponents = pathAndParams[0].split("/");
    return pathComponents[pathComponents.length - 1]
    + (pathAndParams[1] ? "?" + pathAndParams[1] : "");
  },

  /**
  * Replaces standard submit buttons with anchor tags when no images are used.
  * @param {String} buttonText
  *            The text to be displayed on submit button.
  */
  replaceSubmitButton: function(name, buttonText, isCustomSecondaryButton, newbuttonid, hasOnClickFunction) {
    if(curam.replacedButtons[name] == "true") {
      return;
    }

    /*
    * In the agenda player search for input elements where the name attribute
    * ends with SUM. This is required because an extra string of SUM is
    * appended onto the end of the name attribute value in the agenda player.
    * For all other submit buttons in the application we'll search for the
    * input fields the normal way to ensure we're not breaking any older
    * functionality.
    */
    var buttonId = '__o3btn.' + name;
    var inputList;
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
        inputList = query("input[id='" + buttonId + "']");

    } else {
        inputList = query("input[name='" + buttonId + "']");
    }

    /*
    * You can supply 3 parameters to the forEach method of the dojo node list.
    * The current node, the index, and the node list itself.
    */
    inputList.forEach(function(replacedButton, index, theButtons) {
      // if there is a paramter passed in for button text then set the 'value'
      // of the second button (the button dipalyed to user) node to the button
      // text specified.
      // Note: This will replace any value set in the value attribute already!
      if (buttonText) {
        var buttonDisplayed = theButtons[1];
        buttonDisplayed.setAttribute("value",buttonText);
      }
      replacedButton.tabIndex = -1;
      var parentSpan = replacedButton.parentNode;
      var newLink;
      
      var isInternalModalFooter = curam.util.isInternalModal() && curam.util.isModalFooter(replacedButton);

      var buttonId = "btn-id-" + index;
      
      var cssClass = 'ac initially-hidden-widget ' + buttonId;
      if(domClass.contains(replacedButton, "first-action-control")) {
        cssClass += ' first-action-control';
      }
      
      if (isInternalModalFooter) {
    	 // for internal modal render the button using carbon
      	var submitButton = (isCustomSecondaryButton && !hasOnClickFunction) ?  undefined : theButtons[0];

    	// From a handcrafted JSP set the href to blank which will just close the dialog!
    	var buttonJson = isCustomSecondaryButton ?  {"href":"", "buttonid": newbuttonid} : {"buttonid": newbuttonid};
    	var rawDataTestID = replacedButton.getAttribute('data-rawtestid');
    	if (rawDataTestID) {
    	  buttonJson.dataTestId = rawDataTestID;
    	}
    	var isDefaulSubmitButton = domClass.contains(replacedButton, "curam-default-action") ? true : false;
      	curam.util.addCarbonModalButton(buttonJson, replacedButton.value, submitButton, isDefaulSubmitButton);
      } else {
		curam.util.setupWidgetLoadMask("a." + buttonId);
		var cssClass = 'ac initially-hidden-widget ' + buttonId;
	    if(domClass.contains(replacedButton, "first-action-control")) {
	      cssClass += ' first-action-control';
	    }
	
       var newLink = domConstruct.create("a", {
         "class": cssClass,
         href: "#"
       }, replacedButton, "before");

       var pageLevelMenu = dojo.query(".page-level-menu")[0];
       if(pageLevelMenu) {
         attr.set(newLink,"title",replacedButton.value);
       }

       /*
        * Adding filler span to create spacing between buttons. This is needed
        * because if spacing is added to anchor element using CSS, the spacing is
        * still clickable in IE.
        */
        domConstruct.create("span", {
          "class": "filler"
        }, newLink, "before");

        // Adding span elements inside anchor tag to display rounded corners.
        var left = domConstruct.create("span", {
          "class": "left-corner"
        }, newLink);

        var right = domConstruct.create("span", {
          "class": "right-corner"
        }, left);

        // Changed from using inner HTML.
        var middle = domConstruct.create("span", {
        "class": "middle"}, right );

        middle.appendChild(document.createTextNode(replacedButton.value));

        curam.util.addActionControlClass(newLink);
      }
	     

      if (newLink) {
	    on(newLink, "click", function(event) {
	      curam.util.clickButton(this._submitButton);
          dojoEvent.stop(event);
        });
	 
	    /*
        * Record the submit button on the link. This is for modal dialogs, so it
        * can distinguish a submit anchor tag from a normal anchor tag.
        *
        * NB: We have a temporary situation where we have 3 page-level-action
        * sets. 2 actions sets are the existing top and bottom ones, but they are
        * currently hidden. The third is the new button bar at the bottom of the
        * page. This is outside of the HTML form which means the "_submitButton"
        * variable was being set to a button that didn't have an associated form.
        * This caused errors in our modal dialog code. The temporary solution is
            * to set all _submitButtons to the first button found (theButtons[0])
            * which is guaranteed to be inside the form. The real solution
            * is to re-do the new button bar work so it is within the form.
        */
        newLink._submitButton = theButtons[0];
      }
	         

      domClass.add(replacedButton, 'hidden-button');
      attr.set(replacedButton, "aria-hidden", "true");
    
      /* 
       * TODO: ID of the button will be duplicated on the page, as the same 
       * ACTION_CONTROL can appear multiple times on the page. This ID is
       * connected to the ACTION_IDENTIFIER attribute, and causes knock-on
       * effects on buttons in various contexts.
       */
       attr.set(replacedButton, "id", replacedButton.id + "_" + index);
	         
	});

	curam.replacedButtons[name] = "true";
  },
	  
  /**
   * Indicates that the modal is in the internal application.
   */
  isInternalModal: function() {
    return !dojo.global.jsScreenContext.hasContextBits('EXTAPP') && dojo.global.jsScreenContext.hasContextBits('MODAL');
  },
  
  /**
   * Indicates that the modal is in the internal application and that the node is at the higest level in the modal
   * i.e not a hidden input on a form or wtihin a cluster on a modal.
   */
  isModalFooter: function(targetNode) {
	  if (targetNode) {
		var grandParentNode = targetNode.parentNode.parentNode;
		return grandParentNode && grandParentNode.id == "actions-panel";
	  }	
  },
  
  /**
   * Adds a button to modal footer.
   */
  addCarbonModalButton: function(buttonJson, buttonText, submitButton, isDefaultSubmitButton) {
    curam.util.getTopmostWindow().dojo.publish("/curam/CuramCarbonModal/addModalButton", [buttonJson, buttonText, submitButton, isDefaultSubmitButton, window]);
  },
	  

  /**
  * Adds a listener that will display the widget specified by query.
  *
  *  @param query
  *      Query of the widget to setup load mask for.
  */
  setupWidgetLoadMask: function(queryString) {
    curam.util.subscribe('/curam/page/loaded', function() {
        var widget = query(queryString)[0];
      if (widget) {
          style.set(widget, 'visibility', 'visible');

      } else {
        curam.debug.log("setupButtonLoadMask: "
          + debug.getProperty("curam.util.not.found") + "'" + queryString
         + "'" + debug.getProperty("curam.util.ignore.mask"));
      }
    });
  },

  /**
  * Optionaly replaces standard submit buttons within agenda player.
  */
  optReplaceSubmitButton: function(name) {
    if (curam.util.getFrameRoot(dojo.global,"wizard") == null) {
      curam.util.replaceSubmitButton(name);
      return;
    }
    var navigator = curam.util.getFrameRoot(dojo.global,"wizard").navframe.wizardNavigator;
    if (navigator.delegatesSubmit[jsPageID] != 'assumed') {
      curam.util.replaceSubmitButton(name);
    }
  },

  /**
  * Clicks a HTML button.
  *
  * @param buttonObj the button object or the id of the button object.
  */
  clickButton: function(buttonObj) {
      var theForm = dom.byId("mainForm");
    var hiddenButton;

    // if we have no argument, then return
    if (!buttonObj) {
      curam.debug.log("curam.util.clickButton: "
        + debug.getProperty("curam.util..no.arg"));
      return;
    }

    // if the argument is a string, then we assume it is the id of the
    // input element and search for it.
    if (typeof(buttonObj) == "string") {
      var buttonObjID = buttonObj;
      curam.debug.log("curam.util.clickButton: "
        + debug.getProperty("curam.util.searching")
        + debug.getProperty("curam.util.id.of") + "'" + buttonObjID + "'.");
        buttonObj = query("input[id='"  + buttonObjID + "']")[0];
        
        if (!buttonObj) {
          buttonObj = query("input[name='"  + buttonObjID + "']")[0];
        }
        

      // if we still have not found the input element, the return
      if (!buttonObj.form && !buttonObj.id) {
        curam.debug.log("curam.util.clickButton: "
            + debug.getProperty("curam.util.searched")
            + debug.getProperty("curam.util.id.of") + "'" + buttonObjID
            + debug.getProperty("curam.util.exiting"));
        return;
      }
    }

    // In the agenda player search for input elements where the name attribute
    // ends with SUM. This is required because an extra string of SUM is
    // appended onto the end of the name attribute value in the agenda player.
    // For all other submit buttons in the application we'll search for the
    // hidden buttons the normal way to ensure we're not breaking any older
    // functionality.
      if (dojo.global.jsScreenContext.hasContextBits('AGENDA')) {
      hiddenButton = buttonObj;

      } else {
        hiddenButton = query("input[id='" + buttonObj.id + "']", theForm)[0];
        if (!hiddenButton) {
          hiddenButton = query("input[name='" + buttonObj.name + "']", theForm)[0];
        }
    }
    try {
      // if the page is being submitted to self, publish event to enable
      // code to be run before refresh - used for example for saving list state
      // data to be restored on the page reload
        if (attr.get(theForm, "action").indexOf(jsPageID) == 0) {
        curam.util.publishRefreshEvent();
      }
      hiddenButton.click();

    } catch(e) {
      curam.debug.log(debug.getProperty("curam.util.exception.clicking"));
    }
  },

  /**
   * Handles click event on the page level print button.
   * Invokes the windows print function to print the context panel
   * and main content area.
   *
   * @param event the click event object.
   *
   */
  printPage:function(printContextPanelEnabled, event) {
    dojoEvent.stop(event);
	    
    var mainAreaWindow = dojo.window.get(event.currentTarget.ownerDocument);

    // Only printing the main content area when context
    // panel printing is disabled.
    if (printContextPanelEnabled === false) {
      curam.util._printMainAreaWindow(mainAreaWindow);    
      return false;
    }
    
    var mainAreaIframeNode = mainAreaWindow.frameElement;
    var searchNode = mainAreaIframeNode;

    // find the tab conent holder div which holds each tab.
    while(searchNode && !domClass.contains(searchNode, "tab-content-holder")) {
      searchNode = searchNode.parentNode;
    }

    var tabContentHolderNode = searchNode;

    var contextPanel = dojo.query(".detailsPanelFrame", tabContentHolderNode)[0];
    var hasContextPanel = contextPanel != undefined && contextPanel != null;

    if (hasContextPanel) {
      
      var isIE = has('trident') || has('ie');
      var isEdge = has('edge');
      
      // If a context panel is collapsed in IE11, it will not print due to display: none styling.
      // Instead, the main content area is printed twice. The below code addresses that issue.
      var contextPanelCollapsed = domClass.contains(contextPanel.parentNode, "collapsed");
      
      if (isIE && contextPanelCollapsed) {
        style.set(contextPanel.parentNode, "display", "block");
      }
      contextPanel.contentWindow.focus();
      contextPanel.contentWindow.print();
      
      if (isIE && contextPanelCollapsed) {
        style.set(contextPanel.parentNode, "display", "");
      }
      
      if (isIE || isEdge) {  
        // Give the print dialog time to display
	    setTimeout(function() {
	      if (isEdge) {
	        function printMainAreaWindow() {
	          curam.util._printMainAreaWindow(mainAreaWindow);
	          curam.util.getTopmostWindow().document.body.removeEventListener("mouseover", printMainAreaWindow, true);
	          return false;
	        }
	        // Edge will not trigger the onmouseover event on the browsers top most window until the
	        // context panel print dialog is closed.
	    	curam.util.getTopmostWindow().document.body.addEventListener("mouseover", printMainAreaWindow, true);
	      } else if (isIE) {
	        // Internet Explorer will pause timeout countdown when context panel print dialog is displayed, 
	        // once this dialog is closed the timer will continue and we can print the main content area.  
	        curam.util._printMainAreaWindow(mainAreaWindow);
	        return false;
	      }
	    }, 2000);
      } else {
    	  
        curam.util._printMainAreaWindow(mainAreaWindow);    
        return false;
      }
    } else {
      curam.util._printMainAreaWindow(mainAreaWindow);
      return false;
    }
  },
   
  /**
   * Prints the main Area window.
   */
  _printMainAreaWindow: function(mainAreaWindow){
    var hasDetailsRowExpanded = query(".list-details-row-toggle.expanded");
    if(hasDetailsRowExpanded.length > 0){
 	  curam.util._prepareContentPrint(mainAreaWindow);
 	  mainAreaWindow.focus();
      mainAreaWindow.print();
 	  curam.util._deletePrintVersion();
 	}else{
 	  mainAreaWindow.focus();
      mainAreaWindow.print();
    } 
  },
   
  /**
   * Prepare content to copy the body of iframe inside a wrapper and
   * disable the iframe when the user is printing the page.
   * This method reduce the problem of prints iframes nesting commom 
   * in scenario that involves the expandable list. 
   * In this version,the expandable list that contains context panel is excluded
   */
  _prepareContentPrint: function (baseElement){
    var iframes = Array.prototype.slice.call(baseElement.document.querySelectorAll('body iframe'));
    iframes.forEach(function(iframe) {
	  curam.util._prepareContentPrint(iframe.contentWindow);
	  var list = iframe.contentWindow.document.querySelectorAll('.title-exists');
	  var contextPanels = iframe.contentWindow.document.querySelectorAll('.title-exists div.context-panel-wrapper');		  
      if(list.length > 0 && contextPanels.length === 0){		  
	    var wrapper = document.createElement("div");
	    wrapper.setAttribute("class", "tempContentPanelFrameWrapper");
	    wrapper.innerHTML = list[0].innerHTML;
	    var parentOfIframe = iframe.parentNode;
	    parentOfIframe.parentNode.appendChild(wrapper);
	    parentOfIframe.style.display = 'none';			  
	    
	    curam.util.wrappersMap.push({tempDivWithIframeContent : wrapper, iframeParentElement: parentOfIframe}); 		    
	  } 		  
    });	  
  },
	  
  /**
   * Return the page to the original state. Removes the wrappers
   * and enables the iframes again after the user prints the page.
   */
  _deletePrintVersion: function() {
    if(curam.util.wrappersMap){
 	  curam.util.wrappersMap.forEach(function(wrappers){
 	    wrappers.tempDivWithIframeContent.parentNode.removeChild(wrappers.tempDivWithIframeContent);
 	    wrappers.iframeParentElement.style.display = 'block';
 	  });
 	
 	  curam.util.wrappersMap = [];
    }	
  },
   
  /**
  * Handles onmousedown event on the page toolbar buttons.
  * Adds a class name of selected to allow for CSS selected effect.
  *
  * @param event the click event object.
  *
  */
  addSelectedClass:function(event) {
      domClass.add(event.target,"selected");
  },

  /**
  * Handles onmouseup event on the page toolbar buttons.
  * Removes class name of selected..
  *
  * @param event the click event object.
  *
  */
  removeSelectedClass:function(event) {
      domClass.remove(event.target,"selected");
  },

  /**
  * Opens up the page level help page in new window.
  *
  * @param event the mouse click event.
  * @param event the help tag.
  *
  */
  openHelpPage: function(event, helpUrl){
      dojoEvent.stop(event);
    //opens up the constructed URL in new window.
      dojo.global.open(helpUrl);
  },

  /**
  * Connects the handler to the specified event on the specified object
  * and ensures it is disconnected when the page is unloaded.
  *
  * @param object
  *    The object to connect to.
  * @param eventName
  *    Name of the event to connect to.
  * @param handler
  *    The handler for the event.
  *
  * @return The disconnect token to be used with curam.util.disconnect()
  *    function.
  */
  connect: function(object, eventName, handler) {
    // wrap in another function to allow fixing event before passsing
    // to the handler
    var h = function(event) {
        handler(dojoEvent.fix(event));
    };

      if (has("ie") && has("ie") < 9) {
      object.attachEvent(eventName, h);

        unload.addOnWindowUnload(function() {
        object.detachEvent(eventName, h);
      });

      return { object: object, eventName: eventName, handler: h };

    } else {
        // The dojo/on API takes event names without the "on" prefix.
        var eventNameWithoutOn = eventName;
        if (eventName.indexOf("on") == 0) {
          eventNameWithoutOn = eventName.slice(2);
        }
        var dt = on(object, eventNameWithoutOn, h);

        unload.addOnWindowUnload(function() {
          dt.remove();
      });

      return dt;
    }
  },

  disconnect: function(token) {
      if (has("ie") && has("ie") < 9) {
      token.object.detachEvent(token.eventName, token.handler);
      } else {
        token.remove();
    }
  },

  /**
  * Subscribes the handler to the specified topic in the current runtime
  * context and ensures it is unsubscribed when the page is unloaded.
  *
  * @param topicName
  *    Name of the topic to subscribe to.
  * @param handler
  *    The handler for the topic.
  */
  subscribe: function(topicName, handler) {
      var st = topic.subscribe(topicName, handler);
      unload.addOnWindowUnload(function() {
        st.remove();
    });

    return st;
  },

  unsubscribe: function(token) {
      token.remove();
  },

  /**
  * Retrieves all action controls in action set.
  *
  * @param panelId
  *   ID of action set element.
  */
  addActionControlClickListener:function(panelId){
      var actionsPanel = dom.byId(panelId);
      var actionControlList = query(".ac", actionsPanel);
    if (actionControlList.length > 0) {
      for(var i = 0; i < actionControlList.length; i++) {
        var acNode = actionControlList[i];
        curam.util.addActionControlClass(acNode);
      }
    }
    this._addAccessibilityMarkupInAddressClustersWhenContextIsMissing();
  },

  /**
  * Check on each address cluster on a page for the presence of some context given whether
  * by a title or by the presence of a summary attribute in the uim page for the cluster.
  * If no given context exists on the HTML, one will be added automatically from the properties file.
  */
  _addAccessibilityMarkupInAddressClustersWhenContextIsMissing: function() {
    var clusterContentnDivWrapper = query(".bx--accordion__content");

    clusterContentnDivWrapper.forEach(function(cluster) {
      var addressCluster = query(".bx--address", cluster)[0];
      if (typeof(addressCluster) != 'undefined') {
        var bundle = new resBundle("util");
        var divAddressWrapper = addressCluster.parentElement.parentElement.parentElement;
        var divAddressMainWrapper = divAddressWrapper.parentElement.parentElement;

        // To keep it consistent with the behavior in other clusters, context should also be added automatically when
        // there is only a description present <p> on the cluster.
        var hasAddressHeader = query('h4, h3',divAddressWrapper).length == 1 ? true: false;

        var hasAlreadyAriaLabelValuePickedUpfromUIM = attr.get(divAddressMainWrapper, 'aria-label') !== null ? true: false;
        if (!hasAddressHeader && !hasAlreadyAriaLabelValuePickedUpfromUIM) {
          attr.set(divAddressMainWrapper, 'role', "group");
          attr.set(divAddressMainWrapper, 'aria-label', bundle.getProperty("curam.address.header"));
        }
      }
    });
  },

  /**
  * Adds a CSS class names to modal buttons that have been clicked.
  * This allows specific styling to be applied when buttons in a selected
  * state.
  *
  * @param acNode
  *    Modal action button node
  */
  addActionControlClass:function(acNode){
    curam.util.connect(acNode, "onmousedown",function(){
        domClass.add(acNode, "selected-button");
      curam.util.connect(acNode, "onmouseout",function(){
          domClass.remove(acNode, "selected-button");
      });
    });
  },

  /**
  * Gets all cluster level action sets contained in the content panel.
  *
  */
  getClusterActionSet:function(){
      var contentNode = dom.byId("content");
      var clusterActionSets = query(".blue-action-set", contentNode);
    if (clusterActionSets.length > 0){
      for (var i=0; i<clusterActionSets.length; i++) {
        curam.util.addActionControlClickListener(clusterActionSets[i]);
      }
    }
  },

  /**
  * Adjust Button spacing, if needed, to prevent them overlapping
  */
  adjustActionButtonWidth:function() {
      if (has("ie") == 8) {
        ready(function() {
          if (dojo.global.jsScreenContext.hasContextBits('MODAL')) {
            query(".action-set > a").forEach(function(node) {
            if(node.childNodes[0].offsetWidth > node.offsetWidth) {
                style.set(node, "width", node.childNodes[0].offsetWidth + "px");
                style.set(node, "display", "block");
                style.set(node, "display", "inline-block");
            }
          });
        }
      });
    }
  },

  /**
  * Sets the '__o3rpu' parameter for the URL. This parameter is an enocoded
  * value and holds the requesting URL and its parameters. This function may add
  * additonal parameters to the requesting URL prior to encoding it.
  *
  * @param {String} url
  *     The requested URL
  * @param {curam.util.RuntimeContext} rtc
  *     RunTimeContext Object - provides access to Window object.
  * @param {Array} [extraParaArray]
  *     An optional array of extra parametes to be added to the requesting URL.
  *     The expected array structure is
  *     [{key:"x1",value:"y1"},{key:"x2",value:"y2"},...]
  * @return The requested URL with the '__o3rpu' parameter appended.
  */
  setRpu:function(url, rtc, /*optional*/ extraParaArray){
    //Throw exception if null/blank values passed in
    if(!url||!rtc||!rtc.getHref()){
      throw {
        name:"Unexpected values",
        message:"This value not allowed for url or rtc"
      };
    }

    var o3rpuValue = curam.util.getLastPathSegmentWithQueryString(rtc.getHref());

    // strip the __o3rpu parameter from the RPU value
    o3rpuValue = curam.util.removeUrlParam(o3rpuValue, curam.util.Constants.RETURN_PAGE_PARAM);

    //Check for extra parameters passed in as {key:"",value:""} format
    if(extraParaArray){
      var i;
      for(i = 0; i < extraParaArray.length; i++) {
        if(!extraParaArray[i].key||!extraParaArray[i].value){
          throw {
            name:"undefined value error",
            message:"The object did not contain a valid key/value pair"
          };
        }
        o3rpuValue = curam.util.replaceUrlParam(o3rpuValue,
        extraParaArray[i].key, extraParaArray[i].value);
      }
    }
    var returnUrl = curam.util.replaceUrlParam(url, curam.util.Constants.RETURN_PAGE_PARAM, encodeURIComponent(o3rpuValue));
    curam.debug.log("curam.util.setRpu "
      + debug.getProperty("curam.util.added.rpu") + returnUrl);
    return returnUrl;
    },

    /**
     * Retrieves the base URL from the location.href property associated with
     * the current DOM Window object.
     * <p>
     * The base URL is the contents of the URL up as far, and including, the
     * application name.
     * <p>
     * For example, if the value of location.href was
     * "http://philippa:9080/TabTest/AppController.do" then the value returned
     * would be "http://philippa:9080/TabTest"
     *
     * @return the base URL or null if the URL cannot be retrieved.
     *
     */
    retrieveBaseURL: function() {
      //The regular expression will match a path of the form
      //[protocol]://[domain]/[name]. Where [protocol] can be any character
      //e.g. http. Where [domain] can be any character except for
      //the forward slash character e.g. www.curamsoftware.com. Where [name] can
      //be any character except for the forward slash character e.g. Curam.
      return dojo.global.location.href.match(".*://[^/]*/[^/]*");
    },

    removeRoleRegion:function(){
      var body = dojo.query("body")[0];
      attr.remove(body, "role");
    },

    /*
     * Function for iframe title fall back.
     * If PAGE_TITLE isn't specified in the UIM, this function takes care
     * of falling back to the navigation tab title or the application tab.
     */
    iframeTitleFallBack: function(){
      var currentiframe = curam.tab.getContainerTab(curam.tab.getContentPanelIframe());

      var iframe = dom.byId(curam.tab.getContentPanelIframe());
      var pageTitle = iframe.contentWindow.document.title;

      var currentAppTab = dojo.query("div.nowrapTabStrip.dijitTabContainerTop-tabs > div.dijitTabChecked.dijitChecked")[0];
      var currentAppTabName = dojo.query("span.tabLabel", currentAppTab)[0];

      var currentNavTab = dojo.query("div.nowrapTabStrip.dijitTabNoLayout > div.dijitTabChecked.dijitChecked", currentiframe.domNode)[0];
      var currentNavTabName = dojo.query("span.tabLabel", currentNavTab)[0];

      if(pageTitle=="undefined"){
          return this.getPageTitleOnContentPanel();
      } else if(pageTitle && pageTitle!=''){
        return pageTitle;
      } else if (currentNavTab){
          return currentNavTabName.innerHTML;
      } else {
          return currentAppTabName.innerHTML;
      }
    },
    
    /**
     * Function to return the page title from the content panel. 
     * This is for the edge case, where there is in-page-navigation
     * on a UIM page, and the current page title needs to be updated
     * after the content has been put into DOM.
     *
     * @return page title on content panel.
     */
    getPageTitleOnContentPanel: function() {
        
        // Page title on content panel
        var contentPanelPageTitle;
        var iframe = dojo.query("div.dijitVisible div.dijitVisible iframe.contentPanelFrame");
        var iframeDoc;
        if(iframe && iframe.length == 1) {
          iframeDoc = iframe[0].contentWindow.document;
          windowBase.withDoc(iframeDoc, function() {
            var header = dojo.query("div.title h2 span:not(.hidden)");
            if(header && header.length == 1 && header[0].textContent) {
                contentPanelPageTitle = lang.trim(header[0].textContent);
            } 
          }, this);
        } 
        
        if(contentPanelPageTitle) {
         return contentPanelPageTitle;
        }else {
          return undefined;
        }
    },

    /**
     * Function to add a specific class to the last visible node (cluster, list
     * or action set) in the page content area. It only works specifically in
     * the external application.
     *
     * @return There's no return value of this function.
     */
    addClassToLastNodeInContentArea: function() {
      var divNodes = query("> div", "content");
      var divNodesCount = divNodes.length;

      if (divNodesCount == 0) {
        return "No need to add";
      }

      var lastNode = divNodes[--divNodesCount];

      while (domClass.contains(lastNode, "hidden-action-set") && lastNode) {
        lastNode = divNodes[--divNodesCount];
      }

      domClass.add(lastNode, "last-node");

    },

    /*
     * Function to check Highcontrast mode
     * If High contrast mode is turned on the method checks the class name
     * high-contrast on body element.
     */
    highContrastModeType: function(){
      var highContrastMode = dojo.query("body.high-contrast")[0];
      return highContrastMode;
    },

    /**
     * Function to check RTL (right-to-left) mode.
     * Checks for class name 'rtl' on body element to see if RTL mode is turned
     * on.
     */
    isRtlMode: function() {
      var rtlMode = dojo.query("body.rtl")[0];
      return rtlMode;
    },

    processBidiContextual: function (target){
      target.dir = bidi.prototype._checkContextual(target.value);
    },

    getCookie: function(name) {
      var dc=document.cookie;
      var prefix=name+"=";
      var begin=dc.indexOf("; "+prefix);
      if(begin==-1) {
        begin=dc.indexOf(prefix);
        if(begin!=0)
          return null;
        } else {
          begin+=2;
        }
        var end=document.cookie.indexOf(";",begin);
        if(end==-1) {
          end=dc.length;
        }
      return unescape(dc.substring(begin+prefix.length,end));
    },

    getHeadingTitleForScreenReader: function(landmarkTitle) {
      var topWin = curam.util.getTopmostWindow();
      var tabTitle = topWin.dojo.global._tabTitle;

      if (tabTitle) {
        curam.util.getHeadingTitle(tabTitle, landmarkTitle);
      } else {
        var tabTitleSubscription = topWin.dojo.subscribe("/curam/_tabTitle", function(tabTitleFromPublish) {
                  if(tabTitleFromPublish) {
            curam.util.getHeadingTitle(tabTitleFromPublish, landmarkTitle);
                  }
          topWin.dojo.unsubscribe(tabTitleSubscription);
        });
      }
    },

    getHeadingTitle: function(tabTitle, landmarkTitle) {
      var headingTitle = undefined;

      if (tabTitle && tabTitle.length > 0) {
        headingTitle = tabTitle;
      } else {
        headingTitle = landmarkTitle;
      }

      var pageTitleBar = dojo.query(".page-title-bar");
      var mainContentPageHeading = dojo.query("div h2", pageTitleBar[0]);

      // h2 heading
      if (mainContentPageHeading) {
        var childrenSpan = dojo.query("span",mainContentPageHeading[0]);
        var span = undefined;
        if (childrenSpan) {
          span = childrenSpan[0];
        }
        if (!span || (span && (span.innerHTML.length == 0))) {
          if (span) {
            attr.set(span, "class", "hidden");
            attr.set(span, "title", headingTitle);
            span.innerHTML= headingTitle;
          } else {
            span = domConstruct.create("span", {"class" : "hidden", "title": headingTitle}, mainContentPageHeading[0]);
            span.innerHTML = headingTitle;
          }
        }
      }
    },

    /**
     * Sets up the browser tab title data for later use by the
     * curam.util.setBrowserTabTitle method.
     * 
     * @param {String} tabTitle
     *     the static tab title taken from CDEJResource.properties
     *     'browser.tab.title' property
     * @param {String} separator
     *     the separator to use between the application title and context
     *     strings
     * @param {Boolean} appNameFirst
     *     <code>true</code> if the application name should come before the
     *     context, <code>false</code> otherwise
     */
    _setupBrowserTabTitle: function(staticTabTitle, separator, appNameFirst) {
      // Convert newlines to spaces as newlines are allowed in banner title but
      // not in browser tab title
      staticTabTitle = staticTabTitle.replace("\\n", " ");

      curam.util._browserTabTitleData.staticTabTitle = staticTabTitle;
      curam.util._browserTabTitleData.separator = separator;
      curam.util._browserTabTitleData.appNameFirst = appNameFirst;
    },

    /**
     * Stores the browser tab title data.
     */
    _browserTabTitleData: {},

    /**
     * Sets the browser tab title to the given value plus the static title, or,
     * if no value is given, attempt to find an appropriate title from the page
     * layout.
     * <p>
     * Example: "Register Person - IBM Curam Social Program Management"
     * <p>
     * The value is found using the following logic:
     * <ol>
     * <li>Page Title on Content Panel
     * <li>If no page title on CPanel, then get title from page navigation group
     * <li>If no page navigation group title then use title from navigation tab bar
     * <li>If no page title on context panel then use title on application tab bar
     * <li>If no title on application tab then use title on Section
     * </ol>
     *
     * @param {String} [title]
     *         Optional title to use for the page. If a title value is not
     *         given, the function attempts to select an appropriate title from
     *         the information on the page.
     *
     * @return No return value.
     */
    setBrowserTabTitle: function(/*optional*/title) {
      curam.debug.log("curam.util.setBrowserTabTitle(title = " + title + ") called");
      // If no title given then try to find an appropriate title on the page
      if(!title) {
        title = curam.util._findAppropriateDynamicTitle();
      }

      var staticTitle = curam.util._browserTabTitleData.staticTabTitle;
      var separator = curam.util._browserTabTitleData.separator;
      var appNameFirst = curam.util._browserTabTitleData.appNameFirst;

      if (!staticTitle && !separator && !appNameFirst && !title) {
        /**
         * When setBrowserTabTitle is called from a nested page, the curam.util._browserTabTitleData 
         * may not contain staticTabTitle, separator and appNameFirst. In this particolar scenario, 
         * set document.title as the page title.
         */
        
        var headTitle = document.querySelectorAll("head title")[0];
        if (headTitle) {
          document.title = headTitle.text;
        }
    }else if (!title) {
      // If no title given or found, then just use the static title on its own
      document.title = staticTitle; 
      } else {
        if(staticTitle) {
          if(appNameFirst) {
            // Display "Title - Context"
            document.title = staticTitle + separator + title;
          } else {
            // Display "Context - Title"
            document.title = title + separator + staticTitle;
          }
        }
      }
    },
    
    /**
     * Function that handles the toggle event for the Checkboxed Multi Select Renderer
     * 
     * @param e - The checkbox element. 
     * @param div - The Select div (row).
     */
    toggleCheckboxedSelectStyle: function(e, div){ 
      if(e.checked){
	    div.classList.remove('unchecked');
		div.classList.add('checked');
      }else{
	    div.classList.remove('checked'); 
		div.classList.add('unchecked');
      }
    },

    /**
     * Searches the DOM for an approriate string to use as the browser tab
     * title. The value is selected using the following logic:
     * <ol>
     * <li>When a popup window closes, get title from the modal
     * from which it was opened
     * <li>Page Title on Content Panel
     * <li>If no page title on CPanel, then get title from page navigation group
     * <li>If no page navigation group title then use title from navigation tab bar
     * <li>If no page title on context panel then use title on application tab bar
     * <li>If no title on application tab then use title on Section
     * </ol>
     *
     * @return a string to use for the browser tab title chosen by the above
     *         logic, or <code>undefined</code> if nothing could be found.
     */
    _findAppropriateDynamicTitle: function() {
      var i; // Index used for various loops
      
      // 1. When closing a modal or popup widget, relay modal and popup widget titles to browser tab
      var one;
      var numberOfActiveModals = dojo.query("iframe.curam-active-modal").length;
      if (numberOfActiveModals > 1) {
    	// If numberOfActiveModals > 1 we are closing a modal dialog or popup widget and falling back to
    	// to a modal dialog or popup widget.
        var iFrameContainingTheTitleWeWant = dojo.query("iframe.curam-active-modal")[0];
        if (iFrameContainingTheTitleWeWant) {
	      var iFrameContainingTheTitleWeWantDoc = iFrameContainingTheTitleWeWant.contentDocument;
	      if (iFrameContainingTheTitleWeWantDoc) {
	        var iFrameContainingTheTitleWeWantDocHeadTitle = 
	          iFrameContainingTheTitleWeWantDoc.head.getElementsByTagName("title")[0];
	        if (iFrameContainingTheTitleWeWantDocHeadTitle) {
	          if (iFrameContainingTheTitleWeWantDocHeadTitle.innerHTML != '') {
	            one = iFrameContainingTheTitleWeWant.contentDocument.head.getElementsByTagName("title")[0].innerHTML;
	  		  }  
	        }  
	      }
        }
      }
      
      if(one) {
        return one;
      }

      // 2. Page title on content panel
      var two;
      var iframe = dojo.query("div.dijitVisible div.dijitVisible iframe.contentPanelFrame");
      var iframeDoc;
      if(iframe && iframe.length == 1) {
        iframeDoc = iframe[0].contentWindow.document;
        windowBase.withDoc(iframeDoc, function() {
          var header = dojo.query("div.title h2 span:not(.hidden)");
          var errorMessages = dom.byId("error-messages", iframeDoc);
          if(errorMessages) {
            two = iframeDoc.head.getElementsByTagName('title')[0].textContent;
          } else if(header && header.length == 1 && header[0].textContent) {
            two = lang.trim(header[0].textContent);
            curam.debug.log("(2) Page title for Content Panel = " + two);
          } else if(header && header.length > 1) { // Special case for sub-titles
            two = this._checkForSubTitles(header);
          } else {
            curam.debug.log("(2) Could not find page title for content panel: header = " + header);
          }
        }, this);
      } else {
        curam.debug.log("(2) Could not find iframeDoc for content panel: iframe = " + iframe);
      }

      if(two) {
        return two;
      }

      // 3. Selected navigation item title
      var three;
      var navItem = dojo.query("div.dijitVisible div.dijitVisible div.dijitVisible div.child-nav-items li.selected > div.link");
      if(navItem && navItem.length == 1 && navItem[0].textContent) {
        three = lang.trim(navItem[0].textContent);
        curam.debug.log("(3) Selected navigation item = " + three);
      } else {
        curam.debug.log("(3) Could not find selected navigation item: navItem = " + navItem);
      }

      if(three) {
        return three;
      }

      // 4. Navigation bar tab title
      var four;
      var allNavTabs = dojo.query("div.dijitVisible div.dijitVisible div.navigation-bar-tabs span.tabLabel");
      var selectedNavTab;
      for(i = 0; i < allNavTabs.length; i++) {
        if(allNavTabs[i].getAttribute("aria-selected") === "true") {
          selectedNavTab = allNavTabs[i];
        }
      }
      if(selectedNavTab && selectedNavTab.textContent) {
    	four = lang.trim(selectedNavTab.textContent);
        curam.debug.log("(4) Selected navigation bar tab = " + four);
      } else {
        curam.debug.log("(4) Could not find selected navigation bar tab: selectedNavTab = " + selectedNavTab);
      }

      if(four) {
        return four;
      }

      // 5. Application tab title bar
      var five;
      var appTabTitleBar = dojo.query("div.dijitVisible div.dijitVisible h1.detailsTitleText");
      if(appTabTitleBar && appTabTitleBar.length == 1 && appTabTitleBar[0].textContent) {
    	five = lang.trim(appTabTitleBar[0].textContent);
        curam.debug.log("(5) Selected application tab title bar = " + five);
      } else {
        curam.debug.log("(5) Could not find selected application tab title bar: appTabTitleBar = " + appTabTitleBar);
      }

      if(five) {
        return five;
      }

      // 6. Section title
      var six;
      var sections = dojo.query("div.dijitTabInnerDiv div.dijitTabContent div span.tabLabel");
      var selectedSection;
      for(i = 0; i < sections.length; i++) {
        if(sections[i].getAttribute("aria-selected") === "true") {
          selectedSection = sections[i];
          break;
        }
      }
      if(selectedSection && selectedSection.textContent) {
    	six = lang.trim(selectedSection.textContent);
        curam.debug.log("(6) Selected section title = " + six);
      } else {
        curam.debug.log("(6) Could not find selected section title: sections = " + sections);
      }

      if(six) {
        return six;
      }

      // 7. UIM pages in external application (for when curam.ModalDialog._modalClosedHandler gets called in that context.)
      var seven;
      iframe = dom.byId('curamUAIframe');
      if(iframe && iframe.contentWindow && iframe.contentWindow.document) {
        iframeDoc = iframe.contentWindow.document;
        windowBase.withDoc(iframeDoc, function() {
          var uimPageTitle = dojo.query('div.page-header > div.page-title-bar > div.title > h2 > span');
          if(uimPageTitle && uimPageTitle.length == 1 && uimPageTitle[0].textContent) {
        	seven = lang.trim(uimPageTitle[0].textContent);
            curam.debug.log("(7) UIM page title for external application page = " + seven);
          } else {
            curam.debug.log("(7) Could not find UIM page title for external application page: uimPageTitle = " + uimPageTitle);
          }
        }, this);
      }

      if(seven) {
        return seven;
      }

      return undefined;
    },

    /**
     * Checks the given array of elements consists of a valid header and
     * sub-titles. This is for when the PAGE_TITLE element contains multiple
     * CONNECT elements.
     * 
     * The first header only needs to have a textContent child. The second and
     * subsequent headers need a textContent child and to have the class
     * 'sub-title'.
     * 
     * @param {Array} header The array of HTML elements returned by dojo.query.
     * @return a string to use for the browser tab title created from the given
     *         header and sub-titles, or <code>undefined</code> if the array
     *         did not meet the criteria described above.
     */
    _checkForSubTitles: function(header) {
      var i; // Index used for various loops

      // Check first item has a textContet attribute 
      if(!header[0].textContent) {
        return undefined;
      }
      // Check all attributes except the first one have a "sub-title" class and .textContent attribute
      for(i = 1; i < header.length; i++) {
        var clazz = header[i].getAttribute('class'); 
        if(clazz.indexOf('sub-title') === -1 || !header[i].textContent) {
          curam.debug.log("(1) Failed to construct title from content panel page title. Not all header element spans had 'sub-title' class.");
          for(i = 0; i < header.length; i++) {
            curam.debug.log(header[i]);
          }
          return undefined;
        }
      }
      // All elements are valid sub-titles, so concatenate textContent values
      var ret = header[0].textContent;
      for(i = 1; i < header.length; i++) {
        ret += header[i].textContent;
      }
      return ret;
    },

    /**
     * This function adds the necessary context to a widget for accessibility concerns.
     *
     * The closest cluster above the current widget holding a title of type <h3> is used to give context to
     * the widget. If the cluster just above the widget does not have a title it looks for
     * the a cluster above and so on until a title is found.
     * If not tile is found, no accessibility feature is applied.
     *
     * @param {String} widgetId The id of the widget to add context to.
     */
    _addContextToWidgetForScreenReader: function(widgetId) {
      var found = false;
      var index = 0;
      var trainingDetailsListClusterWrapper = dojo.query(".training-details-list");

      if (trainingDetailsListClusterWrapper.length == 1) {
        var trainingDetailsListClusterWrapperParentElement = trainingDetailsListClusterWrapper[0].parentElement;
        var clusterChildrenList = dojo.query("div.bx--cluster", trainingDetailsListClusterWrapperParentElement);
        var currentIndexOfTheClusterInTheListForTheWidget = Array.prototype.indexOf.call(clusterChildrenList, trainingDetailsListClusterWrapper[0]);

        if (currentIndexOfTheClusterInTheListForTheWidget >= 0) {
          //We want to find the closest cluster with a title - hence starting from the index of the widget cluster and checking on the clusters above.
          for (var i = currentIndexOfTheClusterInTheListForTheWidget; i >= 0; i--) {
            if (dojo.query("h3", clusterChildrenList[i]).length == 1) {
              found = true;
              index = i;
              break;
            }
          }
        }

        if (found) {
          var closestClusterWithATitle = dojo.query("h3.bx--accordion__title", clusterChildrenList[index]);
          if (closestClusterWithATitle.length == 1) {
            //Define an id for the closest cluster element containing the title to be used as context for the widget.
            var idForTheClosestClusterWithATitle = closestClusterWithATitle[0].className + "_id";
            attr.set(closestClusterWithATitle[0], "id", idForTheClosestClusterWithATitle);
            //Set the widget itself with the appropriate accessibility features.
            var widgetDivWrapper = dojo.byId(widgetId).parentElement;
            attr.set(widgetDivWrapper, "aria-labelledby", idForTheClosestClusterWithATitle);
            attr.set(widgetDivWrapper, "role", "region");
          }
        }
      }
    },

    /**
     * Set the focus on the parent active iframe.
     * @param {window} [child] If specified, the dialog hierarchy will be used
     * to look up the parent window.
     */
    setParentFocusByChild : function(childID){
      var win = curam.util.UimDialog._getDialogFrameWindow(childID);

      if(win){
         var parentWindow = curam.dialog.getParentWindow(win); 
         if(parentWindow){
            parentWindow.focus();
         }
      }   
    },
    /**
     * Copies the value to system clipboard if the access
     * is configured; passes the value through the Word Integration channel if called
     * as part of Appeals Clause functionality. 
     */
    toClipboard: function(valueToCopy){
      try {
        navigator.clipboard.writeText(valueToCopy);
      } catch (err) {
        console.warn("Failed to copy into the clipboard.");
      }
      if (dojo.getObject('curam.dialog', false) != null) {
        var pw = curam.dialog.getParentWindow(window);
        pw && pw.dojo.publish('/curam/clip/selected', [valueToCopy]);
      }
      return false;
    },
    /**
     * Set to zero the scrollTop in ios devices.
     */
    removeTopScrollForIos: function(){
    	if(has("ios")){
    		window.document.body.scrollTop=0;
    	}
    },
    
    /**
     * Insert aria-live attribute in the span that contains the record of items. 
     * The span content is updated with text containing the amount of records 
     * returned so screen reader reads it when the screen is loaded.
     */
	insertAriaLiveLabelRecordSearchItem: function (numSearchResultsText){
        var span = dojo.query("[data-search-page]")[0];
        if(span) {
          span.setAttribute("aria-live", has('ios') ? "polite" : "assertive");
          // When DOM has loaded, update text after a short delay to trigger
          // screen reader to announce new text.
          setTimeout(function() {
            var currentSearchResultText = span.firstChild.nodeValue;
            var numSearchResultsTextOutput = currentSearchResultText + numSearchResultsText;
            span.innerHTML = numSearchResultsTextOutput;
          }, 10);
        }
    },
    
    /**
     * Remove a session property from the session storage.
     */
    removeSessionStorageProperty: function (propertyName){
        sessionStorage.removeItem(propertyName);
    },
    
    /**
     * This method is invoked from method render() from DateTimeEditRenderer.java
     * when a date time widget field is rendered onto a page. A css class style of 
     * "date-time-exists" is added to the <tr> element containing this widget.
     */
    addLayoutStylingOnDateTimeWidgetOnZoom: function (){
      
      var dateTimeTables = dojo.query("table.input-cluster td.field table.date-time");
      console.log("datetimetable from util.js: "+dateTimeTables);
      var dateTimeTableCount = dateTimeTables.length;
      
      if(dateTimeTables.length >0){
        for (var i=0;i<dateTimeTables.length;i++) {
          
          var dateTimeTable = dateTimeTables[i];
          var tableRow = dateTimeTable.parentNode.parentNode;
          tableRow.setAttribute("class", "date-time-exists");
        }
      }
    },
    
    /**
     * This method is used in FileUploadTag.java to cause the file
     * browser to open and allow the uploading of files to C?ram.
     * We only want to open the file browser on a 'space' or 'enter'
     * key press.
     */
    fileUploadOpenFileBrowser: function(e, elementId) {
    	if (e.keyCode == 32 || e.keyCode == 13) {
    		dom.byId(elementId).click();
    	}
    },
    
    /**
     * Invoked upon each page load to optionally set up lists
     * on a page so that the list selection controls are
     * initialized and updated with the correct text for
     * the screen readers.
     * Relies on the presence of the JavaScript objects
     * output for lists by the tag infrastructure and
     * JSP generator.
     */
    setupControlledLists: function() {
      var crtlPath = 'curam.listControls',
         togglerPath = 'curam.listTogglers';
      var crtlsStorage = getFrom(crtlPath),
            togglers = getFrom(togglerPath),
              lists = [];
      var batchQuery = crtlsStorage && query('*[data-control]'),
          togglerQuery = togglers && query('a[data-toggler]');
      if (crtlsStorage || togglers) { //no lists = no update 
        for (var listId in crtlsStorage) {
          batchQuery.filter(function(item) {
            return attr.get(item, 'data-control') == listId;
          }).forEach(function(listCrtl, ix) {
            var c = dom.byId(listCrtl),
              tr = query(listCrtl).closest('tr')[0];
              !tr.controls && (tr.controls = new Array());
              tr.controls.push(c);
              // do not add the same row twice
              if (!tr.visited) {
                tr.visited = true;
            	crtlsStorage[listId].push(tr);
              }
          });
          var cBuildUp = getFrom(crtlPath + '.' + listId);
          if (cBuildUp && cBuildUp.length && cBuildUp.length > 0) {
            lists.push(listId);
          } else {
            putTo(crtlPath + '.' + listId, false);//blanking out
          }
    	}
        if (togglerQuery && togglerQuery.length > 0) {
          for (var listId in togglers) {
            togglerQuery.filter(function(item) {
              return attr.get(item, 'data-toggler') == listId;
            }).forEach(function(listToggler) {
              var tr = query(listToggler).closest('tr')[0];
              tr.hasToggler = listToggler;
              tr.visited = true;
              togglers[listId].push(tr);
            });
            var tBuildUp = getFrom(togglerPath + '.' + listId);
            if (tBuildUp && tBuildUp.length && tBuildUp.length > 0) {
              (lists.indexOf(listId) == -1) && lists.push(listId);
            } else {
               putTo(togglerPath + '.' + listId, false); //blanking out
            }
          }
    	}
        lists.forEach(function(listId){
          var updateArray = getFrom(crtlPath + '.' + listId)
                             || getFrom(togglerPath + '.' + listId);
          cu.updateListControlReadings(listId, updateArray);      	
        });
      }
      dojo.subscribe("curam/sort/earlyAware", function(listId) {
        cu.suppressPaginationUpdate = listId;
      });
      dojo.subscribe('curam/update/readings/sort', function(listId, rows) {
    	if (!has('trident')) {
    	  cu.updateListActionReadings(listId);
          cu.updateListControlReadings(listId, rows);
          cu.suppressPaginationUpdate = false;
        } else {
      	  var pageBreak = cu.getPageBreak(listId),
	          limit = Math.ceil(rows.length/pageBreak);
	      cu.listRangeUpdate(0, limit, listId, rows, pageBreak);
        }
      });
      dojo.subscribe('curam/update/readings/pagination', function(listId, newPageSize) {
        putTo('curam.pageBreak.' + listId, newPageSize); // set for the subsequent sorts
      });
      dojo.subscribe('curam/update/pagination/rows', function(newRows, listId) {
        // this will cancel the gradual update process in IE only
    	cu.updateDeferred && !cu.updateDeferred.isResolved()
    	                     && cu.updateDeferred.cancel('Superseeded');
    	if (cu.suppressPaginationUpdate && cu.suppressPaginationUpdate == listId) {
          return; //do not attempt multiple updates
        }
        var hasTogglers = isHere('curam.listTogglers.' + listId),
                hasControls = isHere('curam.listControls.' + listId),
                  lms = getFrom('curam.listMenus.' + listId),
                    hasMenus = lms && (lms.length > 0);
        var needsStaticUpdate = hasControls || hasTogglers;
        if (!needsStaticUpdate && !hasMenus) return;
        if (needsStaticUpdate) {
          var nvRows = newRows.filter(function(aRow) {
            return (!aRow.visited || !aRow.done)
               && attr.has(aRow, 'data-lix');
          });
          hasTogglers && nvRows.forEach(function(aRow){
            var tgl = query('a[data-toggler]', aRow)[0];
            aRow.hasToggler = tgl;
            aRow.visited = true;
            curam.listTogglers[listId].push(aRow);
          });
          hasControls && nvRows.forEach(function(aRow){
            var crtlRefs = query('*[data-control]', aRow),
                  storage = new Array();
            crtlRefs.forEach(function(cRef){
              storage.push(dom.byId(cRef));
            });
            aRow.controls = storage;
            curam.listControls[listId].push(aRow);
            aRow.visited = true;
          });
          var updateArray = hasControls
        	            ? curam.listControls[listId]
                        : curam.listTogglers[listId];
          cu.updateListControlReadings(listId, updateArray);
        }
        hasMenus && cu.updateListActionReadings(listId);
      });
    },
    /**
     * Updates big list accessibility readings in parts equal to the
     * current page size, asynchronously and with delay to unlock
     * a page with list for interaction as quickly as possible.
     * Applies to IE11 only since this ancient browser is not capable
     * of reasonable updating otherwise.
     *
     * @param rangeNum the number of list range to be updated in this batch. 
     * @param limit the rage number limit to stop the updater.
     * @param listId the identifier of the list updatye applies to.
     * @param rows the full array containing row objects to be updated.
     * @param psz the current size of the paginated list.
     */
    listRangeUpdate: function(rangeNum, limit, listId, rows, psz) {
      if (rangeNum == limit) {
        cu.suppressPaginationUpdate = false;
        cu.updateDeferred = null;
        return;
      }
      var def = cu.updateDeferred = new Deferred(function(reason) {
        cu.suppressPaginationUpdate = false;
        cu.updateDeferred = null;
      });
      def.then(function(pNum) { cu.listRangeUpdate(pNum, limit, listId, rows, psz) },
    		  function(err) {/* swallow silently,it is cancellation*/});
      // additional delay for the invisible updates.
      var delay = (rangeNum === 0) ? 0 : 200;
      setTimeout(function() {
        var newNum = rangeNum+1, range = [rangeNum*psz, (newNum*psz)];
        cu.updateListActionReadings(listId, range);        
        cu.updateListControlReadings(listId, rows, range);       
        def.resolve(newNum);
      }, delay);
    },

    /**
     * Updates the screen reader texts for the list selection controls (links,
     * radio buttons, row toggle controls) depending on the current row number.
     * Relies on the additional markup output for the rows and lists.
     * 
     * @param listId optional list identifier to apply the update method to.
     * @param rowArray the array of list row objects to traverse.
     * @param suppressFocus indicates that no focus manipulation is needed
     *                      upon update completion.
     * @param range an optional array of two numbers specifying the part of
     * the rowArray to be updated
     *                      
     *                      
     */
    updateListControlReadings: function(listId, rowArray, range) {
      var c0, psz = cu.getPageBreak(listId),
        startAt = cu.getStartShift(listId, rowArray[0] || false),
        portion = rowArray;
      range && (portion = rowArray.slice(range[0], range[1]));
      for (var rix in portion) {
        var aRow = portion[rix],
            lixAttr = parseInt(attr.get(aRow, ROW_IDX)),
              lx = (lixAttr % psz) + startAt,
                crtls = aRow.controls;
        if(!crtls){ //check for controls
        	var crtlRefs = query('*[data-control]', aRow),
            storage = new Array();
      		crtlRefs.forEach(function(cRef){
        		storage.push(dom.byId(cRef));
      		});
      		aRow.controls = storage;
      		crtls = aRow.controls;
        }
        
        if (crtls) { /* a row can contain multiple controls in an array */
      	  for (var cix in crtls) {
      	    var crtl = crtls[cix],
      	      /* links have textContent, single selects do not */
      	      ttl = crtl.textContent || false,
      	        linkPrefixed = ttl ? ttl + ',' : '';  
      	    if (crtl.nodeName == 'A') {
              var imageElement = query("img",crtl)[0];
              if (imageElement && domClass.contains(crtl,"ac first-action-control external-link")) {
                var linkName = attr.get(imageElement,"alt");
                attr.set(crtl, READOUT,
                  linkName + "," + [listcontrol.reading.anchors, lx].join(' '));
              } else {
                attr.set(crtl, READOUT,
                  linkPrefixed + [listcontrol.reading.anchors, lx].join(' '));
              }
        	} else {
        	  attr.set(crtl, READOUT,
        	    linkPrefixed + [listcontrol.reading.selectors, lx].join(' '));
            }
      	  }
        }
        cu.updateToggler(aRow, lx);
        aRow.done = true;
      }
    },
    /**
     * Initializes the list action menus which are subject to the accessibility
     * readings update. Each such menu upon startup registers itself
     * in the dedicated array for quick access when updating when sorting or
     * paginating a list.
     * 
     * @param listId the identifier of the list being updated.
     */
    initListActionReadings: function(listId) {
      var actionsPath = 'curam.listMenus.' + listId; 
      putTo(actionsPath,[]);
      dojo.subscribe('curam/listmenu/started', function(widget, listId){
    	   var tr = query(widget.containerNode).closest('tr')[0],
    	     lix = parseInt(attr.get(tr, ROW_IDX)),
    	       lx = (lix % cu.getPageBreak(listId)) + cu.getStartShift(listId, tr);
    	widget.set({'belongsTo' : tr,
    		        'aria-labelledBy':'',
    		        'aria-label' : [listcontrol.reading.menus, lx].join(' ')});
    	getFrom(actionsPath).push(widget);
    	cu.updateToggler(tr, lx);
      });
    },
    /**
     * Updates toggle control in an expandable list row.
     * This can be initiated either dynamically when a list action menu
     * lazily initializes, or upon regular update where no dynamic controls
     * are present in a list.
     * 
     * @scanRow the row to be checked for toggle control.
     * @relLix the number to use for the toggling control accessibility reading.
     */
    updateToggler: function(scanRow, relLix) {
      scanRow.hasToggler
        && attr.set(scanRow.hasToggler, READOUT,
              [listcontrol.reading.togglers, relLix].join(' '));
    },
    /**
     * Called to update the list actions menu accessibility readings.
     * Used the initialized menu widget array where each of the them
     * stores the associated row reference.
     * 
     * @param listId the identifier of the list being updated.
     * @param range optional array specifying the range of list menus
     * to be updated; if absent the full range is subject to update.
     */
    updateListActionReadings: function(listId, range) {
      var menus = getFrom('curam.listMenus.' + listId),
        psz = cu.getPageBreak(listId), startAt = false,
          portion = menus;
      range && (portion = menus.slice(range[0], range[1]));
      for (var ix in portion) {
        var widget = portion[ix], tr = widget.belongsTo,
            lix = parseInt(attr.get(tr, ROW_IDX)),
              startAt = startAt || cu.getStartShift(listId, tr),
                 finalLix = (lix % psz) + startAt;
        widget.set(READOUT,
         	   [listcontrol.reading.menus, finalLix].join(' '));
        cu.updateToggler(tr, finalLix);
        tr.done = true;
      }
    },
    /**
     * Returns the current page size of a paginated list.
     * 1000 is returned for not paginated lists to exceed
     * any potential list page size.
     * This is used for the accessibility readings update.
     * 
     * @param listId the identifier of the list which page size is requested.
     */
    getPageBreak: function(listId) {
      if (!isHere('curam.list.isPaginated.'+ listId)) return 1000;
      /* NOTE: while the default size is what's used for pagination,
      threshold is what turns on pagination. Hence you can just apply
      the calculation where the threshold is actually reached. */
      if (getFrom('curam.shortlist.'+ listId)) return 1000;
      var psz = 
        getFrom('curam.pageBreak.'+ listId)
        || getFrom('curam.pagination.defaultPageSize') || 1000;
      return psz;
    },
    /**
     * Returns the starting row number to be read by the screen reader
     * for the tables with headers (2) and tables without headers (1).
     * 
     * @param listId the identifier of the list queried.
     * @param refRow a row used in header presence determination.
     */
    getStartShift: function(listId, refRow) {
      if (!refRow) return 2; // best guess default
      var hPath = 'curam.listHeaderStep.' + listId,
            hStep = getFrom(hPath);
      if (hStep) return hStep;
      putTo(hPath, 2);
	  // get header info. Readings correction for the present header is 2,
	  //but just 1 where no header is set on the list
	  var tableRef = query(refRow).closest('table');
	  if (tableRef.length == 0) return 2; //hidden row - no parent.
	  var headerRef = tableRef.children('thead')[0];
	  !headerRef && putTo(hPath, 1);
      return curam.listHeaderStep[listId];
    },
     /**
     * This method is invoked to intercept XMLHttpRequests to 
     * allow the update of sessionExpiry on sessionStorage for each ajax call.
     */
    extendXHR : function(){
        var protoTypeOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function() {
        
          this.addEventListener('load', function() {
            if (typeof(Storage) !== "undefined") {
                var sessionExp = this.getResponseHeader('sessionExpiry');
                sessionStorage.setItem("sessionExpiry", sessionExp);
            }
          });
          protoTypeOpen.apply(this, arguments);
        };
      },
    suppressPaginationUpdate: false,
    updateDeferred: null
  });
  // module level shortcuts. Used by the list control accessibility code above. 
  var cu = curam.util,
      getFrom = dojo.getObject,
      putTo = dojo.setObject,
      isHere = dojo.exists,
      READOUT = 'aria-label',
      ROW_IDX = 'data-lix';

  return curam.util;
});

},
'curam/dialog':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define(["dojo/dom",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/on",
        "dojo/sniff",
        "curam/inspection/Layer",
        "curam/util",
        "curam/debug",
        "curam/util/external",
        "curam/util/Refresh",
        "curam/tab",
        "curam/util/RuntimeContext",
        "curam/util/ScreenContext",
        "curam/define",
        "curam/util/onLoad",
        "dojo/dom-class",
	    "dojo/query",
	    "dojo/NodeList-traverse"], 
	    
	    function(dom, domAttr, domConstruct, on, has, layer, util, trace, external, refresh, tab, runtimeContext, screenContext, define, onload, domClass, query) {


/*
 * Modification History
 * --------------------
 * 09-Mar-2022  CM  [RTC276771] Include the forceParentLocaleRefresh function for new user-locale-selector.jspx file.
 * 11-Aug-2011  SK  [RTC272800] Progress Spinner invocation changed.
 * 15-Jun-2021  SK  [RTC272800] Changes in logging to prevent the memory picture distortion by the DevTools.
 * 03-Jun-2021  BD  [RTC271240] Moved returnFocusToPopupActionAnchorElement function to util.js.
 * 05-May-2021  BD	[RTC266244] Updated unload signal  moving code to CuramCarbonModal JS and 
 * Updated selector from the method curam.dialog._returnFocusToPopupActionAnchorElement.
 * 25-Feb-2021  JD	[RTC266244] Removed checks for IE11 when calling curam.dialog._returnFocusToPopupActionAnchorElement in
 * initModal().
 * 31-Jan-2021 BOS  [RTC267877] Updates for carbon modal.
 * 09-Jan-2020  FN	[RTC254490] Adding some logic in initModal() when using IE11 to focus on correct element once a popup is closing.
 * 10-Oct-2019  CM  [RTC253438] Add check for modals exiting an IEG script to use the dojo.addOnUnload event, as modals
 *                              exiting an IEG script weren't closing correctly in IE11 browsers.
 * 07-Aug-2019  SH  [RTC238154] Do not proceed with submitting a form in formSubmitHandler if event return value is false.
 * 01-Jul-2019  GG [RTC245742] Added call to util.extendXHR in initModal to allow the update of SessionStorage timeout value.
 * 31-May-2019  GG  [RTC244768] Fixing an issue in the agenda player pages when a validation message is displayed.
 * 24-Oct-2018	CMC [RTC225885] Fixing accessibility issue where initial focus was not  
 * 							    being placed correctly on the first editable page element.
 * 20-Sep-2018  CM  [RTC227605] Add method _stylingAddedToMandatoryIconHelp to add class to mandatory-icon-help
 					when wizard progress bar exists.
 * 10-Set-2018  BD  [RTC227106] Included methods _createSpanContainingInformationOnCurrentWizardTab and _screenReaderAnnounceCurrentTabOnWizard
 *                              from ModalDialog.js to dialog.js.
 * 21-Aug-2018  BD  [RTC229425] Removed the handler to the unload event after it happen
 *                  to avoid memory leak.
 * 11-Aug-2018  SK  [RTC234604] The back-button functionality related changes.
 * 11-Jun-2018  BD  [RTC-185627] Added the UA context when the screen context 
 * is created and it is an UA application.
 * 22-Jun-2017  BD  [RTC-198658] Changed method  topic closeModalDialog
 * adding the topic /curam/dialog/close/appExitConfirmation.
 * 05-May-2016  SK  [CR00479312] Removed cm layer usage.
 * 27-Feb-2015  AB  [CR00458854] TEC-17714 Added 'option' variable to the
 * closeModalDialog function so we can pass that variable to the
 * "/curam/dialog/close" event.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 25-Mar-2014  MV  [CR00423311] Handle usage from an external application.
 * 10-Jul-2013  KW  [CR00391894] Remove reference o3_artificial_post parameter.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 11-Mar-2013  MV  [CR00373738] Remove change to close dialog when page
 *    is loaded. We'll do it differently in curam/ModalDialog.
 * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
 * 24-Sep-2012  MV  [CR00345119] Revert the change to the function used for
 *      detecting when page unloads in a modal.
 * 24-Jul-2012  MK  [CR00336401] Wrapped contents of the closeModalDialog
 *    method in dojo.ready to prevent it closing the model before the page has
 *    finished loading.
 * 07-Feb-2012  MV  [CR00301458] Code cleanup.
 * 15-Sept-2011 MK  [CR00287680] Change the function that is used to detect a 
 *      page unloading in a modal. Changing from addOnUnload to addOnWindowUnload
 * 02-Aug-2011  MV  [CR00283023] Refactored modalEventHandler to allow
 *      unit testing. Avoid unwanted refresh when parent is an Action.do page.
 * 29-Jul-2011  MV [CR00269970] Add support for refreshing based on submit with
 *      inline page as parent. 
 * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
 *                    panel on submit.
 * 28-Jan-2011  MV  [CR00245381] Catch Access denied error when accessing
 *    external sites.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 13-Jan-2011  MV  [CR00241667] Fire event when the dialog infrastructure
 *    is ready.
 * 05-Jan-2011  SK  [CR00239843] Previous page id parameter is not added any
 *                  longer to the form submits from Agenda Player.
 * 12-Jan-2011  SK  [CR00241719] Added the option to close modal without
 *                               the parent redirect.
 * 29-Nov-2010  MV  [CR00232623] Add in a hack to properly unregister a handler
 *    on page unload when using agenda player.
 * 23-Nov-2010  MV  [CR00232063] Remove page loading mask.
 * 19-Nov-2010 MV [CR00231655] Store the display status and dialog size
 *     in the runtime context.
 * 18-Nov-2010 MV [CR00231387] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 27-Oct-2010  MV  [CR00224488] Refactor for the dialog closing to work well
 *    with new HTML structure.
 * 26-Oct-2010  SK  [CR00224193] The situation where the dialog is opened from
 *                               non-page parent is now handled correctly.
   * 14-Oct-2010  MV  [CR00223441] Move functions to util namespace. Remove
 *    double invoking of a function.
 * 07-Oct-2010  MV  [CR00221605] Refactor for dialogs to work with the generic
 *    key handler that submits the page when Enter is pressed.
 * 17-Sep-2010  MV  [CR00220607] Removed a dead branch of code.
 * 27-Aug-2010  MV  [CR00217499] Refactored to remove hacks previously needed
 *                    to support the agenda player. Documentation comments
 *                    switched to jsdoc.
 * 21-Jul-2010  MV  [CR00211225] Indicate in the `onLoad` context that modal
 *                    is closing.
 * 24-Jun-2010  AF  [CR00202526] Removing reference to content-panel class name
 *                               in the calculateHeightByContents method.
 * 24-Jun-2010  MV  [CR00203864] Add debug output to autoheight calculation.
 * 09-Jun-2010  MV  [CR00202971] Remove the curam.iframeLoaded event,
 *                               add the height calculation function.
 * 04-Jun-2010  MV  [CR00202412] Simplify getting event identifier.
 * 23-Apr-2010  MV  [CR00194352] Fix screen context handling for HTML forms.
 * 11-Feb-2010  MV  [CR00188844] Add event identifier to the iframeLoaded event.
 * 11-Dec-2009  MV  [CR00173949] Remove the "SrPopUp" window name.
 * 24-Nov-2009  MV  [CR00175899] Only call the closeModal function if there
 *                                are no informational messages.
 * 20-Nov-2009  MV  [CR00175581] Replace curam.tab.refreshCurrentTab() call
   *                               with the correct util.redirectWindow().
   * 20-Nov-2009  MV  [CR00175615] Use the util.firePageSubmittedEvent
 *                                function.
 * 03-Sep-2009  MLB [CR00164883] Updated to refresh the current tab for user
 *                  preferences.
 * 07-Aug-2009  MV  [CR00164029] Notify the tabbed UI refresh mechanism
                                on submit. Reverted the previous change as now
                                the refresh is working as expected.
 * 23-Jul-2009  MV  [CR00162771] Updated to not refresh parent window when
 *                  in Tabbed UI.
 */
  
/**
 * @namespace Functions related to the Curam dialog support for UIMs.
 */
curam.define.singleton("curam.dialog", {
  MODAL_PREV_FLAG: "o3modalprev",
  MODAL_PREV_FLAG_INPUT: "curam_dialog_prev_marker",
  FORCE_CLOSE: false,
  ERROR_MESSAGES_HEADER: "error-messages-header",

  /**
   * Keeps track of the hierarchy of window objects for the open dialogs.
   * @private
   */
  _hierarchy: [],

  /**
   * ID of the dialog for the current context.
   * @private
   */
  _id: null,

  /**
   * @private
   */
  _displayedHandlerUnsToken: null,

  /**
   * True if the dialog has been displayed, false otherwise.
   * @private
   */
  _displayed: false,

  /**
   * Holds the current size of the dialog or null if it was not yet published.
   * @private
   */
  _size: null,

  /**
   * Indicates if the dialog should close without the parent redirection. 
   * @private
   */
  _justClose: false,
  
  /**
   * Indicates if the dialog is exiting an IEG script.
   * @private
   */
  _modalExitingIEGScript: false,

  validTargets: {
    "_top":true,"_self":true
  },

  
  /**
   * 
   * @param pageId - page containing modal's content.
   * @param messagesExist
   * @param parentHrefOnClose - If the modal is closing, this property will be 
   * used to reload the parent. If It is null then window.location.href will be used instead.
   */ 
  initModal: function(pageId, messagesExist, parentHrefOnClose) {
    curam.dialog.pageId = pageId;
    curam.dialog.messagesExist = messagesExist;
    var loaded = false;
    var p1;
    util.extendXHR();
    //trace.logLocalized(["curam.dialog: "], "rangeMessage");

      var topWin = util.getTopmostWindow();
    // receive the ID of the dialog
    var isIdSet = false;
    var unsToken = topWin.dojo.subscribe(
        "/curam/dialog/SetId", this, function(dialogId) {
            trace.log("curam.dialog: " 
              + trace.getProperty("curam.dialog.id"), dialogId);
          //trace.logLocalized(["curam.dialog: ", "curam.dialog.id"], dialogId); // FIXME
          curam.dialog._id = dialogId;
          isIdSet = true;

          topWin.dojo.unsubscribe(unsToken);
        });

    // trigger the dialog infrastructure init
    // also sets the dialog ID - see above
    topWin.dojo.publish("/curam/dialog/init");
    if (!isIdSet) {
      // unsubscribe, the modal infrastructure already initialized
      // or nobody listening for this particular event
      trace.log("curam.dialog: " + trace.getProperty("curam.dialog.no.id")); // FIXME
      //trace.logLocalized(["curam.dialog: "], "curam.dialog.no.id"); 
      topWin.dojo.unsubscribe(unsToken);
    }

    if(curam.dialog.closeDialog(false, parentHrefOnClose)) {
      // Do not do any more modal processing. Either the body is hidden off to
      // the left of the screen and messages are being displayed, or the window
      // has been closed.
      return;
    }

    // let us know when we are displayed
    curam.dialog._displayedHandlerUnsToken =
          util.getTopmostWindow().dojo.subscribe(
        "/curam/dialog/displayed", null, function(dialogID, size) {
          if (dialogID == curam.dialog._id) {
            curam.dialog._displayed = true;
            curam.dialog._size = size;

              util.getTopmostWindow().dojo.unsubscribe(
                curam.dialog._displayedHandlerUnsToken);
            curam.dialog._displayedHandlerUnsToken = null;
          }
        });
    // a hack to unsubscribe for agenda pages
    if (jsScreenContext == undefined) {
      var jsScreenContext = this.jsScreenContext;
      if (!jsScreenContext) {
        jsScreenContext = new screenContext();
        jsScreenContext.addContextBits("MODAL");
        //[RTC-244768] - It sets the correct context for all pages within an agenda player.
		if(dojo.global.jsScreenContext.hasContextBits('AGENDA'))
		{
		  jsScreenContext.addContextBits("AGENDA");
		}
        //[RTC-185627] - If it is an EXTAPP, the context for it is added to the screencontext object.
        curam.util.external.inExternalApp() && jsScreenContext.addContextBits("EXTAPP");
      }
    }
    if (jsScreenContext.hasContextBits("AGENDA")
        || jsScreenContext.hasContextBits("TREE")) {

      dojo.addOnUnload(function() {
        util.getTopmostWindow().dojo.unsubscribe(
          curam.dialog._displayedHandlerUnsToken);
        curam.dialog._displayedHandlerUnsToken = null;
      });
    }

    //Wait for the page to load, then add onClick and onKey listeners to the
    //body element
    dojo.addOnLoad(function() {
    // Handle clicks in the dialog window
      util.connect(dojo.body(), "onclick", curam.dialog.modalEventHandler);

      // setup the forms in the page
     for (var i = 0; i < document.forms.length; i++) {
      var form = document.forms[i];
      curam.dialog.addFormInput(form, 'hidden', 'o3frame', 'modal');

      var ctxField = dom.byId('o3ctx');
      var sc = new curam.util.ScreenContext(jsScreenContext.getValue());
      sc.addContextBits("ACTION|ERROR");
      ctxField.value = sc.getValue();

        util.connect(form, "onsubmit", curam.dialog.formSubmitHandler);
      }

      // mark as modal window - for later detection
      // by util.isModalWindow()
      window.curamModal = true;
    });

    if (curam.util.isExitingIEGScriptInModalWindow()) {

      delete curam.util.getTopmostWindow().exitingIEGScript;
      	
      dojo.addOnUnload(function() {

        util.getTopmostWindow().dojo.publish(
  	            "/curam/dialog/iframeUnloaded", [ curam.dialog._id, window ]);
        });

      } else {
  	      
        var signal = on(window, 'unload', function() {

        signal.remove();
        util.getTopmostWindow().dojo.publish(
                 "/curam/dialog/iframeUnloaded", [ curam.dialog._id, window ]);
                
        });
    } 

    if (isIdSet) {
      dojo.publish("/curam/dialog/ready");
    }
  },

  /**
   * Sets a variable to true for uim pages existing an IEG script. 
   * 
   */
  setVariableForModalExitingIEGScript: function() {

    _modalExitingIEGScript = true;
  },

  closeDialog: function(force, parentHrefOnClose) {
    if(force) {
      curam.dialog.forceClose();
    }
    var closeFunction = curam.dialog.checkClose(curam.dialog.pageId, parentHrefOnClose);
    if(closeFunction) {
        util.onLoad.addPublisher(function(context) {
        context.modalClosing = true;
      });

      //If the dialog window should close, but informational messages exist,
      //delay the closing of the window. Add a class to the messages to make
      //them visible, and place a button under them to close the window.action
      //If no messages exist, then just close the window, and optionally
      //redirect the parent page.
      if(curam.dialog.messagesExist) {
        dojo.addOnLoad(function(){
            var errMsgContainer = dom.byId(util.ERROR_MESSAGES_CONTAINER);
            var errMsgNode = dom.byId(util.ERROR_MESSAGES_LIST);
          var errMsgHeaderNode = dom.byId(curam.dialog.ERROR_MESSAGES_HEADER);

          if(errMsgNode && errMsgHeaderNode) {
            //Save the messages locally, to be loaded by the next page that loads
            //which should be the parent page. The closeFunction is called
            //once the messages have been saved.
              util.saveInformationalMsgs(closeFunction);

            //Disable loading of informational messages in the popup,
            //so it doesn't run. This prevents a race condition which would wipe
            //out the messages before the parent page loads.
              util.disableInformationalLoad();

          } else {
            closeFunction();
          }
        });

      } else {
        //If no error messages exist, just run the close function.
        closeFunction();
      }
      //Return true, stating that the dialog is closing.
      return true;
    }
    //Return false, that the dialog is not closing.
    return false;
  },

  addFormInput: function(form, type, name, value) {
    return domConstruct.create("input", {
      "type": type,
      "name": name,
      "value": value
    }, form);
  },

  /**
   * Checks if the window should be closed. If the window should close, this
   * function returns another function which, when executed, closes the dialog,
   * and optionally redirects the parent page. If the window should not close,
   * it returns false.
   */
  checkClose: function(pageId, parentHrefOnClose) {
    if (curam.dialog._justClose) {
      return function() {
        curam.dialog.closeModalDialog();
      };
    }
	
    var parentWindow = curam.dialog.getParentWindow(window);
    if (!parentWindow) {
      return false;
    }

    //Check if the page is in a modal dialog, and if it is, whether or not
    //it should be closed.
    var href;
    if(parentHrefOnClose){
      href = curam.util.retrieveBaseURL() + parentHrefOnClose;
    }else{
      href = window.location.href;
    }
    
    
    var prevFlag = curam.dialog.MODAL_PREV_FLAG;

    var oldPageId = util.getUrlParamValue(href, prevFlag);
    var doClose = true;
    if (oldPageId) {
      if (parentWindow) {
        // If the URL parameter MODAL_PREV_FLAG is set, and is not the same
        // as the current page id, then shut down the dialog and redirect
        // the parent page the current URL. Remove the MODAL_PREV_FLAG
        if(oldPageId == pageId) {
          doClose=false;
        }
      }
    
    } else {
      doClose = false;
    }

      var scReq = util.getUrlParamValue(href, "o3ctx");
    if (scReq) {
      var sc = new curam.util.ScreenContext();
      sc.setContext(scReq);
      if (sc.hasContextBits('TREE|ACTION')) {
        doClose=false;
      }
    }

    if (doClose || curam.dialog.FORCE_CLOSE) {
      if (!curam.dialog.FORCE_CLOSE) {
        if (oldPageId=="user-prefs-editor") {
          return function() {
            if (parentWindow && parentWindow.location
                               !== util.getTopmostWindow().location) {
              curam.dialog.doRedirect(parentWindow);
            }
            curam.dialog.closeModalDialog();
          };
        }
        return function() {
            var rp = util.removeUrlParam;
          // Remove the modal and prevent cache flags from the url
          // before telling the parent to change it's location.
            href = rp(rp(rp(href, prevFlag), "o3frame"),util.PREVENT_CACHE_FLAG);
            href = util.adjustTargetContext(parentWindow, href);
          if (parentWindow && parentWindow.location
                                 !== util.getTopmostWindow().location) {
            curam.dialog.doRedirect(parentWindow, href, true);

          } else {
            curam.tab.getTabController().handleLinkClick(href);
          }
          curam.dialog.closeModalDialog();
        };

      } else {
        return function() {
          // In case there are some informational messages on the modal dialog,
          // make sure they are loaded in to the parent page, even if it
          // isn't refreshed.
            if (parentWindow !== util.getTopmostWindow()) {
            parentWindow.curam.util.loadInformationalMsgs();
          } //otherwise nowhere to show them
          
          curam.dialog.closeModalDialog();
        };
      }
    }
    return false;
  },

  /**
   * Returns the parent window of either the current window or of the specified
   * window.
   *
   * @param {window} [child] If specified, the dialog hierarchy will be used
   *      to look up the parent window.
   */
  getParentWindow: function(/*optional*/child) {
    if (!child) {
    	trace.log(["curam.dialog.getParentWindow():", 
                   trace.getProperty("curam.dialog.no.child"),
                   window.location ? ' '+ window.location.href : '[no location]'].join(' '));
        trace.log("returning as parent = ", window.parent.location.href);
      return window.parent;
    }
    ///trace.logLocalized(["curam.dialog.getParentWindow(): ", "curam.dialog.child"], child.location.href);
    var hierarchy = curam.dialog._getDialogHierarchy();
    if (hierarchy) {
      for (var i = 0; i < hierarchy.length; i++) {
        if (hierarchy[i] == child) {
          // the child found in the stack, parent is at the previous index
          var realParent = (i > 0) ? hierarchy[i - 1] : hierarchy[0];
          trace.log(["curam.dialog.getParentWindow():",
                       trace.getProperty("curam.dialog.parent.window"),
                       realParent.location ? realParent.location.href : '[no location]'].join(' '));
          return realParent;
        }
      }
      // the child NOT found in the stack
      /*trace.logLocalized(["curam.dialog.getParentWindow(): ", 
        "curam.dialog.child.not.found"], child.location.href);
      trace.logLocalized(["curam.dialog.getParentWindow(): ", 
        "curam.dialog.hierarchy"], hierarchy);*/
      var ret = hierarchy.length > 0 ? hierarchy[hierarchy.length - 1] : undefined;
      trace.log(["curam.dialog.getParentWindow():", 
                 trace.getProperty("curam.dialog.returning.parent"), 
                 ret ? ret.location.href : "undefined"].join(' '));
      return ret;
    }
   
  },

  /**
   * Dialog hierarchy is a way for the code to keep track of parent/opener
   * windows for the open modal dialogs. The window.parent property
   * cannot be used for this purpose, because for dojo dialogs it is always
   * pointing at the same parent window, so it does not reflect the real
   * dialog hierarchy.
   *
   * The hierarchy is implemented as a simple stack of consecutive window
   * objects.
   *
   * @returns Array The hierarchy of window objects.
   * @private
   */
  _getDialogHierarchy: function() {
    // the hierarchy is stored in the topmost window - the truly global context
    // TODO: Lookd like refactoring here using promises e.t.c to have
    // this converted to AMD the fucntions that depend on this one need to
    // behvae async too -- BOS
    var topmostWindow = util.getTopmostWindow();
    topmostWindow.require(["curam/dialog"]);
    return topmostWindow.curam.dialog._hierarchy;
  },

  /**
   * Pushes the specified window onto the dialog hierarchy stack,
   * unless the window is already part of the stack.
   */
  pushOntoDialogHierarchy: function(newParent) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if (hierarchy && dojo.indexOf(hierarchy, newParent) < 0) {
      hierarchy.push(newParent);
        trace.log(trace.getProperty("curam.dialog.add.hierarchy"), 
          newParent.location.href);
        trace.log(trace.getProperty("curam.dialog.full.hierarchy") + hierarchy.reduce(function(acc, hwin) {
           return acc + '[' + (hwin.location.href || '-') + ']';
        }), '');
    }
  },

  /**
   * Removes the specified window from the dialog hierarchy stack.
   *
   * @param child The window object to remove from the dialog hierarchy.
   */
  removeFromDialogHierarchy: function(child) {
    var hierarchy = curam.dialog._getDialogHierarchy();
    if(!child || hierarchy[hierarchy.length - 1] == child) {
      hierarchy.pop();

    } else {
        trace.log("curam.dialog.removeFromDialogHierarchy(): " 
          + trace.getProperty("curam.dialog.ignore.request"));
      try {
          trace.log(child.location.href);
      
      } catch(e) {
        // in scenarios where we open external site in a dialog, this call
        // causes Access denied exception - we just  catch it and continue
          trace.log(e.message);
      }
    }
  },

  stripPageOrActionFromUrl: function(url) {
    var idx = url.lastIndexOf("Page.do");
    var len = 7;
    if(idx < 0) {
      idx = url.lastIndexOf("Action.do");
      len = 9;
    }
    if(idx < 0) {
      idx = url.lastIndexOf("Frame.do");
      len = 8;
    }
    if(idx > -1 && idx == url.length - len){
      return url.substring(0, idx);
    }
    return url;
  },

  /**
   * @private
   * 
   * @param href
   * @param rtc
   * @param stripPageOrAction
   * @returns {Boolean}
   */
  _isSameBaseUrl: function(href, rtc, stripPageOrAction) {
    if(href && href.indexOf('#') == 0){return true;}
    var hrefSplit = href.split("?");
    var hereSplit = rtc.getHref().split("?");

    //If one url is relative, and the other is absolute, compensate by removing
    //everything except what's after the last "/"
    if(hrefSplit[0].indexOf("/") < 0) {
      var parts = hereSplit[0].split("/");
      hereSplit[0] = parts[parts.length -1];
    }
    if(hereSplit[0].indexOf("/") < 0) {
      var parts = hrefSplit[0].split("/");
      hrefSplit[0] = parts[parts.length -1];
    }

    if (stripPageOrAction && stripPageOrAction == true) {
      hrefSplit[0] = curam.dialog.stripPageOrActionFromUrl(hrefSplit[0]);
      hereSplit[0] = curam.dialog.stripPageOrActionFromUrl(hereSplit[0]);
    }

    if(hrefSplit[0] == hereSplit[0]){
      return true;
    }

    return false;
  },

  modalEventHandler: function(event) {
    curam.dialog._doHandleModalEvent(event,
        new curam.util.RuntimeContext(window),
        curam.dialog.closeModalDialog,
        curam.dialog.doRedirect);
  },

  _showSpinnerInDialog: function() {
    // Display Progress Spinner on submit.
	curam.util.getTopmostWindow().dojo.publish("/curam/dialog/spinner");
  },
  
  /**
   * Hanldes the specified event.
   * 
   * @param e The event to handle.
   * @param rtc Runtime context.
   * @param closeDialog The function to be called to close the dialog.
   * @param doRedirect The function to be called to redirect the parent window
   *    to a new location.
   * @returns {Boolean} True if the event should continue, false if it should
   *    be stopped.
   */
  _doHandleModalEvent: function(e, rtc, closeDialog, doRedirect) {
    var target = e.target;
      var u = util;
      
    switch(target.tagName) {
      case 'INPUT':
        // If the user clicks a submit control, copy its "keepModal" attribute
        // on to the form it is in so that can be read by the onSubmit handler
        if(domAttr.get(target, "type") == "submit"
            && typeof target.form != "undefined") {

          target.form.setAttribute("keepModal", target.getAttribute("keepModal"));
          curam.dialog._showSpinnerInDialog();
          
        }
        return true;

      case 'IMG': case 'SPAN': case 'DIV':
        target = query(target).closest('A')[0];
        //target = target.parentNode;
        if (target == null) {
          return;
        }
        //If the IMG, SPAN or DIV node has an anchor tag parent, leave it run
        //into the 'A' case after changing the target to the parent anchor tag.
      case 'A': case 'BUTTON':
        // If the target is an anchor tag, just get out of the switch statement
        // and keep going in the function, unless the anchor tag is a
        // dynamically generated tag used to replace a submit button.
        // This replacement is done in util.replaceSubmitButton function.
        if(target._submitButton) {
          target._submitButton.form.setAttribute("keepModal",
              target._submitButton.getAttribute("keepModal"));
          curam.dialog._showSpinnerInDialog();
          return;
        }
        
        break;
      default:
        //If we're not interested in this tag, ignore the event
        return true;
    }
    var stopEvent = dojo.stopEvent;
    
    var href = target.getAttribute("href") || target.getAttribute("data-href");

    // handling the case of a cancel link where there is no o3rpu
    if (href == '') {
      closeDialog();
      return false;
    }
    
    // If the anchor tag does not have a href, we simply cancel the event.
    // Any onlick handlers attached directly to the anchor element will have
    // completed by the time this handler is called.
    if (!href) {
      return false;
    }

    if (href.indexOf("javascript") == 0) {
      return false;
    }
    var ctx = jsScreenContext;
    ctx.addContextBits('MODAL');

    //If the anchor tag is trying to open a new window, open it separately,
    //and do not change this page, or redirect the parent
    var targetWindow = target.getAttribute("target");
    if(targetWindow && !curam.dialog.validTargets[targetWindow]) {
      return true;
    }
    //Make sure that file download links do not close the modal dialog.
    //Instead, create an iframe on the fly, and set it's source to the file
    //that is to be downloaded.
    if(href && href.indexOf("/servlet/FileDownload?") > -1) {
      var iframe = domConstruct.create("iframe", {
        src: href
      }, dojo.body());
      iframe.style.display = 'none';
      stopEvent(e);
      return false;
    }

    //If the link is to a URL outside the Curam application, open the link in
    //a new window.
    if(domClass.contains(target, "external-link")) {
      return true;
    }

    // If the link is not going to result in the page changing,
    // then do nothing
      if(util.isSameUrl(href, null, rtc)) {
      // If the link is not simply linking in this page, then redirect the page.
      // otherwise just let the page jump to the local anchor tag.
      if(href.indexOf("#") < 0) {
         href = u.replaceUrlParam(href, "o3frame", "modal");
         href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
         doRedirect(window, href);
         return false;
      }
      return true;
    }
    if(href && curam.dialog._isSameBaseUrl(href, rtc, true)
        && !target.getAttribute("keepModal")){

      target.setAttribute("keepModal", "true");
    }

    var parentWindow = curam.dialog.getParentWindow(rtc.contextObject());
    
    if(target && target.getAttribute) {
      stopEvent(e);

      //If the link has the 'keepModal' attribute set to true, then
      // the new page should be opened in the same modal dialog.
      if(target.getAttribute("keepModal") == "true") {
        href = u.replaceUrlParam(href, "o3frame", "modal");
        href = u.replaceUrlParam(href, "o3ctx", ctx.getValue());
        doRedirect(window, href);

      // Otherwise the dialog will close and target will be opened in the parent
      // page
      } else if(parentWindow) {
        href = u.removeUrlParam(href, "o3frame");
        href = u.removeUrlParam(href, curam.dialog.MODAL_PREV_FLAG);
        
        if (parentWindow.location !== util.getTopmostWindow().location) {
          var parentRtc = new curam.util.RuntimeContext(parentWindow);
          var phref = parentRtc.getHref(); 
          phref = u.removeUrlParam(phref, "o3frame");
          
          // only redirect if the parent window is not already on the target
          // page 

          // for submitted action pages in the parent window only comapare
          // the base URL, ignoring any page parameters, because they are not
          // included in the Action.do type URL anyway
          if (util.isActionPage(phref)) {
            if (!curam.dialog._isSameBaseUrl(href, parentRtc, true)) {
              href = u.adjustTargetContext(parentWindow, href);
              doRedirect(parentWindow, href);
            }
            
          // for all other pages compare full URLS and only redirect if
          // the same page is not already loaded
          } else {
            if (!util.isSameUrl(href, phref)) {
              href = u.adjustTargetContext(parentWindow, href);
              curam.dialog.doRedirect(parentWindow, href);
            }
          }
        
        } else {
          //no tab opened
          var tabContext = new curam.util.ScreenContext('TAB');
          href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
          curam.tab.getTabController().handleLinkClick(href);
        }

        closeDialog();
      }

      return false;
    }

    if (parentWindow && typeof(target) == "undefined" || target == null
      || target == "_self" || target == "") {
      stopEvent(e);
      href = href.replace(/[&?]o3frame=modal/g, "")
        .replace("%3Fo3frame%3Dmodal", "")
        .replace("?o3frame%3Dmodal", "");
      //modal closes, so the context should be replaced by the previous.
        href = util.updateCtx(href);
        if (parentWindow.location !== util.getTopmostWindow().location) {
        doRedirect(parentWindow, href);
      
      } else {
        //no tab opened
        var tabContext = new curam.util.ScreenContext('TAB');
        href = u.replaceUrlParam(href, "o3ctx", tabContext.getValue());
        curam.tab.getTabController().handleLinkClick(href);
      }
      
      closeDialog();
      return false;
    }

    //In this case, the page wants to open a popup window
    return true;
  },

  /**
   * This listener handles the onSubmit event of all forms on the page.
   * It adds the current page ID to the URL as the 'oldPageId' parameter
   * and if the window should be closed, it adds the 'MODAL_PREV_FLAG=true'
   * parameter to the URL.
   */
  formSubmitHandler: function(e) {
    // If the event that is submitting this form has a return value of false
    // (eg from a validation) then stop form submission. 
    if (e.type == "submit" && e.defaultPrevented) {
      curam.util.getTopmostWindow().dojo.publish("/curam/progress/unload");
      return false;
    }

    var parentWindow = curam.dialog.getParentWindow(window);
    if(typeof parentWindow == "undefined") {
      return true;
    }

    e.target.method="post";
    e.target.setAttribute("target", window.name);
    var action = e.target.action;

    var prevFlag = curam.dialog.MODAL_PREV_FLAG;
    var flagInputId = curam.dialog.MODAL_PREV_FLAG_INPUT;
      var u = util;

    // If the input has previously been written to the form, delete it.
    // This is to handle multiple submissions, which can happen if an exception
    // is thrown during submission.
    var input = dom.byId(flagInputId);
    if(input) {
      input.parentNode.removeChild(input);
    }

    // Set the page id in the url if the following page should close the modal
    // dialog if the id has changed. Add a hidden input to the form too, which
    // will be used if the form is a multi-part post containing a file.
    if(e.target.getAttribute("keepModal") != "true"
         && !jsScreenContext.hasContextBits('AGENDA')) {
      var multipart = 'multipart/form-data';
      if(e.target.enctype == multipart || e.target.encoding==multipart) {
        e.target.action = u.removeUrlParam(action, prevFlag);
        input = curam.dialog.addFormInput(e.target, "hidden", prevFlag,
                                          curam.dialog.pageId);
        input.setAttribute("id", flagInputId);
        input.id = flagInputId;

      } else {
        e.target.action = u.replaceUrlParam(action, prevFlag, curam.dialog.pageId);
      }

    } else {
      e.target.action = u.removeUrlParam(action, prevFlag);
    }

    //Tell the parent page that the modal it opened has submitted a form, so
    //that if the user clicks a 'Cancel' link later, the parent page will
    //refresh itself.
    parentWindow.curam.util.invalidatePage();

    // Hook into the overall tabbed UI refresh mechanism (except for external
    // application).
    if (!jsScreenContext.hasContextBits("EXTAPP")) {
      util.firePageSubmittedEvent("dialog");
    }
    return true;
  },

  /**
   * If this is called in the document head, then initModal will shut down
   * no matter what the conditions. This is like a window.close call,
   * except it will refresh the parent if necessary.
   */
  forceClose: function() {
    curam.dialog.FORCE_CLOSE = true;
  },

  /**
   * If this is called in the document head, then any call to
     * util.redirectWindow in the parent window will only refresh it,
   * instead of redirecting it to another URL.  This is primarily used
   * in the user preferences dialog.
   */
  forceParentRefresh: function() {
    var parentWindow = curam.dialog.getParentWindow(window);
    if(!parentWindow){return;}
    parentWindow.curam.util.FORCE_REFRESH = true;
  },
  

  /**
   * If this is called in the document head, then any call to
   * curam.util.redirectWindow in the parent window will refresh it, instead
   * of redirecting it to another URL. The locale in the URL will be replaced
   * by locale from the passed href. This is used in the user locale selector
   * dialog.
   */
  forceParentLocaleRefresh: function(){
	var parentWindow=curam.dialog.getParentWindow(window);
	 if(!parentWindow){return;}
	parentWindow.curam.util.LOCALE_REFRESH=true;
  },

  closeModalDialog: function(option) {
    var topmostWindow = util.getTopmostWindow();
    if (curam.dialog._displayedHandlerUnsToken != null) {
      topmostWindow.dojo.unsubscribe(curam.dialog._displayedHandlerUnsToken);
      curam.dialog._displayedHandlerUnsToken = null;
    }

    var isExtApp = curam.util.getTopmostWindow().dojo.global.jsScreenContext.hasContextBits("EXTAPP");
    if ((typeof(curam.dialog._id) == "undefined" || curam.dialog._id == null || !isExtApp) && window.frameElement) {
      var frameID = window.frameElement.id;
      var modalID = frameID.substring(7);  // remove "iframe-" prefix
      curam.dialog._id=modalID;
      trace.log("curam.dialog.closeModalDialog() " 
          + trace.getProperty("curam.dialog.modal.id") + modalID);
    }
    
    util.getTopmostWindow().dojo.publish(
            "/curam/dialog/close/appExitConfirmation", [ curam.dialog._id ]);
    trace.log("publishing /curam/dialog/close/appExitConfirmation for ", curam.dialog._id);
    
    
    trace.log("publishing /curam/dialog/close for ", curam.dialog._id);
    util.getTopmostWindow().dojo.publish(
        "/curam/dialog/close", [ curam.dialog._id, option ]);
  },

  /**
   * Parses the window options string.
   *
   * @returns An object with window option properties. In case no windowOptions
   *          were passed if, empty object (with no properties) is returned.
   */
  parseWindowOptions: function(windowOptions) {
    var opts = {};

    if(windowOptions) {
        trace.log("curam.dialog.parseWindowOptions " 
          + trace.getProperty("curam.dialog.parsing"), windowOptions);
      var tokens = windowOptions.split(',');
      var splitToken;
      for(var i = 0; i < tokens.length; i++) {
        splitToken = tokens[i].split('=');
        opts[splitToken[0]] = splitToken[1];
      }
        trace.log("done:", dojo.toJson(opts));

    } else {
        trace.log("curam.dialog.parseWindowOptions " 
          + trace.getProperty("curam.dialog.no.options"));
    }

    return opts;
  },

  /**
   * Redirects to a new URL in the specified context.
   * 
   * @param context The runtime context in which the redirect will take place.
   * @param [href] URL of the target page or null.
   * @param [force] Indicates if the refresh should take place even
   *    if the href is the same as the current href.
   * @param [ignoreFrames] If true, then any other frames on the page are
   *    not refreshed.
   */
  doRedirect: function(context, href, force, ignoreFrames) {
    window.curamDialogRedirecting = true;
    if (!curam.util.getTopmostWindow().dojo.global.jsScreenContext.hasContextBits("EXTAPP")) {
      curam.util.getTopmostWindow().dojo.publish("/curam/CuramCarbonModal/redirectingModal");
    }
    context.curam.util.redirectWindow(href, force, ignoreFrames);
  },
  
  /**
   * Called on dialog display time. Creates a span containing information
   * on the current wizard tab after the user has clicked next or back, then 
   * adds this span to an aria live region so it can be announced by a screen reader. 
   * Implemented specifically for RTC Defect 227106. Where present, the wizard tab  
   * title and descrition will be read out along with a description of the
   * first cluster if this cluster does not contain a title.
   */
  _screenReaderAnnounceCurrentTabOnWizard: function() {
	var wizardProgressBar = dom.byId("wizard-progress-bar");
	if (wizardProgressBar) {	
		var hiddenAriaLiveElement = dom.byId("hideAriaLiveElement");
		if (typeof hiddenAriaLiveElement != null) {
			this._createSpanContainingInformationOnCurrentWizardTab(wizardProgressBar, hiddenAriaLiveElement);
		}
	 }
  }, 
  
  /**
   * Adds a new styling class to the mandatory icon help label, if both this label and 
   * the wizard progress bar exists.
   */

  _stylingAddedToMandatoryIconHelp: function() {
        var wizardProgressBar = dom.byId("wizard-progress-bar");
        var mandatoryIconHelp = dojo.query(".mandatory-icon-help")[0];
    
        if (wizardProgressBar && mandatoryIconHelp) {
          domClass.add(mandatoryIconHelp, "wizard-progress-bar-exists");
        }
   
        
  },
  
  /**
   * Creates the span containing any reuqired information on the 
   * current wizard tab which should be announned by a screen reader. 
   */
  _createSpanContainingInformationOnCurrentWizardTab: function (wizardProgressBar, hiddenAriaLiveElement) {
		var elementContainingWizardInfoToBeRead = null;
		var description = '';
		var BLANK_SPACE = " ";
		var title = query(".title", wizardProgressBar)[0] && query(".title", wizardProgressBar)[0].innerText;
		var desc =  query(".desc", wizardProgressBar)[0] && query(".desc", wizardProgressBar)[0].innerText;
		if(title && title != ''){
			description += title;
		}
		if(desc && desc != ''){
			description != '' ? description += BLANK_SPACE :'';
			description += desc; 
		}
								
		var pagecontent = dom.byId("content");
		var firstClusterOnPage = query(".cluster,.list", pagecontent)[0];
		if (firstClusterOnPage) {
		  if (typeof query(".collapse-title", firstClusterOnPage)[0] == 'undefined' ||
			  query(".collapse-title", firstClusterOnPage)[0].innerHTML == "") {
		      if (typeof query(".description", firstClusterOnPage)[0] != 'undefined') {
			      if (query(".description", firstClusterOnPage)[0].innerHTML !== "") {
			           // If the modal has a wizard progress bar and the first cluster or list has a description
			           // but no title this description should be announced. 
			          var clusterDescription = query(".description", firstClusterOnPage)[0];  	
			          if (clusterDescription && clusterDescription.innerText !== "") {
			        	  description != '' ? description += BLANK_SPACE :'';
			        	  description += query(".description", firstClusterOnPage)[0].innerText; 
			          }
			      }
		      }
			}
		}else{
			// If the modal has a wizard progress bar and the first table child is a TR with field
			//this description should be announced.  	  
			    var firstTrWithFieldLabel = query("tr:first-child > td.field.last-cell", pagecontent)[0]; 
			    if(firstTrWithFieldLabel && firstTrWithFieldLabel.innerText !== "" ){
			       description != '' ? description += BLANK_SPACE :'';	
			       description += firstTrWithFieldLabel.innerText; 
			    }							 
		}
		
		if(description){
		   // Add the span containing information on the current tab to the hidden
		  // aria live element so it will be read by a screen reader.
		  elementContainingWizardInfoToBeRead = domConstruct.create("span",{innerHTML: description });
		  setTimeout(function () { domConstruct.place(elementContainingWizardInfoToBeRead, hiddenAriaLiveElement); }, 1000);
		}
  },
  
  closeGracefully: function() {
    curam.dialog._justClose = true;
  },
  

   
  });
  layer.register("curam/dialog", this);

  return curam.dialog; 
});
},
'dijit/_CssStateMixin':function(){
define([
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant()
	"dojo/dom-class", // domClass.toggle
	"dojo/has",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/domReady",
	"dojo/touch",
	"dojo/_base/window", // win.body
	"./a11yclick",
	"./registry"
], function(array, declare, dom, domClass, has, lang, on, domReady, touch, win, a11yclick, registry){

	// module:
	//		dijit/_CssStateMixin

	var CssStateMixin = declare("dijit._CssStateMixin", [], {
		// summary:
		//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
		//		state changes, and also higher-level state changes such becoming disabled or selected.
		//
		// description:
		//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
		//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
		//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
		//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
		//
		//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
		//
		//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
		//		within the widget).

		/*=====
		 // cssStateNodes: [protected] Object
		 //		Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
		 //		need CSS classes applied on mouse hover/press and focus.
		 //
		 //		Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
		 //		(like "dijitUpArrowButton"). Example:
		 //	|		{
		 //	|			"upArrowButton": "dijitUpArrowButton",
		 //	|			"downArrowButton": "dijitDownArrowButton"
		 //	|		}
		 //		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
		 //		is hovered, etc.
		 cssStateNodes: {},
		 =====*/

		// hovering: [readonly] Boolean
		//		True if cursor is over this widget
		hovering: false,

		// active: [readonly] Boolean
		//		True if mouse was pressed while over this widget, and hasn't been released yet
		active: false,

		_applyAttributes: function(){
			// This code would typically be in postCreate(), but putting in _applyAttributes() for
			// performance: so the class changes happen before DOM is inserted into the document.
			// Change back to postCreate() in 2.0.  See #11635.

			this.inherited(arguments);

			// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
			array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active", "_opened"], function(attr){
				this.watch(attr, lang.hitch(this, "_setStateClass"));
			}, this);

			// Track hover and active mouse events on widget root node, plus possibly on subnodes
			for(var ap in this.cssStateNodes || {}){
				this._trackMouseState(this[ap], this.cssStateNodes[ap]);
			}
			this._trackMouseState(this.domNode, this.baseClass);

			// Set state initially; there's probably no hover/active/focus state but widget might be
			// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
			this._setStateClass();
		},

		_cssMouseEvent: function(/*Event*/ event){
			// summary:
			//		Handler for CSS event on this.domNode. Sets hovering and active properties depending on mouse state,
			//		which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

			if(!this.disabled){
				switch(event.type){
					case "mouseover":
					case "MSPointerOver":
					case "pointerover":
						this._set("hovering", true);
						this._set("active", this._mouseDown);
						break;
					case "mouseout":
					case "MSPointerOut":
					case "pointerout":
						this._set("hovering", false);
						this._set("active", false);
						break;
					case "mousedown":
					case "touchstart":
					case "MSPointerDown":
					case "pointerdown":
					case "keydown":
						this._set("active", true);
						break;
					case "mouseup":
					case "dojotouchend":
					case "MSPointerUp":
					case "pointerup":
					case "keyup":
						this._set("active", false);
						break;
				}
			}
		},

		_setStateClass: function(){
			// summary:
			//		Update the visual state of the widget by setting the css classes on this.domNode
			//		(or this.stateNode if defined) by combining this.baseClass with
			//		various suffixes that represent the current widget state(s).
			//
			// description:
			//		In the case where a widget has multiple
			//		states, it sets the class based on all possible
			//		combinations.  For example, an invalid form widget that is being hovered
			//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
			//
			//		The widget may have one or more of the following states, determined
			//		by this.state, this.checked, this.valid, and this.selected:
			//
			//		- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
			//		- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
			//		- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
			//		- Selected - ex: currently selected tab will have this.selected==true
			//
			//		In addition, it may have one or more of the following states,
			//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
			//
			//		- Disabled	- if the widget is disabled
			//		- Active		- if the mouse (or space/enter key?) is being pressed down
			//		- Focused		- if the widget has focus
			//		- Hover		- if the mouse is over the widget

			// Compute new set of classes
			var newStateClasses = this.baseClass.split(" ");

			function multiply(modifier){
				newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){
					return c + modifier;
				}), "dijit" + modifier);
			}

			if(!this.isLeftToRight()){
				// For RTL mode we need to set an addition class like dijitTextBoxRtl.
				multiply("Rtl");
			}

			var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
			if(this.checked){
				multiply(checkedState);
			}
			if(this.state){
				multiply(this.state);
			}
			if(this.selected){
				multiply("Selected");
			}
			if(this._opened){
				multiply("Opened");
			}

			if(this.disabled){
				multiply("Disabled");
			}else if(this.readOnly){
				multiply("ReadOnly");
			}else{
				if(this.active){
					multiply("Active");
				}else if(this.hovering){
					multiply("Hover");
				}
			}

			if(this.focused){
				multiply("Focused");
			}

			// Remove old state classes and add new ones.
			// For performance concerns we only write into domNode.className once.
			var tn = this.stateNode || this.domNode,
				classHash = {};	// set of all classes (state and otherwise) for node

			array.forEach(tn.className.split(" "), function(c){
				classHash[c] = true;
			});

			if("_stateClasses" in this){
				array.forEach(this._stateClasses, function(c){
					delete classHash[c];
				});
			}

			array.forEach(newStateClasses, function(c){
				classHash[c] = true;
			});

			var newClasses = [];
			for(var c in classHash){
				newClasses.push(c);
			}
    /* CURAM-FIX: replace followig line - only set className if classes are changed */
		// tn.className = newClasses.join(" ");
    var cls = newClasses.join(" ");
    if(cls != tn.className){
      tn.className = cls;
    }
    /* END CURAM-FIX */

			this._stateClasses = newStateClasses;
		},

		_subnodeCssMouseEvent: function(node, clazz, evt){
			// summary:
			//		Handler for hover/active mouse event on widget's subnode
			if(this.disabled || this.readOnly){
				return;
			}

			function hover(isHovering){
				domClass.toggle(node, clazz + "Hover", isHovering);
			}

			function active(isActive){
				domClass.toggle(node, clazz + "Active", isActive);
			}

			function focused(isFocused){
				domClass.toggle(node, clazz + "Focused", isFocused);
			}

			switch(evt.type){
				case "mouseover":
				case "MSPointerOver":
				case "pointerover":
					hover(true);
					break;
				case "mouseout":
				case "MSPointerOut":
				case "pointerout":
					hover(false);
					active(false);
					break;
				case "mousedown":
				case "touchstart":
				case "MSPointerDown":
				case "pointerdown":
				case "keydown":
					active(true);
					break;
				case "mouseup":
				case "MSPointerUp":
				case "pointerup":
				case "dojotouchend":
				case "keyup":
					active(false);
					break;
				case "focus":
				case "focusin":
					focused(true);
					break;
				case "blur":
				case "focusout":
					focused(false);
					break;
			}
		},

		_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
			// summary:
			//		Track mouse/focus events on specified node and set CSS class on that node to indicate
			//		current state.   Usually not called directly, but via cssStateNodes attribute.
			// description:
			//		Given class=foo, will set the following CSS class on the node
			//
			//		- fooActive: if the user is currently pressing down the mouse button while over the node
			//		- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
			//		- fooFocus: if the node is focused
			//
			//		Note that it won't set any classes if the widget is disabled.
			// node: DomNode
			//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
			//		is handled specially and automatically just by mixing in this class.
			// clazz: String
			//		CSS class name (ex: dijitSliderUpArrow)

			// Flag for listener code below to call this._cssMouseEvent() or this._subnodeCssMouseEvent()
			// when node is hovered/active
			node._cssState = clazz;
		}
	});

	domReady(function(){
		// Document level listener to catch hover etc. events on widget root nodes and subnodes.
		// Note that when the mouse is moved quickly, a single onmouseenter event could signal that multiple widgets
		// have been hovered or unhovered (try test_Accordion.html)

		function pointerHandler(evt, target, relatedTarget){
			// Handler for mouseover, mouseout, a11yclick.press and a11click.release events

			// Poor man's event propagation.  Don't propagate event to ancestors of evt.relatedTarget,
			// to avoid processing mouseout events moving from a widget's domNode to a descendant node;
			// such events shouldn't be interpreted as a mouseleave on the widget.
			if(relatedTarget && dom.isDescendant(relatedTarget, target)){
				return;
			}

			for(var node = target; node && node != relatedTarget; node = node.parentNode){
				// Process any nodes with _cssState property.   They are generally widget root nodes,
				// but could also be sub-nodes within a widget
				if(node._cssState){
					var widget = registry.getEnclosingWidget(node);
					if(widget){
						if(node == widget.domNode){
							// event on the widget's root node
							widget._cssMouseEvent(evt);
						}else{
							// event on widget's sub-node
							widget._subnodeCssMouseEvent(node, node._cssState, evt);
						}
					}
				}
			}
		}

		var body = win.body(), activeNode;

		// Handle pointer related events (i.e. mouse or touch)
		on(body, touch.over, function(evt){
			// Using touch.over rather than mouseover mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, touch.out, function(evt){
			// Using touch.out rather than mouseout mainly to ignore phantom mouse events on iOS.
			pointerHandler(evt, evt.target, evt.relatedTarget);
		});
		on(body, a11yclick.press, function(evt){
			// Save the a11yclick.press target to reference when the a11yclick.release comes.
			activeNode = evt.target;
			pointerHandler(evt, activeNode)
		});
		on(body, a11yclick.release, function(evt){
			// The release event could come on a separate node than the press event, if for example user slid finger.
			// Reference activeNode to reset the state of the node that got state set in the a11yclick.press handler.
			pointerHandler(evt, activeNode);
			activeNode = null;
		});

		// Track focus events on widget sub-nodes that have been registered via _trackMouseState().
		// However, don't track focus events on the widget root nodes, because focus is tracked via the
		// focus manager (and it's not really tracking focus, but rather tracking that focus is on one of the widget's
		// nodes or a subwidget's node or a popup node, etc.)
		// Remove for 2.0 (if focus CSS needed, just use :focus pseudo-selector).
		on(body, "focusin, focusout", function(evt){
			var node = evt.target;
			if(node._cssState && !node.getAttribute("widgetId")){
				var widget = registry.getEnclosingWidget(node);
				if(widget){
					widget._subnodeCssMouseEvent(node, node._cssState, evt);
				}
			}
		});
	});

	return CssStateMixin;
});

},
'curam/tab/util':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012, 2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 /*
 * Modification History
 * --------------------
 * 15-Apr-2019 CM [RTC246336] Update background images to images on cluster
 				  toggle nodes for accessibility purposes.
 * 25-Mar-2019 EP [RTC241286] Added aria-expanded element in context panel
 * 					toggle button to reflect its state.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 22-Apr-2013 MV  [CR00381705] Moved getMarginBoxSimple().
 * 09-Oct-2012 BOS [CR00346368] Localized debug messages to console.
 * 12-Sep-2012 SB  [CR00342403] Added class name to details panel
 *                 div when collapsed, for accessibility purpose.
 * 02-May-2012 MK  [CR00323691] Use new Dojo AMD format.
 * 21-Jan-2011 DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 05-Jan-2011 KW  [CR00240549] Add class name when collapsed, allowing arrow's
 *                              direction to reflect state
 * 20-Jul-2010 JY  [CR00210937] Update the codes due to the
 *                  removing of border container around the
 *                  details panel and content panel.
 * 02-JUN-2010 JY  [CR00201673] Initial Version. function
 *                  for toggling details panel.
 */


/**
 * @name curam.tab.util
 * @namespace Function for toggling details panel.
 */
define(["dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/dom-geometry",
        "curam/define",
        "curam/debug"
        ], function(domStyle, domClass, domAttr, domGeom, define, debug) {
  
define.singleton("curam.tab.util", 
/** @lends curam.tab.util.prototype */    
{
        
        toggleDetailsPanel: function(event){
                event = dojo.fixEvent(event);
                
                dojo.stopEvent(event);
                var arrowNode = event.target;

                // Find the parent span.detailsTitleArrowButton of the element that was actually clicked (could be the span but could also be the img child.)
                var searchNode = arrowNode;
                while(searchNode && !domClass.contains(searchNode, "detailsTitleArrowButton")){
                  searchNode = searchNode.parentNode;
                }
                var arrowNode = searchNode;

                //stop another animation when current animation
                // is not finished
                if(arrowNode._animating){
                        return;
                }
                
                //animating
                arrowNode._animating = true;
                
                var searchNode = arrowNode.parentNode;
                
                //find the inner border container node for header panel and details panel
                while(searchNode 
                                && !domClass.contains(searchNode, "detailsPanel-bc")){
                        searchNode = searchNode.parentNode;
                }
                var borderContainerNode = searchNode;
                
                
                //find the summary pane node
                while(searchNode 
                                && !domClass.contains(searchNode, "summaryPane")){
                        searchNode = searchNode.parentNode;
                }
                var summaryPaneNode = searchNode;
                
                //find the outer container div for summary pane, splitter and nav-panel
                while(searchNode) {
                  if(domClass.contains(searchNode, "dijitBorderContainer") &&
                      !domClass.contains(searchNode, "detailsPanel-bc")){
                    break;
                  }
                  if(domClass.contains(searchNode, "tab-wrapper")){
                    break;
                  }
                  searchNode = searchNode.parentNode;
                }
                var TabWrapperNode = searchNode;       
                
                //find the detailsPanel and headerPane
                headerPanelNode = 
                    dojo.query(".detailsPanelTitleBar", borderContainerNode)[0];

                detailsPanelNode = 
                    dojo.query(".detailsContentPane", borderContainerNode)[0];
                
                //find the nav panel and splitter bar
                var kids = TabWrapperNode.children;
                var splitterBarNode = dojo.filter(kids, function(child){
                  if(domClass.contains(child, "splitter-pane") ||
                      domClass.contains(child, "dijitSplitterH")) {
                        return child;
                  }
                })[0];
                
                var navPanelNode = dojo.filter(kids, function(child){
                  if(domClass.contains(child, "nav-panel")){
                        return child;
                  }
                })[0];

                
                //get the height of header panel, border container height,
                //splitterBar height and navPanel height
                var headerHeight = domGeom.getMarginBoxSimple(headerPanelNode).h;
                var bcHeight = domGeom.getMarginBoxSimple(summaryPaneNode).h;               
                var splitterBarHeight = splitterBarNode.offsetHeight;
                var navPanelHeight = domGeom.getMarginBoxSimple(navPanelNode).h;
                var detailsPanelDiv = dojo.query(".detailsContentPane", borderContainerNode)[0];
                if(headerHeight != summaryPaneNode.clientHeight) {
                        //Details Panel is not collapsed, so collapse it
                        
                        //arrow reflects state
                        domClass.add(arrowNode, "collapsed");
                        domAttr.set(arrowNode, "aria-expanded", "false");
                        this._updateToggleArrowNode(arrowNode, false);
                        domClass.add(detailsPanelDiv, "collapsed");
                        curam.debug
                          .log(debug.getProperty("curam.tab.util.collapsing"));
                        //store the previous height of border container
                        //and nav panel
                        borderContainerNode._previousHeight = bcHeight;
                        navPanelNode._previousHeight = navPanelHeight;
                        //animate the summaryPane
                        dojo.animateProperty({
                                node: summaryPaneNode,
                                //duration for animating is half a sec
                                duration: 500,
                                properties: {
                                        height: {end: headerHeight}
                                }
                        }).play();
                        
                        if(domClass.contains(splitterBarNode, "splitter-pane")) {
                          dojo.animateProperty({
                            node: detailsPanelNode,
                            //duration for animating is half a sec
                            duration: 500,
                            properties: {
                                    height: {end: 0}
                            }
                          }).play();
                        }
                        
                        //animate the spliiterBar
                        dojo.animateProperty({
                                node: splitterBarNode,
                                //duration for animating is half a sec
                                duration: 500,
                                properties: {
                                        top: {end: (headerHeight + splitterBarHeight)}
                                }
                        }).play();
                        
                        //animate the navPanel
                        dojo.animateProperty({
                                node: navPanelNode,
                                duration: 500,
                                properties: {
                                        top: {end: (headerHeight + splitterBarHeight)}
                                },
                                onEnd: function(){
                                        //indicate the current animation is finished
                                        //and allow to start another
                                        arrowNode._animating = false;
                                        if(domClass.contains(splitterBarNode, "dijitSplitterH")) {
                                          domStyle.set(navPanelNode, "height", 
                                              (navPanelNode._previousHeight + 
                                                  borderContainerNode._previousHeight
                                                 - headerHeight) + "px");
                                        }
                                }     
                        }).play();
                        
                        
                } else {
                        //Details panel is Collapsed, so expand it
                        
                        //arrow reflects state
                        domClass.remove(arrowNode, "collapsed");
                        domClass.remove(detailsPanelDiv, "collapsed");
                        domAttr.set(arrowNode, "aria-expanded", "true");
                        this._updateToggleArrowNode(arrowNode, true);
                        debug
                          .log(debug.getProperty("curam.tab.util.expanding"));
                        //set the height of summary pane
                        domStyle.set(summaryPaneNode, "height", 
                                        borderContainerNode._previousHeight + "px");
                        
                        //animate the details content pane
                        if(domClass.contains(splitterBarNode, "splitter-pane")) {
                          dojo.animateProperty({
                            node: detailsPanelNode,
                            //duration for animating is half a sec
                            duration: 500,
                            properties: {
                                    height: {end: borderContainerNode._previousHeight - headerHeight}
                            }
                          }).play();
                        }
                        
                        //animate splitterBar
                        dojo.animateProperty({
                                node: splitterBarNode,
                                duration: 500,
                                properties: {
                                        top: {end: (borderContainerNode._previousHeight
                                                        + splitterBarHeight)}
                                }
                        }).play();

                        //animate navPanel
                        dojo.animateProperty({
                                node: navPanelNode,
                                duration: 500,
                                properties: {
                                        top: {end: (borderContainerNode._previousHeight 
                                                        + splitterBarHeight)}
                                },
                                onEnd: function(){
                                        arrowNode._animating = false;
                                        if(domClass.contains(splitterBarNode, "dijitSplitterH")) {
                                          domStyle.set(navPanelNode, "height", 
                                              navPanelNode._previousHeight + "px");
                                        }
                                }
                        }).play();
                }
        },
        
       /*
        * Update the cluster toggle arrow node images.
        *
        * @param arrowNode Element of the cluster toggle arrow node.
        * @param isExpanded Boolean is true if cluster is expanded. 
        */
        _updateToggleArrowNode: function(/*Element*/arrowNode, /*boolean*/isExpanded){
          
          var toggleImages = this._getToggleImages();
          
          //arrowNode.children[0] is the default icon and 
          //arrowNode.children[1] is the hover icon of the toggle
          //button. Both are updated depending on the toggle state.
          if(isExpanded){
            arrowNode.children[0].src = toggleImages[0]; 
            arrowNode.children[1].src = toggleImages[2];
            
          }else{
            arrowNode.children[0].src = toggleImages[1];
            arrowNode.children[1].src = toggleImages[3];
            
          }
        },
        
       /*
        * Return the cluster toggle arrow images for LTR/RTL mode.
		*
        */
        _getToggleImages: function() {
          var expandedImage;
          var collapsedImage;
          var expandedImageHover;
          var collapsedImageHover;

          var isRtlMode = curam.util.isRtlMode();

          expandedImage = "./themes/curam/images/chevron--down20-enabled.svg";
          expandedImageHover = "./themes/curam/images/chevron--down20-enabled.svg";
          
          if(isRtlMode) {
            // Right-To-Left images
             collapsedImage = "./themes/curam/images/Toggle_Right_Blue80_20px.png";
             collapsedImageHover = "./themes/curam/images/Toggle_Fill_Right_Blue50_20px.png";
          } else {             
            collapsedImage = "./themes/curam/images/chevron--left20-enabled.svg";
            collapsedImageHover = "./themes/curam/images/chevron--left20-enabled.svg";
          }
          return [expandedImage, collapsedImage, expandedImageHover, collapsedImageHover];
        },

});

return curam.tab.util;
});

},
'curam/widget/DeferredDropDownButton':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2013,2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 16-Jan-2023 BOS [SPM-126663] Only hide overflow icons where it is valid
   * scenario to do so.
   * 06-Jan-2023 BOS [SPM-126610] Added hideTabMenuOverflowItems() call to 
   * toggleDropdown() in order to hide overflow items now hidden.
   * 20-May-2019  SK  [RTC241554] Notifies of the startup to update the readings.
   * 14-May-2019  JD  [RTC242058]  Updated to use curam/widget/_HasDropDown.
   * 05-Sep-2014  JY  [CR00444205] Removing the flag "useCustomPlaceAlgorithm"
   *                as the custom algorithm is no longer required in Dojo 1.9.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 15-Jan-2012  SB  [CR00357346] Override HTML template.
   * 09-Oct-2012  MK  [CR00355074] Fix typo. 
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 30-Aug-2011  MV  [CR00284416] Handle cases when no menu items are generated
   *    for a menu.
   * 27-Jan-2011  JY [CR00244789] Override the loadDropDown and openDropDown
   *                 method to set a flag variable "useCustomPlaceAlgorithm"
   *                 that will be used later by the function dijit._place()
   *                 in "dojo-hacks.js" file.
   * 15-Sep-2010  MV [CR00220152] Publish event when the menu is created.
   */

/**
 * @name curam.widget.DeferredDropDownButton
 * @namespace
 *    A DropDownButton which instantiates its contained menu the first
 *    time it is clicked.  This improves page start up performance over
 *    the standard dijit.DropDownButton.  It depends on the renderer
 *    to set the string value for its Menu template in the variable
 *    curam.widgetTemplates, using the widget ID to access it.
 *
 */
define(["dijit/registry",
        "dijit/form/DropDownButton",
        "dojo/_base/declare",
        "dojo/text!curam/widget/templates/DropDownButton.html",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/query",
        "dijit/form/Button",
        "dijit/MenuItem",
        "curam/util/TabActionsMenu",
        "curam/debug",
        "curam/util",
        "dijit/MenuSeparator",
        "dijit/Menu",
        "dijit/MenuItem",
        "curam/widget/_HasDropDown"
        ], function(registry, DropDownButton, declare, template, domAttr, domConstruct,
            query, button, menuItem, tabMenu, debug) {

  var DeferredDropDownButton = declare(
	      "curam.widget.DeferredDropDownButton", [dijit.form.DropDownButton, curam.widget._HasDropDown],
  
  /**
   * @lends curam.widget.DeferredDropDownButton.prototype
   */
  {
    templateString: template,
    /** Id of the related tab. */
    o3tabId: null,
    
    /**
     * Overrides the DropDownButton startup function, and deliberately
     * skips invoking it, instead invoking the grandparent widgets
     * startup method.
     */
    startup: function() {
      if (this._started) {
        return;
      }
      
      var classes = domAttr.get(this.domNode, "class").split(" ");
      dojo.forEach(classes, dojo.hitch(this, function(elemClass) {
        if (elemClass.indexOf("tab-widget-id-") != -1) {
          this.o3tabId = elemClass.slice(14, elemClass.length);
        }
      }));

      // Get the widget template from the curam.widgetTemplates JSON object.
      // This must have been set by the Java renderer.  See MenuBarRenderer.java
      // CR00211189
      this.widgetTemplate = 
        curam.widgetTemplates ? curam.widgetTemplates[this.id] : null;
      dijit.form.Button.prototype.startup.apply(this);
      var listId = this.get('data-notify');
      listId &&
        dojo.publish('curam/listmenu/started', [this, listId]);
    },
    
    /**
     * This is called when the contained menu should be shown.
     * If the menu has not yet been instantiated, use the widget
     * template to instantiate it.
     */
    toggleDropDown: function() {
      // If the dropdown has not been instantiated, and the widget template
      // has been specified, then instantiate the drop down widget.
      if(!this.dropDown && this.widgetTemplate) {
        if (this.widgetTemplate.indexOf("__03qu_") != -1) {       
          this.widgetTemplate = this.widgetTemplate.split("__03qu_").join("\"");      
        }
        // Unescape the widget template
        this.widgetTemplate = 
          this.widgetTemplate
            .split("&lt;").join("<")
            .split("&gt;").join(">")
            .split("&amp;").join("&")
            .split("&quot;").join("'")
            ;
        
        // Create a div and place the widget HTML inside it.  This is necessary
        // because the Dojo parser will only parse 'inside' and node, and not
        // include the node that you pass to it.
        var widgetWrapper = domConstruct.create("div", {
          innerHTML: this.widgetTemplate,
          style: {
            display: "none"
          }
        }, dojo.body());
        
        this.dropDown = dojo.parser.parse(widgetWrapper)[0];
        
        var menu = registry.byNode(widgetWrapper.firstChild);
        if (menu.getChildren().length == 0) {
          // handle the case when all menu items are conditional and none
          // is actually added
          var mi = new dijit.MenuItem({
            disabled: true, label: LOCALISED_EMPTY_MENU_MARKER
          });
          menu.addChild(mi);
        }
        
        // Clear the template so 
        this.widgetTemplate = null;
        
        debug.log(
            debug.getProperty("curam.widget.DeferredDropDownButton.publish") 
            + " /curam/menu/created " 
            + debug.getProperty("curam.widget.DeferredDropDownButton.for"), 
              this.o3tabId);
        var topWin = curam.util.getTopmostWindow();
        topWin.dojo.publish("/curam/menu/created", [ this.o3tabId ]);
        
        // when the overflow is toggled, hide any items that are visible and but should be hidden because
        // they already exist inline
        if (this.o3tabId) {
          tabMenu.hideTabMenuOverflowItems(this.o3tabId, this.dropDown.domNode);
        }
      }
      this.inherited(arguments);
    }
  });
  
  return DeferredDropDownButton;
});

},
'dijit/form/FilteringSelect':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.mixin
	"dojo/when",
	"./MappedTextBox",
	"./ComboBoxMixin"
], function(declare, lang, when, MappedTextBox, ComboBoxMixin){

	// module:
	//		dijit/form/FilteringSelect

	return declare("dijit.form.FilteringSelect", [MappedTextBox, ComboBoxMixin], {
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//
		//		- There is a drop down list of possible values.
		//		- You can only enter a value from the drop down list.  (You can't
		//			enter an arbitrary value.)
		//		- The value submitted with the form is the hidden value (ex: CA),
		//			not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//
		//		- If you type in some text then it will filter down the list of
		//			possible values in the drop down list.
		//		- List can be specified either as a static list or via a javascript
		//			function (that can get the list from a server)

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		_isValidSubset: function(){
			return this._opened;
		},

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return !!this.item || (!this.required && this.get('displayedValue') == ""); // #5974
		},

		_refreshState: function(){
			if(!this.searchTimer){ // state will be refreshed after results are returned
				this.inherited(arguments);
			}
		},

		_callbackSetLabel: function(
						/*Array*/ result,
						/*Object*/ query,
						/*Object*/ options,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback from dojo.store after lookup of user entered value finishes

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((query && query[this.searchAttr] !== this._lastQuery) || (!query && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: don't modify display value on bad input
				//#3285: change CSS to indicate error
				this.set("value", '', priorityChange || (priorityChange === undefined && !this.focused), this.textbox.value, null);
			}else{
				this.set('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// Callback when a data store query completes.
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(query[this.searchAttr] !== this._lastQuery){
				return;
			}
			this.inherited(arguments);

			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for get('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }

			if(item === undefined){
				if(value === null || value === ''){
					value = '';
					if(!lang.isString(displayedValue)){
						this._setDisplayedValueAttr(displayedValue||'', priorityChange);
						return;
					}
				}

				var self = this;
				this._lastQuery = value;
				when(this.store.get(value), function(item){
					self._callbackSetLabel(item? [item] : [], undefined, undefined, priorityChange);
				});
			}else{
				this.valueNode.value = value;
				this.inherited(arguments, [value, priorityChange, displayedValue, item]);
			}
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			this.inherited(arguments);
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.  label should corresponding to item.searchAttr.

			if(label == null){ label = ''; }

			// This is called at initialization along with every custom setter.
			// Usually (or always?) the call can be ignored.   If it needs to be
			// processed then at least make sure that the XHR request doesn't trigger an onChange()
			// event, even if it returns after creation has finished
			if(!this._created){
				if(!("displayedValue" in this.params)){
					return;
				}
				priorityChange = false;
			}

			// Do a reverse lookup to map the specified displayedValue to the hidden value.
			// Note that if there's a custom labelFunc() this code
			if(this.store){
				this.closeDropDown();
				var query = lang.clone(this.query); // #6196: populate query with user-specifics

				// Generate query
				var qs = this._getDisplayQueryString(label), q;
				if(this.store._oldAPI){
					// remove this branch for 2.0
					q = qs;
				}else{
					// Query on searchAttr is a regex for benefit of dojo/store/Memory,
					// but with a toString() method to help dojo/store/JsonRest.
					// Search string like "Co*" converted to regex like /^Co.*$/i.
					q = this._patternToRegExp(qs);
					q.toString = function(){ return qs; };
				}
				this._lastQuery = query[this.searchAttr] = q;

				// If the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox.   Set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				this._set("displayedValue", label);	// for watch("displayedValue") notification
				var _this = this;
				var options = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					}
				};
				lang.mixin(options, this.fetchProperties);
				this._fetchHandle = this.store.query(query, options);
				when(this._fetchHandle, function(result){
					_this._fetchHandle = null;
					_this._callbackSetLabel(result || [], query, options, priorityChange);
				}, function(err){
					_this._fetchHandle = null;
					if(!_this._cancelingQuery){	// don't treat canceled query as an error
						console.error('dijit.form.FilteringSelect: ' + err.toString());
					}
				});
			}
		},

		undo: function(){
			this.set('displayedValue', this._lastDisplayedValue);
		}
	});
});

},
'dijit/_WidgetBase':function(){
define([
	"require", // require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/has",
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.body()
	"./Destroyable",
	"dojo/has!dojo-bidi?./_BidiMixin",
	"./registry"    // registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, has, kernel,
			lang, on, ready, Stateful, topic, win, Destroyable, _BidiMixin, registry){

/* CURAM-FIX: Extend ContentPane to allow P&S instrumentation. */
var curamPerfTrackingEnabled = typeof(dojo.global.perf) != "undefined";

	// module:
	//		dijit/_WidgetBase

	// Flag to make dijit load modules the app didn't explicitly request, for backwards compatibility
	 1 || has.add("dijit-legacy-requires", !kernel.isAsync);

	// Flag to enable support for textdir attribute
	has.add("dojo-bidi", false);


	// For back-compat, remove in 2.0.
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/_base/manager"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	// Nested hash listing attributes for each tag, all strings in lowercase.
	// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
	var tagAttrs = {};

	function getAttrs(obj){
		var ret = {};
		for(var attr in obj){
			ret[attr.toLowerCase()] = true;
		}
		return ret;
	}

	function nonEmptyAttrToDom(attr){
		// summary:
		//		Returns a setter function that copies the attribute to this.domNode,
		//		or removes the attribute from this.domNode, depending on whether the
		//		value is defined or not.
		return function(val){
			domAttr[val ? "set" : "remove"](this.domNode, attr, val);
			this._set(attr, val);
		};
	}

	function isEqual(a, b){
		//	summary:
		//		Function that determines whether two values are identical,
		//		taking into account that NaN is not normally equal to itself
		//		in JS.

		return a === b || (/* a is NaN */ a !== a && /* b is NaN */ b !== b);
	}

	var _WidgetBase = declare("dijit._WidgetBase", [Stateful, Destroyable], {
		// summary:
		//		Future base class for all Dijit widgets.
		// description:
		//		Future base class for all Dijit widgets.
		//		_Widget extends this class adding support for various features needed by desktop.
		//
		//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
		//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
		//
		//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
		//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
		//
		//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
		//
		//		- DOM node attribute
		// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
		// |		_setFocusAttr: "focusNode"	(shorthand)
		// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
		//		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
		//
		//		- DOM node innerHTML
		//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		_setMyClassAttr: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		If the custom setter is null, no action is performed other than saving the new value
		//		in the widget (in this).
		//
		//		If no custom setter is defined for an attribute, then it will be copied
		//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
		//		That's only done though for attributes that match DOMNode attributes (title,
		//		alt, aria-labelledby, etc.)

		// id: [const] String
		//		A unique, opaque ID string that can be assigned by users or by the
		//		system. If the developer passes an ID which is known not to be
		//		unique, the specified ID is ignored and the system-generated ID is
		//		used instead.
		id: "",
		_setIdAttr: "domNode", // to copy to this.domNode even for auto-generated id's

		// lang: [const] String
		//		Rarely used.  Overrides the default Dojo locale used to render this widget,
		//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
		//		Value must be among the list of locales specified during by the Dojo bootstrap,
		//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
		lang: "",
		// set on domNode even when there's a focus node.	but don't set lang="", since that's invalid.
		_setLangAttr: nonEmptyAttrToDom("lang"),

		// dir: [const] String
		//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
		//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
		//		default direction.
		dir: "",
		// set on domNode even when there's a focus node.	but don't set dir="", since that's invalid.
		_setDirAttr: nonEmptyAttrToDom("dir"), // to set on domNode even when there's a focus node

		// class: String
		//		HTML class attribute
		"class": "",
		_setClassAttr: { node: "domNode", type: "class" },

		// Override automatic assigning type --> focusNode, it causes exception on IE6-8.
		// Instead, type must be specified as ${type} in the template, as part of the original DOM.
		_setTypeAttr: null,
		// style: String||Object
		//		HTML style attributes as cssText string or name/value hash
		style: "",

		// title: String
		//		HTML title attribute.
		//
		//		For form widgets this specifies a tooltip to display when hovering over
		//		the widget (just like the native HTML title attribute).
		//
		//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
		//		etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
		//		interpreted as HTML.
		title: "",

		// tooltip: String
		//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
		//		this specifies the tooltip to appear when the mouse is hovered over that text.
		tooltip: "",

		// baseClass: [protected] String
		//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
		//		widget state.
		baseClass: "",

		// srcNodeRef: [readonly] DomNode
		//		pointer to original DOM node
		srcNodeRef: null,

		// domNode: [readonly] DomNode
		//		This is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's data-dojo-attach-point syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null,

		// containerNode: [readonly] DomNode
		//		Designates where children of the source DOM node will be placed.
		//		"Children" in this case refers to both DOM nodes and widgets.
		//		For example, for myWidget:
		//
		//		|	<div data-dojo-type=myWidget>
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//		|	</div>
		//
		//		containerNode would point to:
		//
		//		|		<b> here's a plain DOM node
		//		|		<span data-dojo-type=subWidget>and a widget</span>
		//		|		<i> and another plain DOM node </i>
		//
		//		In templated widgets, "containerNode" is set via a
		//		data-dojo-attach-point assignment.
		//
		//		containerNode must be defined for any widget that accepts innerHTML
		//		(like ContentPane or BorderContainer or even Button), and conversely
		//		is null for widgets that don't, like TextBox.
		containerNode: null,

		// ownerDocument: [const] Document?
		//		The document this widget belongs to.  If not specified to constructor, will default to
		//		srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
		ownerDocument: null,
		_setOwnerDocumentAttr: function(val){
			// this setter is merely to avoid automatically trying to set this.domNode.ownerDocument
			this._set("ownerDocument", val);
		},

		/*=====
		// _started: [readonly] Boolean
		//		startup() has completed.
		_started: false,
		=====*/

		// attributeMap: [protected] Object
		//		Deprecated.	Instead of attributeMap, widget should have a _setXXXAttr attribute
		//		for each XXX attribute to be mapped to the DOM.
		//
		//		attributeMap sets up a "binding" between attributes (aka properties)
		//		of the widget and the widget's DOM.
		//		Changes to widget attributes listed in attributeMap will be
		//		reflected into the DOM.
		//
		//		For example, calling set('title', 'hello')
		//		on a TitlePane will automatically cause the TitlePane's DOM to update
		//		with the new title.
		//
		//		attributeMap is a hash where the key is an attribute of the widget,
		//		and the value reflects a binding to a:
		//
		//		- DOM node attribute
		// |		focus: {node: "focusNode", type: "attribute"}
		//		Maps this.focus to this.focusNode.focus
		//
		//		- DOM node innerHTML
		//	|		title: { node: "titleNode", type: "innerHTML" }
		//		Maps this.title to this.titleNode.innerHTML
		//
		//		- DOM node innerText
		//	|		title: { node: "titleNode", type: "innerText" }
		//		Maps this.title to this.titleNode.innerText
		//
		//		- DOM node CSS class
		// |		myClass: { node: "domNode", type: "class" }
		//		Maps this.myClass to this.domNode.className
		//
		//		If the value is an array, then each element in the array matches one of the
		//		formats of the above list.
		//
		//		There are also some shorthands for backwards compatibility:
		//
		//		- string --> { node: string, type: "attribute" }, for example:
		//
		//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
		//
		//		- "" --> { node: "domNode", type: "attribute" }
		attributeMap: {},

		// _blankGif: [protected] String
		//		Path to a blank 1x1 image.
		//		Used by `<img>` nodes in templates that really get their image via CSS background-image.
		_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		/*=====
		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
		},
		=====*/

		_introspect: function(){
			// summary:
			//		Collect metadata about this widget (only once per class, not once per instance):
			//
			//			- list of attributes with custom setters, storing in this.constructor._setterAttrs
			//			- generate this.constructor._onMap, mapping names like "mousedown" to functions like onMouseDown

			var ctor = this.constructor;
			if(!ctor._setterAttrs){
				var proto = ctor.prototype,
					attrs = ctor._setterAttrs = [], // attributes with custom setters
					onMap = (ctor._onMap = {});

				// Items in this.attributeMap are like custom setters.  For back-compat, remove for 2.0.
				for(var name in proto.attributeMap){
					attrs.push(name);
				}

				// Loop over widget properties, collecting properties with custom setters and filling in ctor._onMap.
				for(name in proto){
					if(/^on/.test(name)){
						onMap[name.substring(2).toLowerCase()] = name;
					}

					if(/^_set[A-Z](.*)Attr$/.test(name)){
						name = name.charAt(4).toLowerCase() + name.substr(5, name.length - 9);
						if(!proto.attributeMap || !(name in proto.attributeMap)){
							attrs.push(name);
						}
					}
				}

				// Note: this isn't picking up info on properties like aria-label and role, that don't have custom setters
				// but that set() maps to attributes on this.domNode or this.focusNode
			}
		},

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			// summary:
			//		Kicks off widget instantiation.  See create() for details.
			// tags:
			//		private

			// Note that we skip calling this.inherited(), i.e. dojo/Stateful::postscript(), because 1.x widgets don't
			// expect their custom setters to get called until after buildRendering().  Consider changing for 2.0.

			this.create(params, srcNodeRef);
		},

		create: function(params, srcNodeRef){
			// summary:
			//		Kick off the life-cycle of a widget
			// description:
			//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
			//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
			//		for a discussion of the widget creation lifecycle.
			//
			//		Of course, adventurous developers could override create entirely, but this should
			//		only be done as a last resort.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified:
			//
			//		- use srcNodeRef.innerHTML as my contents
			//		- if this is a behavioral widget then apply behavior to that srcNodeRef
			//		- otherwise, replace srcNodeRef with my generated DOM tree
			// tags:
			//		private

                /* CURAM-FIX: P&S */
                if(curamPerfTrackingEnabled) {
                        perf.widgetStartedLoadingCallback();
                }
                /* END CURAM-FIX */

			// First time widget is instantiated, scan prototype to figure out info about custom setters etc.
			this._introspect();

			// store pointer to original DOM tree
			this.srcNodeRef = dom.byId(srcNodeRef);

			// No longer used, remove for 2.0.
			this._connects = [];
			this._supportingWidgets = [];

			// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
			if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){
				this.id = this.srcNodeRef.id;
			}

			// mix in our passed parameters
			if(params){
				this.params = params;
				lang.mixin(this, params);
			}
			this.postMixInProperties();

			// Generate an id for the widget if one wasn't specified, or it was specified as id: undefined.
			// Do this before buildRendering() because it might expect the id to be there.
			if(!this.id){
				this.id = registry.getUniqueId(this.declaredClass.replace(/\./g, "_"));
				if(this.params){
					// if params contains {id: undefined}, prevent _applyAttributes() from processing it
					delete this.params.id;
				}
			}

			// The document and <body> node this widget is associated with
			this.ownerDocument = this.ownerDocument || (this.srcNodeRef ? this.srcNodeRef.ownerDocument : document);
			this.ownerDocumentBody = win.body(this.ownerDocument);

			registry.add(this);

			this.buildRendering();

			var deleteSrcNodeRef;

			if(this.domNode){
				// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
				// Also calls custom setters for all attributes with custom setters.
				this._applyAttributes();

				// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
				// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
				// widget being attached to the DOM since it isn't when a widget is created programmatically like
				// new MyWidget({}).	See #11635.
				var source = this.srcNodeRef;
				if(source && source.parentNode && this.domNode !== source){
					source.parentNode.replaceChild(this.domNode, source);
					deleteSrcNodeRef = true;
				}

				// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
				// assuming that dojo._scopeName even exists in 2.0
				this.domNode.setAttribute("widgetId", this.id);
			}
			this.postCreate();

			// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
			// I think for back-compatibility it isn't deleting srcNodeRef until after postCreate() has run.
			if(deleteSrcNodeRef){
				delete this.srcNodeRef;
			}

			this._created = true;

                /* CURAM-FIX: P&S */
                if(curamPerfTrackingEnabled) {
                        perf.widgetLoadedCallback(this);
                }
                /* END CURAM-FIX */
			
		},

		_applyAttributes: function(){
			// summary:
			//		Step during widget creation to copy  widget attributes to the
			//		DOM according to attributeMap and _setXXXAttr objects, and also to call
			//		custom _setXXXAttr() methods.
			//
			//		Skips over blank/false attribute values, unless they were explicitly specified
			//		as parameters to the widget, since those are the default anyway,
			//		and setting tabIndex="" is different than not setting tabIndex at all.
			//
			//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
			//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
			// tags:
			//		private

			// Call this.set() for each property that was either specified as parameter to constructor,
			// or is in the list found above.	For correlated properties like value and displayedValue, the one
			// specified as a parameter should take precedence.
			// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
			// NaN and thus is not ignored like a default value of "".

			// Step 1: Save the current values of the widget properties that were specified as parameters to the constructor.
			// Generally this.foo == this.params.foo, except if postMixInProperties() changed the value of this.foo.
			var params = {};
			for(var key in this.params || {}){
				params[key] = this._get(key);
			}

			// Step 2: Call set() for each property with a non-falsy value that wasn't passed as a parameter to the constructor
			array.forEach(this.constructor._setterAttrs, function(key){
				if(!(key in params)){
					var val = this._get(key);
					if(val){
						this.set(key, val);
					}
				}
			}, this);

			// Step 3: Call set() for each property that was specified as parameter to constructor.
			// Use params hash created above to ignore side effects from step #2 above.
			for(key in params){
				this.set(key, params[key]);
			}
		},

		postMixInProperties: function(){
			// summary:
			//		Called after the parameters to the widget have been read-in,
			//		but before the widget template is instantiated. Especially
			//		useful to set properties that are referenced in the widget
			//		template.
			// tags:
			//		protected
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget, setting this.domNode.
			//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
			// tags:
			//		protected

			if(!this.domNode){
				// Create root node if it wasn't created by _TemplatedMixin
				this.domNode = this.srcNodeRef || this.ownerDocument.createElement("div");
			}

			// baseClass is a single class name or occasionally a space-separated list of names.
			// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
			// TODO: make baseClass custom setter
			if(this.baseClass){
				var classes = this.baseClass.split(" ");
				if(!this.isLeftToRight()){
					classes = classes.concat(array.map(classes, function(name){
						return name + "Rtl";
					}));
				}
				domClass.add(this.domNode, classes);
			}
		},

		postCreate: function(){
			// summary:
			//		Processing after the DOM fragment is created
			// description:
			//		Called after the DOM fragment has been created, but not necessarily
			//		added to the document.  Do not include any operations which rely on
			//		node dimensions or placement.
			// tags:
			//		protected
		},

		startup: function(){
			// summary:
			//		Processing after the DOM fragment is added to the document
			// description:
			//		Called after a widget and its children have been created and added to the page,
			//		and all related widgets have finished their create() cycle, up through postCreate().
			//
			//		Note that startup() may be called while the widget is still hidden, for example if the widget is
			//		inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
			//		For widgets that need to do layout, it's best to put that layout code inside resize(), and then
			//		extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
			if(this._started){
				return;
			}
			this._started = true;
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});
		},

		//////////// DESTROY FUNCTIONS ////////////////////////////////

		destroyRecursive: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroy this widget and its descendants
			// description:
			//		This is the generic "destructor" function that all widget users
			//		should call to cleanly discard with a widget. Once a widget is
			//		destroyed, it is removed from the manager object.
			// preserveDom:
			//		If true, this method will leave the original DOM structure
			//		alone of descendant Widgets. Note: This will NOT work with
			//		dijit._TemplatedMixin widgets.

			this._beingDestroyed = true;
			this.destroyDescendants(preserveDom);
			this.destroy(preserveDom);
		},

		destroy: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy this widget, but not its descendants.  Descendants means widgets inside of
			//		this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
			//
			//		This method will also destroy internal widgets such as those created from a template,
			//		assuming those widgets exist inside of this.domNode but outside of this.containerNode.
			//
			//		For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
			//		depend on the current ability to destroy a widget without destroying its descendants.   Generally
			//		they should use destroyRecursive() for widgets with children.
			// preserveDom: Boolean
			//		If true, this method will leave the original DOM structure alone.
			//		Note: This will not yet work with _TemplatedMixin widgets

			this._beingDestroyed = true;
			this.uninitialize();

			function destroy(w){
				if(w.destroyRecursive){
					w.destroyRecursive(preserveDom);
				}else if(w.destroy){
					w.destroy(preserveDom);
				}
			}

			// Back-compat, remove for 2.0
			array.forEach(this._connects, lang.hitch(this, "disconnect"));
			array.forEach(this._supportingWidgets, destroy);

			// Destroy supporting widgets, but not child widgets under this.containerNode (for 2.0, destroy child widgets
			// here too).   if() statement is to guard against exception if destroy() called multiple times (see #15815).
			if(this.domNode){
				array.forEach(registry.findWidgets(this.domNode, this.containerNode), destroy);
			}

			this.destroyRendering(preserveDom);
			registry.remove(this.id);
			this._destroyed = true;
		},

		destroyRendering: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Destroys the DOM nodes associated with this widget.
			// preserveDom:
			//		If true, this method will leave the original DOM structure alone
			//		during tear-down. Note: this will not work with _Templated
			//		widgets yet.
			// tags:
			//		protected

			if(this.bgIframe){
				this.bgIframe.destroy(preserveDom);
				delete this.bgIframe;
			}

			if(this.domNode){
				if(preserveDom){
					domAttr.remove(this.domNode, "widgetId");
				}else{
					domConstruct.destroy(this.domNode);
				}
				delete this.domNode;
			}

			if(this.srcNodeRef){
				if(!preserveDom){
					domConstruct.destroy(this.srcNodeRef);
				}
				delete this.srcNodeRef;
			}
		},

		destroyDescendants: function(/*Boolean?*/ preserveDom){
			// summary:
			//		Recursively destroy the children of this widget and their
			//		descendants.
			// preserveDom:
			//		If true, the preserveDom attribute is passed to all descendant
			//		widget's .destroy() method. Not for use with _Templated
			//		widgets.

			// get all direct descendants and destroy them recursively
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					widget.destroyRecursive(preserveDom);
				}
			});
		},

		uninitialize: function(){
			// summary:
			//		Deprecated. Override destroy() instead to implement custom widget tear-down
			//		behavior.
			// tags:
			//		protected
			return false;
		},

		////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

		_setStyleAttr: function(/*String||Object*/ value){
			// summary:
			//		Sets the style attribute of the widget according to value,
			//		which is either a hash like {height: "5px", width: "3px"}
			//		or a plain string
			// description:
			//		Determines which node to set the style on based on style setting
			//		in attributeMap.
			// tags:
			//		protected

			var mapNode = this.domNode;

			// Note: technically we should revert any style setting made in a previous call
			// to his method, but that's difficult to keep track of.

			if(lang.isObject(value)){
				domStyle.set(mapNode, value);
			}else{
				if(mapNode.style.cssText){
					mapNode.style.cssText += "; " + value;
				}else{
					mapNode.style.cssText = value;
				}
			}

			this._set("style", value);
		},

		_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
			// summary:
			//		Reflect a widget attribute (title, tabIndex, duration etc.) to
			//		the widget DOM, as specified by commands parameter.
			//		If commands isn't specified then it's looked up from attributeMap.
			//		Note some attributes like "type"
			//		cannot be processed this way as they are not mutable.
			// attr:
			//		Name of member variable (ex: "focusNode" maps to this.focusNode) pointing
			//		to DOMNode inside the widget, or alternately pointing to a subwidget
			// tags:
			//		private

			commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

			array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

				// Get target node and what we are doing to that node
				var mapNode = this[command.node || command || "domNode"];	// DOM node
				var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

				switch(type){
					case "attribute":
						if(lang.isFunction(value)){ // functions execute in the context of the widget
							value = lang.hitch(this, value);
						}

						// Get the name of the DOM node attribute; usually it's the same
						// as the name of the attribute in the widget (attr), but can be overridden.
						// Also maps handler names to lowercase, like onSubmit --> onsubmit
						var attrName = command.attribute ? command.attribute :
							(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

						if(mapNode.tagName){
							// Normal case, mapping to a DOMNode.  Note that modern browsers will have a mapNode.set()
							// method, but for consistency we still call domAttr
							domAttr.set(mapNode, attrName, value);
						}else{
							// mapping to a sub-widget
							mapNode.set(attrName, value);
						}
						break;
					case "innerText":
						mapNode.innerHTML = "";
						mapNode.appendChild(this.ownerDocument.createTextNode(value));
						break;
					case "innerHTML":
						mapNode.innerHTML = value;
						break;
					case "class":
						domClass.replace(mapNode, value, this[attr]);
						break;
				}
			}, this);
		},

		get: function(name){
			// summary:
			//		Get a property from a widget.
			// name:
			//		The property to get.
			// description:
			//		Get a named property from a widget. The property may
			//		potentially be retrieved via a getter method. If no getter is defined, this
			//		just retrieves the object's property.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_getFooAttr()`, calling:
			//		`myWidget.get("foo")` would be equivalent to calling
			//		`widget._getFooAttr()` and `myWidget.get("bar")`
			//		would be equivalent to the expression
			//		`widget.bar2`
			var names = this._getAttrNames(name);
			return this[names.g] ? this[names.g]() : this._get(name);
		},

		set: function(name, value){
			// summary:
			//		Set a property on a widget
			// name:
			//		The property to set.
			// value:
			//		The value to set in the property.
			// description:
			//		Sets named properties on a widget which may potentially be handled by a
			//		setter in the widget.
			//
			//		For example, if the widget has properties `foo` and `bar`
			//		and a method named `_setFooAttr()`, calling
			//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
			//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
			//		would be equivalent to the statement `widget.bar = 3;`
			//
			//		set() may also be called with a hash of name/value pairs, ex:
			//
			//	|	myWidget.set({
			//	|		foo: "Howdy",
			//	|		bar: 3
			//	|	});
			//
			//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

			if(typeof name === "object"){
				for(var x in name){
					this.set(x, name[x]);
				}
				return this;
			}
			var names = this._getAttrNames(name),
				setter = this[names.s];
			if(lang.isFunction(setter)){
				// use the explicit setter
				var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
			}else{
				// Mapping from widget attribute to DOMNode/subwidget attribute/value/etc.
				// Map according to:
				//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
				//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
				//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
				// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
				// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
				// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
				var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
					tag = this[defaultNode] && this[defaultNode].tagName,
					attrsForTag = tag && (tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode]))),
					map = name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
							((attrsForTag && names.l in attrsForTag && typeof value != "function") ||
								/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
				if(map != null){
					this._attrToDom(name, value, map);
				}
				this._set(name, value);
			}
			return result || this;
		},

		_attrPairNames: {}, // shared between all widgets
		_getAttrNames: function(name){
			// summary:
			//		Helper function for get() and set().
			//		Caches attribute name values so we don't do the string ops every time.
			// tags:
			//		private

			var apn = this._attrPairNames;
			if(apn[name]){
				return apn[name];
			}
			var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){
				return c.charAt(c.length - 1).toUpperCase();
			});
			return (apn[name] = {
				n: name + "Node",
				s: "_set" + uc + "Attr", // converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
				g: "_get" + uc + "Attr",
				l: uc.toLowerCase()        // lowercase name w/out dashes, ex: acceptcharset
			});
		},

		_set: function(/*String*/ name, /*anything*/ value){
			// summary:
			//		Helper function to set new value for specified property, and call handlers
			//		registered with watch() if the value has changed.
			var oldValue = this[name];
			this[name] = value;
			if(this._created && !isEqual(oldValue, value)){
				if(this._watchCallbacks){
					this._watchCallbacks(name, oldValue, value);
				}
				this.emit("attrmodified-" + name, {
					detail: {
						prevValue: oldValue,
						newValue: value
					}
				});
			}
		},

		_get: function(/*String*/ name){
			// summary:
			//		Helper function to get value for specified property stored by this._set(),
			//		i.e. for properties with custom setters.  Used mainly by custom getters.
			//
			//		For example, CheckBox._getValueAttr() calls this._get("value").

			// future: return name in this.props ? this.props[name] : this[name];
			return this[name];
		},

		emit: function(/*String*/ type, /*Object?*/ eventObj, /*Array?*/ callbackArgs){
			// summary:
			//		Used by widgets to signal that a synthetic event occurred, ex:
			//	|	myWidget.emit("attrmodified-selectedChildWidget", {}).
			//
			//		Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
			//		Also calls onType() method, if present, and returns value from that method.
			//		By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
			//		Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
			// tags:
			//		protected

			// Specify fallback values for bubbles, cancelable in case they are not set in eventObj.
			// Also set pointer to widget, although since we can't add a pointer to the widget for native events
			// (see #14729), maybe we shouldn't do it here?
			eventObj = eventObj || {};
			if(eventObj.bubbles === undefined){
				eventObj.bubbles = true;
			}
			if(eventObj.cancelable === undefined){
				eventObj.cancelable = true;
			}
			if(!eventObj.detail){
				eventObj.detail = {};
			}
			eventObj.detail.widget = this;

			var ret, callback = this["on" + type];
			if(callback){
				ret = callback.apply(this, callbackArgs ? callbackArgs : [eventObj]);
			}

			// Emit event, but avoid spurious emit()'s as parent sets properties on child during startup/destroy
			if(this._started && !this._beingDestroyed){
				on.emit(this.domNode, type.toLowerCase(), eventObj);
			}

			return ret;
		},

		on: function(/*String|Function*/ type, /*Function*/ func){
			// summary:
			//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
			// type:
			//		Name of event (ex: "click") or extension event like touch.press.
			// description:
			//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
			//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
			//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

			// For backwards compatibility, if there's an onType() method in the widget then connect to that.
			// Remove in 2.0.
			var widgetMethod = this._onMap(type);
			if(widgetMethod){
				return aspect.after(this, widgetMethod, func, true);
			}

			// Otherwise, just listen for the event on this.domNode.
			return this.own(on(this.domNode, type, func))[0];
		},

		_onMap: function(/*String|Function*/ type){
			// summary:
			//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove").
			//		If type is a synthetic event like touch.press then returns undefined.
			var ctor = this.constructor, map = ctor._onMap;
			if(!map){
				map = (ctor._onMap = {});
				for(var attr in ctor.prototype){
					if(/^on/.test(attr)){
						map[attr.replace(/^on/, "").toLowerCase()] = attr;
					}
				}
			}
			return map[typeof type == "string" && type.toLowerCase()];	// String
		},

		toString: function(){
			// summary:
			//		Returns a string that represents the widget.
			// description:
			//		When a widget is cast to a string, this method will be used to generate the
			//		output. Currently, it does not implement any sort of reversible
			//		serialization.
			return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
		},

		getChildren: function(){
			// summary:
			//		Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
			//		is this widget.   Note that it does not return all descendants, but rather just direct children.
			//		Analogous to [Node.childNodes](https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes),
			//		except containing widgets rather than DOMNodes.
			//
			//		The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
			//		outside of this.containerNode.
			//
			//		Note that the array returned is a simple array.  Application code should not assume
			//		existence of methods like forEach().

			return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit/_WidgetBase[]
		},

		getParent: function(){
			// summary:
			//		Returns the parent widget of this widget.

			return registry.getEnclosingWidget(this.domNode.parentNode);
		},

		connect: function(/*Object|null*/ obj, /*String|Function*/ event, /*String|Function*/ method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
			//
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.connect, except with the
			//		implicit use of this widget as the target object.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.own(connect.connect(obj, event, this, method))[0];	// handle
		},

		disconnect: function(handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Disconnects handle created by `connect`.
			// tags:
			//		protected

			handle.remove();
		},

		subscribe: function(t, method){
			// summary:
			//		Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
			//
			//		Subscribes to the specified topic and calls the specified method
			//		of this object and registers for unsubscribe() on widget destroy.
			//
			//		Provide widget-specific analog to dojo.subscribe, except with the
			//		implicit use of this widget as the target object.
			// t: String
			//		The topic
			// method: Function
			//		The callback
			// example:
			//	|	var btn = new Button();
			//	|	// when /my/topic is published, this button changes its label to
			//	|	// be the parameter of the topic.
			//	|	btn.subscribe("/my/topic", function(v){
			//	|		this.set("label", v);
			//	|	});
			// tags:
			//		protected
			return this.own(topic.subscribe(t, lang.hitch(this, method)))[0];	// handle
		},

		unsubscribe: function(/*Object*/ handle){
			// summary:
			//		Deprecated, will be removed in 2.0, use handle.remove() instead.
			//
			//		Unsubscribes handle created by this.subscribe.
			//		Also removes handle from this widget's list of subscriptions
			// tags:
			//		protected

			handle.remove();
		},

		isLeftToRight: function(){
			// summary:
			//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
			// tags:
			//		protected
			return this.dir ? (this.dir.toLowerCase() == "ltr") : domGeometry.isBodyLtr(this.ownerDocument); //Boolean
		},

		isFocusable: function(){
			// summary:
			//		Return true if this widget can currently be focused
			//		and false if not
			return this.focus && (domStyle.get(this.domNode, "display") != "none");
		},

		placeAt: function(/*String|DomNode|DocumentFragment|dijit/_WidgetBase*/ reference, /*String|Int?*/ position){
			// summary:
			//		Place this widget somewhere in the DOM based
			//		on standard domConstruct.place() conventions.
			// description:
			//		A convenience function provided in all _Widgets, providing a simple
			//		shorthand mechanism to put an existing (or newly created) Widget
			//		somewhere in the dom, and allow chaining.
			// reference:
			//		Widget, DOMNode, DocumentFragment, or id of widget or DOMNode
			// position:
			//		If reference is a widget (or id of widget), and that widget has an ".addChild" method,
			//		it will be called passing this widget instance into that method, supplying the optional
			//		position index passed.  In this case position (if specified) should be an integer.
			//
			//		If reference is a DOMNode (or id matching a DOMNode but not a widget),
			//		the position argument can be a numeric index or a string
			//		"first", "last", "before", or "after", same as dojo/dom-construct::place().
			// returns: dijit/_WidgetBase
			//		Provides a useful return of the newly created dijit._Widget instance so you
			//		can "chain" this function by instantiating, placing, then saving the return value
			//		to a variable.
			// example:
			//	|	// create a Button with no srcNodeRef, and place it in the body:
			//	|	var button = new Button({ label:"click" }).placeAt(win.body());
			//	|	// now, 'button' is still the widget reference to the newly created button
			//	|	button.on("click", function(e){ console.log('click'); }));
			// example:
			//	|	// create a button out of a node with id="src" and append it to id="wrapper":
			//	|	var button = new Button({},"src").placeAt("wrapper");
			// example:
			//	|	// place a new button as the first element of some div
			//	|	var button = new Button({ label:"click" }).placeAt("wrapper","first");
			// example:
			//	|	// create a contentpane and add it to a TabContainer
			//	|	var tc = dijit.byId("myTabs");
			//	|	new ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

			var refWidget = !reference.tagName && registry.byId(reference);
			if(refWidget && refWidget.addChild && (!position || typeof position === "number")){
				// Adding this to refWidget and can use refWidget.addChild() to handle everything.
				refWidget.addChild(this, position);
			}else{
				// "reference" is a plain DOMNode, or we can't use refWidget.addChild().   Use domConstruct.place() and
				// target refWidget.containerNode for nested placement (position==number, "first", "last", "only"), and
				// refWidget.domNode otherwise ("after"/"before"/"replace").  (But not supported officially, see #14946.)
				var ref = refWidget && ("domNode" in refWidget) ?
					(refWidget.containerNode && !/after|before|replace/.test(position || "") ?
						refWidget.containerNode : refWidget.domNode) : dom.byId(reference, this.ownerDocument);
				domConstruct.place(this.domNode, ref, position);

				// Start this iff it has a parent widget that's already started.
				// TODO: for 2.0 maybe it should also start the widget when this.getParent() returns null??
				if(!this._started && (this.getParent() || {})._started){
					this.startup();
				}
			}
			return this;
		},

		defer: function(fcn, delay){
			// summary:
			//		Wrapper to setTimeout to avoid deferred functions executing
			//		after the originating widget has been destroyed.
			//		Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
			// fcn: Function
			//		Function reference.
			// delay: Number?
			//		Delay, defaults to 0.
			// tags:
			//		protected

			var timer = setTimeout(lang.hitch(this,
				function(){
					if(!timer){
						return;
					}
					timer = null;
					if(!this._destroyed){
						lang.hitch(this, fcn)();
					}
				}),
				delay || 0
			);
			return {
				remove: function(){
					if(timer){
						clearTimeout(timer);
						timer = null;
					}
					return null; // so this works well: handle = handle.remove();
				}
			};
		}
	});

	if(has("dojo-bidi")){
		_WidgetBase.extend(_BidiMixin);
	}

	return _WidgetBase;
});

},
'dojo/cookie':function(){
define(["./_base/kernel", "./regexp"], function(dojo, regexp){

// module:
//		dojo/cookie

/*=====
var __cookieProps = {
	// expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	// path: String?
	//		The path to use for the cookie.
	// domain: String?
	//		The domain to use for the cookie.
	// secure: Boolean?
	//		Whether to only send the cookie on secure connections
};
=====*/


dojo.cookie = function(/*String*/name, /*String?*/ value, /*__cookieProps?*/ props){
	// summary:
	//		Get or set a cookie.
	// description:
	//		If one argument is passed, returns the value of the cookie
	//		For two or more arguments, acts as a setter.
	// name:
	//		Name of the cookie
	// value:
	//		Value for the cookie
	// props:
	//		Properties for the cookie
	// example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		cookie("configObj", json.stringify(config, {expires: 5 }));
	//	|	});
	//
	// example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
	//	|		config = json.parse(cookie("configObj"));
	//	|	});
	//
	// example:
	//		delete a cookie:
	//	|	require(["dojo/cookie"], function(cookie){
	//	|		cookie("configObj", null, {expires: -1});
	//	|	});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	// summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'curam/cdsl/store/CuramStore':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 26-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 */

define(['dojo/_base/declare',
        'curam/cdsl/request/CuramService',
        'curam/cdsl/_base/FacadeMethodCall',
        "curam/cdsl/Struct",
        'curam/cdsl/store/IdentityApi',
        'dojo/store/util/QueryResults',
        'dojo/_base/lang',
        'curam/cdsl/_base/_Connection'
        /*=== 'dojo/store/api/Store ===*/
        ],
    function(declare, CuramService, FacadeMethodCall, Struct, IdentityApi,
        QueryResults, lang /*===, Store ===*/) {
  
  var METHOD_MAPPINGS = {
    query: 'listItems',
    get: 'read',
    put: 'modify',
    add: 'insert',
    remove: 'remove'
  };
  
  var DEFAULT_OPTIONS = {
    identityApi: new IdentityApi(),
    dataAdapter: null
  };
    
  var processOptions = function(options) {
    var o = lang.clone(DEFAULT_OPTIONS);
    
    /* TODO: REMOVE
     * this branch is here to support old API where the third parameter
     * to the constructor was the identityApi, not options. */
    if (options && options.getIdentity
        && options.parseIdentity
        && options.getIdentityPropertyNames) {
      
      o.identityApi = options;
      
    } else {
      o = lang.mixin(o, options);
    }
    
    return o;
  };
  
  var Store = null; // We implement the Store API, but not directly extending
                    // it in order to save resources. Noted here and above
                    // as commented out dependency for documentation purposes.
  
  /**
   * @name curam.cdsl.store.CuramStore
   * @namespace Store implementation that connects to Curam server and allows
   *  using specifically modeled Curam facades to provide data.
   */
  var CuramStore = declare(Store,
  /**
   * @lends curam.cdsl.store.CuramStore.prototype
   */
  {
    _service: null,
    _baseFacadeName: null,
    _identityApi: null,
    
    /**
     * Creates an instance of CuramStore.
     * 
     * @param {curam/cdsl/_base/_Connection} connection The connection object
     *  to be used. Use an instance of curam/cdsl/connection/CuramConnection
     *  class.
     * @param {String} baseFacadeName Name of the base facade that contains
     *  specific modeled methods to be used by the store.
     * @param {Object} [options] Object containing the options for this store
     *  instance. The accepted options are: "identityApi" An instance
     *  of identity API in case you want to base identity on a property other
     *  than the default "id". "dataAdapter" Object containing functions
     *  to be run on data as it is sent to and from the server. More information
     *  on this in curam/cdsl/request/FacadeMethodCall.
     */
    constructor: function(connection, baseFacadeName, opts) {
      var options = processOptions(opts);
      
      this._service = new CuramService(connection, {
        dataAdapter: options.dataAdapter
      });
      this._baseFacadeName = baseFacadeName;
      this._identityApi = options.identityApi;
    },
    
    /**
     * Implements the dojo/store get() method.
     * 
     * @param {Object} identity Object containing the identity properties.
     * @returns {dojo/Promise::curam/cdsl/Struct} Promise for a result struct.
     */
    get: function(identity) {
      var idStruct = new Struct(this._identityApi.parseIdentity(identity));
      var methodCall = new FacadeMethodCall(this._baseFacadeName,
          METHOD_MAPPINGS.get, [idStruct]);

      return this._service.call([methodCall]).then(function(data) {
        // unpack result from array
        return data[0];
      });
    },
    
    /**
     * Implements the dojo/store getIdentity() method.
     * 
     * @param {curam/cdsl/Struct} struct Object you want to get identity for.
     *    It must be one of the data objects returned by this API.
     * @returns {Number|String} The object identity.
     */
    getIdentity: function(struct) {
      return this._identityApi.getIdentity(struct);
    },
    
    /**
     * Implements the dojo/store query() method.
     * 
     * @param {Object} query The query object. It is expected to be a JavaScript
     *  object containing values to be mapped to the first input struct
     *  you modeled in your listItems() method in Curam facade.
     * @param {Object} options The standard dojo/store API options object for
     *  the query() method.
     * 
     * @returns {dojo/store/util/QueryResults} The query results, typically
     *  containing an array of curam/cdsl/Struct objects.
     */
    query: function(query, options) {
      var methodCall = new FacadeMethodCall(
          this._baseFacadeName, METHOD_MAPPINGS.query, [ new Struct(query) ]);

      if (options) {
        methodCall._setMetadata({ queryOptions: {
          offset: options.start,
          count: options.count,
          sort: options.sort
        }});
      }

      var promise = this._service.call([methodCall]).then(function(data) {
        // unpack results array and wrap with QueryResults API
        return data[0].dtls;
      });

      return new QueryResults(promise);
    },
    
    /**
     * Implements the dojo/store put() method.
     * 
     * @param {curam/cdsl/Struct} object Struct with the data to be updated
     *  on the server.
     * @param {Object} options The standard dojo/store API options object for
     *  the put() method. Please note the options are currently ingored by CDSL.
     * 
     * @returns {dojo/Promise::curam/cdsl/Struct} Promise for a result struct,
     *  which is the case of this method is expected to contain the identity
     *  of the updated object.
     */
    put: function(object, options) {
      if (options && typeof options.overwrite !== 'undefined'
        && !options.overwrite) {
        throw new Error(
            'The overwrite option is set to false, but adding new items '
            + 'via CuramStore.put() is not supported.');
      }
      return this._addOrPut(METHOD_MAPPINGS.put, object, options, 'putOptions');
    },
    
    /**
     * Implements the dojo/store add() method.
     * 
     * @param {curam/cdsl/Struct} object Struct with the data to be inserted
     *  on the server.
     * @param {Object} options The standard dojo/store API options object for
     *  the add() method. Please note the options are currently ingored by CDSL.
     * 
     * @returns {dojo/Promise::curam/cdsl/Struct} Promise for a result struct,
     *  which is the case of this method is expected to contain the identity
     *  of the inserted object.
     */
    add: function(object, options) {
      var opts = {};
      if (options) {
        opts = lang.mixin(opts, options);
      }
      opts.overwrite = false; // setting to satisfy dojo/store API spec
      return this._addOrPut(METHOD_MAPPINGS.add, object, opts, 'addOptions');
    },
    
    /**
     * Implementation of add() and put() methods.
     * 
     * @private
     * 
     * @param methodName
     * @param object
     * @param options
     * @param metadataPropertyName
     * @returns
     */
    _addOrPut: function(methodName, object, options, metadataPropertyName) {
      var struct = object;
      if (!struct.isInstanceOf || !struct.isInstanceOf(Struct)) {
        struct = new Struct(object);
      }
      
      var methodCall = new FacadeMethodCall(
          this._baseFacadeName, methodName, [ struct ]);

      if (options) {
        var metadata = {};
        metadata[metadataPropertyName] = {
          id: options.id ? options.id : null,
          before: options.before ? this.getIdentity(options.before) : null,
          parent: options.parent ? this.getIdentity(options.parent) : null,
          overwrite: false
        };

        methodCall._setMetadata(metadata);
      }

      return this._service.call([methodCall]).then(
          lang.hitch(this, function(data) {
            // return the identity value provided in options
            if (options && options.id) {
              return options.id;
            }
            // if updating existing object, use identity of provided struct
            if(options && options.overwrite) {
              return this.getIdentity(struct);
            }
            // otherwise the returned data contain the identity
            return this.getIdentity(data[0]);
          }));
    },
    
    /**
     * Implements the dojo/store remove() method.
     * 
     * @param {Object} identity Object containing the identity properties
     *  for the object to be removed.
     * 
     * @returns {dojo/Promise::curam/cdsl/Struct} Promise for a result struct,
     *  which is the case of this method is expected to contain the identity
     *  of the removed object.
     */
    remove: function(identity) {
      var idStruct = new Struct(this._identityApi.parseIdentity(identity)),
          methodCall = new FacadeMethodCall(this._baseFacadeName,
              METHOD_MAPPINGS.remove, [idStruct]);

      return this._service.call([methodCall]).then(function(data) {
        // success, no server error, return identity of deleted object
        return identity;
      });
    }
  });
  
  return CuramStore;
});

},
'curam/dcl':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2016, 2017. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/*
 * Modification History
 * --------------------
 * 06-Dec-2017 GB  [RTC215570] Changing the bindCluster method to use 
 * 					dojo.getObject instead of dojo.global.
 * 28-Jan-2016 AB  [CR00475665] Fixed issue with nested clusters not working
 *                 when clusters were children of each other in UIM.
 * 25-Jan-2016 AB  [CR00475466] Fixed issue with toggle clusters code getting
 *                 stuck in an infinite loop.
 * 19-Jan-2016 AB  [CR00475170] Fixed issue with drop down widgets not working
 *                 on first selection under certain circumstances.
 * 15-Jan-2016 AB  [CR00474927] Fixed incorrect cluster states when a page was
 *                 submitted to itself.
 * 11-Jan-2016 AB  [CR00474307] Fixed nested cluster not disappearing when
 *                 hiding parent cluster.
 * 08-Dec-2015 AB  [CR00473697] Fixed bug when repopulating initial values.
 * 27-Oct-2015 SK  Initial version
 */
/**
 * @name curam.dcl
 * @namespace Provides access to the value of data sources that control whether
 * a dynamic conditional cluster is displayed or hidden.
 * 
 * The important API functions are:<ul>
 * <li><code>{@link curam.dcl.getField}</code> This should be invoked within the
 * JavaScript function that is mapped to a dynamic conditional cluster. i.e. the 
 * JavaScript function identifier is the value of the <code>EXPRESSION</code> 
 * attribute on a <code>SCRIPT</code> element on a cluster</li>
 * <p/>
 */
define(["dojo/_base/connect",
        "curam/define",
        "curam/debug",
        "dojo/query", 
        "dojo/dom-class",
        "dijit/registry"], function(connect, def, debug, query, domClass,registry) {
  //TODO redefine the scoped variables and functions as vars to hide them for any other use
  def.singleton("curam.dcl",
/**
 * @lends curam.dcl
 */
 {   
        /**
         * Evaluates to <code>true</code> and indicates that a conditional cluster
         * will be displayed.
         */
        CLUSTER_SHOW:true,
        
        /**
         * Evaluates to <code>false</code> and indicates that a conditional cluster
         * will be hidden.
         */
        CLUSTER_HIDE:false,
        
        /**
         * Holds the key for the initial values when dynamic conditional cluster
         * is initially loaded.
         * @private
         */
        DCL_PAGE_CLUSTER_INITVALS_KEY: "curam.dcl.page_cluster_intvals_key",
        
        /**
         * Holds the array for initial values.
         * @private
         */
        initialValues:{}, // Initial values from the fields
        
        /**
         * Holds the array for raw values of controlling fields.
         * @private
         */
        rawItems:{},
        
        /**
         * Holds the array for IDs of the control fields.
         * @private
         */
        controls:{},
        
        /**
         * Holds the array for IDs of the controlling clusters.
         * @private
         */
        clusters:{},
        
        /**
         * Holds the array of the current state for each dynamic conditional 
         * cluster in relation to whether it is displayed or hidden.
         * @private
         */
        states:{},
        
        /**
         * Holds the array of the getter functions.
         * @private
         */
        getters:{},
        
        /**
         * Holds the array of dynamic conditional clusters.
         * @private
         */
        clusterRecords:{},
        
        /**
         * Holds the array of field records.
         * @private
         */
        fieldRecords:{},
        
        /**
         * Holds the array of toggles.
         * @private
         */
        togglesArray:[],
        
        /**
         * Holds the array for references to all single and nested dynamic 
         * conditional cluster functions. Nested clusters will contains a tree
         * structure to represent inline functions.
         * @private
         */
        fnRoot: {'refs':[]},
        
        /**
         * Indicates if the current page had been loaded.
         * @private
         */
        pageLoaded:false,
        
        
        /**
         * Setup of dynamic conditional cluster on page load.
         * 
         * @private
         */
        init: function(){
          for (var clName in curam.dcl.clusterRecords) {
            var cl = query("." + clName)[0];
            if (cl) {
              curam.dcl.clusters[clName] = cl;
            } else {
              console.warn("Dynamic cluster", clName, " declared on the page but not associated!");
            }
          }
          // first handle the batch addition
          for (var rawItem in curam.dcl.rawItems) {
            curam.dcl.fieldRecords[rawItem] = 
             curam.dcl.initRef(curam.dcl.rawItems[rawItem]);
          }
          for (var fGetter in curam.dcl.fieldRecords) {
            curam.dcl.controls[fGetter] =  
                         curam.dcl.fieldRecords[fGetter];
          }
          dojo.subscribe("curam/dcl/execute", curam.dcl.evaluateExpression);

          // Evaluate initial cluster states
          curam.dcl.evaluateExpression(false);

          for (var clusterId in curam.dcl.clusterRecords) {
            // Transfer initial values for all clusters to curam.dcl.initialValues array
            curam.dcl.transferValuesFromDomToStorage(clusterId);
            // If the cluster is hidden, blank the initial values so that they are not submitted
            if(curam.dcl.states[clusterId] == curam.dcl.CLUSTER_HIDE) {
              curam.dcl.blankFields(clusterId);
            }
          }
        },
        
        /**
         * Adds a control variable and value to the current list of controlling
         * fields.
         * 
         * @param {String} [varName] The field variable/name to add.
         * @param {Object} [val] The value to be added.
         * @private
         */
        addControlVar: function(varName, val) {
          curam.dcl.fieldRecords[varName] = curam.dcl.initVar(val);
        },
        
        /**
         * Adds a control reference to the current list
         * fields.
         * 
         * @param {String} [controlVar] The control variable to be added.
         * @param {String} [fieldRef] The controlling field reference.
         * @private
         */
        addControlRef: function(controlVar, fieldRef){
          curam.dcl.fieldRecords[controlVar] = curam.dcl.initRef(fieldRef);
        },
        
        /**
         * Binds the cluster for the static expression. This expression 
         * currently on only evaluates to boolean (i.e hide/show).
         * @private
         */
        bindCluster: function(clusterId, fnParentExpression, fnExpression) {
        	var fnExpressionValue = dojo.getObject(fnExpression);
            var exprRecord = {'fnRef':fnExpressionValue, 'clId':clusterId};
              if (fnParentExpression != '') {
            	var fnParentExpressionValue = dojo.getObject(fnParentExpression);
                if (!fnParentExpressionValue.refs) {
                  fnParentExpressionValue.refs = [];
                }
                fnParentExpressionValue.refs.push(exprRecord);
              } else {
                curam.dcl.fnRoot.refs.push(exprRecord);
              }
              curam.dcl.clusterRecords[clusterId] = fnExpressionValue;
              curam.dcl.states[clusterId] = curam.dcl.CLUSTER_HIDE;
           },
        
        /**
         * Sets getter function.
         * @param {String} [controlVar] The control variable to be added.
         * @param {String} [fnGetter] The function to be used.
         * @private
         */
        setGetter: function(controlVar, fnGetter) {
          curam.dcl.getters[controlVar] = fnGetter;
        },
        
        /**
         * Gets the value of a field which is identified by it's name. The value
         * can be used as part of the logic to evaluate whether a dynamic
         * conditional cluster will be displayed or not.
         * 
         * @param {String} fieldName The name of a field to get. If it is not 
         * specified an error will occur. It must match the value of a 
         * <code>CONTROL_REF</code> attribute on a <code>FIELD</code> element or
         *  the value of a <code>JSCRIPT_REF</code> attribute on a
         * <code>TARGET</code> element in UIM.
         */
        getField: function(fieldName) {
          if (!fieldName) {
            throw Error("You must specify a field name");
          }
          var value = undefined;
          try {
            value = curam.dcl.controls[fieldName].apply();
          } catch (e) {
              debug.log(debug.getProperty("curam.dcl.field.error") + fieldName);
              debug.log(debug.getProperty("curam.dcl.field.valid",[fieldName]));
          }
          if (value) {
            curam.debug.log("curam.dcl.getField(" + fieldName + ") - " + value);
          }
          return value;
        },
        
        /**
         * Evaluates a nested tree of dynamic conditional clusters.
         * 
         * @param {Array} [arrRefs] The array of controlling expressions.
         * @private
         */
        evaluateRefs: function(arrRefs) {
          for (var i = 0; i < arrRefs.length; i++) {
            var aRef = arrRefs[i];
            // aRef.fnRef.apply() is the execution of control ref function
            var nextState = aRef.fnRef.apply();
            if (nextState != curam.dcl.states[aRef.clId]) {
              // This cluster needs to toggle, so push its ID to togglesArray for later
              curam.dcl.togglesArray.push(aRef.clId);
            }
            if (aRef.fnRef.refs != null) {
              // recursively evaluating nested tree..
              curam.dcl.evaluateRefs(aRef.fnRef.refs);
            }
          }
        },
        
        /**
         * Evaluates whether a specific cluster is displayed or hidden.
         * 
         * @param {Boolean} [changedField] Indicates if the field has been 
         * changed or not already.
         * @private
         */
        evaluateExpression: function(changedField) {
          curam.dcl.pageLoaded = false;
          if (!changedField) {
            curam.dcl.pageLoaded = true;
          }

          curam.dcl.evaluateRefs(curam.dcl.fnRoot.refs);
          var count = 0;
          var limit = 1000;
          while(curam.dcl.togglesArray.length > 0 && count < limit) {
            count++;
            for (var i=0; i < curam.dcl.togglesArray.length;i++) {
              var clusterNode = query('.' + curam.dcl.togglesArray[i])[0];

              // Toggle the cluster
              curam.dcl.toggleCluster(curam.dcl.pageLoaded, clusterNode, curam.dcl.togglesArray[i]);
            }
            curam.dcl.togglesArray = [];
            // We need to re-evaluate the control_refs at this point, as
            // some of the clusters toggled off may be control_refs for other
            // clusters (i.e. nested clusters.)
            curam.dcl.evaluateRefs(curam.dcl.fnRoot.refs);
          }
          if(count >= limit) {
            // If a user hammers a checkbox faster than the animation can play,
            // they can get stuck in an infinite loop that crashes the browser.
        	  debug.log(debug.getProperty("curam.dcl.field.inifinte.loop.info",[limit]));
          }
        },

        /**
         * Toggles the cluster state. Make appropriate changes to the DOM
         * including blanking values when hiding a cluster and restoring
         * initial values when showing. Also triggers the hide/show animation.
         * 
         * @param {Boolean} [pageLoaded] Indicates if the page is loaded. 
         * @param {Object}  [clusterNode] The dynamic conditional cluster node.
         * @param {String}  [clusterId] The id of the dynamic conditional cluster node.
         * @private
         */
        toggleCluster: function(pageLoaded, clusterNode, clusterId) {
          // Flip cluster state
          curam.dcl.states[clusterId] = !curam.dcl.states[clusterId];
          // Modify DOM elements
          if(curam.dcl.states[clusterId] == curam.dcl.CLUSTER_SHOW) {
            domClass.remove(clusterNode, "hide-dynamic-cluster"); // Show the cluster
            curam.dcl.transferValuesFromStorageToDom(clusterId); // Restore initial values (i.e. wipe out any user values)
          } else {
            domClass.add(clusterNode, "hide-dynamic-cluster"); // Hide the cluster
            curam.dcl.blankFields(clusterId); // Blank the fields so initial/user data is not submitted
          }
          // Trigger animation
          curam.dcl.animateCluster(pageLoaded, clusterNode, clusterId);
        },

        /**
         * Trigger the animation to toggle the cluster from visible to
         * invisible. Only animation code should live in this function.
         */
        animateCluster: function(pageLoaded, clusterNode, clusterId) {

          //return if the animation has already begun
          if (!clusterNode || clusterNode.inAnimation) {
            return;
          }

          require(["dojo/fx"], function(fx) {
            //The arguments passed to the dojo.fx function are created here
            
            //wipeIn arguments. Used when expanding the cluster
            var DirDownArgs = {
              node: clusterNode,
              duration: 200,
              onBegin: function () {
                clusterNode.inAnimation = true;
              },
              onEnd: function() {
                clusterNode.inAnimation = false;
              }
            };
          
            //wipeOut arguments. Used when collapsing the cluster
            var DirUpArgs = {
              node: clusterNode,
              duration: 200,
              onBegin: function () {
                clusterNode.inAnimation = true;
              },
              onEnd: function() {
                clusterNode.inAnimation = false;
              }
            };

            //Perform animation.
            //There will always be a cluster body, but we must cater for the presence
            //of descriptions and page indexes
            if (pageLoaded || curam.dcl.states[clusterId] == curam.dcl.CLUSTER_SHOW) { //will expand cluster
              fx.wipeIn(DirDownArgs).play();  //main cluster body
            } else if (curam.dcl.states[clusterId] == curam.dcl.CLUSTER_HIDE) { //will collapse cluster
              fx.wipeOut(DirUpArgs).play(); //main cluster body
            } else {
              //debug.log("The cluster does not have a class name indicating" +
              //            "its collapsed/uncollapsed state");
            }
          });
        },

        /**
         * Transfer values from the javascript storage to the DOM elements.
         * 
         * @param clusterId The ID of the cluster we are working on.
         * @private
         */
        transferValuesFromStorageToDom: function(clusterId) {
          var clusterNode = query('.' + clusterId)[0];
          var values = curam.dcl.initialValues[clusterId];
          var textNodes = query("table input[value]", clusterNode);
          for (var i = 0; i < textNodes.length; i++) {
            textNode = textNodes[i];
            if (values) {
              var storedTextNodeValue = values[i].value;
              textNode.value = storedTextNodeValue;

              // If _lastValueReported is present then this must be a drop down
              // widget, so get the widget and push the value to it
              if(textNode.id && values[i]._lastValueReported) {
                var dropdownWidget = this.getDropdownWidget(textNode.id);
                dropdownWidget._lastValueReported = values[i]._lastValueReported;
              }

            } else {
              // The first time the cluster is expanded we won't have any user
              // values so we just leave the defaults as they are.
            }
          }
          //curam.dcl.evaluateExpression(true);
        },

        /**
         * Transfer values from the DOM elements to the javascript storage.
         * Also calls evaluateExpression(true) as those fields may be control
         * refs.
         * 
         * @param clusterId The ID of the cluster we are working on
         * @private
         */
        transferValuesFromDomToStorage: function(clusterId) {
          var clusterNode = query('.' + clusterId)[0];
          var inputTextNodes = query("table input[value]", clusterNode);
          var clusterIdValues = [];
          for (var i = 0; i < inputTextNodes.length; i++) {
            var textNode = inputTextNodes[i];

            var valuesToStore = {id: textNode.id, value: textNode.value};

            // If this is a drop-down widget then add an extra value
            var dropdownWidget = this.getDropdownWidget(textNode.id);
            if(dropdownWidget) {
              valuesToStore._lastValueReported = dropdownWidget._lastValueReported;
            }

            clusterIdValues.push(valuesToStore);
          }
          curam.dcl.initialValues[clusterId] = clusterIdValues;
        },

        /**
         * Blanks the fields on a hidden cluster. Also calls
         * evaluateExpression(true) as those fields may be control refs.
         * 
         * @param clusterId The ID of the cluster we are working on
         * @private
         */
        blankFields: function(clusterId) {
          var clusterNode = query('.' + clusterId)[0];
          var textNodes = query("table input[value]", clusterNode);
          for (var i = 0; i < textNodes.length; i++) {
            textNode = textNodes[i];

            // There are "special" fields that should not be blanked. These fields
            // are "hidden" and have an attribute named "dcl-blankable" set to false.
            if(textNode.type === "hidden" && textNode.getAttribute('dcl-blankable') === 'false') {            	
            	debug.log(debug.getProperty("curam.dcl.skip.blank"), textNode);
            } else {
            	textNode.value = "";
            }

            if(textNode.type === "checkbox" || textNode.type === "radio") {
              textNode.checked = false;
            }

            // For drop-down widgets get the dojo object from the dijit
            // registry and blank the '_lastValueReported' attribute
            var dropdownWidget = this.getDropdownWidget(textNode.id);
            if(dropdownWidget) {
              dropdownWidget._lastValueReported = "";
            }

            //curam.dcl.evaluateExpression(true);
          }
        },

        /**
         * Searches dijit/registry for a widget with the given id. Used to find
         * drop-down widgets so we can set/blank the _lastValueReported value.
         * 
         * @param id The ID of the element to search for. The widget will have
         *           the same ID as the input node.
         * @return the drop-down widget. Returns undefined if no widget was
         *         found or if no 'id' parameter was given.
         * @private
         */
        getDropdownWidget: function(id) {
          if(id) {
            var dropdownWidget = registry.byId(id);
            return dropdownWidget;
          }
        },

        /**
         * Initializes fields from <code>CONTROL_REF</code> attributes.
         * 
         * @param {String}  [fName] The specific field name.
         * @private
         */
        initRef: function(fName) {
          var ref = document.getElementsByName(fName);
          var cGetter = curam.dcl.getters[fName];
          var fallBack = function() {
            return ref[0].selectedValue || ref[0].value;
          };
          if (ref.length > 1) { //radiogroup
            fallBack =
              function() {
                for (var i = 0; i < ref.length; i++) {
                  if (ref[i].checked) {
                    return ref[i].value;
                  }
                }
                return "";
              };
          } else if (ref[0].type == "checkbox") {
            fallBack = function() {
              return document.getElementsByName(fName)[0].checked;
            };
          }          
          return function() {
            return cGetter ? cGetter.apply(ref) : fallBack.apply();
          };
        },
        
        /**
         * Initializes fields from <code>JSCRIPT_REF</code> attributes.
         * 
         * @param {Object}  [value] The value.
         * @private
         */
        initVar: function(value) {
          return function() {
            return value;
          };
        }
      });
    return curam.dcl;     
});

},
'dijit/MenuBarItem':function(){
define([
	"dojo/_base/declare", // declare
	"./MenuItem",
	"dojo/text!./templates/MenuBarItem.html"
], function(declare, MenuItem, template){

	// module:
	//		dijit/MenuBarItem

	var _MenuBarItemMixin = declare("dijit._MenuBarItemMixin", null, {
		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setIconClassAttr: null	// cancel MenuItem setter because we don't have a place for an icon
	});

	var MenuBarItem = declare("dijit.MenuBarItem", [MenuItem, _MenuBarItemMixin], {
		// summary:
		//		Item in a MenuBar that's clickable, and doesn't spawn a submenu when pressed (or hovered)

	});
	MenuBarItem._MenuBarItemMixin = _MenuBarItemMixin;	// dojox.mobile is accessing this


	return MenuBarItem;
});

},
'dojo/uacss':function(){
define(["./dom-geometry", "./_base/lang", "./domReady", "./sniff", "./_base/window"],
	function(geometry, lang, domReady, has, baseWindow){

	// module:
	//		dojo/uacss

	/*=====
	return {
		// summary:
		//		Applies pre-set CSS classes to the top-level HTML node, based on:
		//
		//		- browser (ex: dj_ie)
		//		- browser version (ex: dj_ie6)
		//		- box model (ex: dj_contentBox)
		//		- text direction (ex: dijitRtl)
		//
		//		In addition, browser, browser version, and box model are
		//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.
		//
		//		Returns the has() method.
	};
	=====*/

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		trident = has("trident"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_quirks": has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),
			"dj_edge": has("edge"),

			"dj_gecko": has("mozilla"),

			"dj_ios": has("ios"),
			"dj_android": has("android")
		}; // no dojo unsupported browsers

	if(ie){
		classes["dj_ie"] = true;
		classes["dj_ie" + maj(ie)] = true;
		classes["dj_iequirks"] = has("quirks");
	}
	if(trident){
		classes["dj_trident"] = true;
		classes["dj_trident" + maj(trident)] = true;
	}
	if(ff){
		classes["dj_ff" + maj(ff)] = true;
	}

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	domReady(function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'curam/util/Refresh':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012-2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
 
  /*
   * Modification History
   * --------------------
   * 07-Feb-2023  BOS [SPM-126846] Ensuring that the corect number of tab action items are diaplyed
   * if no dynamic update.
   * 06-Jan-2023  BOS [SPM-126610] Path name change for manageInlineTabMenuStates() function.
   * 22-Nov-2022  AT [SPM-126184]  Support for autorecovery restore modal.
   * 16-Nov-2022  FN  [SPM-106691] Amending setupRefreshButton and adding accessibility
   *                               mark-up for screen reader.
   * 21-Nov-2014  MV  [CR00450009] Stop request if there is no data.
   * 17-Oct-2014  MV  [CR00447421] Logic for tab open scenario moved to refresh
   *                               controller.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
   * 27-Feb-2014  MV  [CR00419961] Move to common AJAX request API.
   * 07-Oct-2013  BOS [CR00396277] Refactoring to take account of the fact that
   *                    the selected tab may not be defined. 
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 05-Aug-2011  MV  [CR00283589] Stop the click event in refreshPage() function.
   * 29-Jul-2011  MV  [CR00269970] Make use of the new refresh controller.
   * 24-May-2011  MV  [CR00267843] Disallow auto refresh on submitted action pages.
   * 29-Apr-2011  SC  [CR00264826] Removed incorrect usage of getselectedtab.
   * 11-Feb-2011  PK  [CR00251730] Added support for refreshing main content
   *                    panel on submit.
   * 22-Dec-2010  MV  [CR00239864] Only call menu/nav loaders if there is request
   *                    for menu/nav update.
   * 14-Dec-2010  DG  [CR00217921] Updated for "tabDescriptor" on a tab panel.
   *                    Added copyright.
   * 30-Nov-2010  FG  [CR00232780] Add a new function that may be used to refresh
   *                    the page content and smart panel of a page.
   * 13-Jul-2010  MV  [CR00210064] Ensure tab menu and navigation is not updated
   *                   twice on tab load.
   * 07-Jul-2010  MV  [CR00180694] Refactor to unify dynamic updates of actions
   *                  menu and tab navigation. Move JavaScript code from renderer
   *                  to here.
   * 29-Apr-2010  MV  [CR00195109] Uncomment menu bar refresh code.
   * 26-Apr-2010  JS  [CR00197709] Removed refresh navigation bar code.
   * 27-Nov-2009  MV  [CR00180297] Pass the tab widget ID to the handlers.
   * 18-Nov-2009  MV  [CR00172452] Only call handlers for the corresponding tab.
   * 03-Aug-2009  MLB [CR00163869] Full refresh implementation.
   * 16-Jul-2009  MLB [CR00162701] Initial version.
*/

  define(["dijit/registry",
        "dojo/dom-class",
        "dojo/dom-attr",
        "curam/inspection/Layer",
        "curam/util/Request",
        "curam/define",
        "curam/debug",
        "curam/util/ResourceBundle",
        "curam/util",
        "curam/tab",
        "curam/util/ContextPanel",
        "curam/util/ui/refresh/TabRefreshController"
        ], function(registry, domClass, domAttr, layer, curamRequest, define, debug, resBundle) {
 

  /**
   * Contains functions for refreshing the various panels.
   */
  define.singleton("curam.util.Refresh", {
    // flag if the content panel has been submitted
    submitted : false,
    // the id of the page that was submitted
    pageSubmitted : "",
    // array of refresh configuration for all tabs
    refreshConfig : [],

    menuBarCallback: null,
    navigationCallback: null,
    
    /** Holds references to refresh controllers for individual tabs. */
    _controllers: {},
    
    /** Holds reference to the page level refresh button anchor. */
    _pageRefreshButton: undefined,

    /**
     * Called by the MenuBarRenderer to register functions to be used
     * for dynamically updating the menu items.
     * 
     * The function is called once for each opened tab that has dynamic menu
     * items. The assumption is that all such tabs are using the same callbacks
     * so only the first call to this function is used to set the callbacks.
     * Subsequent calls are ignored.
     * 
     * @param updateMenuItemStates
     * @param getRefreshParams
     */
    setMenuBarCallbacks: function(updateMenuItemStates, getRefreshParams) {
      if (!curam.util.Refresh.menuBarCallback) {
        curam.util.Refresh.menuBarCallback = {
          updateMenuItemStates: updateMenuItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    /**
     * Called by the NavigationTabRenderer to register functions to be used
     * for dynamically updating the navigation items.
     * 
     * The function is called once for each opened tab that has dynamic
     * navigation items. The assumption is that all such tabs are using the same
     * callbacks so only the first call to this function is used to set
     * the callbacks. Subsequent calls are ignored.
     * 
     * @param updateNavItemStates
     * @param getRefreshParams
     */
    setNavigationCallbacks: function(updateNavItemStates, getRefreshParams) {
      if (!curam.util.Refresh.navigationCallback) {
        curam.util.Refresh.navigationCallback = {
          updateNavItemStates: updateNavItemStates,
          getRefreshParams: getRefreshParams
        };
      }
    },

    refreshMenuAndNavigation: function(tabWidgetId, refreshMenuBar,
        refreshNavigation) {
      // Summary:
      //    Sends an AJAX request to get dynamic menu and navigation data
      //    and calls the functions for updating these components.
      curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
          + "tabWidgetId=%s, refreshMenuBar || refreshNavigation: %s || %s",
          tabWidgetId, refreshMenuBar, refreshNavigation);

      if (!refreshMenuBar && !refreshNavigation) {
        // do nothing
        curam.debug.log(debug.getProperty("curam.util.Refresh.no.refresh"));
        return;
      }

      var callbacks = {
        /**
         * Handles the successful return of the AJAX call.
         */
        update: function(tabWidgetId, result, ioargs) {
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.refresh"), result);
          var ncb = curam.util.Refresh.navigationCallback;
          curam.debug.log("refreshNavigation? ", refreshNavigation);
          if (refreshNavigation && result.navData && ncb) {
            ncb.updateNavItemStates(tabWidgetId, result);
          };
          var mcb = curam.util.Refresh.menuBarCallback;
          curam.debug.log("refreshMenuBar? ", refreshMenuBar);
          if (refreshMenuBar && result.menuData && mcb) {
            // TODO: Put this string in debug.js.properties -- BOS
            curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
              + "dynamic tab menu item update");
            mcb.updateMenuItemStates(tabWidgetId, result);
          } else {
            // TODO: Put this string in debug.js.properties -- BOS
            curam.debug.log("curam.util.Refresh.refreshMenuAndNavigation: "
              + "no dynamic data, updating initially loaded tab action items to show"
              + "only those that should be inlined");
            curam.util.TabActionsMenu.manageInlineTabMenuStates(tabWidgetId);
          }
        },

        /**
         * Handles the failure case of the AJAX call made to get data
         * for the dynamic items.
         */
        error: function(error, ioargs) {
          curam.debug.log("========= " + debug
            .getProperty("curam.util.Refresh.dynamic.failure") 
              + " ===========");
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.error"), error);
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.args"), ioargs);
          curam.debug.log("==================================================");
        }
      };

      // send the AJAX request
      var fullUrl = "servlet/JSONServlet?o3c=TAB_DYNAMIC_STATE_QUERY",
          hasAnyParams = false;
      var mcb = curam.util.Refresh.menuBarCallback;
      if (refreshMenuBar && mcb) {
        var menuParams = mcb.getRefreshParams( tabWidgetId);
        if (menuParams) {
          fullUrl += "&" + menuParams;
          hasAnyParams = true;
        }
      }
      var ncb = curam.util.Refresh.navigationCallback;
      if (refreshNavigation && ncb) {
        var navParams = ncb.getRefreshParams(tabWidgetId);
        if (navParams) {
          fullUrl += "&" + navParams;
          hasAnyParams = true;
        }
      }
      curam.debug.log(debug
          .getProperty("curam.util.Refresh.dynamic.refresh.req"));
      if (hasAnyParams) {
        curamRequest.post({
         url: fullUrl,
         handleAs: "json",
         preventCache: true,
         load: dojo.hitch(callbacks, "update", tabWidgetId),
         error: dojo.hitch(callbacks, "error")
      });

      } else {
        // manage the state on inline items
        curam.util.TabActionsMenu.manageInlineTabMenuStates(tabWidgetId);
        curam.debug.log(debug
            .getProperty("curam.util.Refresh.dynamic.refresh.no_dynamic_items"));
      }
    },
    
    /**
     * Called by the tab renderer this function ensures that if config is added
     * repeatedly, it overrides any existing config for the same tab.
     * 
     * This caters for closing and reopening tabs.
     * 
     * @param {Object} config The tab refresh configuration to add.
     */
    addConfig: function(config) {
      var updated = false;
      
      // if the config for the tab is already added, replace it with the new one
      dojo.forEach(curam.util.Refresh.refreshConfig, function(existingConfig) {
        if (existingConfig.tab == config.tab) {
          existingConfig.config = config.config;
          
          updated = true;
        }
      });
      
      // otherwise just add as a new config
      if (!updated) {
        curam.util.Refresh.refreshConfig.push(config);
      }
    },

    /**
     * Called by the tab renderer this function instantiates the refresh
     * controller for the specified tab.
     * 
     * @param {String} tabWidgetId Widget ID of the tab to create refresh
     *    controller for.
     */
    setupRefreshController: function(tabWidgetId) {
      curam.debug.log("curam.util.Refresh.setupRefreshController " 
         + debug.getProperty("curam.util.ExpandableLists.load.for"), 
           tabWidgetId);
      
      var selectedTab = registry.byId(tabWidgetId);
      var tabId = selectedTab.tabDescriptor.tabID;
      
      var filteredConfigs = dojo.filter(curam.util.Refresh.refreshConfig,
          function(item) { return item.tab == tabId; });

      if (filteredConfigs.length == 1) {
        var refreshConfigTab = filteredConfigs[0];
        var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, refreshConfigTab);
        curam.util.Refresh._controllers[tabWidgetId] = ctl;
        ctl.setRefreshHandler(curam.util.Refresh.handleRefreshEvent);
      
      } else {
        if (filteredConfigs.length == 0) {
          curam.debug.log(debug
            .getProperty("curam.util.Refresh.no.dynamic.refresh"), tabWidgetId);
          var ctl = new curam.util.ui.refresh.TabRefreshController(tabWidgetId, null);
          curam.util.Refresh._controllers[tabWidgetId] = ctl;
        
        } else {
          throw "curam.util.Refresh: multiple dynamic refresh "
              + "configurations found for tab " + tabWidgetId;

        }
      }
      
      // destroy controller reference on tab close
      curam.tab.executeOnTabClose(function() {
        curam.util.Refresh._controllers[tabWidgetId].destroy();
        curam.util.Refresh._controllers[tabWidgetId] = undefined;
      }, tabWidgetId);
    },
    
    /**
     * Returns the refresh controller for the specified tab, throwing exception
     * in case controller doesn't exist for the tab.
     * 
     * @param tabWidgetId Widget ID of the tab.
     * 
     * @returns The refresh controller.
     */
    getController: function(tabWidgetId) {
      var ctl = curam.util.Refresh._controllers[tabWidgetId];
      if (!ctl) {
        throw "Refresh controller for tab '" + tabWidgetId + "' not found!";
      }
      return ctl;
    },
    
    /**
     * This is called by nested frames to notify the refresh controller of a page
     * load.
     * 
     * @param iframeId ID of the source iframe.
     * @param context The context in which the load happened.
     */
    handleOnloadNestedInlinePage: function(iframeId, context) {
      curam.debug.log("curam.util.Refresh.handleOnloadNestedInlinePage " 
        + debug.getProperty("curam.util.Refresh.iframe", [iframeId, context]));
       var topmostWin = curam.util.getTopmostWindow();
       var tabWidgetId = undefined;

      // get the source tab of the nested page
      var sourceTab = curam.tab.getSelectedTab();
      if (sourceTab) {
        tabWidgetId = curam.tab.getTabWidgetId(sourceTab);  
      }

      if (tabWidgetId) {
        curam.debug.log(debug.getProperty("curam.util.Refresh.parent"), 
                      tabWidgetId);
        topmostWin.curam.util.Refresh.getController(tabWidgetId).pageLoaded(
          context.pageID,
          curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_INLINE);
        topmostWin.dojo.publish("/curam/main-content/page/loaded",
          [context.pageID, tabWidgetId, sourceTab]);
        return true;
      }
      return false;
    },

    /**
     * Handles refresh events emitted by refresh controllers for tabs in the UI.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     */
    handleRefreshEvent: function(eventIds) {
      var contextPanelRefreshHandler = function(tabWidgetId) {
        curam.util.ContextPanel.refresh(registry.byId(tabWidgetId));
      };
      var mainContentRefreshHandler = function(tabWidgetId) {
        curam.tab.refreshMainContentPanel(registry.byId(tabWidgetId));
      };
      var menuAndNavigationRefreshHandler =
      function(tabWidgetId, refreshMenuBar, refreshNavigation) {
        curam.util.Refresh.refreshMenuAndNavigation(
            tabWidgetId, refreshMenuBar, refreshNavigation);
      };
      curam.util.Refresh._doRefresh(eventIds, contextPanelRefreshHandler,
        mainContentRefreshHandler, menuAndNavigationRefreshHandler);
    },
    
    /**
     * Performs the actual refresh using the specified handlers.
     * THis is factored out to a separate function so that it can be unit tested.
     * 
     * @param {Array} eventIds A list of refresh events to be processed.
     * @param {Function} refreshContextPanel A handler to be called when context
     *            panel refresh is required.
     * @param refreshMainContent A handler to be called when main content panel
     *            refresh is required.
     * @param refreshMenuAndNavigation A handler to be called when menu
     *            and navigation refresh is required.
     */
    _doRefresh: function(eventIds, refreshContextPanel, refreshMainContent,
        refreshMenuAndNavigation) {

      var tabWidgetId = null;
      var refreshMenuBar = false;
      var refreshNavigation = false;
      var refreshContext = false;
      var refreshMain = false;
      var trc = curam.util.ui.refresh.TabRefreshController.prototype;
      dojo.forEach(eventIds, function(eventId) {
        var lastSlashIndex = eventId.lastIndexOf("/");
        var target = eventId.slice(0, lastSlashIndex);
        // all events are for the same tabWidgetId so just read the first one
        if (!tabWidgetId) {
          tabWidgetId = eventId.slice(lastSlashIndex + 1, eventId.length);
        }
        // now read the target part
        if (target == trc.EVENT_REFRESH_MENU) {
          refreshMenuBar = true;
        }
        if (target == trc.EVENT_REFRESH_NAVIGATION) {
          refreshNavigation = true;
        }
        if (target == trc.EVENT_REFRESH_CONTEXT) {
          refreshContext = true;
        }
        if (target == trc.EVENT_REFRESH_MAIN) {
          refreshMain = true;
        }
      });
      
      // perform the refreshes
      if (refreshContext) {
        // refreshes the context panel
        refreshContextPanel(tabWidgetId);
      }
      if (refreshMain) {
        refreshMainContent(tabWidgetId);
      }
      refreshMenuAndNavigation(tabWidgetId, refreshMenuBar, refreshNavigation);
    },
    
    setupRefreshButton:function(buttonClass) {
      dojo.ready(function() {
        var button = dojo.query("." + buttonClass)[0];
        if (!button) {
          throw "Refresh button not found: " + buttonClass;
        }
        curam.util.Refresh._pageRefreshButton = button;
        var href = window.location.href;
        if (curam.util.isActionPage(href)) {
          // disable the button
          var bundle = new resBundle("Refresh");
          var disabledRefreshButtonText = bundle.getProperty("refresh.button.disabled");               
          domClass.add(button, "disabled");
          domAttr.set(button, "title", disabledRefreshButtonText);
          domAttr.set(button, "aria-label", disabledRefreshButtonText);
          domAttr.set(button, "role", "link");
          domAttr.remove(button, "href");
          domAttr.set(button, "aria-disabled", "true");
          curam.util.Refresh._pageRefreshButton._curamDisable = true;
          if (button.firstChild != null) {
            domClass.add(button.firstChild, "refresh-disabled");
            domAttr.set(button.firstChild, "alt", disabledRefreshButtonText); 
          }

        } else {
          domClass.add(button, "enabled");
          curam.util.Refresh._pageRefreshButton["_curamDisable"] = undefined;
        }
        
        curam.util.getTopmostWindow().curam.util.setupPreferencesLink(href);
      });
    },
    
    /**
     * Sets the force refresh flag to true and then invokes the function
     * that refreshes the main content area of a page. An event is also fired
     * that ensures that the associated smart panel is also refreshed.
     */
    refreshPage: function(event){
      dojo.stopEvent(event);

      var href = window.location.href;
      var buttonDisabled = curam.util.Refresh._pageRefreshButton._curamDisable;
      if(buttonDisabled) {
        // do nothing
        return;
      }

      // Ensure that the force refresh flag is set to true and make a call to
      // the function that will carry out the refresh operation.
      curam.util.FORCE_REFRESH = true;
      curam.util.redirectWindow(href, true);
    }
  });
  layer.register("curam/util/Refresh", curam.util.Refresh);

  return curam.util.Refresh;
});

},
'dijit/form/_FormWidget':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/sniff", //  1 , has("msapp")
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, has, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

	// module:
	//		dijit/form/_FormWidget

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/form/_FormValueWidget"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
		// summary:
		//		Base class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,
		//		which can be children of a `<form>` node or a `dijit/form/Form` widget.
		//
		// description:
		//		Represents a single HTML element.
		//		All these widgets should have these attributes just like native HTML input elements.
		//		You can set them during widget construction or afterwards, via `dijit/_WidgetBase.set()`.
		//
		//		They also share some common methods.

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.  Use set('disabled', ...) instead.
			kernel.deprecated("setDisabled(" + disabled + ") is deprecated. Use set('disabled'," + disabled + ") instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		setValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('value', ...) instead.
			kernel.deprecated("dijit.form._FormWidget:setValue(" + value + ") is deprecated.  Use set('value'," + value + ") instead.", "", "2.0");
			this.set('value', value);
		},

		getValue: function(){
			// summary:
			//		Deprecated.  Use get('value') instead.
			kernel.deprecated(this.declaredClass + "::getValue() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified).
			// Unfortunately we can't use _setNameAttr to set the name in IE due to IE limitations, see #8484, #8660.
			// But when IE6 and IE7 are desupported, then we probably don't need this anymore, so should remove it in 2.0.
			// Also, don't do this for Windows 8 Store Apps because it causes a security exception (see #16452).
			// Regarding escaping, see heading "Attribute values" in
			// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
			this.nameAttrSetting = (this.name && !has("msapp")) ? ('name="' + this.name.replace(/"/g, "&quot;") + '"') : '';
			this.inherited(arguments);
		}
	});
});

},
'curam/contentPanel':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2009,2022. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */
define(["curam/util",
        "curam/tab",
        "dojo/dom-attr",
        "dojo/dom",
        "curam/util/onLoad",
        "curam/util/Refresh",
        "curam/util/ui/refresh/RefreshEvent",
        "curam/define",
        "curam/debug",
        "curam/ui/PageRequest",
        'dijit/registry'	
        ], function(cu, ct,domAttr,dom) {
  
  /*
   * Modification History
   * --------------------
   * 22-Nov-2022  AT [SPM-126184]  Support for autorecovery restore modal.
   * 28-Mar-2022 GG  [RTC274773]   Added additional logic on executeOnTabClose. When closing a tab
   * 							   we check if lastOpenedTabButton is the tab we are closing.
   * 17-Jan-2019  CM  [241236]     Update iframeUpdateTitle() if pageTitle is undefined.
   * 20-Sep-2016  AZ  [171778]     Initialize smart panel subscribers.
   * 04-Aug-2016  CD  [143055]     Set document title on first load of a title-less content panel.
   * 13-Aug-2015  AB  [CR00465541] Avoid IE memory leaks (Adding debug statement.)
   * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
   * 13-Oct-2014  LL  [CR00446361] Make sure smart panel events are only
   *      published for tabs that do have smart panel. Also correctly unregister
   *      events.
   * 11-Mar-2013  SB  [CR00372052] Updated iframeOnloadHandler() to add
   *                              Content Panel Title.
   * 22-Oct-2012  SK  [CR00346419] Now properly releasing smart panel, so 
   *            avoiding the related memory leak.
   * 11-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 17-Sep-2012  MV  [CR00344216] Label content panel iframe as loaded when
   *            finished loading. 
   * 11-Sep-2012  MV  [CR00339639] Use Dojo function for setting DOM attribute. 
   * 29-Jul-2011  MV  [CR00269970] Notify the new refresh controller of page load.
   * 21-Aug-2011  JK  [TEC-6883]  Added Content Panel Title
   * 31-Jan-2011  MK  [CR00250297] The smart panel now only responds to the 
   *               "expandedList.toggle" event if it has been raised from the 
   *               same tab as the smart panel itself exists on.
   * 05-Jul-2010 BD   [CR00204119] Add publisher to relay In Page Navigation events
   * 18-Sep-2010  PK  [CR00204622] Ensure when a page loads for the first time
   *                    in an expandable list, only the "expandedList.toggle"
   *                    event is processed.
   * 28-Jun-2010  SD  [CR00204622] Added event handling for Smart Panel.
   * 04-Jun-2010  MV  [CR00202412] Refactor to use the new standard onLoad
   *                    event manager.
   * 18-Nov-2009  MV  [CR00172452] Pass tab widget ID to the event handler.
   * 06-Aug-2009  MLB [CR00163869] Passing the page ID with the published topic.
   * 15-Jun-2009  MV  [CR00160095] Initial version.
   */

  /**
   * Contains functions for the content panel.
   */
  curam.define.singleton("curam.contentPanel", {

    /**
    * Holds smart panel listener tokens for all tabs in the application.
    * Property names in this object correspond to tabWidgetIds of application
    * tabs and the property value is the smart panel listener token
    * that can be used to unregister the listener later.
    */
   smartPanelLoadedTokens: {},

      initSmartPanelExpListPageLoadListener: function() {
        if (!cu.getTopmostWindow().dojo.body()._spListenerInitialized) {
          // TODO: can this class be re-factored so that we don't need both
          // "expandedList.pageLoaded" and "expandedList.pageLoaded.final" events?
          cu.getTopmostWindow().dojo.subscribe("expandedList.pageLoaded",
              curam.contentPanel.smartPanelExpListPageLoadListener);
          cu.getTopmostWindow().dojo.body()._spListenerInitialized
              = "true";
        }
      },

      /**
       * Listener for the "expandedList.pageLoaded" event. This is initialized in
       * initSmartPanelExpListPageLoadListener above.
       */
      smartPanelExpListPageLoadListener: function(data) {
        if (ct.getSmartPanelIframe()) {
          curam.contentPanel.checkSmartPanelLoaded(data,
              "ExpandedList.TabContentArea.Reloaded",
              curam.tab.getSelectedTabWidgetId());
        }
      },

      /**
       * This method is invoked from "listRowFrameLoaded()" in "util.js" when a
       * page is loaded in an expandable panel on subsequent page loads after
       * the first page load. The "listRowFrameLoaded()" method in "util.js"
       * handles the distinction between first and subsequent page loads.
       */
      publishSmartPanelExpListPageLoad: function(iframe) {
        if (ct.getSmartPanelIframe()) {
          cu.getTopmostWindow().dojo.publish("expandedList.pageLoaded",
              [iframe.contentWindow.location.href]);
        }
      },

      setupOnLoad: function(iframeId, tabWidgetId) {
        curam.debug.log("curam.contenPanel: setupOnLoad: " + iframeId + " "
                        + tabWidgetId);

        // setup expandable lists page load listener
        curam.contentPanel.initSmartPanelExpListPageLoadListener();

        var handler = curam.contentPanel.iframeOnloadHandler;
        // subscribe for onLoad events on the iframe
        curam.util.onLoad.addSubscriber(iframeId, handler);

        // subscribe for events and republish into Smart Panel
        if (curam.tab.getSmartPanelIframe(dijit.byId(tabWidgetId))) {
          curam.debug.log("tab has smart panel, setting up event listener");
          curam.contentPanel.targetSmartPanel(iframeId, tabWidgetId);
        }

        // ensure removing the subscribers on tab close
        ct.executeOnTabClose(function() {
          curam.util.onLoad.removeSubscriber(iframeId, handler);
          curam.contentPanel._unregisterSmartPanelListener(tabWidgetId);
          //ensure if closing the last opened tab we clear lastOpenedTabButton
          if (curam.util.getTopmostWindow().curam.util.lastOpenedTabButton && 
	          curam.util.getTopmostWindow().curam.util.lastOpenedTabButton.domNode.id.includes(tabWidgetId,0))
	          {
	            curam.util.getTopmostWindow().curam.util.lastOpenedTabButton = null;
	          }

        }, tabWidgetId);
      },

      iframeUpdateTitle: function(tabWidgetId, iframeId, title) { 

        var iframeTitleFallBackPrefix = CONTENT_PANEL_TITLE + " - ";
        
        var iframe = dom.byId(iframeId);
        if (iframe == null) {
          iframe = dojo.query("iframe." + iframeId)[0];
        }

        ct.executeOnTabClose(function() {
          // make sure we release iframe content - avoid memory leaks
          var src = domAttr.get(iframe, "src");
          domAttr.set(iframe, "src", "");
          curam.debug.log("curam.contentPanel: Released iframe content for " + src);
        }, tabWidgetId);

        var pageTitle;
        if (title) {
          
          // This block is for the edge case of the first load of a content panel 
          // which has no PAGE_TITLE. It sets the title on the Content Panel for
          // the accessibility region list feature.
          
          // We could also set pageTitle to a default if title is a blank string.
          // However that should no longer be possible, assuming that the tab title 
          // cannot be blank. Therefore omitting it.
          
          // content panel iframes from other tabs may be hidden on the page
          // find the one with the unfinished title
          var iframeList =  dojo.query("iframe.contentPanelFrame");
          var iframeContentPanel;
          for (var i=0; i<iframeList.length; i++) {
            if (iframeList[i].title == iframeTitleFallBackPrefix) {
              iframeContentPanel = iframeList[i];
              break;
            }
          }
          if (iframeContentPanel) {
            pageTitle = title;
            iframeContentPanel.contentWindow.document.title = pageTitle;
          }
          
        } else {
          pageTitle = iframe.contentWindow.document.title;
        }
        
        if(pageTitle == "" || pageTitle == "undefined") {
          var iframeTitle = curam.util.iframeTitleFallBack(); 
          iframe.contentWindow.document.title = iframeTitle;
        }
        domAttr.set(iframe, "title", iframeTitleFallBackPrefix + curam.util.iframeTitleFallBack());
        domAttr.set(iframe, "data-done-loading", true);
      },

      iframeOnloadHandler: function(iframeId, context) {    

                
        // summary:
        //  Handles the onload event of the content panel iframe.
        
        dojo.subscribe('tab.title.name.finished', function(data){  

          var sourceTabSub = ct.getContainerTab(
              dojo.query("iframe." + data.frameid)[0]);
          var tabWidgetIdSub = ct.getTabWidgetId(sourceTabSub);
          curam.contentPanel.iframeUpdateTitle(tabWidgetIdSub, data.frameid, data.title);          
        });        

        var sourceTab = ct.getContainerTab(
            dojo.query("iframe." + iframeId)[0]);
        var tabWidgetId = ct.getTabWidgetId(sourceTab);
        
        curam.contentPanel.iframeUpdateTitle(tabWidgetId, iframeId);
        
        // Republish the IPN Data on a more targeted channel so only the correct
        // UIMController processes it.
        //var topic = curam.UIMController.prototype.EVENT.TOPIC_PREFIX + iframeId;
        //dojo.publish(topic, [context.inPageNavItems]);

        cu.Refresh.getController(tabWidgetId).pageLoaded(context.pageID,
            cu.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN);
        dojo.publish("/curam/main-content/page/loaded", [context.pageID, tabWidgetId, sourceTab]);
      },

      spOnLoadHandler: function(iframeId, context) {

        // find content panel iFrame
        var contentPanel = dojo.query("." + iframeId)[0];

        curam.contentPanel.checkSmartPanelLoaded(
            contentPanel.src, "TabContentArea.Reloaded",
            curam.tab.getSelectedTabWidgetId());
      },

      checkSmartPanelLoaded: function(url, eventType, tabWidgetId) {
        // summary;
        // check if the Smart Panel is loaded, if not keep querying until it is
        
        if (!tabWidgetId) {
          throw new Error("Required argument 'tabWidgetId' was not specified.");
        }

        var smartPanel = ct.getSmartPanelIframe();

        var spLoaded = domAttr.get(smartPanel, "iframeLoaded");

        if(spLoaded == "true") {
          curam.contentPanel.smartPanelPublisher(smartPanel, url, eventType,
              tabWidgetId);
        } else {
          var token = dojo.subscribe("smartPanel.loaded", function(iframe) {
            if(iframe == smartPanel) {
              curam.contentPanel._unregisterSmartPanelListener(tabWidgetId);
              curam.contentPanel.smartPanelPublisher(smartPanel, url, eventType,
                  tabWidgetId);
            }
          });
          curam.contentPanel._storeSmartPanelToken(token, tabWidgetId);
        }
      },

      /**
       * Stores the smart panel listener token for later use.
       * 
       * @param token The token to store.
       * @param tabWidgetId ID of the tab the token relates to.
       */
      _storeSmartPanelToken: function(token, tabWidgetId) {
        var oldToken = curam.contentPanel.smartPanelLoadedTokens[tabWidgetId];
        if (oldToken) {
          dojo.unsubscribe(oldToken);
        }
        curam.contentPanel.smartPanelLoadedTokens[tabWidgetId] = token;
      },

      /**
       * Unregisters the smart panel listener for the specified tab.
       * 
       * @param tabWidgetId ID of the tab to remove the listener for.
       */
      _unregisterSmartPanelListener: function(tabWidgetId) {
        dojo.unsubscribe(
            curam.contentPanel.smartPanelLoadedTokens[tabWidgetId]);
        curam.contentPanel.smartPanelLoadedTokens[tabWidgetId] = null;
      },

      smartPanelPublisher: function(smartPanel, url, eventType, tabWidgetId) {

        // parse the url
        var uimPageRequest = new curam.ui.PageRequest(url);

        curam.debug.log(
            "Publishing event to smart panel in tab %s: eventType=%s;"
                + " pageID=%s; parameters=%s", tabWidgetId, eventType,
                uimPageRequest.pageID, dojo.toJson(uimPageRequest.parameters));
        
        // Target publish into smart panel iFrame
        smartPanel.contentWindow.dojo.publish(
          "contentPane.targetSmartPanel",
          [{'eventType': eventType,
            'pageId': uimPageRequest.pageID,
            'parameters': uimPageRequest.parameters}]);
      },

      targetSmartPanel: function(iframeId, tabWidgetId) {
        curam.debug.log("curam.contentPanel:targetSmartPanel(): "
            + iframeId + " " + tabWidgetId);
        // iframeId input parameter is that of content panel
        var smartPanelIFrame = ct.getSmartPanelIframe();

        var smartPanelTabWidgetId = tabWidgetId;
        // Ensure Smart Panel exists
        if(smartPanelIFrame) {
          var spId = curam.util.onLoad.defaultGetIdFunction(smartPanelIFrame);
          // 1. listen for onClick from expandable list
          var spOnClickSubscribe =
            dojo.subscribe("expandedList.toggle", function(iframeId, context, tabWidgetId) {
                  
                  // only respond to expandable lists that exist within the same tab
                  // as the smart panel.
                  if (smartPanelTabWidgetId === tabWidgetId){               
                curam.contentPanel.checkSmartPanelLoaded(context.url, 
                        context.eventType, tabWidgetId);
              }
            }
          );

          // 3. set up handler and subscribe for onLoad events
          var smartPanelOnLoad = curam.contentPanel.spOnLoadHandler;
          curam.util.onLoad.addSubscriber(iframeId, smartPanelOnLoad);

          // 4. ensure removing the subscribers on tab close
          ct.executeOnTabClose(function() {
            dojo.unsubscribe(spOnClickSubscribe);
            curam.util.onLoad.removeSubscriber(iframeId, smartPanelOnLoad);
            curam.util.onLoad.removeSubscriber(spId, curam.smartPanel._handleSmartPanelLoad);
          }, tabWidgetId);
        }
      }
  });
  
  return curam.contentPanel;
});

},
'dijit/MenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/sniff", // has("ie")
	"dojo/_base/lang", // lang.hitch
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, kernel, has, lang,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

	// module:
	//		dijit/MenuItem

	var MenuItem = declare("dijit.MenuItem" + (has("dojo-bidi") ? "_NoBidi" : ""),
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin], {
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text as HTML
		label: "",
		_setLabelAttr: function(val){
			this._set("label", val);
			var shortcutKey = "";
			var text;
			var ndx = val.search(/{\S}/);
			if(ndx >= 0){
				shortcutKey = val.charAt(ndx + 1);
				var prefix = val.substr(0, ndx);
				var suffix = val.substr(ndx + 3);
				text = prefix + shortcutKey + suffix;
				val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
			}else{
				text = val;
			}
			this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
			this.containerNode.innerHTML = val;
			this._set('shortcutKey', shortcutKey);
		},

		/*=====
		// shortcutKey: [readonly] String
		//		Single character (underlined when the parent Menu is focused) used to navigate directly to this widget,
		//		also known as [a mnemonic](http://en.wikipedia.org/wiki/Mnemonics_(keyboard%29).
		//		This is denoted in the label by surrounding the single character with {}.
		//		For example, if label="{F}ile", then shortcutKey="F".
		shortcutKey: "",
		=====*/

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination, a control, alt, etc. modified keystroke meant to
		//		execute the menu item regardless of where the focus is on the page.
		//
		//		Note that although Menu can display accelerator keys, there is no infrastructure to actually catch and
		//		execute those accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this._set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id + "_text";
			domAttr.set(this.containerNode, "id", label); // only needed for backward compat
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel"); // only needed for backward compat
			}
			dom.setSelectable(this.domNode, false);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},

		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			if(this.accelKeyNode){
				this.accelKeyNode.style.display = value ? "" : "none";
				this.accelKeyNode.innerHTML = value;
				//have to use colSpan to make it work in IE
				domAttr.set(this.containerNode, 'colSpan', value ? "1" : "2");
			}
			this._set("accelKey", value);
		}
	});

	if(has("dojo-bidi")){
		MenuItem = declare("dijit.MenuItem", MenuItem, {
			_setLabelAttr: function(val){
				this.inherited(arguments);
				if(this.textDir === "auto"){
					this.applyTextDir(this.textDirNode);
				}
			}
		});
	}

	return MenuItem;
});

},
'dijit/_AttachMixin':function(){
define([
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/connect",	// remove for 2.0
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.getObject
	"dojo/mouse",
	"dojo/on",
	"dojo/touch",
	"./_WidgetBase"
], function(require, array, connect, declare, lang, mouse, on, touch, _WidgetBase){

	// module:
	//		dijit/_AttachMixin

	// Map from string name like "mouseenter" to synthetic event like mouse.enter
	var synthEvents = lang.delegate(touch, {
		"mouseenter": mouse.enter,
		"mouseleave": mouse.leave,
		"keypress": connect._keypress	// remove for 2.0
	});

	// To be lightweight, _AttachMixin doesn't require() dijit/a11yclick.
	// If the subclass has a template using "ondijitclick", it must load dijit/a11yclick itself.
	// In that case, the a11yclick variable below will get set to point to that synthetic event.
	var a11yclick;

	var _AttachMixin = declare("dijit._AttachMixin", null, {
		// summary:
		//		Mixin for widgets to attach to dom nodes and setup events via
		//		convenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.
		//
		//		Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the
		//		server.
		//
		//		Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip
		//		scanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it
		//		doesn't.

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
		_attachPoints: [],

		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
		_attachEvents: [],

		// attachScope: [public] Object
		//		Object to which attach points and events will be scoped.  Defaults
		//		to 'this'.
		attachScope: undefined,

		// searchContainerNode: [protected] Boolean
		//		Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.
		//		Should generally be left false (the default value) both for performance and to avoid failures when
		//		this.containerNode holds other _AttachMixin instances with their own attach points and events.
 		searchContainerNode: false,
 =====*/

		constructor: function(/*===== params, srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this._attachPoints = [];
			this._attachEvents = [];
		},


		buildRendering: function(){
			// summary:
			//		Attach to DOM nodes marked with special attributes.
			// tags:
			//		protected

			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(this.domNode);

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin
		},

		_beforeFillContent: function(){
		},

		_attachTemplateNodes: function(rootNode){
			// summary:
			//		Iterate through the dom nodes and attach functions and nodes accordingly.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//
			//		- dojoAttachPoint/data-dojo-attach-point
			//		- dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode
			//		The node to search for properties. All descendants will be searched.
			// tags:
			//		private

			// DFS to process all nodes except those inside of this.containerNode
			var node = rootNode;
			while(true){
				if(node.nodeType == 1 && (this._processTemplateNode(node, function(n,p){ return n.getAttribute(p); },
						this._attach) || this.searchContainerNode) && node.firstChild){
					node = node.firstChild;
				}else{
					if(node == rootNode){ return; }
					while(!node.nextSibling){
						node = node.parentNode;
						if(node == rootNode){ return; }
					}
					node = node.nextSibling;
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// summary:
			//		Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.
			//		Returns true if caller should process baseNode's children too.

			var ret = true;

			// Process data-dojo-attach-point
			var _attachScope = this.attachScope || this,
				attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
			if(attachPoint){
				var point, points = attachPoint.split(/\s*,\s*/);
				while((point = points.shift())){
					if(lang.isArray(_attachScope[point])){
						_attachScope[point].push(baseNode);
					}else{
						_attachScope[point] = baseNode;
					}
					ret = (point != "containerNode");
					this._attachPoints.push(point);
				}
			}

			// Process data-dojo-attach-event
			var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent; ..."
				var event, events = attachEvent.split(/\s*,\s*/);
				var trim = lang.trim;
				while((event = events.shift())){
					if(event){
						var thisFunc = null;
						if(event.indexOf(":") != -1){
							// oh, if only JS had tuple assignment
							var funcNameArr = event.split(":");
							event = trim(funcNameArr[0]);
							thisFunc = trim(funcNameArr[1]);
						}else{
							event = trim(event);
						}
						if(!thisFunc){
							thisFunc = event;
						}

						this._attachEvents.push(attachFunc(baseNode, event, lang.hitch(_attachScope, thisFunc)));
					}
				}
			}

			return ret;
		},

		_attach: function(node, type, func){
			// summary:
			//		Roughly corresponding to dojo/on, this is the default function for processing a
			//		data-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.
			// node: DOMNode
			//		The node to setup a listener on.
			// type: String
			//		Event name like "click".
			// getAttrFunc: Function
			//		Function to get the specified property for a given DomNode/Widget.
			// attachFunc: Function?
			//		Attaches an event handler from the specified node/widget to specified function.

			// Map special type names like "mouseenter" to synthetic events.
			// Subclasses are responsible to require() dijit/a11yclick if they want to use it.
			type = type.replace(/^on/, "").toLowerCase();
			if(type == "dijitclick"){
				type = a11yclick || (a11yclick = require("./a11yclick"));
			}else{
				type = synthEvents[type] || type;
			}

			return on(node, type, func);
		},

		_detachTemplateNodes: function() {
			// summary:
			//		Detach and clean up the attachments made in _attachtempalteNodes.

			// Delete all attach points to prevent IE6 memory leaks.
			var _attachScope = this.attachScope || this;
			array.forEach(this._attachPoints, function(point){
				delete _attachScope[point];
			});
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, function(handle){ handle.remove(); });
			this._attachEvents = [];
		},

		destroyRendering: function(){
			this._detachTemplateNodes();
			this.inherited(arguments);
		}
	});

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.).
	// Remove for 2.0.   Also, hide from API doc parser.
	lang.extend(_WidgetBase, /*===== {} || =====*/ {
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});
	
	return _AttachMixin;
});

},
'curam/ui/ClientDataAccessor':function(){
/*
 * Copyright 2010-2020 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 20-Apr-2020  IK  [RTC- 259485]Added CSRF token to POST request of the set method.
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 27-Feb-2014  MV  [CR00419961] Move to common AJAX request API.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 09-Aug-2012  MV  [CR00337714] Convert to AMD.
 * 31-Jul-2012  MV  [CR00336202] Fix calls to log() function.
 * 08-Feb-2011  DG  [TEC-6115] Explicitly set content encoding to UTF-8.
 * 29-Jul-2010  PK  [CR00211736] Moved to "curam.ui" package.
 * 02-Jun-2010  PK  [CR00203531] Moved UIMPageRequest class to
 *                    curam\ui\PageRequest.js.
 * 13-Oct-2009  SC  [CR00172239] Moved ClientDataAccessor to this file.
 */

define(["dojo/_base/declare",
        "curam/inspection/Layer",
        "curam/util/Request",
        "curam/debug"
        ], function(declare, layer, curamRequest, debug) {

  /**
   * Support for accessing the PathResolver servlet to retrieve and
   * set data on the web-tier. The PathResolver only supports a limited
   * set of paths.
   */
  return declare("curam.ui.ClientDataAccessor", null, {

    constructor: function() { 
    layer.register("curam/ui/ClientDataAccessor", this);
      
    },
  
    /**
     * Return a single string result by calling the specified path.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    get: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "text",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Return a list of results by calling the specified path.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    getList: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?r=l&p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "json",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Return a raw JSON object.
     *
     * path: The path to invoke on the web-tier.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    getRaw: function(path, successCallback, failCallback, handleCallback) {
      var tabServletURL =
        "servlet/PathResolver" + "?r=j&p=" + path;

      // Set defaults if not defined
      if (failCallback == undefined ) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined ) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8" },
        handleAs: "json",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Set a value in the web-tier by calling the specified path. The
     * successCallback is optional in this case because the set may return
     * nothing of significance.
     *
     * path: The path to invoke on the web-tier.
     * value: The value to set.
     * successCallback: The function to invoke for handling the returned data.
     * failCallback: The function to invoke on failure of resolving the path.
     * handleCallback: The function that will be invoked in all circumstances.
     */
    set: function(path, value, successCallback, failCallback, handleCallback) {
      // TODO: Would it be safer to submit the value as the "content" of the
      // xhrPost below? That would avoid problems with URI length limits. See
      // "codetable-hierarchy.js" and "ApplicationController.java" for an example.
      var tabServletURL =
        "servlet/PathResolver" + "?r=x&p=" + path + "&v="
          + encodeURIComponent(value);
      
      var topWindow = curam.util.getTopmostWindow();
      

      // Set defaults if not defined
      if (failCallback == undefined || failCallback == null) {
        failCallback = dojo.hitch(this, this.handleClientDataAccessorError);
      }

      if (handleCallback == undefined || handleCallback == null) {
        handleCallback = dojo.hitch(this, this.handleClientDataAccessorCallback);
      }

      if (successCallback == undefined || successCallback == null) {
        successCallback = dojo.hitch(this, this.handleClientDataAccessorSuccess);
      }

      curamRequest.post({
        url: tabServletURL,
        headers: { "Content-Encoding": "UTF-8","csrfToken":topWindow.csrfToken },
        handleAs: "text",
        preventCache: true,
        load: successCallback,
        error:  failCallback,
        handle: handleCallback
      });
    },

    /**
     * Generic handler for errors when invoking the ClientDataAccessor path
     * resolver.
     */
    handleClientDataAccessorError: function(error, ioargs) {
      var errorPart1
        = debug.getProperty("curam.ui.ClientDataAccessor.err.1")
          + "PathResolverServlet : ";
      var errorPart2 = debug.getProperty("curam.ui.ClientDataAccessor.err.2");
      debug.log(errorPart1 + error + errorPart2 + ioargs);
    },

    /**
     * Generic handler for successful invocation when invoking the ClientDataAccessor
     * path resolver.
     */
    handleClientDataAccessorSuccess: function(response, ioargs) {
      curam.debug
        .log("curam.ui.ClientDataAccessor.handleClientDataAccessorSuccess : "
          + response);
    },

    /**
     * Generic handler for errors when invoking the ClientDataAccessor path
     * resolver.
     */
    handleClientDataAccessorCallback: function(response, ioargs) {
      debug
        .log("curam.ui.ClientDataAccessor.handleClientDataAccessorCallback :"
          + " " + debug.getProperty("curam.ui.ClientDataAccessor.callback"));
    }
  });
});

},
'curam/util/onLoad':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2016. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 15-Jun-2021 SK  Removing old IE related functionality to free up memory.
   * 08-Jun-2016 SO  [156831] Removing the ie-progress-indicator-helper iframe
   * 06-May-2014 AB   [Cr00430639]Adding title to Iframe-RPT project
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
   * 14-Dec-2010  MV  [CR00238518] Ensure the hidden iframe is not picked up by
   *    WordIntegration control.
   * 06-Dec-2010  MV  [CR00233442] Avoid never ending progress bar in IE.
   * 19-Nov-2010  MV  [CR00231655] Subscribe/connect to events with
   *    a function that will automatically unsubscribe/disconnect on page unload.
   * 30-Jun-2010 MV [CR00161271] Update documentation.
   * 11-Jun-2010 MV [CR00202971] Fixed function for removing subscribers.
   * 02-Jun-2010 MV [CR00202412] Initial version.
   */

define(['curam/util',
        'curam/define',
        'curam/debug',
        'dojo/dom-attr'], function(util, define, debug, attr) {

  /**
   * Creating Resource Bundle Object to access localized resources.
   */
  //dojo.requireLocalization("curam.application", "Debug");
  //var bundle = new curam.util.ResourceBundle("Debug");
  
  define.singleton("curam.util.onLoad", {
    EVENT: "/curam/frame/load",

    // Used in the context of the iframe.
    publishers: [],

    /* Used in the context of the parent window and contains subscribers
     * for all the iframes that exist in this window context.
     */
    subscribers: [],

    defaultGetIdFunction: function(iframeNode) {
      // summary:
      // This is the default function for getting a unique ID of an iframe.
      // If the iframe has a CSS class that starts with "iframe-" then this class
      // is returned as the unique ID of the iframe.
      var classes = attr.get(iframeNode, "class").split(" ");
      return dojo.filter(classes, function(className) {
        return className.indexOf("iframe-") == 0;
      })[0];
    },

    addPublisher: function(callback) {
      // summary:
      //   Public function, is called in the context of the iframe window.
      curam.util.onLoad.publishers.push(callback);
    },

    addSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //   This is called in the context of the parent window.
      //   Multiple subscribers per iframe can be registered, provided each
      //   has a different handler function.
      // parameter: getId
      //   optional, if not specified the default getId function will be used

      curam.util.onLoad.subscribers.push({
        "getId": getId ? getId : curam.util.onLoad.defaultGetIdFunction,
        "callback": callback,
        "iframeId": iframeId
      });
    },

    removeSubscriber: function(iframeId, callback, /*optional*/getId) {
      // summary:
      //  Must be called in the context of the parent window.

      curam.util.onLoad.subscribers =
        dojo.filter(curam.util.onLoad.subscribers, function(subscriberData) {
          return !(subscriberData.iframeId == iframeId
              && subscriberData.callback == callback);
        });
    },

    execute: function() {
      // summary:
      //   Public function, is called in the context of the iframe window.

      if(window.parent == window) {
        curam.debug.log("curam.util.onLoad.execute(): " 
          + debug.getProperty("curam.util.onLoad.exit"));
        return;
      }

      var context = {};

      dojo.forEach(curam.util.onLoad.publishers, function(callback) {
        // Allow each of the publishers to add to the context object
        callback(context);
      });

      // Free up references to functions
      curam.util.onLoad.publishers = [];
      
      curam.util.getTopmostWindow().dojo.publish('/curam/progress/unload');
      window.parent.dojo.publish(curam.util.onLoad.EVENT, [window.frameElement, context]);
    }
  });

  /* Subscribe to events in the context this file is being loaded in.
   * This is meant for parent window contexts.
   */
  curam.util.subscribe(curam.util.onLoad.EVENT, function(iframeNode, context) {
    dojo.forEach(curam.util.onLoad.subscribers, function(subscriberData) {
      var currentId = subscriberData.getId(iframeNode);
      if (subscriberData.iframeId == currentId) {
        subscriberData.callback(currentId, context);
      }
    });
  });
  
  return curam.util.onLoad;
});

},
'curam/widget/MenuItem':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2019. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * @name curam.widget.MenuItem
 * @namespace Customized dijit.widget.MenuItem class in order to add extra
 * functionality to close all tabs.
 */
define(["dijit/MenuItem",
        "dojo/_base/declare",
        "dojo/text!dijit/templates/MenuItem.html"
        ], function(MenuItem, declare, template) {

/*
 * Modification History
 * --------------------
 * 08-Aug-2019  JD   [RTC249365]  Added _setLabelAttr to strip out HTML tags
 * from the label and aria-label of a menu item.
 * 27-Oct-2012  BOS  [CR00211743] Initial Version.
 */

var CuramMenuItem = declare("curam.widget.MenuItem", MenuItem,
  /**
   * @lends curam.widget.MenuItem
   */
{
  templateString: template,

  /**
   * The value of the onClick event that will be used when the user executes an
   * on click event.
   * @private
   */
  onClickValue: "",

  /**
   * New function that may be called by the onClick event, in order to close all
   * tabs.
   */
  _onClickAll:function(evt){
    var tabContainer = curam.tab.getTabContainer();
    var children = tabContainer.getChildren();
    for (var i = 0; i < children.length; i++){
      // Check if a child is closable or not, 
      // only the closable child can be closed down.
      if (children[i].closable) {
        tabContainer.closeChild(children[i]);
      }
    }
  },
  
  /**
   * Overriding dojo function to strip out HTML tags that can be contained in the
   * aria-label. Added due to accessibility defect where a blank image is added to
   * disabled menu items, and the _setLabelAttr function is adding the HTML for the
   * blank image to the aria-label.
   */
  _setLabelAttr: function(val){
	// Regex to strip out HTML tags from label.  
	// Did not directly strip them from val as containerNode's
	// innerHTML is set to the value of val, so it may be legitimate
	// to have HTML here.
	var removeHTMLTags = /<[a-zA-Z\/][^>]*>/g;
	var valText = val.replace(removeHTMLTags,'');
	this._set("label", valText);
	var shortcutKey = "";
	var text;
	var ndx = val.search(/{\S}/);
	if(ndx >= 0){
		shortcutKey = val.charAt(ndx + 1);
		var prefix = val.substr(0, ndx);
		var suffix = val.substr(ndx + 3);
		text = prefix + shortcutKey + suffix;
		val = prefix + '<span class="dijitMenuItemShortcutKey">' + shortcutKey + '</span>' + suffix;
	}else{
		text = val;
	}
	// Repeating regex here to strip out HTML tags from aria-label.
	text = text.replace(removeHTMLTags,'');
	this.domNode.setAttribute("aria-label", text + " " + this.accelKey);
	this.containerNode.innerHTML = val;
	this._set('shortcutKey', shortcutKey);
  }
});

return CuramMenuItem;
});


},
'curam/cdsl/Struct':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 23-Sep-2014  MV  [CR00445374] Remove unneeded inherited call in constructor.
 */

define(["dojo/_base/declare",
        "dojo/_base/lang",
        "./_base/_StructBase"
        ], function(
            declare, lang, _StructBase) {

  /**
   * @name curam.cdsl.Struct
   * @namespace Represents a Curam struct. The instances of this class
   *  are expected as inputs and will be produced as outputs of the CDSL API.
   *  The properties you specify in constructor are the ones that will be used
   *  for mapping onto your modeled Curam structs. You are not allowed to add
   *  more properties dynamically after the Struct object instance has been
   *  created.
   */
  var Struct = declare(_StructBase,
  /**
   * @lends curam.cdsl.Struct.prototype
   */
  {
    /**
     * Creates an instance of Struct.
     * 
     * @param {Object} data Object containing values to be mapped to the struct
     *  properties. The values must adhere to the data types supported
     *  by CDSL API and they must map correctly to the modelled server side
     *  structs in the context where you will use this Struct instance.
     */
    constructor: function(data) {
      // fill this object with data passed into the constructor 
      lang.mixin(this, this._data);
    }
  });
  
  return Struct;
});

},
'dijit/DropDownMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_MenuBase"
], function(declare, keys, template, _MenuBase){

	// module:
	//		dijit/DropDownMenu

	return declare("dijit.DropDownMenu", _MenuBase, {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		// Arrow key navigation
		_onUpArrow: function(){
			this.focusPrev();
		},
		_onDownArrow: function(){
			this.focusNext();
		},
		_onRightArrow: function(/*Event*/ evt){
			this._moveToPopup(evt);
			evt.stopPropagation();
			evt.preventDefault();
		},
		_onLeftArrow: function(/*Event*/ evt){
			if(this.parentMenu){
				if(this.parentMenu._isMenuBar){
					this.parentMenu.focusPrev();
				}else{
					this.onCancel(false);
				}
			}else{
				evt.stopPropagation();
				evt.preventDefault();
			}
		}
	});
});

},
'cm/_base/_dom':function(){
define(["dojo/dom", 
        "dojo/dom-style",
        "dojo/dom-class"], function(dom, domStyle, domClass) {
  
/*
  This file includes generic functions for use with the DOM.
*/

/*
 * Modification History
 * --------------------
 * 24-Mar-2010 BD  [CR00191575] Added exit function to getParentByType() when 
 *                              the document root is reached. Handles the 
 *                              iframe scenario.
 */

  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  dojo.mixin(cm, {
    nextSibling: function(node, tagName) {
      //  summary:
            //            Returns the next sibling element matching tagName
      return cm._findSibling(node, tagName, true);
    },
    
    prevSibling: function(node, tagName) {
      //  summary:
            //            Returns the previous sibling element matching tagName
      return cm._findSibling(node, tagName, false);
    },
    
    getInput: function(name, multiple) {
      if(!dojo.isString(name)){
        return name;
      }
      var inputs = dojo.query("input[name='" + name + "'],select[name='" + name + "']");
      return multiple ? (inputs.length > 0 ? inputs : null) 
                                                                                  : (inputs.length > 0 ? inputs[0]:null);
    },
    
    getParentByClass: function(node, classStr) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      while (node) {
        if(domClass.contains(node, classStr)){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
    
    getParentByType: function(node, type) {
      // summary:
      //   Returns the first parent of the node that has the require class
      node = node.parentNode;
      type = type.toLowerCase();
      var docRoot = "html";
      while (node) {
        // Give up when you reach the root of the doc,
        // applies to iframes
        if(node.tagName.toLowerCase() == docRoot){
          break;
        }
        if(node.tagName.toLowerCase() == type){
          return node;
        }
        node = node.parentNode;
      }
      return null;
    },
  
    replaceClass: function(node, newCls, oldCls) {
      // summary:
      //   Replaces a single css class with another.
      //   node:   The node to operate on.
      //   newCls: The class to be added
      //   oldCls: The class to be removed
      domClass.remove(node, oldCls);
      domClass.add(node, newCls);
    },
    
    setClass: function(/* HTMLElement */node, /* string */classStr){
                  //      summary
                  //      Clobbers the existing list of classes for the node, replacing it with
                  //      the list given in the 2nd argument. Returns true or false
                  //      indicating success or failure.
                  node = dom.byId(node);
                  var cs = new String(classStr);
                  try{
                          if(typeof node.className == "string"){
                                  node.className = cs;
                          }else if(node.setAttribute){
                                  node.setAttribute("class", classStr);
                                  node.className = cs;
                          }else{
                                  return false;
                          }
                  }catch(e){
                          dojo.debug("dojo.html.setClass() failed", e);
                  }
                  return true;
          },
  
    _findSibling: function(node, tagName, forward) {
      
      if(!node) { return null; }
      if(tagName) { tagName = tagName.toLowerCase(); }
      var param = forward ? "nextSibling":"previousSibling";
            do {
                    node = node[param];
            } while(node && node.nodeType != 1);
  
            if(node && tagName && tagName != node.tagName.toLowerCase()) {
                    return cm[forward ? "nextSibling":"prevSibling"](node, tagName);
            }
            return node;  //      Element
    },
    
    getViewport: function(){
                  // summary: returns a viewport size (visible part of the window)
          
                  // FIXME: need more docs!!
                  var d = dojo.doc, dd = d.documentElement, w = window, b = dojo.body();
                  if(dojo.isMozilla){
                          return {w: dd.clientWidth, h: w.innerHeight};   // Object
                  }else if(!dojo.isOpera && w.innerWidth){
                          return {w: w.innerWidth, h: w.innerHeight};             // Object
                  }else if (!dojo.isOpera && dd && dd.clientWidth){
                          return {w: dd.clientWidth, h: dd.clientHeight}; // Object
                  }else if (b.clientWidth){
                          return {w: b.clientWidth, h: b.clientHeight};   // Object
                  }
                  return null;    // Object
          },
          
          toggleDisplay: function(node) {
            domStyle.set(node, "display", domStyle.get(node, "display") == "none" ? "": "none");
          },
          
          
          
          endsWith: function(/*string*/str, /*string*/end, /*boolean*/ignoreCase){
                  // summary:
                  //      Returns true if 'str' ends with 'end'
          
                  if(ignoreCase){
                          str = str.toLowerCase();
                          end = end.toLowerCase();
                  }
                  if((str.length - end.length) < 0){
                          return false; // boolean
                  }
                  return str.lastIndexOf(end) == str.length - end.length; // boolean
          },
          
          hide: function(n){
                  domStyle.set(n, "display", "none");
          },
          
          show: function(n){
                  domStyle.set(n, "display", "");
          }
  });
  
  return cm;
});

},
'dojo/store/Memory':function(){
define(["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine" /*=====, "./api/Store" =====*/],
function(declare, QueryResults, SimpleQueryEngine /*=====, Store =====*/){

// module:
//		dojo/store/Memory

// No base class, but for purposes of documentation, the base class is dojo/store/api/Store
var base = null;
/*===== base = Store; =====*/

return declare("dojo.store.Memory", base, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo/store/api/Store.
	constructor: function(options){
		// summary:
		//		Creates a memory object store.
		// options: dojo/store/Memory
		//		This provides any configuration information that will be mixed into the store.
		//		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		// summary:
		//		Retrieves an object by its identity
		// id: Number
		//		The identity to use to lookup the object
		// returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// summary:
		//		Returns an object's identity
		// object: Object
		//		The object to get the identity from
		// returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// summary:
		//		Stores an object
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = object[idProperty] = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// summary:
		//		Creates an object, throws an error if the object already exists
		// object: Object
		//		The object to store.
		// options: dojo/store/api/Store.PutDirectives?
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		// returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// summary:
		//		Deletes an object by its identity
		// id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		//		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// summary:
		//		Queries the store for objects.
		// query: Object
		//		The query to use for retrieving objects from the store.
		// options: dojo/store/api/Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		// returns: dojo/store/api/Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// example:
		//		Given the following store:
		//
		// 	|	var store = new Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// summary:
		//		Sets the given data as the source for this store, and indexes it
		// data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier || this.idProperty;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

},
'dojo/hccss':function(){
define([
	"require",			// require, require.toUrl
	"./_base/config", // config.blankGif
	"./dom-class", // domClass.add
	"./dom-style", // domStyle.getComputedStyle
	"./has",
	"./domReady",
	"./_base/window" // win.body
], function(require, config, domClass, domStyle, has, domReady, win){

	// module:
	//		dojo/hccss

	/*=====
	return function(){
		// summary:
		//		Test if computer is in high contrast mode (i.e. if browser is not displaying background images).
		//		Defines `has("highcontrast")` and sets `dj_a11y` CSS class on `<body>` if machine is in high contrast mode.
		//		Returns `has()` method;
	};
	=====*/

	// Has() test for when background images aren't displayed.  Don't call has("highcontrast") before dojo/domReady!.
	has.add("highcontrast", function(){
		// note: if multiple documents, doesn't matter which one we use
		var div = win.doc.createElement("div");
		div.style.cssText = "border: 1px solid; border-color:red green; position: absolute; height: 5px; top: -999px;" +
			"background-image: url(\"" + (config.blankGif || require.toUrl("./resources/blank.gif")) + "\");";
		win.body().appendChild(div);

		var cs = domStyle.getComputedStyle(div),
			bkImg = cs.backgroundImage,
			hc = (cs.borderTopColor == cs.borderRightColor) ||
				(bkImg && (bkImg == "none" || bkImg == "url(invalid-url:)" ));

		if(has("ie") <= 8){
			div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
		}else{
			win.body().removeChild(div);
		}

		return hc;
	});

	domReady(function(){
		if(has("highcontrast")){
			domClass.add(win.body(), "dj_a11y");
		}
	});

	return has;
});

},
'curam/inspection/Layer':function(){
define(['curam/define'], function(def) {
 
  curam.define.singleton("curam.inspection.Layer", {
    /* Called from every module participating in inspecting */
    register: function(moduleName, inst) {
      require(["curam/util"]);
      var tWin = curam.util.getTopmostWindow();
      return tWin.inspectionManager ? tWin.inspectionManager.observe(moduleName, inst): null;
    }
  });
  var ref = curam.inspection.Layer;
  require(["curam/util"]);
  ref.tWin = curam.util.getTopmostWindow();
  var directs = ref.tWin.inspectionManager ? ref.tWin.inspectionManager.getDirects() : [];
  if (directs.length > 0) {
    require(directs);
  }
      
  return ref;
});
},
'dijit/form/_ListBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/on",
	"dojo/window" // winUtils.scrollIntoView
], function(declare, on, winUtils){

	// module:
	//		dijit/form/_ListBase

	return declare("dijit.form._ListBase", null, {
		// summary:
		//		Focus-less menu to handle UI events consistently.
		//		Abstract methods that must be defined externally:
		//
		//		- onSelect: item is active (mousedown but not yet mouseup, or keyboard arrow selected but no Enter)
		//		- onDeselect:  cancels onSelect
		// tags:
		//		private

		// selected: DOMNode
		//		currently selected node
		selected: null,

		_listConnect: function(/*String|Function*/ eventType, /*String*/ callbackFuncName){
			// summary:
			//		Connects 'containerNode' to specified method of this object
			//		and automatically registers for 'disconnect' on widget destroy.
			// description:
			//		Provide widget-specific analog to 'connect'.
			//		The callback function is called with the normal event object,
			//		but also a second parameter is passed that indicates which list item
			//		actually received the event.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect
			//		before the widget is destroyed.
			// tags:
			//		private

			var self = this;
			return self.own(on(self.containerNode,
				on.selector(
					function(eventTarget, selector, target){
						return eventTarget.parentNode == target;
					},
					eventType
				),
				function(evt){
					self[callbackFuncName](evt, this);
				}
			));
		},

		selectFirstNode: function(){
			// summary:
			//		Select the first displayed item in the list.
			var first = this.containerNode.firstChild;
			while(first && first.style.display == "none"){
				first = first.nextSibling;
			}
			this._setSelectedAttr(first, true);
		},

		selectLastNode: function(){
			// summary:
			//		Select the last displayed item in the list
			var last = this.containerNode.lastChild;
			while(last && last.style.display == "none"){
				last = last.previousSibling;
			}
			this._setSelectedAttr(last, true);
		},

		selectNextNode: function(){
			// summary:
			//		Select the item just below the current selection.
			//		If nothing selected, select first node.
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectFirstNode();
			}else{
				var next = selectedNode.nextSibling;
				while(next && next.style.display == "none"){
					next = next.nextSibling;
				}
				if(!next){
					this.selectFirstNode();
				}else{
					this._setSelectedAttr(next, true);
				}
			}
		},

		selectPreviousNode: function(){
			// summary:
			//		Select the item just above the current selection.
			//		If nothing selected, select last node (if
			//		you select Previous and try to keep scrolling up the list).
			var selectedNode = this.selected;
			if(!selectedNode){
				this.selectLastNode();
			}else{
				var prev = selectedNode.previousSibling;
				while(prev && prev.style.display == "none"){
					prev = prev.previousSibling;
				}
				if(!prev){
					this.selectLastNode();
				}else{
					this._setSelectedAttr(prev, true);
				}
			}
		},

		_setSelectedAttr: function(/*DomNode*/ node, /*Boolean*/ scroll){
			// summary:
			//		Does the actual select.
			// node:
			//		The option to select
			// scroll:
			//		If necessary, scroll node into view.  Set to false for mouse/touch to
			//		avoid jumping problems on mobile/RTL, see https://bugs.dojotoolkit.org/ticket/17739.
			if(this.selected != node){
				var selectedNode = this.selected;
				if(selectedNode){
					this.onDeselect(selectedNode);
				}
				if(node){
					if(scroll){
						winUtils.scrollIntoView(node);
					}
					this.onSelect(node);
				}
				this._set("selected", node);
			}else if(node){
				this.onSelect(node);
			}
		}
	});
});

},
'curam/util/DialogObject':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.util.DialogObject
 * @namespace Provides access to a dialog instance.
 * 
 */
define(["dojo/_base/declare",
        "curam/dialog",
        "curam/util"
        ], function(declare) { 
/*
 * Modification History
 * --------------------
 * 30-Oct-2014  MV  [CR00448178] Fix handler deregistration.
 * 05-Feb-2013  MV  [CR00366128] Fix documentation comment.
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 13-Jan-2011  MV  [CR00241667] Added close() function. Updated documentation.
 * 19-Nov-2010  MV  [CR00231655] Added the registerOnDisplayHandler() function.
 * 04-Nov-2010  MV  [CR00229849] Unsubscribe handlers in the right context.
 * 01-Nov-2010  SD  [CR00225331] Initial version.
 */


var DialogObject = declare("curam.util.DialogObject", null, 
/** @lends curam.util.DialogObject.prototype */{  

    /**
     * Holds ID of the dialog in the current context.
     * @private
     */
    _id: null,
    
    /**
     * Constructor takes the input token and uses it to listen for a 
     * specific publish event which will return the dialogId for the
     * opened dialog.
     *
     * @constructor
     * @private
     */
    constructor: function(tokenValue, id) {
      if (!id) {
        var unSubConstructor = 
          window.top.dojo.subscribe(
            "/curam/dialog/uim/opened/" + tokenValue, this, function(dialogID) {
          this._id = dialogID;
          window.top.dojo.unsubscribe(unSubConstructor);
        });
      
      } else {
        this._id = id;
      }
    },
    
    /**
     * Registers a custom function that will be called before the dialog
     * is closed.
     * 
     * @param {Function} handler The handler function for the BeforeClose event.
     */
    registerBeforeCloseHandler: function(handler) {
      var unSubClose = 
        window.top.dojo.subscribe(
          "/curam/dialog/BeforeClose", this, function(dialogID) {
            if (dialogID == this._id) {
              window.top.dojo.unsubscribe(unSubClose);
              handler();
            }
      });
    },
    
    /**
     * Registers a custom handler for the onDispaly event of the dialog. 
     * If the handler is registered after the dialog has been displayed, then
     * it is executed immediately.
     * 
     * @param handler
     *    The handler function for the dialog OnDisplay event. The handler
     *    will be passed the size object in the following form:
     *    {width: 125, height: 236}
     */
    registerOnDisplayHandler: function(handler) {
      if (curam.dialog._displayed == true) {
        handler(curam.dialog._size);
        
      } else {
        var ut = window.top.dojo.subscribe(
            "/curam/dialog/displayed", this, function(dialogID, size) {
              if (dialogID == this._id) {
                window.top.dojo.unsubscribe(ut);
                handler(size);
              }
            });
      }
    },
    
    /**
     * Closes the dialog, optionally refreshing or redirecting the parent window.
     * 
     * @param {Boolean} [refreshParent=false] Should the parent be refreshed
     *              when this dialog closes?
     * @param {String} [newPageIdOrFullUrl] ID of the page the parent window
     *      should be redirected to when this dialog closes. Alternatively
     *      a full URL including the page parameters can be passed.
     * @param {Object} [pageParameters] Page parameters to be used when
     *        redirecting the parent to the new page. The following format
     *        is expected: <code>{ param1Name:"value", param2Name:248 }</code>
     *        The infrastructure handles URL-encoding the values so do NOT encode
     *        them yourself.
     *        If full URL is specified then the pageParameters are ignored.
     */
    close: function(/*optional*/ refreshParent, /*optional*/ newPageIdOrFullUrl,
        /*optional*/ pageParameters) {
      
      var win = curam.util.UimDialog._getDialogFrameWindow(this._id);
      var parentWindow = win.curam.dialog.getParentWindow(win);
      if (refreshParent && !newPageIdOrFullUrl) {
        win.curam.dialog.forceParentRefresh();
        curam.dialog.doRedirect(parentWindow, null);
        
      } else if (newPageIdOrFullUrl) {
        var newParentUrl = newPageIdOrFullUrl;
        // distinguish between pageId and full URL
        if (newPageIdOrFullUrl.indexOf("Page.do") == -1) {
          newParentUrl = newPageIdOrFullUrl + "Page.do"
              + curam.util.makeQueryString(pageParameters);
        }
  
        curam.dialog.doRedirect(parentWindow, newParentUrl);
      }
  
      curam.dialog.closeModalDialog();
    }
  });
  
  return DialogObject;  
});

},
'curam/define':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/lang"], function(lang) {

  /*
   * Modification History
   * --------------------
   * 29-Jul-2011  MV [CR00269970] Initial version.
   */

  /**
   * This package contains function for working with classes in our code.
   */
  var global = this;
  if(typeof(global.curam) == "undefined") {
    global.curam = {};
  }

  if (typeof(global.curam.define) == "undefined") {
    lang.mixin(global.curam, {define: {}});
  }

  lang.mixin(global.curam.define, {
    /**
     * Defines a singleton class ensuring any packages are created and no
     * existing packages are overwritten in the process.
     *
     * @param {String} singletonName Name of the singleton class to be defined.cdej
     * @param {Object} [content] Optional content of the singleton class.
     */
    singleton: function(singletonName, content) {
      var parts = singletonName.split(".");

      // we assume we are runnning within a browser environment so the window
      // object is available.
      var currentContext = window;

      // now check for existence and create any missing packages
      for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (typeof currentContext[part] == "undefined") {
          currentContext[part] = {};
        }
        currentContext = currentContext[part];
      }

      // now set the content
      if (content) {
        lang.mixin(currentContext, content);
      }
    }
  });

  return global.curam.define;
});

},
'curam/util/ui/ApplicationTabbedUiController':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2021. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/_base/declare",
        "curam/inspection/Layer",
        "curam/debug",
        "dojox/layout/ContentPane",
        "curam/tab"], function(declare, layer, debug) {
  
  /*
   * Modification History
   * --------------------
   * 11-Aug-2021  SK  [RTC272800] Progress spinner invocation is now decoupled.
   * 01-Jul-2019  GG  [RTC245742] Updated ApplicationTabbedUiController 
   *							  constructor in order to call curam.util.extendXHR 
   *							  to manage session timeout.
   * 06-Oct-2016  SO  [175374] "aria-label":"tab content holder" has
   *                            removed as a reason of accessibility issue
   * 17-Aug-2015  AZ  [CR00465620] Open tabs adjacent to source tab.
   * 23-Feb-2015  SK  [CR00458512] Avoid IE memory leaks.
   * 30-Oct-2014  MV  [CR00448315] Do not load page when finding tab.
   * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
   * 27-Jun-2014  AB  [Cr00435428] RPT Project 
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 30-Sep-2013  MK  [CR00390932] Upgrade to Dojo 1.9
   * 28-Sep-2013  BOS [CR00396277] Modified findOpenTab() function to ensure an
   *                    undefined tab container handled correctly.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 22-Feb-2013  MV  [CR00368145] Remove standard Dojo tab load mask.
   * 23-Oct-2012  MV  [CR00347543] Refer to top level UIController.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 11-Sep-2012  MV  [CR00339639] Performance related updates: Handle tab load
   *    mask differently.
   * 05-Sep-2012  MK  [CR00339638] Fix issue responding to title of content
   *   pane being set.
   * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
   * 21-Sep-2011  MV  [CR00288065] Initial version.
   * 23-May-2012  SB  [CR00321886] Added tab focus code.
   */
  
  /**
   * Defines an interface into the application tabbed UI elements.
   *
   */
  var ApplicationTabbedUiController = declare(
      "curam.util.ui.ApplicationTabbedUiController", null, {
    _tabContainer: null,
    
    /**
     * Performs initial setup.
     * 
     * @param tabContainer The application tab container to manage.
     */
    constructor: function(tabContainer) {
      curam.util.extendXHR();
      this._tabContainer = tabContainer;
      layer.register("curam/util/ui/ApplicationTabbedUiController", this);
     
    },
    
    /**
     * Finds an open tab that can be used to display the page identified in the
     * open tab event. If no suitable tab is found, a new one will need to be
     * created. If a matching tab is found, it need only be selected, as it
     * already contains the requested page.
     *
     * @param {curam.ui.OpenTabEvent} openTabEvent The event describing the tab
     *   to be opened.
     * @return An existing tab panel to select to show the page, or null if a new
     *   tab must be opened.
     */
    findOpenTab: function(openTabEvent) {
      var eventTD = openTabEvent.tabDescriptor;
      var tabContainer = curam.tab.getTabContainer(eventTD.sectionID);
      var foundTab = null;
      var tabs = undefined;
      var selectedTab = undefined;
      
      if (tabContainer != undefined) {
        tabs = tabContainer.getChildren();
        selectedTab = tabContainer.selectedChildWidget;
      }     
      

      // If there is a selected tab, then use it to open the page if the request
      // explicitly request opening the page in the current tab. Otherwise, we
      // will search for a matching tab and return it and it will then be
      // selected. If the selected tab matches, it will be used in preference to
      // any other.
      if (selectedTab) {
        var selTD = selectedTab.tabDescriptor;
        this._log(debug
          .getProperty("curam.util.ui.ApplicationTabbedUiController.testing"));

        if (openTabEvent.uimPageRequest.openInCurrentTab
            || (selTD.tabID == eventTD.tabID
                && selTD.matchesPageRequest(openTabEvent.uimPageRequest))) {
          foundTab = selectedTab;
        }
      }

      // If the page was not opened in the selected tab, then find one of the
      // other tabs that matches.
      if (!foundTab && tabs) {
        var firstTabWithNoParams = true;
        this._log(debug
          .getProperty("curam.util.ui.ApplicationTabbedUiController.searching") 
          + " " + tabs.length + " " + debug
          .getProperty("curam.util.ui.ApplicationTabbedUiController.tabs"));
        for (var i = 0; i < tabs.length; i++) {
          var currentTab = tabs[i];
          var curTD = currentTab.tabDescriptor;
          if (curTD && curTD.tabID == eventTD.tabID) {
            if ((firstTabWithNoParams && curTD.tabSignature == curTD.tabID)
                || curTD.matchesPageRequest(openTabEvent.uimPageRequest)) {
              // The signature of a tab combines the tab ID with its parameters.
              // If the signature is set to just the tab ID, then the tab has no
              // parameters and is treated as a "singleton" tab. If the first
              // matching tab is a "singleton" tab, use it, otherwise use the
              // first tab that matches fully.
              foundTab = currentTab;
              break;
            }
            firstTabWithNoParams = false;
          }
        }
      }
      this._log(debug
        .getProperty("curam.util.ui.ApplicationTabbedUiController.searched") 
          + " '" + eventTD.tabID + "'. " + debug
           .getProperty("curam.util.ui.ApplicationTabbedUiController.found")
           + " " + (foundTab ? 
           debug.getProperty("curam.util.ui.ApplicationTabbedUiController.a") : 
           debug.getProperty("curam.util.ui.ApplicationTabbedUiController.no")) 
           + " " 
           + debug
             .getProperty("curam.util.ui.ApplicationTabbedUiController.match"));

      return foundTab;
    },
    
    /**
     * Opens the specified page in the current tab.
     *
     * TODO: Consolidate with openInCurrentTab below.
     *
     * @param {curam.ui.PageRequest} pageRequest
     *    Page request for the page to be loaded.
     */
    openPageInCurrentTab: function(pageRequest) {
      // Get the currently selected Tab
      var selectedTab = curam.tab.getSelectedTab();
      var mainContentPane = undefined;
      if (selectedTab) {
         mainContentPane = dojo.query(".nav-panel", selectedTab.domNode)[0];
      }
     
      if (mainContentPane) {
        // IPN Spinner
        var panelToReload = dojo.query(".content-area-container", mainContentPane)[0];
        if (!panelToReload) {
          panelToReload = selectedTab.domNode;
        }
        dojo.publish('/curam/progress/display', [panelToReload]);
        
        var urlAppend;
        if (pageRequest.getURL().indexOf("?") == -1) {
          urlAppend = "?";
        } else {
          urlAppend = "&";
        }
        var loc = curam.config ? curam.config.locale : jsL;
        var fullURL = dojo.global.jsBaseURL + "/" + loc + "/"
                      + pageRequest.getURL()
                      + urlAppend
                      + curam.tab.getTabController().getCacheBusterParameter();

        if (pageRequest.pageHolder) {
          // pageHolder will be set by the expanding list feature in
          // tab-app-adaptor.js. This means we should not open up in the
          // main content panel, instead in the window object referenced by
          // pageHolder.
          pageRequest.pageHolder.location.href = fullURL;

        } else {
          // Otherwise we just open up in the main content panel
          // TODO: check ContentPane API, must be a way to get the content
          // directly instead of getting the domNode (which contains a generated
          // DOJO div) and it's first child.
          var iframe = dojo.query(".contentPanelFrame", mainContentPane)[0];
          iframe.src = fullURL;
        }
      }
    },
    
    
    /**
     * This is called when opening links (for current tab) when link in navigation
     * and for cancel links. But not for submit links or from menu bar.
     * TODO: explain why it's used in one place or the other.
     * TODO: Consolidate with openPageInCurrentTab above.
     * @private
     * 
     * @param {curam.ui.PageRequest} uimPageRequest
     *    Page request for the page to be loaded.
     */
    _openInCurrentTab: function(uimPageRequest) {
      var selectedTab = curam.tab.getSelectedTab();
      var mainContentPane = undefined;
      if (selectedTab) {
        mainContentPane = dojo.query(".nav-panel", selectedTab.domNode)[0];  
      }

      if (mainContentPane) {
        // TODO: check ContentPane API, must be a way to get the content
        // directly instead of getting the domNode (which contains a generated
        // DOJO div) and it's first child.
        var iframe = dojo.query(".contentPanelFrame", mainContentPane)[0];
        // reset context parameter to TAB.
        uimPageRequest.cdejParameters["o3ctx"]="4096";
        var loc = curam.config ? curam.config.locale : jsL;
        var url = loc + "/" + uimPageRequest.getURL();
        if (url.indexOf('?') == -1) {
          url += "?";
        } else {
          url += "&";
        }
        iframe.src = url + curam.tab.getTabController().getCacheBusterParameter();
      }
    },

    /**
     * Forces reload of the content panel in the specified tab.
     * 
     * @param tab The tab to reload.
     */
    refreshExistingPageInTab: function(tab) {
      var iframe = curam.tab.getContentPanelIframe(tab);
      // specifically pass false so that browser uses cached resources where
      // possible
      iframe.contentWindow.location.reload(false);
    },
    
    /**
     * Makes the specified tab active.
     * 
     * @param tab The tab to select.
     */
    selectTab: function(tab) {
      this._tabContainer.selectChild(tab);
    },
    
    /**
     * Create a new Dojo content panel for a tab and set its content "href". The
     * content will only be loaded if the content panel is added to a tab
     * container and brought to the foreground. This method does not add or select
     * the tab.
     *
     * @param {curam.ui.OpenTabEvent} The event detailing the tab to be opened.
     * @return {dojox.layout.ContentPane} The content pane representing the tab.
     */
    createTab: function(openTabEvent) {
      this._log("createTab(): " + debug
        .getProperty("curam.util.ui.ApplicationTabbedUiController.start"));

      // Get the "TabDescriptor" that contains all of the information needed
      // to track the tab session. This is incomplete until the TabRenderer
      // calls the "instantiateTab" function to set the tab signature in the
      // tab descriptor.
      var eventTD = openTabEvent.tabDescriptor;

      // If we are restoring a tab from the tab session, then the title may be
      // available already. Otherwise it is set after loading.
      // TODO: Figure out under what conditions the tabID should be used as the
      // title. -- DG
      var restoredTitle = "";
      if (eventTD.tabContent && eventTD.tabContent.tabName) {
        restoredTitle = eventTD.tabContent.tabName;
      }

      var cp = new dojox.layout.ContentPane({
        // THESE PROPERTIES ARE CURAM-SPECIFIC:
        // Most of the magic is in the TabDescriptor. See that class for details.
        tabDescriptor: eventTD,
        uimPageRequest: openTabEvent.uimPageRequest,

        // THESE PROPERTIES ARE SUPPORTED BY THE DOJO ContentPane CLASS:

        // The title will be set after the page has loaded if it is not restored
        // from the tab session. See the "attr" event hook below.
        title: restoredTitle,
        // Home page tabs cannot be closed.
        closable: !eventTD.isHomePage,
        // Automatically append a time stamp to the "href" to prevent caching.
        // Not sure why this is used. TODO: Confirm if this is OK. -- DG
        preventCache: true,
        "class": "tab-content-holder dijitContentPane "
               + "dijitTabContainerTop-child "
               + "dijitTabContainerTop-dijitContentPane dijitTabPane",
         
         /* Override this function to remove standard Dojo load mask. */
         onDownloadStart: function(){
           // just return empty space - we don't want any load mask text
           return "&nbsp;";
         }
      });

      // Array of event listeners that should be removed when the content pane is
      // destroyed. Every dojo.connect call in this function for the cp object
      // should add the result to the eventListeners array.
      var eventListeners = [];
      // We know that we are opening a new tab. The context must always be just
      // the "TAB" context (see ScreenContext.js).
      // TODO: Change ScreenContext.js so the "constants" can be accessed rather
      // than having to repeat the number here.
      // TODO: Change PageRequest.js to have a "setScreenContext" method instead
      // of accessing the cdejParameters array directly.
      openTabEvent.uimPageRequest.cdejParameters["o3ctx"] = "4096";
      var listener = dojo.connect(cp, "onDownloadEnd", null, 
        function() {curam.util.fireTabOpenedEvent(cp.id);});
      eventListeners.push(listener);

      // Unsubscribe the registered listeners in curam.tab.
      listener = dojo.subscribe("/curam/tab/closing", null, function(twid) {
        if (twid == cp.id) {
          curam.tab.doExecuteOnTabClose(cp.id);
        }
      });
      eventListeners.push(listener);
      
      /* Disconnect all listeners added to eventListeners array when the tab
       * is closed.
       * NOTE: this must be connected after the other "destroy" handler above
       * as the above one must be executed before being disconnected.
       */
      eventListeners.push(dojo.connect(cp, "destroy", function() {
        dojo.forEach(eventListeners, dojo.disconnect);
      }));

      listener = dojo.connect(cp, "set", function(name, value) {
        if (name == "title" && arguments.length == 2) {
          // Something has just changed the title.
          curam.debug.log(debug
            .getProperty("curam.util.ui.ApplicationTabbedUiController.title"));
          // Complete the information in the tab descriptor now that the title
          // has been set. This will be saved automatically if needed.
		  var topLevelDojo = curam.util.getTopmostWindow().dojo;
          topLevelDojo.global._tabTitle = value;
		  try {
            topLevelDojo.publish("/curam/_tabTitle",[value]);
		  } catch(err) {
		    // Ignore and continue.
		  }
          cp.tabDescriptor.setTabContent(openTabEvent.uimPageRequest, value);
          var selectedTab = curam.tab.getSelectedTab();
          if (selectedTab) { 
            var tabToFocus = selectedTab.domNode.parentNode;
            if(tabToFocus){
              tabToFocus.focus();
            }
          }
        }
      });
      eventListeners.push(listener);

      // Handler for when the tab closes
      listener = dojo.connect(cp, "onClose", function() {
        new curam.tab.TabSessionManager().tabClosed(cp.tabDescriptor);
      });
      eventListeners.push(listener);

      // Set the "href" on the content pane. The content pane will only load this
      // if the content pane is shown (i.e., selected). However, if it is the
      // only visible tab, it will load immediately. Therefore, we only set the
      // "href" after registering all of the event listeners above first.
      var qs = openTabEvent.uimPageRequest.getQueryString();
      var href = "TabContent.do" + "?"
              + curam.tab.getTabController().COMMAND_PARAM_NAME + "=PAGE&"
              + curam.tab.getTabController().PAGE_ID_PARAM_NAME + "="
              + openTabEvent.uimPageRequest.pageID
              + (qs.length > 0 ? "&" + qs : "")
              + "&o3tabid=" + eventTD.tabID
              + "&o3tabWidgetId=" + cp.id;
      this._log(debug
        .getProperty("curam.util.ui.ApplicationTabbedUiController.href") 
          + " " + href);
      cp.set("href", href);

      this._log(debug
        .getProperty("curam.util.ui.ApplicationTabbedUiController.finished") 
          + " ", cp.tabDescriptor);
      return cp;
    },
    
    /**
     * Inserts the tab into the UI.
     * 
     * @param newTab The tab to be added.
     * @param isHomeTab Indicates if the tab should be the home tab.
     * @param isInSequence Indicates if the tab should open in logical or chronological order.
     * 
     * @return The previously selected tab or null if no tab was selected.
     */
    insertTabIntoApp: function(newTab, isHomeTab, isInSequence) {
      var previouslySelectedTab = null;
      if (isHomeTab) {
        if (this._tabContainer.hasChildren()) {
          // Note the currently selected tab. This will be reverted to
          // after adding the default home tab
          previouslySelectedTab = this._tabContainer.selectedChildWidget;
        }
        // Make sure the home page is always inserted at tab 0
        // This is to fix a timing issue with the default page in a section
        this._tabContainer.addChild(newTab, 0);        
      
      } else if (isInSequence) {  
        var prevTabIdx = -1;
        
        if (this._tabContainer.hasChildren()) {
          // Note the currently selected tab as the source of tab event
          var prevTab = this._tabContainer.selectedChildWidget;
          var tabs = this._tabContainer.tablist.getChildren();
          
          // Find tab index of the source tab
          for (var i = 0; i < tabs.length; i++) {
            var currentTab = tabs[i];
            if (currentTab 
                  && currentTab._curamPageId == prevTab.id) {
                prevTabIdx = i;
                break;
            }
          }
        }
        
        // If tab was found, add new tab immediately after.
        if (prevTabIdx != -1) {
            this._tabContainer.addChild(newTab, prevTabIdx + 1);
        } else {
          // If no tab, add to end.
          this._tabContainer.addChild(newTab);
        }
        
      } else {
        this._tabContainer.addChild(newTab);        
      }
      
      return previouslySelectedTab;
    },
    
    /**
     * Simplifies production of consistent log messages from this class.
     *
     * @param {String} msg The message to be logged.
     * @param object An optional object that will be converted to JSON form and
     *   appended to the message string.
     */
    _log: function(msg, object) {
      // If debug logging is turned off, then we do not want to keep the overhead
      // of converting objects to JSON form to create the log message, so we
      // check the DEBUG switch even before calling "curam.debug.log".
      if (curam.debug.enabled()) {
        curam.debug.log(
            "curam.util.ui.ApplicationTabbedUiController: " + msg
                + (object ? " " + dojo.toJson(object) : ""));
      }
    }
  });
  
  return ApplicationTabbedUiController;
});

},
'dojo/dnd/move':function(){
define([
	"../_base/declare",
	"../dom-geometry", "../dom-style",
	"./common", "./Mover", "./Moveable"
], function(declare, domGeom, domStyle, dnd, Mover, Moveable){

// module:
//		dojo/dnd/move

/*=====
var __constrainedMoveableArgs = declare([Moveable.__MoveableArgs], {
	// constraints: Function
	//		Calculates a constraint box.
	//		It is called in a context of the moveable object.
	constraints: function(){},

	// within: Boolean
	//		restrict move within boundaries.
	within: false
});
=====*/

var constrainedMoveable = declare("dojo.dnd.move.constrainedMoveable", Moveable, {
	// object attributes (for markup)
	constraints: function(){},
	within: false,

	constructor: function(node, params){
		// summary:
		//		an object that makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: __constrainedMoveableArgs?
		//		an optional object with additional parameters;
		//		the rest is passed to the base class
		if(!params){ params = {}; }
		this.constraints = params.constraints;
		this.within = params.within;
	},
	onFirstMove: function(/*Mover*/ mover){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.
		var c = this.constraintBox = this.constraints.call(this, mover);
		c.r = c.l + c.w;
		c.b = c.t + c.h;
		if(this.within){
			var mb = domGeom.getMarginSize(mover.node);
			c.r -= mb.w;
			c.b -= mb.h;
		}
	},
	onMove: function(/*Mover*/ mover, /*Object*/ leftTop){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		var c = this.constraintBox, s = mover.node.style;
		this.onMoving(mover, leftTop);
		leftTop.l = leftTop.l < c.l ? c.l : c.r < leftTop.l ? c.r : leftTop.l;
		leftTop.t = leftTop.t < c.t ? c.t : c.b < leftTop.t ? c.b : leftTop.t;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	}
});

/*=====
var __boxConstrainedMoveableArgs = declare([__constrainedMoveableArgs], {
	// box: Object
	//		a constraint box
	box: {}
});
=====*/

var boxConstrainedMoveable = declare("dojo.dnd.move.boxConstrainedMoveable", constrainedMoveable, {
	// box:
	//		object attributes (for markup)
	box: {},

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: __boxConstrainedMoveableArgs?
		//		an optional object with parameters
		var box = params && params.box;
		this.constraints = function(){ return box; };
	}
});

/*=====
var __parentConstrainedMoveableArgs = declare( [__constrainedMoveableArgs], {
	// area: String
	//		A parent's area to restrict the move.
	//		Can be "margin", "border", "padding", or "content".
	area: ""
});
=====*/

var parentConstrainedMoveable = declare("dojo.dnd.move.parentConstrainedMoveable", constrainedMoveable, {
	// area:
	//		object attributes (for markup)
	area: "content",

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: __parentConstrainedMoveableArgs?
		//		an optional object with parameters
		var area = params && params.area;
		this.constraints = function(){
			var n = this.node.parentNode,
				s = domStyle.getComputedStyle(n),
				mb = domGeom.getMarginBox(n, s);
			if(area == "margin"){
				return mb;	// Object
			}
			var t = domGeom.getMarginExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "border"){
				return mb;	// Object
			}
			t = domGeom.getBorderExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			if(area == "padding"){
				return mb;	// Object
			}
			t = domGeom.getPadExtents(n, s);
			mb.l += t.l, mb.t += t.t, mb.w -= t.w, mb.h -= t.h;
			return mb;	// Object
		};
	}
});


return {
	// summary:
	//		TODOC
	constrainedMoveable: constrainedMoveable,
	boxConstrainedMoveable: boxConstrainedMoveable,
	parentConstrainedMoveable: parentConstrainedMoveable
};

});

},
'curam/ui/UIController':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2009,2023. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

define(["dojo/_base/declare",
        "dojo/_base/lang",
        "dojo/json",
        "dojo/dom-style",
        "dojo/dom-attr",
        "curam/inspection/Layer",
        "curam/util/Request",
        "curam/define",
        "curam/debug",
        "curam/util/RuntimeContext",
        "curam/tab/TabDescriptor",
        "curam/util/ui/ApplicationTabbedUiController"], function(declare, lang, 
            dojoJSON, domStyle, domAttr, layer, curamRequest, define, debug) {

/*
 * Modification History
 * --------------------
 * 06-Jan-2023  AT  [SPM-126441] Autorecovery.
 * 03-Jan-2023  JD  [SPM-125865] Updated span to h1 in dojo query in setTabTitleAndName.
 * 11-Aug-2021  SK  [RTC272800] Progress spinner invocation is now decoupled.
 * 25-Nov-2019  JD  [RTC246520] Added forceLoad property to pageRequestToProcess if it 
 * exists on initial pageRequest in resolvePageCheckSuccess function in order to force a 
 * parent page to refresh when a modal submit links to a resolve page.
 * 07-Nov-2019  GG  [RTC251143] Updated _doHandleTabEvent to set the lastOpenedTabButton 
 * to store the last opened tab button when a new Tab is created.
 * 23-Aug-2018  BD  [RTC229425]  Included publish to alert the number of iframes
 *                               may be loaded by tabwigetID and when the context is refreshed.
 * 14-Mar-2018  LD  [223635] Create a wrapper to the previous changes in this file. 
 *						  It should be clear that the changes made in RTC216427
 *						  should be used only by the smart navigator.
 * 18-Dec-2017  LD  [RTC216427] Changes made to support the new Quick Search Redirects:
 * 						  1-Added Callbacks to the checkPage and checkResolvePage to be 
 * 						  called after the checks to see if the user has a tab configured to the 
 * 						  destination page. 						  
 * 						  2-Added the attribute preferredTab to be used when the user has 
 * 						  more than one tab configured to the same page. 
 * 11-Oct-2017  JD  [RTC206743]  Removed GENERIC_ERROR_MODAL_MAP and moved it
 * 								 to util.js as the object was not visible in UA.
 * 11-Apr-2017  GB  [RTC107246]  Increasing the max number of tabs to 15.
 * 07-Apr-2017  GB  [RTC182027]  Fixing the logic to remove the parameter for 
 * 								 openGenericErrorModalDialog from the request.
 * 06-Oct-2016  AZ  [172334]     isLoginPage has been moved to curam/util/Request.
 * 04-Aug-2016  CD  [143055]     Set document title on first load of a title-less content panel.
 * 24-Aug-2015  AB  [CR00465809] Dynamic browser tab titles.
 * 17-Aug-2015  AZ  [CR00465620] Pass tab order config into the TabbedUI controller
 * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
 * 06-Oct-2014  MV  [CR00446285] Use cache when reloading page.
 * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
 * 10-Apr-2014  SK  [CR00424462] Added event to notify about the dynamic tab
 *                    title being set. 
 * 10-Dec-2013  SK  [CR00410477] Added events for loading mask monitoring.
 * 28-Sep-2013  BOS [CR00396277] Modified _doHandleTabEvent function to
 *                    ensure an undefined tab container handled correctly.
 * 16-Aug-2013  MK  [CR00393829] Handle scenario where link opens home page
 *      in another section, and the section is being open for the first time.
 * 04-Aug-2013  NLH [CR00388987] Toggle button on context panel disappears.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 13-Mar-2013  MV  [CR00373990] Only set src attribute on content panel iframe
 *      after tab content is put in DOM.
 * 10-Jan-2013  SB  [CR00357346]  Removed tab focusing code as it is handled
 * 							     in a different function.
 * 03-Oct-2012  SB  [CR00344085] Updated _checkMaxNumOpenTabsReached() and
 *      _checkMaxNumOpenTabsExceeded() function to include true/false
 *      value for error modals.
 * 11-Sep-2012  MV  [CR00339639] Performance related updates: Move a function
 *      to different module. Handle tab load mask differently.
 * 23-Aug-2012  BOS [CR00338361] Enabling support to set a maximum number of
 *                    tabs that can be open in an application.
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 17-Jul-2012  MV  [CR00329547] Send event on tab activation.
 * 22-Mar-2012  MV  [CR00311066] Fix infinite recursion when page associations
 *                      XHR fails.
 * 14-Dec-2011  KW  [TEC-8648]  Refactored the handling of 'o3gtu'. Now handled
 *                              in TabSessionManager.js
 * 18-Oct-2011  MV  [CR00295164] Avoid infinite loop when calling path resolver.
 * 28-Sep-2011  MV  [CR00288956] Finish refactoring of tabTopicHandler.
 * 23-Sep-2011  MV  [CR00288065] Switch to target tab before loading page.
 *    Refactor tabTopicHandler for testability.
 * 29-Aug-2011  MV  [CR00285689] Handle page loading when switching between
 *    tabs consistently.
 * 27-Jul-2011  MV  [CR00278546] Fixed handleLinkClick() broken by previous
 *      refactoring.
 * 05-Jul-2011  KW  [CR00275353] Refactored handleLinkClick().
 * 29-Apr-2011  SC  [CR00265494] Resolved timing issue opening default page.
 * 29-Apr-2011  SC  [CR00264826] Modified event fired when page loaded.
 * 27-Apr-2011  MV  [CR00265188] Refactored to support custom handler for
 *    unmapped pages.
 * 31-Mar-2011  MK  [CR00263400] Updated tabTopicHandler function to use the
 *                    jsBaseURL global variable when assigning URL.
 * 24-Jan-2011  MK  [CR00262346] Added retrieveBaseURL function. Updated
 *                    the calculation of the fullURL in the
 *                    openPageInCurrentTab function to get it working with
 *                    the Chrome browser.
 * 26-Jan-2011  MV  [CR00244801] Added another type of refresh behaviour. Strip
 *    o3rpu from RPU value.
 * 21-Jan-2011  MV  [CR00243263] Implement "force refresh" behaviour.
 * 15-Jan-2011  PK  [CR00242698] Added error handling when a page is shared by
 *                    multiple tabs; when the AJAX query to check for a resolve
 *                    page fails.
 * 14-Jan-2011  DG  [CR00242400] Added support for restoring the content page
 *                    when the tab session is restored. Changed the way load
 *                    masking works to make it work with concurrent tab loading.
 *                    Removed "requires" made unnecessary by "cdej.js".
 * 12-Jan-2011  DG  [CR00238642] Fixed tab loading race condition by setting
 *                    "href" only after connecting listeners to content pane.
 * 01-Dec-2010  DG  [CR00217921] Major changes to support use of "TabDescriptor"
 *                    objects for easier tab session management.
 * 23-Nov-2010  MV  [CR00232063] Code cleanup.
 * 19-Nov-2010  MV  [CR00231655] Subscribe to topics with a function that will
 *    automatically unsubscribe on page unload.
 * 26-Oct-2010  SK  [CR00224193] change in link handling to allow for opening
                    modals from the shortcut/menu without the content panel.
 * 26-Oct-2010  SJ  [CR00226152] Added File down load support for menu bar.
 * 22-Sep-2010  PK  [CR00221139] Fix for parameter encoding in resolve pages.
 * 17-Sep-2010  MV  [CR00220607] Fix o3rpu value for dialogs opened from action
 *                    return page.
 * 14-Sep-2010 MV  [CR00220152] Fixed handling of menu item clicks when page
 *                    parameters with forward slashes are present.
 * 29-Jul-2010 PK  [CR00211736] Moved tab-app-controller.js to create this
 *                   "class", curam.ui.UIController.
 * 27-Jul-2010 MV  [CR00211474] Clear loading mask in error scenarios.
 * 21-Jul-2010 PK  [CR00211095] Support for default page in a section.
 * 20-Jul-2010 MV  [CR00211031] Fix naming of a link handling function.
 * 10-Jul-2010 OK  [CR00209714] Added default CSS classes to ContentPane.
 * 23-Jun-2010 PK  [CR00203531] Updated link processing triggered by
 *                   handlePageRequest method to handle sections. Removed some
 *                   unused code. Removed use of "currentUIMPageRequest" which
 *                   was stored "globally" on the TabController object. This is
 *                   now passed around as a parameter which is "safer".
 * 10-Jun-2010 OK  [CR00202886] Checking done to handle when  to remove
 *                              loading mask from tab
 * 04-Jun-2010 MV  [CR00202412] Refactored to reflect changes to code
 *                   that executes functions on tab close.
 * 23-Mar-2010 SD  [CR00190733] Updated query to populate title text from
 *                              tab name.
 * 22-Mar-2010 BD  [CR00191495] Code fix, update handle on mainContentPane for
 *                              iframe to match new layout.
 * 02-Feb-2010 BD  [CR00183006] Removed listener for onClick event. This is
 *                              now handled by the navigationTab.js file for
 *                              the content area.
 * 21-Jan-2010 MV  [CR00183104] Code cleanup in the handlePreferencesAction
 *                               function.
 * 17-Dec-2009 AF  [CR00167063] Added support for pages that do not pass back
 *                their page id in JSON data.
 * 08-Dec-2009 MV  [CR00181267] Take on dojo v 1.4 - fix issues
 * 24-Nov-2009 MV  [CR00175837] Provide a new tabOpened event.
 * 13-Oct-2009 SC  [CR00172239] Added support for session persistence.
 * 03-Sep-2009 MLB [CR00164883] Added  preferences action handler.
 * 07-Aug-2009 MV  [CR00164029] refactored to use the new method for getting
 *                  the selected tab.
 * 06-Aug-2009 MLB [CR00163869] Added Tree persistence.
 * 23-Jul-2009 MV  [CR00162771] Menu click handler updated to handle modal
 *                        windows.
 * 24-Jun-2009 MV  [CR00160877] Updated so that the tab widget id is passed
 *                        as request parameter when loading a tab.
 */

	curam.define.singleton("curam.ui.UIController", {

		  TAB_TOPIC: "/app/tab",
		  ROOT_OBJ: "curam.ui.UIController",
		  PAGE_ASSOCIATIONS: {},
		  RESOLVE_PAGES: {},
		  PAGE_ID_PARAM_NAME: "o3pid",
		  COMMAND_PARAM_NAME: "o3c",
		  CACHE_BUSTER: 0,
		  CACHE_BUSTER_PARAM_NAME: "o3nocache",
		  DUPLICATE_TAB_MAPPING_ERROR: "dupTabError",
		  UNASSOCIATED_SHORTCUT_ERROR: "looseShortcutError",
		  LOAD_MASK_TIMEOUT: 15000, // Max. wait (milliseconds) before revealing a tab.
		  TABS_INFO_MODAL_TITLE_PROP_NAME: "title.info",
		  TABS_ERROR_MODAL_TITLE_PROP_NAME: "title.error",
		  TABS_INFO_MODAL_MSG_PROP_NAME: "message.max.tabs.info",
		  TABS_ERROR_MODAL_MSG_PROP_NAME: "message.max.tabs.error",
		  TABS_MSG_PLACEHOLDER_MAX_TABS: 15,
		  TABS_SEQUENTIAL_ORDER: false,
		  MAX_NUM_TABS: 15,
		  MAX_TABS_MODAL_SIZE: "width=470,height=80",
		  TAB_INSTANTIATOR: null,
		  

		  /**
		   * Initializes various aspects of the user interface (e.g. listeners, tab
		   * session manager etc.). AppController.jspx generates the JavaScript code
		   * that invokes this method.
		   */
		  initialize: function(directBrowseURL) {
		    curam.ui.UIController._log("curam.ui.UIController.initialize()");
		    curam.ui.UIController._log("dojo.isQuirks: " + dojo.isQuirks);

		    // This "rootObject" indicates we are on the root window of the user
		    // interface (i.e. the window output by AppController.jspx. If is used in
		    // curam/util.js in the "getFrameRoot" method. This object
		    // (curam.ui.UIController) is only included from AppController.jspx so it
		    // will be used as the "rootObject" to search for.
		    window.rootObject = curam.ui.UIController.ROOT_OBJ;

		    // Sets the main handler that opens new tabs on request.
		    curam.util.subscribe(curam.ui.UIController.TAB_TOPIC,
		        curam.ui.UIController.tabTopicHandler);

		    // Subscribe to the event for setting the tab title and name
		    curam.util.subscribe("tab.title.name.set",
		        curam.ui.UIController.setTabTitleAndName);
		    
		    // TODO: Update TabSessionManager so it doesn't use "dojo.declare" and make
		    // it a simple "namespace".
		    if (directBrowseURL) {
		      new curam.tab.TabSessionManager().init(directBrowseURL);
		    } else {
		      new curam.tab.TabSessionManager().init();
		    }

		    curam.ui.UIController._log(
		      debug.getProperty("curam.ui.UIController.event"));
		  },

		  ajaxPostFailure: function(err) {
		    curam.ui.UIController._log("========= "
		      +debug.getProperty("curam.ui.UIController.test")
		      + " JSON "
		      + debug.getProperty("curam.ui.UIController.servlet.failure")
		      + " =========");
		    curam.ui.UIController._log(debug
		      .getProperty("curam.ui.UIController.error") + " " + err);
		    curam.ui.UIController._log(debug
		        .getProperty("curam.ui.UIController.args") + " " + ioargs);
		    curam.ui.UIController._log("============================================");
		  },

		  /**
		   * Instantiates a tab by setting the tab's signature. The identified tab
		   * content panel is the one that must be instantiated fully. If the tab
		   * parameter names are empty, then the tab will be a "singleton" tab: only
		   * one instance of a tab with that ID will be allowed. This function is
		   * called only by a script generated by the <code>TabRenderer</code>. It
		   * also sets up listeners that will reveal the tab when the content pane and
		   * details panels have loaded and another to track changes to the content
		   * page within the tab.
		   *
		   * @param tabParamNames   An array of the names of the parameters defined in
		   *                          in the tab configuration. The values of these
		   *                          parameters (and only these parameters) will be
		   *                          extracted from the page request and will be used
		   *                          to uniquely identify this tab instance.
		   * @param tabWidgetID     The ID of the tab content panel.
		   * @param hasDetailsPanel True if the tab has a details panel.
		   */
		  instantiateTab: function(tabParamNames, tabWidgetID, hasDetailsPanel) {
			 var expectedFrames = hasDetailsPanel ? 2 : 1;
			 dojo.publish("curam/tab/quantityExpectedFrames/load",[tabWidgetID, expectedFrames ]);

		    var tabToInstantiate;
		    if (curam.ui.UIController.TAB_INSTANTIATOR != null) {
		      tabToInstantiate = curam.ui.UIController.TAB_INSTANTIATOR;
		    } else {
		      tabToInstantiate = dijit.byId(tabWidgetID);
		    }

		    /*try {
		      tabToInstantiate = dijit.byId(tabWidgetID);
		    } catch (e) {
		      tabToInstantiate = dijit.registry.byId(tabWidgetID);
		    }*/

		    if (tabToInstantiate) {
			  curam.util.getTopmostWindow().dojo.publish(
			    "/curam/application/tab/requested", [tabWidgetID]);
		      var td = tabToInstantiate.tabDescriptor;
		      var loggedID = "'" + td.tabID + "/" + tabWidgetID + "'";

		      curam.ui.UIController._log(
		          debug.getProperty("curam.ui.UIController.instantiating")
		          + " " + loggedID + " "
		          + debug.getProperty("curam.ui.UIController.with.signature"));

		      // Setting the signature will cause the tab to be saved to the session
		      // if the tab content details and title have been set. Otherwise, it will
		      // be saved when those details arrive later. See the TabDescriptor class.
		      td.setTabSignature(tabParamNames, tabToInstantiate.uimPageRequest);

		      // The function used to reveal the tab. Created here as it is easier to
		      // use with time-outs if it has no parameters.
		      var revealTabNow = function () {
		        var loadMaskDiv = dojo.query("#"+tabWidgetID+" .tab-wrapper .tab-load-mask")[0];
		        if (loadMaskDiv && domStyle.get(loadMaskDiv, "display") != "none") {
		        curam.ui.UIController._log(debug
		          .getProperty("curam.ui.UIController.revealing") + " " + loggedID
		          + " " + debug.getProperty("curam.ui.UIController.now"));
		           domStyle.set(loadMaskDiv, "display", "none");
				  curam.util.getTopmostWindow().dojo.publish(
				    "/curam/application/tab/revealed", [tabWidgetID]);

		          // Update the browser tab title
		          curam.debug.log("curam.ui.UIController.revealTabNow function calling curam.util.setBrowserTabTitle");
		          curam.util.setBrowserTabTitle();
		        }
		      };

		      // If a details panel is not present, reveal the tab immediately,
		      // otherwise wait until both the content pane and the details panel have
		      // loaded before revealing.
		      if (!hasDetailsPanel) {
		        curam.ui.UIController._log(debug
		          .getProperty("curam.ui.UIController.no.details"));
		        // TODO: Should this wait until the panel has loaded? -- DG
		        revealTabNow();
		      } else {
		        curam.ui.UIController._log(debug
		            .getProperty("curam.ui.UIController.has.details")
		            + loggedID + debug.getProperty("curam.ui.UIController.listeners"));

		        // No matter what happens, reveal the tab after a set period of time in
		        // case case the loading events do not fire for any reason, or fire
		        // before we get a chance to set up the loading listeners, or both set
		        // the "firstPanelHasLoaded" flag at precisely the wrong time.
		        dojo.global.tabLoadMaskTimeout = setTimeout(revealTabNow,
		            curam.ui.UIController.LOAD_MASK_TIMEOUT);

		        // A function to reveal the tab only when both panes are loaded.
		        var firstPanelHasLoaded = false;
		        var revealTabMaybe = function () {
		          if (firstPanelHasLoaded) {
		            curam.ui.UIController._log(debug
		              .getProperty("curam.ui.UIController.panels.loaded"));
		            // This is the second panel to load. Both are now loaded. Show the
		            // tab and cancel any pending time-out, as it is no longer needed.
		            revealTabNow();
		            clearTimeout(dojo.global.tabLoadMaskTimeout);
		          } else {
		            curam.ui.UIController._log(debug
		              .getProperty("curam.ui.UIController.panels.not.loaded")
		                + " " + loggedID + " "
		                + debug.getProperty("curam.ui.UIController.later"));
		            // This is the first panel to load. Wait for the second panel.
		            firstPanelHasLoaded = true;
		          }
		        };

		        // Wait until the main content pane loads then reveal the tab (maybe).
		        var mainListener = dojo.connect(tabToInstantiate, "onDownloadEnd",
		            function () {
		              curam.ui.UIController._log(debug
		                .getProperty("curam.ui.UIController.content.pane.loaded")
		                  + " " + debug.getProperty("curam.ui.UIController.reveal")
		                  + " " + loggedID + " "
		                  + debug.getProperty("curam.ui.UIController.now"));
		              revealTabMaybe();
		              dojo.disconnect(mainListener);
		            });

		        // Wait until the details pane loads then reveal the tab (maybe).
		        var detailsHandler = curam.util.getTopmostWindow().dojo.subscribe(
		            "/curam/frame/detailsPanelLoaded",
		            function (detailsPanel, publishedTabWidgetID) {
		              // Make sure we are listening to the event from our own tab!
		              if (tabWidgetID == publishedTabWidgetID) {
		                curam.ui.UIController._log(debug
		                  .getProperty("curam.ui.UIController.details.panel.loaded")
		                     + " " + loggedID + " " +
		                     + debug.getProperty("curam.ui.UIController.now"));
		                revealTabMaybe();
		                dojo.unsubscribe(detailsHandler);
		              }
		            });
		      }

		      // Set up a listener for changes to the content page in the new tab. This
		      // listener will be unsubscribed automatically if the tab is closed.
		      var handler = curam.tab.getHandlerForTab(
		          function(pageID, publishedTabWidgetID) {
		            curam.ui.UIController._log(debug
		              .getProperty("curam.ui.UIController.content.pane.changed") + " "
		                + loggedID + " "
		                + debug.getProperty("curam.ui.UIController.now"));
		            curam.ui.UIController._contentPanelUpdated(tabToInstantiate);
		          }, tabWidgetID);
		      var unsubToken = curam.util.getTopmostWindow().dojo.subscribe(
		          "/curam/main-content/page/loaded", null, handler);
		      curam.tab.unsubscribeOnTabClose(unsubToken, tabWidgetID);
		    } else {
		      curam.ui.UIController._log(
		        debug.getProperty("curam.ui.UIController.tab.not.found")
		          + " '" + tabWidgetID + "'.");
		    }
		  },

		  /**
		   * Updates the tab session data to record that a new content page has been
		   * opened in the content area within a tab. When the session is restored, the
		   * new content page should be restored, not the original page loaded in that
		   * tab.
		   *
		   * @param {ContentPane} tab The tab whose content pane has been updated.
		   * @private
		   */
		  _contentPanelUpdated: function(tab) {
		    var iframe = curam.tab.getContentPanelIframe(tab);
		    tab.tabDescriptor.setTabContent(new curam.ui.PageRequest(iframe.src), null);
		  },

		  getCacheBusterParameter: function() {
		    return curam.ui.UIController.CACHE_BUSTER_PARAM_NAME + "="
		           + new Date().getTime() + "_"
		           + curam.ui.UIController.CACHE_BUSTER++;
		  },

		  /**
		   * Gets the tabbed UI api instance for the specified tab open event.
		   * @private
		   *
		   * @param {curam.ui.OpenTabEvent} [openTabEvent] The tab open event or null.
		   * @returns {curam.util.ui.ApplicationTabbedUiController} The tabbed UI API.
		   */
		  _getTabbedUiApi: function(openTabEvent) {
		    var tabContainer = curam.ui.UIController._selectSection(openTabEvent);
		    return new curam.util.ui.ApplicationTabbedUiController(tabContainer);
		  },

		  /**
		   * Selects the section corresponding to the specified tab event.
		   * @private
		   *
		   * @param [openTabEvent] The tab event to select section for or null,
		   *    in which case the current section is maintained.
		   *
		   * @returns The tab container of the selected section.
		   */
		  _selectSection: function(openTabEvent) {
		    var inForeground = openTabEvent ? !openTabEvent.openInBackground : true;
		    var sectionsTabContainer = dijit.byId(curam.tab.SECTION_TAB_CONTAINER_ID);
		    var sectionId = openTabEvent ? openTabEvent.tabDescriptor.sectionID
		        : curam.tab.getCurrentSectionId();
		    var borderContainer = dijit.byId(sectionId + "-sbc");
		    var tabContainer = curam.tab.getTabContainer(sectionId);

		    // The child of the application sections border container can be a border
		    // container (if there is a shortcuts panel) or another tab container (that
		    // holds the applications main tabs, person, case etc.). We have to use the
		    // correct child to make it the selected one.
		    // TODO: use "hasShortcutPanel" API on section objects.
		    // TODO: Ideally selecting the section tab should come *after* selecting
		    // the child tab to make it appear smoother. However, some of the functions
		    // below like findOpenTab actually rely on the currently selected section
		    // tab, so we have to make sure to select this first. This needs to be
		    // re-worked.

		    // Only select the container if the new tab is to be selected.
		    if (inForeground) {
		      if (borderContainer) {
		        sectionsTabContainer.selectChild(borderContainer);

		      } else {
		        sectionsTabContainer.selectChild(tabContainer);
		      }
		    }

		    return tabContainer;
		  },

		  /**
		   * Handles a "TAB_TOPIC" request to open a new tab. The event may indicate
		   * that the tab should be opened in the foreground (i.e., selected after
		   * creation) or in the background.
		   *
		   * @param {curam.ui.OpenTabEvent} openTabEvent The event describing the tab
		   *   to be opened and the content to be loaded in that tab.
		   */
		  tabTopicHandler: function(openTabEvent) {
		    var api = curam.ui.UIController._getTabbedUiApi(openTabEvent);

		    curam.ui.UIController._doHandleTabEvent(openTabEvent, api);
		  },

		  _doHandleTabEvent: function(openTabEvent, tabbedUiApi) {
		    var eventTD = openTabEvent.tabDescriptor;
		    var sectionID = eventTD.sectionID;
		    var tabContainer = curam.tab.getTabContainer(sectionID);
		    openTabEvent.tabDescriptor.openInBackground = openTabEvent.openInBackground;

		    var topDojo = curam.util.getTopmostWindow().dojo;
		    var isNew = false;

		    curam.ui.UIController._log(
			  debug.getProperty("curam.ui.UIController.fired")
		                         + " " + sectionID + " : " + eventTD.tabID + " : "
		                         + openTabEvent.uimPageRequest.pageID);

		    // Select a tab that already has the requested page, or else open a new tab.
		    var tab = tabbedUiApi.findOpenTab(openTabEvent);
		    if (tab === null &&
		         lang.exists("selectedChildWidget.tabDescriptor.isHomePage", tabContainer) &&
		         tabContainer.selectedChildWidget.tabDescriptor.isHomePage === true &&
		         tabContainer.selectedChildWidget.tabDescriptor.tabID === openTabEvent.tabDescriptor.tabID) {

		      // When the tab requested is a home page of a section and the section
		      // is not visible at the time, the previous function call to
		      // tabTopicHandler will display the section and the associated home page
		      // tab. So the tab will exist at this point.
		     // However, at this stage of the execution the tabSignature property
		     // of the TabDescriptor will not be set on the tab as the page has not
		     // fully loaded. The findOpenTab function relies on the tabSignature
		     // property being set to find a tab. So it will return null in this
		     // particular scenario.
		     // In this scenario we instead carry out the comparison not on the
		     // tabSignature property of the TabDescriptor but using the tabID
		     // property instead.
		     tab = tabContainer.selectedChildWidget;
		    }
		    if (!tab) { //create new tab
		      if (tabContainer == undefined) {
		        return false;
		      }
		      //the openTabs starts at zero so we going to increment this by one
		      var numOpenTabs = tabContainer.getChildren().length + 1;
		      // if we are creating a new tab then check that the number of open tabs
		      // is not greater than the number of maximum allowable open tabs.
		      var numMaxOpenTabs = this.MAX_NUM_TABS;
		      var maxOpenTabsExceeded = this._checkMaxNumOpenTabsExceeded(numMaxOpenTabs, numOpenTabs);
		      if (maxOpenTabsExceeded) {
		        return true;
		      }
		      // if the max open tabs has not been exceeded then open a new one and
		      // finally check the limt has not been reached after creation..
		      curam.ui.UIController._log(debug
		                                 .getProperty("curam.ui.UIController.creating"));
		      tab = tabbedUiApi.createTab(openTabEvent);
		      
		      dojo.publish('/curam/progress/display', [tab.domNode]);

		      // notify listeners that the tab is setup and ready for use
		      // listener will be deregistered automatically when the tab destroys
		      tab.connect(tab, "onLoad", function() {

		        // start loading the iframe only when the tab content hs been put
		        // into DOM - this is to avoid IE9+ throwing JS error
		        var iframe = curam.tab.getContentPanelIframe(tab);
		        domAttr.set(iframe, "src", domAttr.get(iframe, "data-content-url"));
		        topDojo.publish("/curam/application/tab/ready", [tab]);
		      });
		      isNew = true;
		    }
		    if (isNew) {
		      var currentlySelectedTab = tabbedUiApi
			                   .insertTabIntoApp(tab, openTabEvent.uimPageRequest.isHomePage,
			                       this.TABS_SEQUENTIAL_ORDER);

		      // TODO: auto select newly opened tab or not....can we give the user
		      // the choice? e.g. they may be on a search page and want to open up
		      // multiple items. But if we bring the focus to the new tab, they have
		      // to switch back to the search tab before opening another item....
		      // should the user have some way of controlling this behavior (e.g.
		      // key press + mouse?)
		      if (!openTabEvent.openInBackground) {
		          curam.ui.UIController._log(debug
		            .getProperty("curam.ui.UIController.new.fore.tab"),
		              tab.tabDescriptor);
				 tabbedUiApi.selectTab(tab);
				 if(tab.controlButton != "undefined")
				 {
					 curam.util.setLastOpenedTabButton(dijit.byId(tab.controlButton.id));
				 }
		         if (currentlySelectedTab != null) {
		          // Revert selection of the tab
		          tabbedUiApi.selectTab(currentlySelectedTab);
		          if( currentlySelectedTab.controlButton != "undefined")
		          {
		        	  curam.util.setLastOpenedTabButton(dijit.byId(currentlySelectedTab.controlButton.id));
		          }
		        }
		      } else {
		        curam.ui.UIController._log(debug
		                   .getProperty("curam.ui.UIController.new.back.tab"),
		                      tab.tabDescriptor);
		      }
		      // if we are creating a new tab then check that the number of open
		      // tabs has not exceeded the number of open tabs in the application.
		      this._checkMaxNumOpenTabsReached(numMaxOpenTabs, numOpenTabs);
		    } else {
		        curam.ui.UIController._log(
		          debug.getProperty("curam.ui.UIController.show.page"),
		            tab.tabDescriptor);
		        // Select the tab within the section. We ignore the "openInBackground"
		        // flag for now, as this is not the path used when restoring a session.
		        // Opening an already open tab in the background would be the same as
		        // doing nothing at all, so we do something instead.
		        tabbedUiApi.selectTab(tab);

		        /*
		         * justRefresh   forceLoad
		         * true          true      -> just reload, keep existing URL gnoring passed URL
		         * false         false     -> load the page, only if not same
		         * true          false     -> just reload, keep existing URL
		         * false         true      -> load the page even if URL is same
		         */
		        if (openTabEvent.uimPageRequest.justRefresh) {
		          // disregard the passed URL and just refresh the current page
		          tabbedUiApi.refreshExistingPageInTab(tab);
		        } else if (openTabEvent.uimPageRequest.forceLoad) {
		          // force load of the tab
		          tabbedUiApi.openPageInCurrentTab(openTabEvent.uimPageRequest);
		        } else {
		          // Handle the "false false -> load the page, only if not same" scenario
		          // described above. The URLs have to be compared to see if the current
		          // tab should be loaded or not. When we get to this point the
		          // findOpenTab method has already selected the associated tab and taken
		          // care of loading the page if the pageRequest matches.
		          // findOpenTab doesn't handle the scenario where they don't match.
		          // TODO: Consolidate this code with findOpenTab. NB: there is a similar
		          // "todo" statement in findOpenTab. This needs to be resolved together.
		          var tabDescriptor = tab.tabDescriptor;
		          var isSameTab = tabDescriptor.tabID == openTabEvent.tabDescriptor.tabID
		                           && tabDescriptor.matchesPageRequest(openTabEvent.uimPageRequest);
		          var isSamePage = tabDescriptor.tabContent.pageID == openTabEvent.uimPageRequest.pageID;
		          if (isSameTab && !isSamePage) {
		            // load the page
		            tabbedUiApi.openPageInCurrentTab(openTabEvent.uimPageRequest);
		          }
		          isSamePage && isSameTab && 
		          	curam.util.getTopmostWindow().dojo.publish("curam/tab/contextRefresh",[true]);
		        }
		      }
		      return true;
		    },

		  /**
		   * Check that the number of open tabs has not reached the maximum
		   * number of tabs that are allowed to be open in an application.
		   */
		  _checkMaxNumOpenTabsReached: function(numMaxOpenTabs, numOpenTabs){
		    if (numOpenTabs == numMaxOpenTabs) {
		      this.TABS_MSG_PLACEHOLDER_MAX_TABS = numMaxOpenTabs;

		      curam.util.openGenericErrorModalDialog(this.MAX_TABS_MODAL_SIZE,
		    		  this.TABS_INFO_MODAL_TITLE_PROP_NAME,
		    		  this.TABS_INFO_MODAL_MSG_PROP_NAME,
		    		  this.TABS_MSG_PLACEHOLDER_MAX_TABS, false);

		      return true;
		    }
		  },

		  /**
		   * Check that the number of open tabs has not exceeded the maximum
		   * number of tabs that are allowed to be open in an application.
		   */
		  _checkMaxNumOpenTabsExceeded: function(numMaxOpenTabs, numOpenTabs){
		    if (numOpenTabs > numMaxOpenTabs) {
		      this.TABS_MSG_PLACEHOLDER_MAX_TABS = numMaxOpenTabs;

		      curam.util.openGenericErrorModalDialog(this.MAX_TABS_MODAL_SIZE,
		    		  this.TABS_ERROR_MODAL_TITLE_PROP_NAME,
		              this.TABS_ERROR_MODAL_MSG_PROP_NAME,
		              this.TABS_MSG_PLACEHOLDER_MAX_TABS, true);
		      
		      return true;
		    }
		  },

		  /**
		   * @param pageRequest The page request to check.
		   * @param unmappedPageLoader Null by default. If null the unmapped pages will
		   *    be loaded in current tab's content area.
		   *    If function is passed, the unmapped pages will be loaded using that
		   *    function. It is expected that the function takes the page request
		   *    as a parameter.
		   * @return True if the page has been loaded, otherwise false;
		   */
		  checkPage: function(pageRequest, unmappedPageLoader) {
		    curam.ui.UIController._log(debug
		        .getProperty("curam.ui.UIController.checking.page")
		        + " '" + pageRequest.pageID + "'.");
		    
		    //Hijacked attribute for Smart Navigator
		    //Using the attribute to send callbacks needed.
		    var preferredTabs = null;
		    var moreThanOneTabMappedCallback = null;
		    var shouldLoadPage = null;
		    var successCallback = null;
		    var unmappedPageLoaderCallback = unmappedPageLoader;
		    if(unmappedPageLoader && 
		    		typeof unmappedPageLoader != "function"){
		    	unmappedPageLoaderCallback = unmappedPageLoader.unmappedPageLoader;
		    	preferredTabs = unmappedPageLoader.preferredTabs;
		    	moreThanOneTabMappedCallback = unmappedPageLoader.moreThanOneTabMappedCallback;
		    	shouldLoadPage = unmappedPageLoader.shouldLoadPage;
		    	successCallback = unmappedPageLoader.successCallback;
		    }
		    
		    if (typeof shouldLoadPage === "undefined" || shouldLoadPage === null) {
		    	shouldLoadPage = true;
		    }  

		    // This is to avoid infinite loop when calling path resolver
		    // for tab descriptors. The infinite loop happens when an invalid page
		    // request with empty page ID is passed.
		    if (pageRequest.pageID == "") {
		      curam.ui.UIController._log(debug
		        .getProperty("curam.ui.UIController.ignoring") + " "
		        + pageRequest.getURL());
		      return;
		    }

		    var continueSynchronously =
		        curam.ui.UIController._ensurePageAssociationInitialized(
		            pageRequest, function() {
		              /* At this point (after calling _ensurePageAssociationInitialized)
		               * the associations should be there.
		               * If not, something has gone wrong and we won't try again
		               * otherwiise we risk infinite recursion loop.
		               */
		              if (curam.ui.UIController.isPageAssociationInitialized(
		                  pageRequest.pageID, curam.ui.UIController.PAGE_ASSOCIATIONS)) {

		                curam.ui.UIController.checkPage(pageRequest, unmappedPageLoader);   

		              } else {
		                var msg = debug.getProperty("curam.ui.UIController.failed");
		                curam.ui.UIController._log(msg);
		                throw new Error(msg);
		              }
		            });

		    if (continueSynchronously) {
		      try {
		        var tabDescriptor = curam.ui.UIController.getTabDescriptorForPage(
		            pageRequest.pageID, curam.ui.UIController.PAGE_ASSOCIATIONS, preferredTabs);

		        if (tabDescriptor != null) {
		        	
		        	if(shouldLoadPage) {
		        		curam.ui.UIController._log(debug
		        				.getProperty("curam.ui.UIController.page.opened")
		        				+ " '" + pageRequest.pageID
		        				+ "'. " + debug.getProperty("curam.ui.UIController.sec.id")
		        				+ " '" + tabDescriptor.sectionID
		        				+ "'. " + debug.getProperty("curam.ui.UIController.tab.id")
		        				+ " '" + tabDescriptor.tabID + "'.");

						// This page is mapped to a tab.
		        		if (pageRequest.isHomePage) {
		        			// Required for default section pages. TODO: Clean this up. -- DG
		        			tabDescriptor.isHomePage = true;
		        		}
		        		tabDescriptor.setTabContent(pageRequest);
		        		dojo.publish(curam.ui.UIController.TAB_TOPIC,
		    				[new curam.ui.OpenTabEvent(tabDescriptor, pageRequest)]);
		        	}
		        	
		        	if(successCallback){
		        		successCallback();
		        	}

		        } else {
		          // This page is not mapped to any tabs
		          curam.ui.UIController._log(debug
		            .getProperty("curam.ui.UIController.page.id") + " '"
		              + pageRequest.pageID + "'.");
		          if (!unmappedPageLoaderCallback || 
		        		  typeof unmappedPageLoaderCallback != "function") {
		            if (typeof curam.tab.getSelectedTab() == "undefined") {
		              // the page to open hasn't been associated with any tab and no tab
		              // open so either opens from the shortcut panel or menu.
		              // This is a misconfiguration and hence exception is throw
		              throw {
		                name: curam.ui.UIController.UNASSOCIATED_SHORTCUT_ERROR,
		                message: "ERROR:The requested page " + pageRequest.pageID
		                          + " is not associated with any tab and there is no "
		                          + "tab to open it!" };

		            }
		            
		            if(shouldLoadPage) {
		            	curam.ui.UIController._log(debug.getProperty("curam.ui.UIController.load"));
		            	curam.ui.UIController._getTabbedUiApi().openPageInCurrentTab(pageRequest);
		            }
		          } else {
		            curam.ui.UIController._log(debug
		              .getProperty("curam.ui.UIController.unmapped"));
		            unmappedPageLoaderCallback(pageRequest);
		          }
		        }

		      } catch (e) {
		        if (e.name == curam.ui.UIController.DUPLICATE_TAB_MAPPING_ERROR) {
		        	if(!moreThanOneTabMappedCallback){
		        		// The page is referenced by multiple tabs, show this error.
		            	alert(e.message);

		            	// Now open the page in the current tab
		            	curam.ui.UIController._getTabbedUiApi().openPageInCurrentTab(pageRequest);
		        	}else {
		        		moreThanOneTabMappedCallback(pageRequest);
		        	}
		        	
		        	return null;
		        } else
		          if (e.name == curam.ui.UIController.UNASSOCIATED_SHORTCUT_ERROR) {
		          alert(e.message);
		          console.error(e.message);
		          return null;

		        } else {
		          throw e;
		        }
		      }
		    }
		  },

		  isPageAssociationInitialized: function(pageID, pageAssociations) {
		    var pageAssociation = pageAssociations[pageID];
		    return !(typeof pageAssociation == "undefined");
		  },

		  /**
		   * Checks if the page association has been initialized.
		   * If they have than the function does nothing else and returns true.
		   * If they haven't than asynchronous call is made to initialize them
		   * and the callback function is invoked after init is done.
		   *
		   * @param pageRequest The page request to check.
		   * @param callback the function to call after the page associations have been
		   *    asynchronously initialized.
		   * @return True if the associations are already initialized and the caller
		   *    can continue synchronously. False if the associations are not initialized
		   *    yet and will be initialized asynchronously.
		   */
		  _ensurePageAssociationInitialized: function(pageRequest, callback) {
		    if (!curam.ui.UIController.isPageAssociationInitialized(
		        pageRequest.pageID, curam.ui.UIController.PAGE_ASSOCIATIONS)) {
		      /* Page associations for this page have not been initialized. An AJAX
		       * query is used to retrieve the associations from the the server.
		       *
		       * The "initializePageAssociations" function is invoked on a successful
		       * response from the AJAX query. This method populates
		       * the PAGE_ASSOCIATIONS map and does nothing else.
		       * The callback reference is subsequently invoked to process the map
		       * now that it has been populated.
		       */
		      var path = "/config/tablayout/associated[" + pageRequest.pageID + "]["
		      + USER_APPLICATION_ID + "]";

		  new curam.ui.ClientDataAccessor().getRaw(
		      path,
		      function(data) {
		        curam.ui.UIController.initializePageAssociations(
		            pageRequest, data);
		        callback();
		      },

		      function(error, args) {
		        // use localizable error message and append the actual error text
		        var msg = curam_ui_UIController_data_error + " " + error;
		        curam.ui.UIController._log(msg);
		        if (!curamRequest.checkLoginPage(args.xhr)) {
		          // If not a session timeout scenario, display error message before
		          // reloading the application.
		          alert(msg);
		        }
		        /* If the server call fails we force the application to reload.
		         * This takes care of situations where the session timeout occurs
		         * and we need to force the login screen.
		         * In cases of a failure other than due to timeout the same
		         * behaviour is used
		         */
		        var topWin = curam.util.getTopmostWindow();
		        
		        // Unload any spinners before reloading.
		        topWin.dojo.publish("/curam/progress/unload");
		        
		        // specifically pass false so that browser uses cached resources
		        // where possible
		        topWin.location.reload(false);
		      }, null);

		      return false;
		    }

		    return true;
		  },
		  
		  /**
		   * This method initializes the PAGE_ASSOCIATIONS map for the specified page
		   * with data provided by the
		   * "/config/tablayout/associated[pageID][applicationID]" path. The path is
		   * executed asynchronously using the ClientDataAccessor API and this method is
		   * set up as a call-back when the AJAX query successfully completes.
		   *
		   * This method expects the first parameter to be the page ID used in the
		   * "/associated" path. When the call-back is being created, dojo.hitch() is
		   * used to bind the parameter value to the call back (search for references
		   * to this function for details). The "result" and "ioargs" parameters are
		   * supplied by dojo itself as a result of using "dojo.xhrGet\xhrPost".
		   *
		   * @param pageRequest An instance of curam.ui.PageRequest which indicates the
		   *                    page to initialize associations for.
		   * @param result A valid object, it will never be null. If associations exist
		   *               this object will have two properties: "sectionID" and
		   *               "tabIDs", the latter being an array of associated tab IDs.
		   */
		  initializePageAssociations: function(pageRequest, result) {
		    curam.ui.UIController._log(debug
		      .getProperty("curam.ui.UIController.got.assoc") + " '"
		        + pageRequest.pageID + "'.");
		    curam.ui.UIController._log(debug
		      .getProperty("curam.ui.UIController.assoc"), result);
		    if (result) {
		      if (result.tabIDs && result.tabIDs.length > 0) {
		        curam.ui.UIController.PAGE_ASSOCIATIONS[pageRequest.pageID] = result;
		      } else {
		        curam.ui.UIController._log(debug
		          .getProperty("curam.ui.UIController.no.mappings") + " '"
		            + pageRequest.pageID + "'.");
		        curam.ui.UIController.PAGE_ASSOCIATIONS[pageRequest.pageID] = null;
		      }
		    } else {
		      throw "initializePageAssociations did not recieve a valid response.";
		    }
		  },

		  /**
		   * Retrieves information about the target tab for the specified page ID.
		   * @param {String} pageId Id of the page.
		   * @param {Object} pageAssociations Page associons to get the tab information
		   *    from.
		   * @param {Array} preferredTabs List of preferred tabs to be used case the 
		   * 	page id is mapped to more than one tab. The first preferred tab
		   *    that the user have access will be used.   
		   * @return {curam.tab.TabDescriptor} A corresponding tab descriptor or null
		   *    if the page is not mapped to any tabs.
		   */
		  getTabDescriptorForPage: function (pageId, pageAssociations, preferredTabs) {
		    var pageAssociation = pageAssociations[pageId];
		    if (!curam.ui.UIController.isPageAssociationInitialized(
		        pageId, pageAssociations)) {
		      throw "Page associations have not been initialized for: " + pageId;
		    }

		    if (pageAssociation != null) {
		      var tabID = curam.ui.UIController.getTabFromMappings(
		          pageAssociation.tabIDs, curam.tab.getSelectedTab(), preferredTabs);

		      return new curam.tab.TabDescriptor(pageAssociation.sectionID, tabID);

		    } else {
		      // page is not mapped to any tabs
		      return null;
		    }
		  },

		  getTabFromMappings: function(tabMappings, selectedTab, preferredTabs) {
		    if (!selectedTab) {
		      // if there is no tab open, then it's the very first page request,
		      // the home page. we check the number of mappings. The home page should
		      // always be assigned to a single tab.
		      if (tabMappings.length == 1) {
		        return tabMappings[0];
		      } else if (tabMappings.length > 1 ) {
			    //Preferred tabs used by the application search to open 
			    //pages used in more than on tab.  
		    	if(preferredTabs && preferredTabs.length > 0){
		    	  for (var i = 0; i < preferredTabs.length; i++) {
		    	    if(tabMappings.indexOf(preferredTabs[i]) >= 0){
		    	      return preferredTabs[i];
		    	    }      
		    	  }
		    	}     	  
		    	  
		        // TODO: localize
		        throw "Home page mapped to multiple tabs";
		      }
		    }
		    //Preferred tabs used by the application search to open 
		    //pages used in more than on tab.
		    if(tabMappings.length > 1 && 
		    		preferredTabs && preferredTabs.length > 0){
		        for (var i = 0; i < preferredTabs.length; i++) {
		          if(tabMappings.indexOf(preferredTabs[i]) >= 0){
		        	  return preferredTabs[i];
		          }      
		    	}
		    }
		    
		    var currentTabID = selectedTab.tabDescriptor.tabID;
		    
		    for (var i = 0; i < tabMappings.length; i++) {
		      if (currentTabID == tabMappings[i]) {
		        return currentTabID;
		      }
		    }

		    if (tabMappings.length == 1) {
		      return tabMappings[0];
		    } else if (tabMappings.length > 1 ) {
		    
		      throw {
		        name: curam.ui.UIController.DUPLICATE_TAB_MAPPING_ERROR,
		        message:
		          "ERROR: The page that you are trying to link to is associated with "
		          + "multiple tabs: [" + tabMappings.toString() + "]. Therefore the "
		          + "tab to open cannot be determined and the page will open in the "
		          + "current tab. Please report this error.",
		        tabID: currentTabID
		      };
		    } else {
		      //TODO: scenario where there are no tab mappings.....
		    }
		  },

		  /**
		   * Convenience function that takes a UIM Page ID and performs the usual
		   * link handling on it (opening new sections, tabs etc.)
		   *
		   * @param {String} pageID The ID of the page to be opened in a tab.
		   * @param {Boolean} isDefaultSectionPage True if this is a default section
		   *   page and therefore should not be closeable.
		   */
		  handleUIMPageID: function(pageID, isDefaultSectionPage) {
		    // Normalize the Boolean value. Default section pages are treated the same
		    // as home pages. This only means that they are not closeable.
		    var isHomePage = isDefaultSectionPage ? true : false;

		    curam.ui.UIController._log(debug
		      .getProperty("curam.ui.UIController.handling.uim")
		        + " '" + pageID + "'. Page is "
		        + (isHomePage ? "" : "not ")
		        + debug.getProperty("curam.ui.UIController.default.sec"));

		    curam.ui.UIController.handlePageRequest(
		        new curam.ui.PageRequest(pageID + "Page.do", isHomePage));
		  },

		  /**
		   * Processes the supplied URL to figure out if it should open in a new tab
		   * or in the current tab.
		   * @param url A url in the form "SamplePage.do?param=value". This is usually
		   *            the value of a href taken from a link. If must not have the http
		   *            protocol, server addresses etc.
		   */
		  processURL: function(url) {
		    var uimPageRequest = new curam.ui.PageRequest(url);
		    curam.ui.UIController.handlePageRequest(uimPageRequest);
		  },

		  handlePageRequest: function(uimPageRequest, preferredTabs) {
		    curam.ui.UIController._log(debug
		      .getProperty("curam.ui.UIController.handling.page")
		        + " '" + uimPageRequest.pageID
		        + "'. " + debug.getProperty("curam.ui.UIController.panel.will")
		        + (uimPageRequest.forceRefresh ? "" :
		          debug.getProperty("curam.ui.UIController.not"))
		        + debug.getProperty("curam.ui.UIController.reload"));
		    var canCheckPage = curam.ui.UIController.checkResolvePage(uimPageRequest,
		        uimPageRequest.forceRefresh, null, preferredTabs);
		    if (canCheckPage == true) { 
		      curam.ui.UIController.checkPage(uimPageRequest, { preferredTabs : preferredTabs });
		    }
		  },

		  checkResolvePage: function(uimPageRequest, forceRefresh, unmappedPageLoader, 
				  preferredTabs, moreThanOneTabMappedCallback, shouldLoadPage, successCallback) {
			var optionalAttributes = { 
				unmappedPageLoader : unmappedPageLoader,
				moreThanOneTabMappedCallback : moreThanOneTabMappedCallback,
				shouldLoadPage : shouldLoadPage,
				successCallback : successCallback, 
				preferredTabs : preferredTabs
			}  
			  
		    if (forceRefresh) {
		      return true;
		    }
		    var isResolvePage =
		      curam.ui.UIController.RESOLVE_PAGES[uimPageRequest.pageID];
		    /* Below: checking specifically for Boolean "false" value as the value
		     * of "undefined" means we haven't yet checked if this page is a resolve
		     * page.
		     */
		    if (isResolvePage == false) {
		      return true;

		    } else {
		      var urlAppend;
		      if (uimPageRequest.getURL().indexOf("?") == -1) {
		        urlAppend = "?";
		      } else {
		        urlAppend = "&";
		      }
		      var loc = curam.config ? curam.config.locale + "/": "";
		      curamRequest.post({
		        url: loc + uimPageRequest.getURL() + urlAppend + "o3resolve=true",
		        handleAs: "text",
		        preventCache: true,
		        load: dojo.hitch(curam.ui.UIController, "resolvePageCheckSuccess",
		                         uimPageRequest, optionalAttributes),
		        error: dojo.hitch(curam.ui.UIController, "resolvePageCheckFailure",
		                          uimPageRequest, optionalAttributes)
		      });
		      return false;
		    }
		  },

		  resolvePageCheckSuccess: function(pageRequest, optionalAttributes, result, ioargs) {
		    // check if Json data exists. If so continue on as normal. If json data is
		    // not present (in the agenda player or maybe an external site) skip the
		    // resolve page check.
		    var jsonDataExists = false;
		    var resultPageID;
		    var resultPageURL;
		    var pageRequestToProcess;

		    if(result.substring(2,0) == '{"' && result.charAt(result.length-1) == "}"){
		      jsonDataExists = true;
		      // convert text data to a json object to be process below in the resolve
		      // page check.
		      result = dojoJSON.parse(result, true);
		      resultPageID = result.pageID;
		      resultPageURL = result.pageURL;
		    } else {
		      jsonDataExists = false;
		    }

		    if (jsonDataExists && pageRequest.pageID != resultPageID) {
		      // this means it must be a resolve page so record this.
		      curam.ui.UIController.RESOLVE_PAGES[pageRequest.pageID] = true;

		      // handle variations of o3resolve parameter appended to a URL.
		      // The third variation is to fall back on the code that existed before
		      // verison CR00221139.
		      resultPageURL = resultPageURL.replace("&amp;o3resolve=true", "");
		      resultPageURL = resultPageURL.replace("&o3resolve=true", "");
		      resultPageURL = resultPageURL.replace("o3resolve=true", "");

		      // TEMPORARY JAVA SCRIPT FIX FOR ISSUE WITH __o3 PARAMS BEING STRIPPED.
		      // The correct fix is to use a different getEncodedURL() method in the
		      // generated jspx file for the resolve page check, or parse the
		      // result.pageURL into another PageRequest and write a "merge" method
		      // obeying the rules below i.e. that we take CDEJ parameters from the
		      // original PageRequest that linked to the resolve page.
		      for (paramName in pageRequest.cdejParameters) {
		        if (paramName.length > 0 && paramName.indexOf("__o3") != -1) {
		          // Include the parameter, as it will be stripped
		          if (resultPageURL.indexOf("?") == -1) {
		            // NB: This code accesses "private" attributes of
		            // the PageRequest class (i.e. "cdejParameters). It therefore needs
		            // to handle encoding each parameter.
		            resultPageURL += "?" + paramName + "="
		                          + encodeURIComponent(
		                              pageRequest.cdejParameters[paramName]);
		          } else {
		            resultPageURL += "&" + paramName + "="
		                          + encodeURIComponent(
		                              pageRequest.cdejParameters[paramName]);
		          }
		        }
		      }
		      // This is a resolve page, so we create a new request.
		      pageRequestToProcess = new curam.ui.PageRequest(resultPageURL);
              if (pageRequest.forceLoad) {
                pageRequestToProcess.forceLoad = pageRequest.forceLoad;
              }
		    } else {
		      // Indicate it is not a resolve page so we don't have to do a call again
		      // to check this.
		      curam.ui.UIController.RESOLVE_PAGES[pageRequest.pageID] = false;
		      // As it was not a resolve page, we process the same request that was
		      // passed to this function.
		      pageRequestToProcess = pageRequest;
		    }
		    curam.ui.UIController.checkPage(pageRequestToProcess, optionalAttributes);
		  },

		  /**
		   * Handles the failure of the "resolve page check" AJAX query invoked from
		   * the "checkResolvePage" method.
		   * @param pageRequest An instance of a "curam.ui.PageRequest".
		   * @param error The JavaScript erro object indicating what the error was.
		   * @param optionalAttributes - list of callbacks.
		   * @param ioargs The object containing details information about the XHR call.
		   */
		  resolvePageCheckFailure: function(pageRequest, optionalAttributes, error, ioargs) {
		    // If an error occurs during the resolve check, then we let the page request
		    // continue. This ensures the response is displayed to the user in the
		    // content panel of the current tab. We also record that this isn't a
		    // resolve page. We don't actually care whether the page in question is a
		    // resolver or not. This just has the effect of the "handlePageRequest"
		    // method calling "curam.ui.UIController.checkPage" directly if the user
		    // clicks the same link again. It avoids invoking the AJAX quey in
		    // "checkResolvePage" again.
		    curam.ui.UIController.RESOLVE_PAGES[pageRequest.pageID] = false;
		    curam.ui.UIController.checkPage(pageRequest, optionalAttributes);
		  },

		  /**
		   * Set the title and name of a tab. This is invoked when the Dojo event
		   * "tab.title.name.set" is raised by the details panel "iframe". The tab name
		   * is set by a JavaScript call output by the tab renderer where there is no
		   * details panel. When reloading tabs on a refresh, the tab name is set from
		   * the value saved in the session.
		   *
		   * @param {Node} iFrameNode The "iframe" node that raised the event.
		   * @param {String} tabTitle The title of the tab.
		   * @param {String} tabName  The name to set on the tab.
		   */
		  setTabTitleAndName: function(iFrameNode, tabTitle, tabName) {
		    var tab = curam.tab.getContainerTab(iFrameNode);

		    if (tab) {
		      curam.ui.UIController._log(debug
		          .getProperty("curam.ui.UIController.changing.tab") + " '" + tabTitle
		          + "', '" + tabName + "'. " + debug
		          .getProperty("curam.ui.UIController.descriptor.before"),
		          tab.tabDescriptor);
		      // Set the tab title (above the details panel).
		      dojo.query("h1.detailsTitleText", tab.domNode)[0].innerHTML = tabTitle;
		      var tabTitleText = dojo.query("h1.detailsTitleText", tab.domNode)[0];
		      tabTitleText.setAttribute("title", tabTitle);
		      // Set the tab name (on the tab handle). A listener is set on the tab to
		      // connect to this call and record the new tab name in the session.
		      tab.set("title", tabName);
		      
		      var frameid;
		      for (var i=0; i<iFrameNode.classList.length; i++) {
		        if (iFrameNode.classList[i].indexOf("iframe-") == 0) {
		          frameid = iFrameNode.classList[i];
		          break;
		        }
		      }
		      dojo.publish("tab.title.name.finished", [{'title':tabName, 'frameid':frameid}]);
		    } else {
		      curam.ui.UIController._log(debug
		          .getProperty("curam.ui.UIController.cannot.change") + " '"
		          + tabTitle + "', '" + tabName + "'. " + debug
		          .getProperty("curam.ui.UIController.iframe") + " '"
		          + iFrameNode.id + "'.");
		    }
		  },

		  /**
		   * Handles click on the tab actions menu and section shortcuts panel links.
		   * Also called from the pages loaded in Cram dialogs.
		   *
		   * @param {String} targetUrl URL of the target page.
		   * @param {Object} modalWrapper the presence of this parameter indicates that
		   * the link should open in modal dialog. The object comes in the form of
		   * {openDialogFunction:openFunction, args:array of arguments} where both
		   * arguments are optional, the first specifying the custom modal opening
		   * function, should one be required, and the second - arguments to that
		   * function.
		   */
		  handleLinkClick: function(targetUrl, modalWrapper) {
		    curam.ui.UIController._doHandleLinkClick(
		        targetUrl,
		        modalWrapper,
		        curam.tab.getContentPanelIframe(),
		        curam.ui.UIController.handlePageRequest,
		        curam.util.openModalDialog);
		  },

		  /**
		   * Implement the link click handling logic.
		   *
		   * @private
		   *
		   * @param {String} targetUrl The URL to follow.
		   * @param {Object} [modalWrapper] The modal wrapper object.
		   * @param {Object} [iframe] The iframe to use as the source for the RPU value.
		   * @param {Function} requestHandler Function to call when page request
		   *    is to be handled by the linking infrastructure.
		   * @param {Function} defaultOpenDialog Function to call when page request
		   *    is to be opened in a dialog and there is no dialog open function
		   *    specified in the modalWrapper object.
		   */
		  _doHandleLinkClick: function(targetUrl, modalWrapper, iframe, requestHandler,
		      defaultOpenDialog) {

		    var newUrl = targetUrl;
		    if (iframe) {
		    var rtc = new curam.util.RuntimeContext(iframe.contentWindow);
		      var extraParaArray = null;
		    if(modalWrapper){
		        extraParaArray = [ {key:"o3frame", value:"modal"} ];
		      }
		      newUrl = curam.util.setRpu(targetUrl, rtc, extraParaArray);
		    }

		    // if modals are enabled, open in a modal
		    if (modalWrapper && curam.config && curam.config.modalsEnabled != "false") {
		      var dialogFunction = modalWrapper.openDialogFunction || defaultOpenDialog;
		      var fArgs =
		          modalWrapper.args || [{href:newUrl}, modalWrapper.dialogOptions];
		      dialogFunction.apply(this, fArgs);

		    } else {
		      var uimPageRequest = new curam.ui.PageRequest(newUrl);
		      requestHandler(uimPageRequest);
		    }
		  },

		  /**
		   * Handles the click event when a menu item in the Tab Actions Menu is used
		   * to download a file. NOTE: This is the legacy version of the method using
		   * a temporary iframe.
		   *
		   * @param {String} targetUrl URL to invoke the file download servlet.
		   */
		  handleDownLoadClickLegacy: function(targetUrl) {
		    require(["dojo/io/iframe"], function(ioIframe) {
		      var iframe = ioIframe.create("o3lrm_frame", "");
		      iframe.src = location.href.substring(0,location.href.lastIndexOf("/"))
		                   + decodeURIComponent(targetUrl.replace(/\+/g, " "));
		      return;
		    });   
		  },

		  /**
		   * Handles the click event when a menu item in the Tab Actions Menu is used
		   * to download a file.
		   *
		   * @param {String} targetUrl URL to invoke the file download servlet.
		   */
		  handleDownLoadClick: function(targetUrl) {
		    // Direct the file download request at the main content frame.
		    // If the request is successfull the browser will begin downloading the
		    // file and the content frame will be left as-is. If the request fails
		    // the response will be the application error page and will be displayed
		    // in the main content frame.
		    var iframe = curam.tab.getContentPanelIframe();
		    iframe.src = location.href.substring(0,location.href.lastIndexOf("/"))
		                 + decodeURIComponent(targetUrl.replace(/\+/g, " "))
		                 + "&" + jsScreenContext.toRequestString();
		    return;
		  },

		  /**
		   * Simplifies the production of consistent log messages from the UIController.
		   *
		   * @param {String} msg The message to be logged.
		   * @param object An optional object that will be converted to JSON form and
		   *   appended to the message string.
		   */
		  _log: function(msg, object) {
		    // If debug logging is turned off, then we do not want to keep the overhead
		    // of converting objects to JSON form to create the log message, so we
		    // check the DEBUG switch even before calling "curam.debug.log".
		    if (curam.debug.enabled()) {
		      curam.debug.log(
		          "UI CONTROLLER: " + msg + (object ? " " + dojo.toJson(object) : ""));
		    }
		  },

		  _prepareWordLanding:function() {
		    var as1, as2;
		    require(["dojo/aspect", "curam/tab"], function(asp) {
		      as1 = 
		        asp.before(curam.ui.UIController, "_doHandleTabEvent", function(ote, tabApi) {
		        var tabContainer = curam.tab.getTabContainer(ote.tabDescriptor.sectionID);
		          as2 = 
		            asp.after(tabApi, "findOpenTab", function(result) {
		              if (!result) {
		                ote.uimPageRequest.forceLoad = true;
		                tabs = tabContainer.getChildren();
		                for (var i = 0; i < tabs.length; i++) {
		                  var currentTab = tabs[i];
		                  var curTD = currentTab.tabDescriptor;
		                  if (curTD && curTD.tabID == ote.tabDescriptor.tabID) {
		                    result = currentTab;
		                  }
		                }
		              }
		              as2.remove();
		              return result;    
		            });
		          as1.remove();
		      });
		    });
		    dojo.subscribe("curam/fileedit/aspect/release", function(){
		      if (as2 != null) {
		        as2.remove();
		      }
		      as1.remove();
		    });
		    return as1;
		  }
		  });
		  layer.register("curam/ui/UIController", curam.ui.UIController);

		  return curam.ui.UIController;
});

},
'curam/FastUIMController':function(){
/*
 * Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012-2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

  /*
   * Modification History
   * --------------------
   * 22-Sep-2014  SK [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 23-Oct-2012  SK  [CR00346419] Now properly unsubscribes from the onload
   *    registry to avoid memory leak.
   * 11-Sep-2012  MV  [CR00339639] Initial version, this is a clone
   *    of curam/UIMController to achieve faster loading of main content panel.
   */

define(["dojo/_base/declare",
        "dojo/parser",
        "dijit/registry",
        "curam/inspection/Layer",
        "curam/UIMController",
        "curam/debug",
        "dojo/dom-class",
        "dojo/dom-style",
        "dojo/dom-attr",
        "curam/util/onLoad"], function(declare, parser, registry, layer, uimController, debug, domClass, domStyle, domAttr) {
  
  /**
   * @name curam.FastUIMController
   * @namespace Create and manage a widget that controls an IFRAME that is known
   * to load UIM pages. The controller will handle official communications
   * from the IFRAME to the parent window using the event system.
   * This will bridge the gap created by security restrictions that stop parent
   * windows manipulating the content of IFRAMES they control.
   * 
   * The controller also provides "In Page Navigation" functionality by creating
   * a tab controller to handle the page linking described by In Page Navigation
   * in the UIM file.
   *
   */
 
  
  var FastUIMController = declare("curam.FastUIMController",
        [curam.UIMController],
  /**
   * @lends curam.FastUIMController.prototype
   */
  {
    buildRendering: function() {
      // we already have the srcNodeRef, so lets just
      // keep it and use it as the domNode
      this.domNode = this.srcNodeRef;
      
      // call this._attachTemplateNodes to parse the template,
      // which is actually just the srcnode
      // this method is provided by the _TemplatedMixin
      this._attachTemplateNodes(this.domNode, function(node, prop){
        return node.getAttribute(prop);
      });
    },
    
    postCreate: function() {
      // override to stop using superclass method
      layer.register("curam/FastUIMController", this);
      //this.inherited(arguments);
    },
    
    /**
     * after the widget has been created add a listener for events
     * coming from the iframe, then load the iframe. It is important that the
     * order is maintained here as adding the listener after loading the iframe
     * will mean the events are missed.
     */
    startup: function() {
      this.tabController = registry.byId(this.tabControllerId);
    
      domAttr.set(this.frame, "iscpiframe", this.iscpiframe);
      domAttr.set(this.frame, "title", this.title);
      domClass.add(this.frame, this.iframeClassList);
      domClass.add(this.domNode, this.classList);

      /* width and height specified on dom node in application.css
      domAttr.set(this.domNode, 
          "style", {"height": this.height,"width": this.width});
      debug.log(
          "FastUIMController Height: " + domStyle.set(this.domNode,"height"));
      debug.log(
          "FastUIMController Width: " + domStyle.set(this.domNode,"width"));
      */

      this.frameLoadEvent = this.EVENT.TOPIC_PREFIX + this.frame.id;
      
      this.setURL(this.url);

      // subscribe for onLoad events on the iframe
      if (this._iframeLoaded()) {
        // process the page already loaded in the frame
        // TODO: FUIMC already loaded - process page
        debug.log("curam.FastUIMController " 
          + debug.getProperty("curam.FastUIMControlle.msg"));
        
      } else {
        var fLoadFunct = dojo.hitch(this, "processFrameLoadEvent");
        curam.util.onLoad.addSubscriber(this.frame.id, fLoadFunct);
        dojo.connect(this, "destroy", function() {
          curam.util.onLoad.removeSubscriber(this.iframeId, fLoadFunct);
          fLoadFunct = null;
        });
      }

      if (this.inDialog) {
        // Set the initial dimensions of the iframe.
        // The width is particularly important for correct automatic height
        // calculation in dialogs
        domStyle.set(this.frame, {
          width: this.width,
          height: this.height
        });
      }
    },
    
    _iframeLoaded: function() {
      return domAttr.get(this.frame, "data-done-loading") == "true";
    }
  });

  return FastUIMController;
});

},
'curam/cdsl/connection/SimpleAccess':function(){
/*
 * Copyright 2014 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 06-Oct-2014  JY  [CR00446378] Initial version.
 */

  /**
   * @name curam.cdsl.connection.SimpleAccess
   * @namespace Simplified APIs to direct requesting the Curam cdsl layer. 
   */
define(["curam/cdsl/_base/_Connection",
        "curam/cdsl/store/CuramStore",
        "curam/cdsl/request/CuramService",
        "curam/cdsl/_base/FacadeMethodCall",
        "curam/cdsl/Struct",
        "dojo/_base/lang",
        "dojo/store/Observable",
        "dojo/store/Cache",
        "dojo/store/Memory"
        ], function(
            _Connection, 
            CuramStore,
            CuramService,
            FacadeMethodCall,
            Struct,
            lang,
            Observable,
            Cache,
            Memory) {
  
  //The connection object held here is a singleton. 
  var connection = null;
  
  /**
   * @lends curam.cdsl.connection.SimpleAccess.prototype
   */
  return {
    
    /**
     * Initialize the connection object. Once it is set, it can not be changed.
     * 
     * @param {curam/cdsl/_base/_Connection} connectionObj The connection object
     *  to be used. Use an instance of curam/cdsl/connection/CuramConnection
     *  class.
     * @return {curam/cdsl/_base/_Connection} An instance of the
     *  curam/cdsl/_base/_Connection class.
     */
    initConnection: function(connectionObj) {
      
      if (connectionObj == null) {
        throw new Error("The connection object should be provided.");
        
      } else if (!(connectionObj instanceof _Connection)){
        
        throw new Error("The wrong type of the connection object is provided.");
      }
      
      // Initializing the connection object.
      // Lazy loading.
      if (connection == null) {
        connection = connectionObj;
      }
      
      return connection;
    },
    
    /**
     * Builds an instance of curam/cdsl/store/CuramStore.
     * 
     * @param {String} facadeClassName Name of the facade class that contains
     *  specific modeled methods to be used by the store.
     * @param {curam/cdsl/store/IdentityApi} identityApi An instance of the 
	 *  IdentityApi.
     * @param {boolean} observable The indicator to make the store observable
     *  or not.
     * @param {boolean} cache The indicator to wrap the curam store with a 
     *  cache store.
     * @return {curam/cdsl/store/CuramStore} An instance of the CuramStore. 
     */
    buildStore: function(facadeClassName, identityApi, observable, cache) {                  

      if (connection == null) {
        throw new Error("The connection shoud be initialized first with initConnection() before using this API.");
      }
      
      
      if(facadeClassName == null){
              throw new Error("Facade class name is missing.");
      }                     
      
      if(cache == null){
        cache = false;
      }
      
      if(observable == null){
        observable = false;
      }
                   
      
      var store = new CuramStore(connection, facadeClassName, identityApi);
      
      if (observable) {
        store = new Observable(store);
      }
      
      if (cache) {
        var cacheStore = new Memory();
        store = new Cache(store, cacheStore);
      }
      
      return store;
    },
    
    /**
     * Makes a request to the Curam facade layer for the specified server
     * interface method calls.
     * 
     * @param {String} facadeClassName Name of the server interface to call.
     * @param {String} facadeMethodName Name of the server interface method to call. 
     * @param {Object} facadeMethodParmas The object containing all the method
     *  parameters that required by the server interface method.
     * @returns {dojo/Promise::[curam/cdsl/Struct]} A promise for the array
     *  of Struct objects returned from the server call.
     */
    makeRequest: function(facadeClassName, facadeMethodName, facadeMethodParmas) {      
      
      if (connection == null) {
        throw new Error("The connection shoud be initialized first with initConnection() before using this API.");
      }
      
      
      if(facadeClassName == null){
        throw new Error("Facade class name is missing.");
      }
      
      if(facadeMethodName == null){
              throw new Error("Facade method name is missing.");
      }
      
      var service = new CuramService(connection);
      
      var idStructs;
      
      if(facadeMethodParmas == null) {
        
        idStructs = [];
      } else {
        
        idStructs = [new Struct(facadeMethodParmas)];
      }

      var methodCall = new FacadeMethodCall(facadeClassName,
          facadeMethodName, idStructs);
      
      return service.call([methodCall]);
    }
  };
});
},
'cm/_base/_pageBehaviors':function(){
define(["cm/_base/_behavior"
        ], function() {

  /*
  This file contains behaviors that can be added to the page
  using the cm.addBehavior function.
  */

  var cm = dojo.global.cm || {};
  dojo.global.cm = cm;

  cm.registerBehavior("FORM_SINGLE_SUBMIT", {
    "form" : {
      "onsubmit" : function(evt) {
        if (cm.wasFormSubmitted(evt.target)) {
          try {dojo.stopEvent(evt);}catch(e){}
          return false;
        }
        cm.setFormSubmitted(evt.target, true);
      }
    }
  });

  function getVal(type){
    return function(evt) {
      cm.validation.validateMandatory(evt.target ? evt.target : evt, type);
    };
  };

  function getValWithEvts(type, events) {
    var obj = {};
    var fn = getVal(type);
    dojo.forEach(events, function(evt) {
      obj[evt] = fn;
    });
    obj.found = function(node) {
      // Register the validation with the system.
      cm.validation.registerValidation(node.getAttribute("name"), fn, node);
      // Run the validation on each input when the page loads.
      fn(node);
    };
    return obj;
  };

  cm.registerBehavior("MANDATORY_FIELD_VALIDATION", {
    
    "input[type='text'],input[type='password']" :getValWithEvts("text", ["blur", "onkeyup"]),
    
    "input[type='checkbox']" :getValWithEvts("checkbox", ["blur", "onclick"]),
    
    "select": getValWithEvts("select", ["blur", "onchange"]),
    
    "input[type='radio']" : getValWithEvts("radio", ["blur", "onclick"])
  });
  
  return cm;
});

},
'curam/layout/CuramTabContainer':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.layout.CuramTabContainer
 * @namespace Customized dijit.layout.TabContainer class that uses
 *    our customized curam.layout.ScrollingTabController.
 * 
 */
define(["dojo/_base/lang",
        "dojo/_base/declare",
        "dijit/layout/TabContainer",
        "curam/layout/ScrollingTabController",
        "dijit/layout/TabController"
        ], function(lang, declare, TabContainer, CuramScrollingTabController,
            TabController) {
/*
 * Modification History
 * --------------------
 * 15-Sep-2014  MV [CR00444915] Add missing import.
 * 30-Sep-2013  MK [CR00390932] Upgrade to Dojo 1.9 
 * 02-May-2012  MK [CR00323691] Use new Dojo AMD format.
 * 22-Nov-2010  MV [CR00231655] Replaced the compressed version with the proper
 *    source.
 */

var CuramTabContainer = declare("curam.layout.CuramTabContainer", dijit.layout.TabContainer,
/**
 * @lends curam.layout.CuramTabContainer.prototype
 */
{
  postMixInProperties: function() {
    // Scrolling controller only works for horizontal non-nested tabs
    if(!this.controllerWidget){
      this.controllerWidget =
          (this.tabPosition == "top" || this.tabPosition == "bottom")
          && !this.nested
          ? CuramScrollingTabController : TabController;
    }

    this.inherited(arguments);
  }
});

return CuramTabContainer;

});

},
'dijit/form/_FormSelectWidget':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map array.some
	"dojo/_base/Deferred",
	"dojo/aspect", // aspect.after
	"dojo/data/util/sorter", // util.sorter.createSortFunction
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel",	// _scopeName
	"dojo/_base/lang", // lang.delegate lang.isArray lang.isObject lang.hitch
	"dojo/query", // query
	"dojo/when",
	"dojo/store/util/QueryResults",
	"./_FormValueWidget"
], function(array, Deferred, aspect, sorter, declare, dom, domClass, kernel, lang, query, when,
			QueryResults, _FormValueWidget){

	// module:
	//		dijit/form/_FormSelectWidget

	/*=====
	var __SelectOption = {
		// value: String
		//		The value of the option.  Setting to empty (or missing) will
		//		place a separator at that location
		// label: String
		//		The label for our option.  It can contain html tags.
		// selected: Boolean
		//		Whether or not we are a selected option
		// disabled: Boolean
		//		Whether or not this specific option is disabled
	};
	=====*/

	var _FormSelectWidget = declare("dijit.form._FormSelectWidget", _FormValueWidget, {
		// summary:
		//		Extends _FormValueWidget in order to provide "select-specific"
		//		values - i.e., those values that are unique to `<select>` elements.
		//		This also provides the mechanism for reading the elements from
		//		a store, if desired.

		// multiple: [const] Boolean
		//		Whether or not we are multi-valued
		multiple: false,

		// options: __SelectOption[]
		//		The set of options for our select item.  Roughly corresponds to
		//		the html `<option>` tag.
		options: null,

		// store: dojo/store/api/Store
		//		A store to use for getting our list of options - rather than reading them
		//		from the `<option>` html tags.   Should support getIdentity().
		//		For back-compat store can also be a dojo/data/api/Identity.
		store: null,
		_setStoreAttr: function(val){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(val);
			}
		},

		// query: object
		//		A query to use when fetching items from our store
		query: null,
		_setQueryAttr: function(query){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {query: query});
			}
		},

		// queryOptions: object
		//		Query options to use when fetching from the store
		queryOptions: null,
		_setQueryOptionsAttr: function(queryOptions){
			if(this._created){		// don't repeat work that will happen in postCreate()
				this._deprecatedSetStore(this.store, this.selectedValue, {queryOptions: queryOptions});
			}
		},

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the dojo.store items.
		//		If ``store`` is set, labelAttr must be set too, unless store is an old-style
		//		dojo.data store rather than a new dojo/store.
		labelAttr: "",

		// onFetch: Function
		//		A callback to do with an onFetch - but before any items are actually
		//		iterated over (i.e. to filter even further what you want to add)
		onFetch: null,

		// sortByLabel: Boolean
		//		Flag to sort the options returned from a store by the label of
		//		the store.
		sortByLabel: true,


		// loadChildrenOnOpen: Boolean
		//		By default loadChildren is called when the items are fetched from the
		//		store.  This property allows delaying loadChildren (and the creation
		//		of the options/menuitems) until the user clicks the button to open the
		//		dropdown.
		loadChildrenOnOpen: false,

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by setStore().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior setStore completes.
		onLoadDeferred: null,

		getOptions: function(/*anything*/ valueOrIdx){
			// summary:
			//		Returns a given option (or options).
			// valueOrIdx:
			//		If passed in as a string, that string is used to look up the option
			//		in the array of options - based on the value property.
			//		(See dijit/form/_FormSelectWidget.__SelectOption).
			//
			//		If passed in a number, then the option with the given index (0-based)
			//		within this select will be returned.
			//
			//		If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will be
			//		returned if and only if it exists within this select.
			//
			//		If passed an array, then an array will be returned with each element
			//		in the array being looked up.
			//
			//		If not passed a value, then all options will be returned
			//
			// returns:
			//		The option corresponding with the given value or index.
			//		null is returned if any of the following are true:
			//
			//		- A string value is passed in which doesn't exist
			//		- An index is passed in which is outside the bounds of the array of options
			//		- A dijit/form/_FormSelectWidget.__SelectOption is passed in which is not a part of the select

			// NOTE: the compare for passing in a dijit/form/_FormSelectWidget.__SelectOption checks
			//		if the value property matches - NOT if the exact option exists
			// NOTE: if passing in an array, null elements will be placed in the returned
			//		array when a value is not found.
			var opts = this.options || [];

			if(valueOrIdx == null){
				return opts; // __SelectOption[]
			}
			if(lang.isArrayLike(valueOrIdx)){
				return array.map(valueOrIdx, "return this.getOptions(item);", this); // __SelectOption[]
			}
			if(lang.isString(valueOrIdx)){
				valueOrIdx = { value: valueOrIdx };
			}
			if(lang.isObject(valueOrIdx)){
				// We were passed an option - so see if it's in our array (directly),
				// and if it's not, try and find it by value.

				if(!array.some(opts, function(option, idx){
					for(var a in valueOrIdx){
						if(!(a in option) || option[a] != valueOrIdx[a]){ // == and not === so that 100 matches '100'
							return false;
						}
					}
					valueOrIdx = idx;
					return true; // stops iteration through opts
				})){
					valueOrIdx = -1;
				}
			}
			if(valueOrIdx >= 0 && valueOrIdx < opts.length){
				return opts[valueOrIdx]; // __SelectOption
			}
			return null; // null
		},

		addOption: function(/*__SelectOption|__SelectOption[]*/ option){
			// summary:
			//		Adds an option or options to the end of the select.  If value
			//		of the option is empty or missing, a separator is created instead.
			//		Passing in an array of options will yield slightly better performance
			//		since the children are only loaded once.
			array.forEach(lang.isArrayLike(option) ? option : [option], function(i){
				if(i && lang.isObject(i)){
					this.options.push(i);
				}
			}, this);
			this._loadChildren();
		},

		removeOption: function(/*String|__SelectOption|Number|Array*/ valueOrIdx){
			// summary:
			//		Removes the given option or options.  You can remove by string
			//		(in which case the value is removed), number (in which case the
			//		index in the options array is removed), or select option (in
			//		which case, the select option with a matching value is removed).
			//		You can also pass in an array of those values for a slightly
			//		better performance since the children are only loaded once.
			//		For numeric option values, specify {value: number} as the argument.
			var oldOpts = this.getOptions(lang.isArrayLike(valueOrIdx) ? valueOrIdx : [valueOrIdx]);
			array.forEach(oldOpts, function(option){
				// We can get null back in our array - if our option was not found.  In
				// that case, we don't want to blow up...
				if(option){
					this.options = array.filter(this.options, function(node){
						return (node.value !== option.value || node.label !== option.label);
					});
					this._removeOptionItem(option);
				}
			}, this);
			this._loadChildren();
		},

		updateOption: function(/*__SelectOption|__SelectOption[]*/ newOption){
			// summary:
			//		Updates the values of the given option.  The option to update
			//		is matched based on the value of the entered option.  Passing
			//		in an array of new options will yield better performance since
			//		the children will only be loaded once.
			array.forEach(lang.isArrayLike(newOption) ? newOption : [newOption], function(i){
				var oldOpt = this.getOptions({ value: i.value }), k;
				if(oldOpt){
					for(k in i){
						oldOpt[k] = i[k];
					}
				}
			}, this);
			this._loadChildren();
		},

		setStore: function(store, selectedValue, fetchArgs){
			kernel.deprecated(this.declaredClass+"::setStore(store, selectedValue, fetchArgs) is deprecated. Use set('query', fetchArgs.query), set('queryOptions', fetchArgs.queryOptions), set('store', store), or set('value', selectedValue) instead.", "", "2.0");
			this._deprecatedSetStore(store, selectedValue, fetchArgs);
		},

		_deprecatedSetStore: function(store, selectedValue, fetchArgs){
			// summary:
			//		Sets the store you would like to use with this select widget.
			//		The selected value is the value of the new store to set.  This
			//		function returns the original store, in case you want to reuse
			//		it or something.
			// store: dojo/store/api/Store
			//		The dojo.store you would like to use - it MUST implement getIdentity()
			//		and MAY implement observe().
			//		For backwards-compatibility this can also be a data.data store, in which case
			//		it MUST implement dojo/data/api/Identity,
			//		and MAY implement dojo/data/api/Notification.
			// selectedValue: anything?
			//		The value that this widget should set itself to *after* the store
			//		has been loaded
			// fetchArgs: Object?
			//		Hash of parameters to set filter on store, etc.
			//
			//		- query: new value for Select.query,
			//		- queryOptions: new value for Select.queryOptions,
			//		- onFetch: callback function for each item in data (Deprecated)
			var oStore = this.store;
			fetchArgs = fetchArgs || {};

			if(oStore !== store){
				// Our store has changed, so cancel any listeners on old store (remove for 2.0)
				var h;
				while((h = this._notifyConnections.pop())){
					h.remove();
				}

				// For backwards-compatibility, accept dojo.data store in addition to dojo.store.store.  Remove in 2.0.
				if(!store.get){
					lang.mixin(store, {
						_oldAPI: true,
						get: function(id){
							// summary:
							//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
							//		Like dojo.store.DataStore.get() except returns native item.
							var deferred = new Deferred();
							this.fetchItemByIdentity({
								identity: id,
								onItem: function(object){
									deferred.resolve(object);
								},
								onError: function(error){
									deferred.reject(error);
								}
							});
							return deferred.promise;
						},
						query: function(query, options){
							// summary:
							//		Queries the store for objects.   Like dojo/store/DataStore.query()
							//		except returned Deferred contains array of native items.
							var deferred = new Deferred(function(){
								if(fetchHandle.abort){
									fetchHandle.abort();
								}
							});
							deferred.total = new Deferred();
							var fetchHandle = this.fetch(lang.mixin({
								query: query,
								onBegin: function(count){
									deferred.total.resolve(count);
								},
								onComplete: function(results){
									deferred.resolve(results);
								},
								onError: function(error){
									deferred.reject(error);
								}
							}, options));
							return new QueryResults(deferred);
						}
					});

					if(store.getFeatures()["dojo.data.api.Notification"]){
						this._notifyConnections = [
							aspect.after(store, "onNew", lang.hitch(this, "_onNewItem"), true),
							aspect.after(store, "onDelete", lang.hitch(this, "_onDeleteItem"), true),
							aspect.after(store, "onSet", lang.hitch(this, "_onSetItem"), true)
						];
					}
				}
				this._set("store", store);			// Our store has changed, so update our notifications
			}

			// Remove existing options (if there are any)
			if(this.options && this.options.length){
				this.removeOption(this.options);
			}

			// Cancel listener for updates to old (dojo.data) store
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			// If user has specified new query and query options along with this new store, then use them.
			if(fetchArgs.query){
				this._set("query", fetchArgs.query);
			}
			if(fetchArgs.queryOptions){
				this._set("queryOptions", fetchArgs.queryOptions);
			}

			// Add our new options
			if(store && store.query){
				this._loadingStore = true;
				this.onLoadDeferred = new Deferred();

				// Run query
				// Save result in this._queryRes so we can cancel the listeners we register below
				this._queryRes = store.query(this.query, this.queryOptions);
				when(this._queryRes, lang.hitch(this, function(items){

					if(this.sortByLabel && !fetchArgs.sort && items.length){
						if(store.getValue){
							// Old dojo.data API to access items, remove for 2.0
							items.sort(sorter.createSortFunction([
								{
									attribute: store.getLabelAttributes(items[0])[0]
								}
							], store));
						}else{
							// TODO: remove sortByLabel completely for 2.0?  It can be handled by queryOptions: {sort: ... }.
							var labelAttr = this.labelAttr;
							items.sort(function(a, b){
								return a[labelAttr] > b[labelAttr] ? 1 : b[labelAttr] > a[labelAttr] ? -1 : 0;
							});
						}
					}

					if(fetchArgs.onFetch){
						items = fetchArgs.onFetch.call(this, items, fetchArgs);
					}

					// TODO: Add these guys as a batch, instead of separately
					array.forEach(items, function(i){
						this._addOptionForItem(i);
					}, this);

					// Register listener for store updates
					if(this._queryRes.observe){
						// observe returns yet another handle that needs its own explicit gc
						this._observeHandle = this._queryRes.observe(lang.hitch(this, function(object, deletedFrom, insertedInto){
							if(deletedFrom == insertedInto){
								this._onSetItem(object);
							}else{
								if(deletedFrom != -1){
									this._onDeleteItem(object);
								}
								if(insertedInto != -1){
									this._onNewItem(object);
								}
							}
						}), true);
					}

					// Set our value (which might be undefined), and then tweak
					// it to send a change event with the real value
					this._loadingStore = false;
					this.set("value", "_pendingValue" in this ? this._pendingValue : selectedValue);
					delete this._pendingValue;

					if(!this.loadChildrenOnOpen){
						this._loadChildren();
					}else{
						this._pseudoLoadChildren(items);
					}
					this.onLoadDeferred.resolve(true);
					this.onSetStore();
				}), function(err){
					console.error('dijit.form.Select: ' + err.toString());
					this.onLoadDeferred.reject(err);
				});
			}
			return oStore;	// dojo/data/api/Identity
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		set the value of the widget.
			//		If a string is passed, then we set our value from looking it up.
			if(!this._onChangeActive){
				priorityChange = null;
			}
			if(this._loadingStore){
				// Our store is loading - so save our value, and we'll set it when
				// we're done
				this._pendingValue = newValue;
				return;
			}
			if(newValue == null){
				return;
			}
			if(lang.isArrayLike(newValue)){
				newValue = array.map(newValue, function(value){
					return lang.isObject(value) ? value : { value: value };
				}); // __SelectOption[]
			}else if(lang.isObject(newValue)){
				newValue = [newValue];
			}else{
				newValue = [
					{ value: newValue }
				];
			}
			newValue = array.filter(this.getOptions(newValue), function(i){
				return i && i.value;
			});
			var opts = this.getOptions() || [];
			if(!this.multiple && (!newValue[0] || !newValue[0].value) && !!opts.length){
				newValue[0] = opts[0];
			}
			array.forEach(opts, function(opt){
				opt.selected = array.some(newValue, function(v){
					return v.value === opt.value;
				});
			});
			var val = array.map(newValue, function(opt){
				return opt.value;
			});

			if(typeof val == "undefined" || typeof val[0] == "undefined"){
				return;
			} // not fully initialized yet or a failed value lookup
			var disp = array.map(newValue, function(opt){
				return opt.label;
			});
			this._setDisplay(this.multiple ? disp : disp[0]);
			this.inherited(arguments, [ this.multiple ? val : val[0], priorityChange ]);
			this._updateSelection();
		},

		_getDisplayedValueAttr: function(){
			// summary:
			//		returns the displayed value of the widget
			var ret = array.map([].concat(this.get('selectedOptions')), function(v){
				if(v && "label" in v){
					return v.label;
				}else if(v){
					return v.value;
				}
				return null;
			}, this);
			return this.multiple ? ret : ret[0];
		},

		_setDisplayedValueAttr: function(label){
			// summary:
			//		Sets the displayed value of the widget
			this.set('value', this.getOptions(typeof label == "string" ? { label: label } : label));
		},

		_loadChildren: function(){
			// summary:
			//		Loads the children represented by this widget's options.
			//		reset the menu to make it populatable on the next click
			if(this._loadingStore){
				return;
			}
			array.forEach(this._getChildren(), function(child){
				child.destroyRecursive();
			});
			// Add each menu item
			array.forEach(this.options, this._addOptionItem, this);

			// Update states
			this._updateSelection();
		},

		_updateSelection: function(){
			// summary:
			//		Sets the "selected" class on the item for styling purposes
			this.focusedChild = null;
			this._set("value", this._getValueFromOpts());
			var val = [].concat(this.value);
			if(val && val[0]){
				var self = this;
				array.forEach(this._getChildren(), function(child){
					var isSelected = array.some(val, function(v){
						return child.option && (v === child.option.value);
					});
					if(isSelected && !self.multiple){
						self.focusedChild = child;
					}
					domClass.toggle(child.domNode, this.baseClass.replace(/\s+|$/g, "SelectedOption "), isSelected);
					child.domNode.setAttribute("aria-selected", isSelected ? "true" : "false");
				}, this);
			}
		},

		_getValueFromOpts: function(){
			// summary:
			//		Returns the value of the widget by reading the options for
			//		the selected flag
			var opts = this.getOptions() || [];
			if(!this.multiple && opts.length){
				// Mirror what a select does - choose the first one
				var opt = array.filter(opts, function(i){
					return i.selected;
				})[0];
				if(opt && opt.value){
					return opt.value;
				}else{
					opts[0].selected = true;
					return opts[0].value;
				}
			}else if(this.multiple){
				// Set value to be the sum of all selected
				return array.map(array.filter(opts, function(i){
					return i.selected;
				}), function(i){
					return i.value;
				}) || [];
			}
			return "";
		},

		// Internal functions to call when we have store notifications come in
		_onNewItem: function(/*item*/ item, /*Object?*/ parentInfo){
			if(!parentInfo || !parentInfo.parent){
				// Only add it if we are top-level
				this._addOptionForItem(item);
			}
		},
		_onDeleteItem: function(/*item*/ item){
			var store = this.store;
			this.removeOption({value: store.getIdentity(item) });
		},
		_onSetItem: function(/*item*/ item){
			this.updateOption(this._getOptionObjForItem(item));
		},

		_getOptionObjForItem: function(item){
			// summary:
			//		Returns an option object based off the given item.  The "value"
			//		of the option item will be the identity of the item, the "label"
			//		of the option will be the label of the item.

			// remove getLabel() call for 2.0 (it's to support the old dojo.data API)
			var store = this.store,
				label = (this.labelAttr && this.labelAttr in item) ? item[this.labelAttr] : store.getLabel(item),
				value = (label ? store.getIdentity(item) : null);
			return {value: value, label: label, item: item}; // __SelectOption
		},

		_addOptionForItem: function(/*item*/ item){
			// summary:
			//		Creates (and adds) the option for the given item
			var store = this.store;
			if(store.isItemLoaded && !store.isItemLoaded(item)){
				// We are not loaded - so let's load it and add later.
				// Remove for 2.0 (it's the old dojo.data API)
				store.loadItem({item: item, onItem: function(i){
					this._addOptionForItem(i);
				},
					scope: this});
				return;
			}
			var newOpt = this._getOptionObjForItem(item);
			this.addOption(newOpt);
		},

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree

			//		Saves off our value, if we have an initial one set so we
			//		can use it if we have a store as well (see startup())
			this._oValue = (params || {}).value || null;
			this._notifyConnections = [];	// remove for 2.0
		},

		buildRendering: function(){
			this.inherited(arguments);
			dom.setSelectable(this.focusNode, false);
		},

		_fillContent: function(){
			// summary:
			//		Loads our options and sets up our dropdown correctly.  We
			//		don't want any content, so we don't call any inherit chain
			//		function.
			if(!this.options){
				this.options =
					this.srcNodeRef
						? query("> *", this.srcNodeRef).map(
						function(node){
							if(node.getAttribute("type") === "separator"){
								return { value: "", label: "", selected: false, disabled: false };
							}
							return {
								value: (node.getAttribute("data-" + kernel._scopeName + "-value") || node.getAttribute("value")),
								label: String(node.innerHTML),
								// FIXME: disabled and selected are not valid on complex markup children (which is why we're
								// looking for data-dojo-value above.  perhaps we should data-dojo-props="" this whole thing?)
								// decide before 1.6
								selected: node.getAttribute("selected") || false,
								disabled: node.getAttribute("disabled") || false
							};
						},
						this)
						: [];
			}
			if(!this.value){
				this._set("value", this._getValueFromOpts());
			}else if(this.multiple && typeof this.value == "string"){
				this._set("value", this.value.split(","));
			}
		},

		postCreate: function(){
			// summary:
			//		sets up our event handling that we need for functioning
			//		as a select
			this.inherited(arguments);

			// Make our event connections for updating state
			aspect.after(this, "onChange", lang.hitch(this, "_updateSelection"));

			//		Connects in our store, if we have one defined
			var store = this.store;
			if(store && (store.getIdentity || store.getFeatures()["dojo.data.api.Identity"])){
				// Temporarily set our store to null so that it will get set
				// and connected appropriately
				this.store = null;
				this._deprecatedSetStore(store, this._oValue, {query: this.query, queryOptions: this.queryOptions});
			}

			this._storeInitialized = true;
		},

		startup: function(){
			// summary:
			this._loadChildren();
			this.inherited(arguments);
		},

		destroy: function(){
			// summary:
			//		Clean up our connections

			var h;
			while((h = this._notifyConnections.pop())){
				h.remove();
			}

			// Cancel listener for store updates
			if(this._queryRes && this._queryRes.close){
				this._queryRes.close();
			}

			// Cancel listener for updates to new (dojo.store) store
			if(this._observeHandle && this._observeHandle.remove){
				this._observeHandle.remove();
				this._observeHandle = null;
			}

			this.inherited(arguments);
		},

		_addOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, adds an
			//		item to the select.  If the option doesn't have a value, then a
			//		separator is added in that place.  Make sure to store the option
			//		in the created option widget.
		},

		_removeOptionItem: function(/*__SelectOption*/ /*===== option =====*/){
			// summary:
			//		User-overridable function which, for the given option, removes
			//		its item from the select.
		},

		_setDisplay: function(/*String or String[]*/ /*===== newDisplay =====*/){
			// summary:
			//		Overridable function which will set the display for the
			//		widget.  newDisplay is either a string (in the case of
			//		single selects) or array of strings (in the case of multi-selects)
		},

		_getChildren: function(){
			// summary:
			//		Overridable function to return the children that this widget contains.
			return [];
		},

		_getSelectedOptionsAttr: function(){
			// summary:
			//		hooks into this.attr to provide a mechanism for getting the
			//		option items for the current value of the widget.
			return this.getOptions({ selected: true });
		},

		_pseudoLoadChildren: function(/*item[]*/ /*===== items =====*/){
			// summary:
			//		a function that will "fake" loading children, if needed, and
			//		if we have set to not load children until the widget opens.
			// items:
			//		An array of items that will be loaded, when needed
		},

		onSetStore: function(){
			// summary:
			//		a function that can be connected to in order to receive a
			//		notification that the store has finished loading and all options
			//		from that store are available
		}
	});

	/*=====
	_FormSelectWidget.__SelectOption = __SelectOption;
	=====*/

	return _FormSelectWidget;
});

},
'dijit/form/_ComboBoxMenu':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-style", // domStyle.get
	"dojo/keys", // keys.DOWN_ARROW keys.PAGE_DOWN keys.PAGE_UP keys.UP_ARROW
	"../_WidgetBase",
	"../_TemplatedMixin",
	"./_ComboBoxMenuMixin",
	"./_ListMouseMixin"
], function(declare, domClass, domStyle, keys,
			_WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin){


	// module:
	//		dijit/form/_ComboBoxMenu

	return declare("dijit.form._ComboBoxMenu",[_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		//		Abstract methods that must be defined externally:
		//
		//		- onChange: item was explicitly chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		//		- onPage: next(1) or previous(-1) button pressed
		// tags:
		//		private

		// TODO for 2.0 or earlier: stop putting stuff inside this.containerNode.   Switch to using this.domNode
		// or a different attach point.    See _TemplatedMixin::searchContainerNode.
		templateString: "<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;' role='listbox'>"
				+"<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>"
				+"<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>"
				+"</div>",

		baseClass: "dijitComboBoxMenu",

		postCreate: function(){
			this.inherited(arguments);
			if(!this.isLeftToRight()){
				domClass.add(this.previousButton, "dijitMenuItemRtl");
				domClass.add(this.nextButton, "dijitMenuItemRtl");
			}
			this.containerNode.setAttribute("role","listbox");
		},

		_createMenuItem: function(){
			// note: not using domConstruct.create() because need to specify document
			var item = this.ownerDocument.createElement("div");
			item.className = "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl");
			item.setAttribute("role", "option");
			return item;
		},

		onHover: function(/*DomNode*/ node){
			// summary:
			//		Add hover CSS
			domClass.add(node, "dijitMenuItemHover");
		},

		onUnhover: function(/*DomNode*/ node){
			// summary:
			//		Remove hover CSS
			domClass.remove(node, "dijitMenuItemHover");
		},

		onSelect: function(/*DomNode*/ node){
			// summary:
			//		Add selected CSS
			domClass.add(node, "dijitMenuItemSelected");
		},

		onDeselect: function(/*DomNode*/ node){
			// summary:
			//		Remove selected CSS
			domClass.remove(node, "dijitMenuItemSelected");
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = domStyle.get(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this.selectNextNode();
			}
			while(scrollamount<height){
				var highlighted_option = this.getHighlightedOption();
				if(up){
					// stop at option 1
					if(!highlighted_option.previousSibling ||
						highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this.selectPreviousNode();
				}else{
					// stop at last option
					if(!highlighted_option.nextSibling ||
						highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this.selectNextNode();
				}
				// going backwards
				var newscroll = this.domNode.scrollTop;
				scrollamount += (newscroll-oldscroll)*(up ? -1:1);
				oldscroll = newscroll;
			}
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.keyCode){
				case keys.DOWN_ARROW:
					this.selectNextNode();
					return false;
				case keys.PAGE_DOWN:
					this._page(false);
					return false;
				case keys.UP_ARROW:
					this.selectPreviousNode();
					return false;
				case keys.PAGE_UP:
					this._page(true);
					return false;
				default:
					return true;
			}
		}
	});
});

},
'dijit/layout/_TabContainerBase':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"./StackContainer",
	"./utils", // marginBox2contextBox, layoutChildren
	"../_TemplatedMixin",
	"dojo/text!./templates/TabContainer.html"
], function(declare, domClass, domGeometry, domStyle, StackContainer, layoutUtils, _TemplatedMixin, template){

	// module:
	//		dijit/layout/_TabContainerBase

	return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {
		// summary:
		//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
		//		and return the widget that displays the tab labels
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// tabPosition: String
		//		Defines where tabs go relative to tab content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		baseClass: "dijitTabContainer",

		// tabStrip: [const] Boolean
		//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
		//		around the set of tabs.   Not supported by claro theme.
		tabStrip: false,

		// nested: [const] Boolean
		//		If true, use styling for a TabContainer nested inside another TabContainer.
		//		For tundra etc., makes tabs look like links, and hides the outer
		//		border since the outer TabContainer already has a border.
		nested: false,

		templateString: template,

		postMixInProperties: function(){
			// set class name according to tab position, ex: dijitTabContainerTop
			this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

			this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");

			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
			this.tablist = this._makeController(this.tablistNode);

			if(!this.doLayout){
				domClass.add(this.domNode, "dijitTabContainerNoLayout");
			}

			if(this.nested){
				/* workaround IE's lack of support for "a > b" selectors by
				 * tagging each node in the template.
				 */
				domClass.add(this.domNode, "dijitTabContainerNested");
				domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
				domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
				domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
			}else{
				domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
			}
		},

		_setupChild: function(/*dijit/_WidgetBase*/ tab){
			// Overrides StackContainer._setupChild().
			domClass.add(tab.domNode, "dijitTabPane");
			this.inherited(arguments);
		},

		startup: function(){
			if(this._started){
				return;
			}

			// wire up the tablist and its tabs
			this.tablist.startup();

			this.inherited(arguments);
		},

		layout: function(){
			// Overrides StackContainer.layout().
			// Configure the content pane to take up all the space except for where the tabs are

			if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){
				return;
			}

			var sc = this.selectedChildWidget;

			if(this.doLayout){
				// position and size the titles and the container node
				var titleAlign = this.tabPosition.replace(/-h/, "");
				this.tablist.region = titleAlign;
				var children = [this.tablist, {
					domNode: this.tablistSpacer,
					region: titleAlign
				}, {
					domNode: this.containerNode,
					region: "center"
				}];
				layoutUtils.layoutChildren(this.domNode, this._contentBox, children);

				// Compute size to make each of my children.
				// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
				this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);

				if(sc && sc.resize){
					sc.resize(this._containerContentBox);
				}
			}else{
				// just layout the tab controller, so it can position left/right buttons etc.
				if(this.tablist.resize){
					//make the tabs zero width so that they don't interfere with width calc, then reset
					var s = this.tablist.domNode.style;
					s.width = "0";
					var width = domGeometry.getContentBox(this.domNode).w;
					s.width = "";
					this.tablist.resize({w: width});
				}

				// and call resize() on the selected pane just to tell it that it's been made visible
				if(sc && sc.resize){
					sc.resize();
				}
			}
		},

		destroy: function(preserveDom){
			if(this.tablist){
				this.tablist.destroy(preserveDom);
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/_KeyNavContainer':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/lang", // lang.hitch
	"./registry",
	"./_Container",
	"./_FocusMixin",
	"./_KeyNavMixin"
], function(array, declare, domAttr, kernel, keys, lang, registry, _Container, _FocusMixin, _KeyNavMixin){


	// module:
	//		dijit/_KeyNavContainer

	return declare("dijit._KeyNavContainer", [_FocusMixin, _KeyNavMixin, _Container], {
		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		Provides normalized keyboard and focusing code for Container widgets.
		//		To use this mixin, call connectKeyNavHandlers() in postCreate().
		//		Also, child widgets must implement a focus() method.

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Deprecated.  You can call this in postCreate() to attach the keyboard handlers to the container,
			//		but the preferred method is to override _onLeftArrow() and _onRightArrow(), or
			//		_onUpArrow() and _onDownArrow(), to call focusPrev() and focusNext().
			// prevKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: remove for 2.0, and make subclasses override _onLeftArrow, _onRightArrow etc. instead.

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){
				keyCodes[code] = prev;
			});
			array.forEach(nextKeyCodes, function(code){
				keyCodes[code] = next;
			});
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit/_WidgetBase*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		_startupChild: function(/*dijit/_WidgetBase*/ widget){
			// summary:
			//		Setup for each child widget.
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			//
			//		Note: if you add children by a different method than addChild(), then need to call this manually
			//		or at least make sure the child's tabIndex is -1.
			//
			//		Note: see also _LayoutWidget.setupChild(), which is also called for each child widget.
			// tags:
			//		private

			widget.set("tabIndex", "-1");
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[0] : null;
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var children = this.getChildren();
			return children.length ? children[children.length - 1] : null;
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		childSelector: function(/*DOMNode*/ node){
			// Implement _KeyNavMixin.childSelector, to identify focusable child nodes.
			// If we allowed a dojo/query dependency from this module this could more simply be a string "> *"
			// instead of this function.

			var node = registry.byNode(node);
			return node && node.getParent() == this;
		}
	});
});

},
'dijit/form/DataList':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/lang", // lang.trim
	"dojo/query", // query
	"dojo/store/Memory",
	"../registry"	// registry.add registry.remove
], function(declare, dom, lang, query, MemoryStore, registry){

	// module:
	//		dijit/form/DataList

	function toItem(/*DOMNode*/ option){
		// summary:
		//		Convert `<option>` node to hash
		return {
			id: option.value,
			value: option.value,
			name: lang.trim(option.innerText || option.textContent || '')
		};
	}

	return declare("dijit.form.DataList", MemoryStore, {
		// summary:
		//		Inefficient but small data store specialized for inlined data via OPTION tags
		//
		// description:
		//		Provides a store for inlined data like:
		//
		//	|	<datalist>
		//	|		<option value="AL">Alabama</option>
		//	|		...

		constructor: function(params, srcNodeRef){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String
			//		Attach widget to this DOM node.

			// store pointer to original DOM tree
			this.domNode = dom.byId(srcNodeRef);

			lang.mixin(this, params);
			if(this.id){
				registry.add(this); // add to registry so it can be easily found by id
			}
			this.domNode.style.display = "none";

			this.inherited(arguments, [{
				data: query("option", this.domNode).map(toItem)
			}]);
		},

		destroy: function(){
			registry.remove(this.id);
		},

		fetchSelectedItem: function(){
			// summary:
			//		Get the option marked as selected, like `<option selected>`.
			//		Not part of dojo.data API.
			var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
			return option && toItem(option);
		}
	});
});

},
'dijit/Tooltip':function(){
define([
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/mouse",
	"dojo/on",
	"dojo/sniff", // has("ie"), has("trident")
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"./main"		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, mouse, on, has,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

	// module:
	//		dijit/Tooltip


	// TODO: Tooltip should really share more positioning code with TooltipDialog, like:
	//		- the orient() method
	//		- the connector positioning code in show()
	//		- the dijitTooltip[Dialog] class
	//
	// The problem is that Tooltip's implementation supplies it's own <iframe> and interacts directly
	// with dijit/place, rather than going through dijit/popup like TooltipDialog and other popups (ex: Menu).

	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			this.ownerDocumentBody.appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode|dijit/place.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
			// onMouseEnter: Function?
			//		Callback function for mouse enter on tooltip
			// onMouseLeave: Function?
			//		Callback function for mouse leave on tooltip

			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;

			if(textDir){
				this.set("textDir", textDir);
			}

			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}else{
				// Not *-centered, but just above/below/after/before
				this.connectorNode.style.left = "";
				this.connectorNode.style.top = "";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;

			this.onMouseEnter = onMouseEnter || noop;
			this.onMouseLeave = onMouseLeave || noop;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected

			this.connectorNode.style.top = ""; //reset to default

			var heightAvailable = spaceAvailable.h,
				widthAvailable = spaceAvailable.w;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.style.width = "auto";

			// Reduce tooltip's width to the amount of width available, so that it doesn't overflow screen.
			// Note that sometimes widthAvailable is negative, but we guard against setting style.width to a
			// negative number since that causes an exception on IE.
			var size = domGeometry.position(this.domNode);
			if(has("ie") || has("trident")){
				// workaround strange IE bug where setting width to offsetWidth causes words to wrap
				size.w += 2;
			}

			var width = Math.min((Math.max(widthAvailable,1)), size.w);

			domGeometry.setMarginBox(this.domNode, {w: width});

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var bb = domGeometry.position(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(bb.h > heightAvailable){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = heightAvailable - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						bb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - widthAvailable);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}

			this.onMouseEnter = this.onMouseLeave = noop;
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		}
	});

	if(has("dojo-bidi")){
		MasterTooltip.extend({
			_setAutoTextDir: function(/*Object*/node){
				// summary:
				//		Resolve "auto" text direction for children nodes
				// tags:
				//		private

				this.applyTextDir(node);
				array.forEach(node.children, function(child){ this._setAutoTextDir(child); }, this);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				// summary:
				//		Setter for textDir.
				// description:
				//		Users shouldn't call this function; they should be calling
				//		set('textDir', value)
				// tags:
				//		private

				this._set("textDir", textDir);

				if (textDir == "auto"){
					this._setAutoTextDir(this.containerNode);
				}else{
					this.containerNode.dir = this.textDir;
				}
			}
		});
	}

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit/Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit/Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: place.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		// onMouseEnter: Function?
		//		Callback function for mouse over on tooltip
		// onMouseLeave: Function?
		//		Callback function for mouse leave on tooltip

		// After/before don't work, but for back-compat convert them to the working after-centered, before-centered.
		// Possibly remove this in 2.0.   Alternately, get before/after to work.
		if(position){
			position = array.map(position, function(val){
				return {after: "after-centered", before: "before-centered"}[val] || val;
			});
		}

		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir, onMouseEnter, onMouseLeave);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	// Possible states for a tooltip, see Tooltip.state property for definitions
	var DORMANT = "DORMANT",
		SHOW_TIMER = "SHOW TIMER",
		SHOWING = "SHOWING",
		HIDE_TIMER = "HIDE TIMER";

	function noop(){}

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.
		//		Also provides static show() and hide() methods that can be used without instantiating a dijit/Tooltip.

		// label: String
		//		HTML to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// hideDelay: Integer
		//		Number of milliseconds to wait after unhovering the object, before
		//		the tooltip is hidden.  Note that blurring an object hides the tooltip immediately.
		hideDelay: 400,

		// connectId: String|String[]|DomNode|DomNode[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node(s), the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on position parameter.
		position: [],

		// selector: String?
		//		CSS expression to apply this Tooltip to descendants of connectIds, rather than to
		//		the nodes specified by connectIds themselves.    Useful for applying a Tooltip to
		//		a range of rows in a table, tree, etc.   Use in conjunction with getContent() parameter.
		//		Ex: connectId: myTable, selector: "tr", getContent: function(node){ return ...; }
		//
		//		The application must require() an appropriate level of dojo/query to handle the selector.
		selector: "",

		// TODO: in 2.0 remove support for multiple connectIds.   selector gives the same effect.
		// So, change connectId to a "", remove addTarget()/removeTarget(), etc.

		_setConnectIdAttr: function(/*String|String[]|DomNode|DomNode[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id, this.ownerDocument); }, this);

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id, this.ownerDocument),
					selector = this.selector,
					delegatedEvent = selector ?
						function(eventType){ return on.selector(selector, eventType); } :
						function(eventType){ return eventType; },
					self = this;
				return [
					on(node, delegatedEvent(mouse.enter), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent("focusin"), function(){
						self._onHover(this);
					}),
					on(node, delegatedEvent(mouse.leave), lang.hitch(self, "_onUnHover")),
					on(node, delegatedEvent("focusout"), lang.hitch(self, "set", "state", DORMANT))
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*OomNode|String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode|String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		getContent: function(/*DomNode*/ node){
			// summary:
			//		User overridable function that return the text to display in the tooltip.
			// tags:
			//		extension
			return this.label || this.domNode.innerHTML;
		},

		// state: [private readonly] String
		//		One of:
		//
		//		- DORMANT: tooltip not SHOWING
		//		- SHOW TIMER: tooltip not SHOWING but timer set to show it
		//		- SHOWING: tooltip displayed
		//		- HIDE TIMER: tooltip displayed, but timer set to hide it
		state: DORMANT,
		_setStateAttr: function(val){
			if(this.state == val ||
				(val == SHOW_TIMER && this.state == SHOWING) ||
				(val == HIDE_TIMER && this.state == DORMANT)){
				return;
			}

			if(this._hideTimer){
				this._hideTimer.remove();
				delete this._hideTimer;
			}
			if(this._showTimer){
				this._showTimer.remove();
				delete this._showTimer;
			}

			switch(val){
				case DORMANT:
					if(this._connectNode){
						Tooltip.hide(this._connectNode);
						delete this._connectNode;
						this.onHide();
					}
					break;
				case SHOW_TIMER:	 // set timer to show tooltip
					// should only get here from a DORMANT state, i.e. tooltip can't be already SHOWING
					if(this.state != SHOWING){
						this._showTimer = this.defer(function(){ this.set("state", SHOWING); }, this.showDelay);
					}
					break;
				case SHOWING:		// show tooltip and clear timers
					var content = this.getContent(this._connectNode);
					if(!content){
						this.set("state", DORMANT);
						return;
					}

					// Show tooltip and setup callbacks for mouseenter/mouseleave of tooltip itself
					Tooltip.show(content, this._connectNode, this.position, !this.isLeftToRight(), this.textDir,
						lang.hitch(this, "set", "state", SHOWING), lang.hitch(this, "set", "state", HIDE_TIMER));

					this.onShow(this._connectNode, this.position);
					break;
				case HIDE_TIMER:	// set timer set to hide tooltip
					this._hideTimer = this.defer(function(){ this.set("state", DORMANT); }, this.hideDelay);
					break;
			}

			this._set("state", val);
		},

		_onHover: function(/*DomNode*/ target){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private

			if(this._connectNode && target != this._connectNode){
				// Tooltip is displaying for another node
				this.set("state", DORMANT);
			}
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"

			this.set("state", SHOW_TIMER);	// no-op if show-timer already set, or if already showing
		},

		_onUnHover: function(/*DomNode*/ target){
			// summary:
			//		Handles mouseleave event on the target node, hiding the tooltip.
			// tags:
			//		private

			this.set("state", HIDE_TIMER);		// no-op if already dormant, or if hide-timer already set
		},

		// open() and close() aren't used anymore, except from the _BidiSupport/misc/Tooltip test.
		// Should probably remove for 2.0, but leaving for now.
		open: function(/*DomNode*/ target){
			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			this.set("state", DORMANT);
			this._connectNode = target;		// _connectNode means "tooltip currently displayed for this node"
			this.set("state", SHOWING);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			this.set("state", DORMANT);
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		destroy: function(){
			this.set("state", DORMANT);

			// Remove connections manually since they aren't registered to be removed by _WidgetBase
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, function(handle){ handle.remove(); });
			}, this);

			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	Tooltip.defaultPosition = ["after-centered", "before-centered"];

	/*=====
	lang.mixin(Tooltip, {
		 // defaultPosition: String[]
		 //		This variable controls the position of tooltips, if the position is not specified to
		 //		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the values
		 //		possible for `dijit/place.around()`.   The recommended values are:
		 //
		 //		- before-centered: centers tooltip to the left of the anchor node/widget, or to the right
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- after-centered: centers tooltip to the right of the anchor node/widget, or to the left
		 //		  in the case of RTL scripts like Hebrew and Arabic
		 //		- above-centered: tooltip is centered above anchor node
		 //		- below-centered: tooltip is centered above anchor node
		 //
		 //		The list is positions is tried, in order, until a position is found where the tooltip fits
		 //		within the viewport.
		 //
		 //		Be careful setting this parameter.  A value of "above-centered" may work fine until the user scrolls
		 //		the screen so that there's no room above the target node.   Nodes with drop downs, like
		 //		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
		 //		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
		 //		is only room below (or above) the target node, but not both.
	 });
	=====*/
	return Tooltip;
});

},
'dijit/PopupMenuItem':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang",
	"dojo/query", // query
	"./popup",
	"./registry",	// registry.byNode
	"./MenuItem",
	"./hccss"
], function(declare, domStyle, lang, query, pm, registry, MenuItem){

	// module:
	//		dijit/PopupMenuItem

	return declare("dijit.PopupMenuItem", MenuItem, {
		// summary:
		//		An item in a Menu that spawn a drop down (usually a drop down menu)

		baseClass: "dijitMenuItem dijitPopupMenuItem",

		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRef.innerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div data-dojo-type="dijit/PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = query("*", this.srcNodeRef);
				this.inherited(arguments, [nodes[0]]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		_openPopup: function(/*Object*/ params, /*Boolean*/ focus){
			// summary:
			//		Open the popup to the side of/underneath this MenuItem, and optionally focus first item
			// tags:
			//		protected

			var popup = this.popup;

			pm.open(lang.delegate(params, {
				popup: this.popup,
				around: this.domNode
			}));

			if(focus && popup.focus){
				popup.focus();
			}
		},

		_closePopup: function(){
			pm.close(this.popup);
			this.popup.parentMenu = null;
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// We didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  Move it to <body>.
			if(!this.popup){
				var node = query("[widgetId]", this.dropDownContainer)[0];
				this.popup = registry.byNode(node);
			}
			this.ownerDocumentBody.appendChild(this.popup.domNode);
			this.popup.domNode.setAttribute("aria-labelledby", this.containerNode.id);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				domStyle.set(this.arrowWrapper, "visibility", "");
			}
			this.focusNode.setAttribute("aria-haspopup", "true");
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive(preserveDom);
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/main':function(){
define([
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit/main

/*=====
return {
	// summary:
	//		The dijit package main module.
	//		Deprecated.   Users should access individual modules (ex: dijit/registry) directly.
};
=====*/

	return dojo.dijit;
});

},
'dijit/layout/ContentPane':function(){
define([
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject
	"../_Widget",
	"../_Container",
	"./_ContentPaneResizeMixin",
	"dojo/string", // string.substitute
	"dojo/html", // html._ContentSetter
	"dojo/i18n!../nls/loading",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-construct", // empty()
	"dojo/_base/xhr", // xhr.get
	"dojo/i18n", // i18n.getLocalization
	"dojo/when"
], function(kernel, lang, _Widget, _Container, _ContentPaneResizeMixin, string, html, nlsLoading, array, declare,
			Deferred, dom, domAttr, domConstruct, xhr, i18n, when){

/* CURAM-FIX: Extend ContentPane to allow P&S instrumentation. */
var curamPerfTrackingEnabled = typeof(dojo.global.perf) != "undefined" && dojo.global.perf != "undefined";


	// module:
	//		dijit/layout/ContentPane

	return declare("dijit.layout.ContentPane", [_Widget, _Container, _ContentPaneResizeMixin], {
		// summary:
		//		A widget containing an HTML fragment, specified inline
		//		or by uri.  Fragment may include widgets.
		//
		// description:
		//		This widget embeds a document fragment in the page, specified
		//		either by uri, javascript generated markup or DOM reference.
		//		Any widgets within this content are instantiated and managed,
		//		but laid out according to the HTML structure.  Unlike IFRAME,
		//		ContentPane embeds a document fragment as would be found
		//		inside the BODY tag of a full HTML document.  It should not
		//		contain the HTML, HEAD, or BODY tags.
		//		For more advanced functionality with scripts and
		//		stylesheets, see dojox/layout/ContentPane.  This widget may be
		//		used stand alone or as a base class for other widgets.
		//		ContentPane is useful as a child of other layout containers
		//		such as BorderContainer or TabContainer, but note that those
		//		widgets can contain any widget as a child.
		//
		// example:
		//		Some quick samples:
		//		To change the innerHTML:
		// |		cp.set('content', '<b>new content</b>')`
		//		Or you can send it a NodeList:
		// |		cp.set('content', dojo.query('div [class=selected]', userSelection))
		//		To do an ajax update:
		// |		cp.set('href', url)

		// href: String
		//		The href of the content that displays now.
		//		Set this at construction if you want to load data externally when the
		//		pane is shown.  (Set preload=true to load it immediately.)
		//		Changing href after creation doesn't have any effect; Use set('href', ...);
		href: "",

		// content: String|DomNode|NodeList|dijit/_Widget
		//		The innerHTML of the ContentPane.
		//		Note that the initialization parameter / argument to set("content", ...)
		//		can be a String, DomNode, Nodelist, or _Widget.
		content: "",

		// extractContent: Boolean
		//		Extract visible content from inside of `<body> .... </body>`.
		//		I.e., strip `<html>` and `<head>` (and it's contents) from the href
		extractContent: false,

		// parseOnLoad: Boolean
		//		Parse content and create the widgets, if any.
		parseOnLoad: true,

		// parserScope: String
		//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
		//		will search for data-dojo-type (or dojoType).  For backwards compatibility
		//		reasons defaults to dojo._scopeName (which is "dojo" except when
		//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		parserScope: kernel._scopeName,

		// preventCache: Boolean
		//		Prevent caching of data from href's by appending a timestamp to the href.
		preventCache: false,

		// preload: Boolean
		//		Force load of data on initialization even if pane is hidden.
		preload: false,

		// refreshOnShow: Boolean
		//		Refresh (re-download) content when pane goes from hidden to shown
		refreshOnShow: false,

		// loadingMessage: String
		//		Message that shows while downloading
		loadingMessage: "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>",

		// errorMessage: String
		//		Message that shows if an error occurs
		errorMessage: "<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>",

		// isLoaded: [readonly] Boolean
		//		True if the ContentPane has data in it, either specified
		//		during initialization (via href or inline content), or set
		//		via set('content', ...) / set('href', ...)
		//
		//		False if it doesn't have any content, or if ContentPane is
		//		still in the process of downloading href.
		isLoaded: false,

		baseClass: "dijitContentPane",

		/*======
		 // ioMethod: dojo/_base/xhr.get|dojo._base/xhr.post
		 //		Function that should grab the content specified via href.
		 ioMethod: dojo.xhrGet,
		 ======*/

		// ioArgs: Object
		//		Parameters to pass to xhrGet() request, for example:
		// |	<div data-dojo-type="dijit/layout/ContentPane" data-dojo-props="href: './bar', ioArgs: {timeout: 500}">
		ioArgs: {},

		// onLoadDeferred: [readonly] dojo.Deferred
		//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
		//		Calling onLoadDeferred.then() registers your
		//		callback to be called only once, when the prior set('href', ...) call or
		//		the initial href parameter to the constructor finishes loading.
		//
		//		This is different than an onLoad() handler which gets called any time any href
		//		or content is loaded.
		onLoadDeferred: null,

		// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify
		// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
		// entire pane.
		_setTitleAttr: null,

		// Flag to parser that I'll parse my contents, so it shouldn't.
		stopParser: true,

		// template: [private] Boolean
		//		Flag from the parser that this ContentPane is inside a template
		//		so the contents are pre-parsed.
		// TODO: this declaration can be commented out in 2.0
		template: false,

		markupFactory: function(params, node, ctor){
			var self = new ctor(params, node);

			// If a parse has started but is waiting for modules to load, then return a Promise for when the parser
			// finishes.  Don't return a promise though for the case when content hasn't started loading because the
			// ContentPane is hidden and it has an href (ex: hidden pane of a TabContainer).   In that case we consider
			// that initialization has already finished.
			return !self.href && self._contentSetter && self._contentSetter.parseDeferred && !self._contentSetter.parseDeferred.isFulfilled() ?
				self._contentSetter.parseDeferred.then(function(){
					return self;
				}) : self;
		},

		create: function(params, srcNodeRef){
			// Convert a srcNodeRef argument into a content parameter, so that the original contents are
			// processed in the same way as contents set via set("content", ...), calling the parser etc.
			// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
			if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
				srcNodeRef = dom.byId(srcNodeRef);
				var df = srcNodeRef.ownerDocument.createDocumentFragment();
				while(srcNodeRef.firstChild){
					df.appendChild(srcNodeRef.firstChild);
				}
				params = lang.delegate(params, {content: df});
			}
			this.inherited(arguments, [params, srcNodeRef]);
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = string.substitute(this.loadingMessage, messages);
			this.errorMessage = string.substitute(this.errorMessage, messages);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
			// For subclasses of ContentPane that do have a template, does nothing.
			if(!this.containerNode){
				this.containerNode = this.domNode;
			}

			// remove the title attribute so it doesn't show up when hovering
			// over a node  (TODO: remove in 2.0, no longer needed after #11490)
			this.domNode.removeAttribute("title");
		},

		startup: function(){
			// summary:
			//		Call startup() on all children including non _Widget ones like dojo/dnd/Source objects

			// This starts all the widgets
			this.inherited(arguments);

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		_startChildren: function(){
			// summary:
			//		Called when content is loaded.   Calls startup on each child widget.   Similar to ContentPane.startup()
			//		itself, but avoids marking the ContentPane itself as "restarted" (see #15581).

			// This starts all the widgets
			array.forEach(this.getChildren(), function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			});

			// And this catches stuff like dojo/dnd/Source
			if(this._contentSetter){
				array.forEach(this._contentSetter.parseResults, function(obj){
					if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
						obj.startup();
						obj._started = true;
					}
				}, this);
			}
		},

		setHref: function(/*String|Uri*/ href){
			// summary:
			//		Deprecated.   Use set('href', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
			return this.set("href", href);
		},
		_setHrefAttr: function(/*String|Uri*/ href){
			// summary:
			//		Hook so set("href", ...) works.
			// description:
			//		Reset the (external defined) content of this pane and replace with new url
			//		Note: It delays the download until widget is shown if preload is false.
			// href:
			//		url to the page you want to get, must be within the same domain as your mainpage

			// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));

			this._set("href", href);

			// _setHrefAttr() is called during creation and by the user, after creation.
			// Assuming preload == false, only in the second case do we actually load the URL;
			// otherwise it's done in startup(), and only if this widget is shown.
			if(this.preload || (this._created && this._isShown())){
				this._load();
			}else{
				// Set flag to indicate that href needs to be loaded the next time the
				// ContentPane is made visible
				this._hrefChanged = true;
			}

			return this.onLoadDeferred;		// Deferred
		},

		setContent: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Deprecated.   Use set('content', ...) instead.
			kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
			this.set("content", data);
		},
		_setContentAttr: function(/*String|DomNode|Nodelist*/data){
			// summary:
			//		Hook to make set("content", ...) work.
			//		Replaces old content with data content, include style classes from old content
			// data:
			//		the new Content may be String, DomNode or NodeList
			//
			//		if data is a NodeList (or an array of nodes) nodes are copied
			//		so you can import nodes from another document implicitly

			// clear href so we can't run refresh and clear content
			// refresh should only work if we downloaded the content
			this._set("href", "");

			// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
			this.cancel();

			// Even though user is just setting content directly, still need to define an onLoadDeferred
			// because the _onLoadHandler() handler is still getting called from setContent()
			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			if(this._created){
				// For back-compat reasons, call onLoad() for set('content', ...)
				// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)
				// or as initialization parameter (ie: new ContentPane({content: ...})
				this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			}

			this._setContent(data || "");

			this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

			return this.onLoadDeferred;	// Deferred
		},
		_getContentAttr: function(){
			// summary:
			//		Hook to make get("content") work
			return this.containerNode.innerHTML;
		},

		cancel: function(){
			// summary:
			//		Cancels an in-flight download of content
			if(this._xhrDfd && (this._xhrDfd.fired == -1)){
				this._xhrDfd.cancel();
			}
			delete this._xhrDfd; // garbage collect

			this.onLoadDeferred = null;
		},

		destroy: function(){
			this.cancel();
			this.inherited(arguments);
		},

		destroyRecursive: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy the ContentPane and its contents

			// if we have multiple controllers destroying us, bail after the first
			if(this._beingDestroyed){
				return;
			}
			this.inherited(arguments);
		},

		_onShow: function(){
			// summary:
			//		Called when the ContentPane is made visible
			// description:
			//		For a plain ContentPane, this is called on initialization, from startup().
			//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
			//		called whenever the pane is made visible.
			//
			//		Does necessary processing, including href download and layout/resize of
			//		child widget(s)

			this.inherited(arguments);

			if(this.href){
				if(!this._xhrDfd && // if there's an href that isn't already being loaded
					(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
					){
					return this.refresh();	// If child has an href, promise that fires when the load is complete
				}
			}
		},

		refresh: function(){
			// summary:
			//		[Re]download contents of href and display
			// description:
			//		1. cancels any currently in-flight requests
			//		2. posts "loading..." message
			//		3. sends XHR to download new data

			// Cancel possible prior in-flight request
			this.cancel();

			this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
			this._load();
			return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
		},

		_load: function(){
			// summary:
			//		Load/reload the href specified in this.href

    /* CURAM-FIX: P&S */
    if(curamPerfTrackingEnabled) { /*1*/
            perf.widgetStartedLoadingCallback();
    }
    /* END CURAM-FIX */


			// display loading message
			this._setContent(this.onDownloadStart(), true);

			var self = this;
			var getArgs = {
				preventCache: (this.preventCache || this.refreshOnShow),
				url: this.href,
				handleAs: "text"
			};
			if(lang.isObject(this.ioArgs)){
				lang.mixin(getArgs, this.ioArgs);
			}

			var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs)),
				returnedHtml;

			hand.then(
				function(html){
					returnedHtml = html;
					try{
						self._isDownloaded = true;
						return self._setContent(html, false);
					}catch(err){
						self._onError('Content', err); // onContentError
					}
				},
				function(err){
					if(!hand.canceled){
						// show error message in the pane
						self._onError('Download', err); // onDownloadError
					}
					delete self._xhrDfd;
					return err;
				}
			).then(function(){
					self.onDownloadEnd();
					
                  /* CURAM-FIX: P&S */
                  if(curamPerfTrackingEnabled) {
                          perf.widgetLoadedCallback(self);
                  }
                  /* END CURAM-FIX */
					
					delete self._xhrDfd;
					return returnedHtml;
				});

			// Remove flag saying that a load is needed
			delete this._hrefChanged;
		},

		_onLoadHandler: function(data){
			// summary:
			//		This is called whenever new content is being loaded
			this._set("isLoaded", true);
			try{
				this.onLoadDeferred.resolve(data);
			}catch(e){
				console.error('Error ' + this.widgetId + ' running custom onLoad code: ' + e.message);
			}
		},

		_onUnloadHandler: function(){
			// summary:
			//		This is called whenever the content is being unloaded
			this._set("isLoaded", false);
			try{
				this.onUnload();
			}catch(e){
				console.error('Error ' + this.widgetId + ' running custom onUnload code: ' + e.message);
			}
		},

		destroyDescendants: function(/*Boolean*/ preserveDom){
			// summary:
			//		Destroy all the widgets inside the ContentPane and empty containerNode

			// Make sure we call onUnload (but only when the ContentPane has real content)
			if(this.isLoaded){
				this._onUnloadHandler();
			}

			// Even if this.isLoaded == false there might still be a "Loading..." message
			// to erase, so continue...

			// For historical reasons we need to delete all widgets under this.containerNode,
			// even ones that the user has created manually.
			var setter = this._contentSetter;
			array.forEach(this.getChildren(), function(widget){
				if(widget.destroyRecursive){
					// All widgets will hit this branch
					widget.destroyRecursive(preserveDom);
				}else if(widget.destroy){
					// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
					widget.destroy(preserveDom);
				}
				widget._destroyed = true;
			});
			if(setter){
				// Most of the widgets in setter.parseResults have already been destroyed, but
				// things like Menu that have been moved to <body> haven't yet
				array.forEach(setter.parseResults, function(widget){
					if(!widget._destroyed){
						if(widget.destroyRecursive){
							// All widgets will hit this branch
							widget.destroyRecursive(preserveDom);
						}else if(widget.destroy){
							if((widget["class"] === "rotator" || widget["class"] === "hcrRotatorNav") && !widget.wfe) {
								widget.wfe = { remove: function() { /*dummy*/ } };
							}
							// Things like dojo/dnd/Source have destroy(), not destroyRecursive()
							widget.destroy(preserveDom);
						}
						widget._destroyed = true;
					}
				});
				delete setter.parseResults;
			}

			// And then clear away all the DOM nodes
			if(!preserveDom){
				domConstruct.empty(this.containerNode);
			}

			// Delete any state information we have about current contents
			delete this._singleChild;
		},

		_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
			// summary:
			//		Insert the content into the container node
			// returns:
			//		Returns a Deferred promise that is resolved when the content is parsed.

			// first get rid of child widgets
			this.destroyDescendants();

			// html.set will take care of the rest of the details
			// we provide an override for the error handling to ensure the widget gets the errors
			// configure the setter instance with only the relevant widget instance properties
			// NOTE: unless we hook into attr, or provide property setters for each property,
			// we need to re-configure the ContentSetter with each use
			var setter = this._contentSetter;
			if(!(setter && setter instanceof html._ContentSetter)){
				setter = this._contentSetter = new html._ContentSetter({
					node: this.containerNode,
					_onError: lang.hitch(this, this._onError),
					onContentError: lang.hitch(this, function(e){
						// fires if a domfault occurs when we are appending this.errorMessage
						// like for instance if domNode is a UL and we try append a DIV
						var errMess = this.onContentError(e);
						try{
							this.containerNode.innerHTML = errMess;
						}catch(e){
							console.error('Fatal ' + this.id + ' could not change content due to ' + e.message, e);
						}
					})/*,
					 _onError */
				});
			}

			var setterParams = lang.mixin({
				cleanContent: this.cleanContent,
				extractContent: this.extractContent,
				parseContent: !cont.domNode && this.parseOnLoad,
				parserScope: this.parserScope,
				startup: false,
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir
			}, this._contentSetterParams || {});

			var p = setter.set((lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams);

			// dojox/layout/html/_base::_ContentSetter.set() returns a Promise that indicates when everything is completed.
			// dojo/html::_ContentSetter.set() currently returns the DOMNode, but that will be changed for 2.0.
			// So, if set() returns a promise then use it, otherwise fallback to waiting on setter.parseDeferred
			var self = this;
			return when(p && p.then ? p : setter.parseDeferred, function(){
				// setter params must be pulled afresh from the ContentPane each time
				delete self._contentSetterParams;

				if(!isFakeContent){
					if(self._started){
						// Startup each top level child widget (and they will start their children, recursively)
						self._startChildren();

						// Call resize() on each of my child layout widgets,
						// or resize() on my single child layout widget...
						// either now (if I'm currently visible) or when I become visible
						self._scheduleLayout();
					}
					self._onLoadHandler(cont);
				}
			});
		},

		_onError: function(type, err, consoleText){
			this.onLoadDeferred.reject(err);

			// shows user the string that is returned by on[type]Error
			// override on[type]Error and return your own string to customize
			var errText = this['on' + type + 'Error'].call(this, err);
			if(consoleText){
				console.error(consoleText, err);
			}else if(errText){// a empty string won't change current content
				this._setContent(errText, true);
			}
		},

		// EVENT's, should be overide-able
		onLoad: function(/*===== data =====*/){
			// summary:
			//		Event hook, is called after everything is loaded and widgetified
			// tags:
			//		callback
		},

		onUnload: function(){
			// summary:
			//		Event hook, is called before old content is cleared
			// tags:
			//		callback
		},

		onDownloadStart: function(){
			// summary:
			//		Called before download starts.
			// description:
			//		The string returned by this function will be the html
			//		that tells the user we are loading something.
			//		Override with your own function if you want to change text.
			// tags:
			//		extension
			return this.loadingMessage;
		},

		onContentError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called on DOM faults, require faults etc. in content.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		By default (if this method is not overriden), it returns
			//		nothing, so the error message is just printed to the console.
			// tags:
			//		extension
		},

		onDownloadError: function(/*Error*/ /*===== error =====*/){
			// summary:
			//		Called when download error occurs.
			//
			//		In order to display an error message in the pane, return
			//		the error message from this method, as an HTML string.
			//
			//		Default behavior (if this method is not overriden) is to display
			//		the error message inside the pane.
			// tags:
			//		extension
			return this.errorMessage;
		},

		onDownloadEnd: function(){
			// summary:
			//		Called when download is finished.
			// tags:
			//		callback
		}
	});
});

},
'dijit/_WidgetsInTemplateMixin':function(){
define([
	"dojo/_base/array", // forEach()
	"dojo/aspect", // after()
	"dojo/_base/declare", // declare()
	"dojo/_base/lang",	// hitch()
	"dojo/parser" // parse()
], function(array, aspect, declare, lang, parser){

	// module:
	//		dijit/_WidgetsInTemplateMixin

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		// contextRequire: Function
		//		Used to provide a context require to the dojo/parser in order to be
		//		able to use relative MIDs (e.g. `./Widget`) in the widget's template.
		contextRequire: null,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				if(this.containerNode && !this.searchContainerNode){
					// Tell parse call below not to look for widgets inside of this.containerNode
					this.containerNode.stopParser = true;
				}

				parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					contextRequire: this.contextRequire,
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}).then(lang.hitch(this, function(widgets){
					this._startupWidgets = widgets;

					// _WidgetBase::destroy() will destroy any supporting widgets under this.domNode.
					// If we wanted to, we could call this.own() on anything in this._startupWidgets that was moved outside
					// of this.domNode (like Dialog, which is moved to <body>).

					// Hook up attach points and events for nodes that were converted to widgets
					for(var i = 0; i < widgets.length; i++){
						this._processTemplateNode(widgets[i], function(n,p){
							// callback to get a property of a widget
							return n[p];
						}, function(widget, type, callback){
							// callback to do data-dojo-attach-event to a widget
							if(type in widget){
								// back-compat, remove for 2.0
								return widget.connect(widget, type, callback);
							}else{
								// 1.x may never hit this branch, but it's the default for 2.0
								return widget.on(type, callback, true);
							}
						});
					}

					// Cleanup flag set above, just in case
					if(this.containerNode && this.containerNode.stopParser){
						delete this.containerNode.stopParser;
					}
				}));

				if(!this._startupWidgets){
					throw new Error(this.declaredClass + ": parser returned unfilled promise (probably waiting for module auto-load), " +
						"unsupported by _WidgetsInTemplateMixin.   Must pre-load all supporting widgets before instantiation.");
				}
			}
		},

		_processTemplateNode: function(/*DOMNode|Widget*/ baseNode, getAttrFunc, attachFunc){
			// Override _AttachMixin._processNode to skip DOMNodes with data-dojo-type set.   They are handled separately
			// in the _beforeFillContent() code above.

			if(getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type")){
				return true;
			}

			return this.inherited(arguments);
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this._startupWidgets = null;
			this.inherited(arguments);
		}
	});
});

},
'dijit/_HasDropDown':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has", // has("touch")
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/on",
	"dojo/touch",
	"./registry", // registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, on, touch,
			registry, focus, popup, _FocusMixin){


	// module:
	//		dijit/_HasDropDown

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the aria-expanded class on.
		//		Also sets popupActive class but that will be removed in 2.0.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width.
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: -1,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//		- before: places drop down to the left of the target node/widget, or to the right in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- after: places drop down to the right of the target node/widget, or to the left in
		//		  the case of RTL scripts like Hebrew and Arabic
		//		- above: drop down goes above target node
		//		- below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below", "above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subclass
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown/touchstart on the arrow icon.

			if(this.disabled || this.readOnly){
				return;
			}

			// Prevent default to stop things like text selection, but don't stop propagation, so that:
			//		1. TimeTextBox etc. can focus the <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			//
			// Also, don't call preventDefault() on MSPointerDown event (on IE10) because that prevents the button
			// from getting focus, and then the focus manager doesn't know what's going on (#17262)
			if(e.type != "MSPointerDown" && e.type != "pointerdown"){
				e.preventDefault();
			}

			this.own(on.once(this.ownerDocument, touch.release, lang.hitch(this, "_onDropDownMouseUp")));

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback on mouseup/touchend after mousedown/touchstart on the arrow icon.
			//		Note that this function is called regardless of what node the event occurred on (but only after
			//		a mousedown/touchstart on the arrow).
			//
			//		If the drop down is a simple menu and the cursor is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser `<select>` nodes:
			//
			//		1. mouse down on the select node (probably on the arrow)
			//		2. move mouse to a menu item while holding down the mouse button
			//		3. mouse up.  this selects the menu item as though the user had clicked it.

			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) || !(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				// Focus the dropdown widget unless it's a menu (in which case autoFocus is set to false).
				// Even if it's a menu, we need to focus it if this is a fake mouse event caused by the user typing
				// SPACE/ENTER while using JAWS.  Jaws converts the SPACE/ENTER key into mousedown/mouseup events.
				// If this.hovering is false then it's presumably actually a keyboard event.
				if(dropDown.focus && (dropDown.autoFocus !== false || (e.type == "mouseup" && !this.hovering))){
					// Do it on a delay so that we don't steal back focus from the dropdown.
					this._focusDropDownTimer = this.defer(function(){
						dropDown.focus();
						delete this._focusDropDownTimer;
					});
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// defer() needed to make it work on IE (test DateTextBox)
				if(this.focus){
					this.defer("focus");
				}
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			// The drop down was already opened on mousedown/keydown; just need to stop the event
			if(this._stopClickEvents){
				e.stopPropagation();
				e.preventDefault();
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
				"after": this.isLeftToRight() ? "Right" : "Left",
				"before": this.isLeftToRight() ? "Left" : "Right",
				"above": "Up",
				"below": "Down",
				"left": "Left",
				"right": "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keyboard events

			this.inherited(arguments);

			var keyboardEventNode = this.focusNode || this.domNode;
			this.own(
				on(this._buttonNode, touch.press, lang.hitch(this, "_onDropDownMouseDown")),
				on(this._buttonNode, "click", lang.hitch(this, "_onDropDownClick")),
				on(keyboardEventNode, "keydown", lang.hitch(this, "_onKey")),
				on(keyboardEventNode, "keyup", lang.hitch(this, "_onKeyUp"))
			);
		},

		destroy: function(){
			// If dropdown is open, close it, to avoid leaving dijit/focus in a strange state.
			// Put focus back on me to avoid the focused node getting destroyed, which flummoxes IE.
			if(this._opened){
				this.closeDropDown(true);
			}

			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){
				return;
			}
			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					e.stopPropagation();
					e.preventDefault();
					return;
				}
			}
			if(d && this._opened && e.keyCode == keys.ESCAPE){
				this.closeDropDown();
				e.stopPropagation();
				e.preventDefault();
			}else if(!this._opened &&
				(e.keyCode == keys.DOWN_ARROW ||
					// ignore unmodified SPACE if _KeyNavMixin has active searching in progress
					( (e.keyCode == keys.ENTER || (e.keyCode == keys.SPACE && (!this._searchTimer || (e.ctrlKey || e.altKey || e.metaKey)))) &&
						//ignore enter and space if the event is for a text input
						((target.tagName || "").toLowerCase() !== 'input' ||
							(target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				e.stopPropagation();
				e.preventDefault();
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					this.defer(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Close dropdown but don't focus my <input>.  User may have focused somewhere else (ex: clicked another
			// input), and even if they just clicked a blank area of the screen, focusing my <input> will unwantedly
			// popup the keyboard on mobile.
			this.closeDropDown(false);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){
				return;
			}
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown(true);	// refocus button to avoid hiding node w/focus
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit/popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				maxHeight: this.maxHeight,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._set("_opened", false);	// use set() because _CssStateMixin is watching
				}
			});

			// Set width of drop down if necessary, so that dropdown width + width of scrollbar (from popup wrapper)
			// matches width of aroundNode
			if(this.forceWidth || (this.autoWidth && aroundNode.offsetWidth > dropDown._popupWrapper.offsetWidth)){
				var widthAdjust = aroundNode.offsetWidth - dropDown._popupWrapper.offsetWidth;
				var resizeArgs = {
					w: dropDown.domNode.offsetWidth + widthAdjust
				};
				this._origStyle = ddNode.style.cssText;
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(resizeArgs);
				}else{
					domGeometry.setMarginBox(ddNode, resizeArgs);
				}

				// If dropdown is right-aligned then compensate for width change by changing horizontal position
				if(retVal.corner[1] == "R"){
					dropDown._popupWrapper.style.left =
						(dropDown._popupWrapper.style.left.replace("px", "") - widthAdjust) + "px";
				}
			}

			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(this._popupStateNode, "dijitHasDropDownOpen");
			this._set("_opened", true);	// use set() because _CssStateMixin is watching

			this._popupStateNode.setAttribute("aria-expanded", "true");
			this._popupStateNode.setAttribute("aria-owns", dropDown.id);

			// Set aria-labelledby on dropdown if it's not already set to something more meaningful
			if(ddNode.getAttribute("role") !== "presentation" && !ddNode.getAttribute("aria-labelledby")){
				ddNode.setAttribute("aria-labelledby", this.id);
			}

			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._focusDropDownTimer){
				this._focusDropDownTimer.remove();
				delete this._focusDropDownTimer;
			}

			if(this._opened){
				this._popupStateNode.setAttribute("aria-expanded", "false");
				if(focus && this.focus){
					this.focus();
				}
				popup.close(this.dropDown);
				this._opened = false;
			}

			if(this._origStyle){
				this.dropDown.domNode.style.cssText = this._origStyle;
				delete this._origStyle;
			}
		}
	});
});

},
'curam/cdsl/types/codetable/CodeTables':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 26-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 */

define(['dojo/_base/declare',
        'dojo/_base/lang',
        'dojo/Deferred',
        'curam/cdsl/_base/FacadeMethodCall',
        'curam/cdsl/Struct'
        ], function(
            declare, lang, Deferred, FacadeMethodCall, Struct) {

  /**
   * @name curam.cdsl.types.codetable.CodeTables
   * @namespace The main entry point to using code tables in CDSL.
   */
  var CodeTables = declare(null,
  /**
   * @lends curam.cdsl.types.codetable.CodeTables.prototype
   */
  {
    _connection: null,
    
    /**
     * Instantiates the API.
     * 
     * @param {curam/cdsl/_base/_Connection} connection The connection object
     *  to be used. Use an instance of curam/cdsl/connection/CuramConnection
     *  class.
     */
    constructor: function(connection) {
      if (!connection) {
        throw new Error("Missing parameter.");
      }
      if (typeof connection !== "object") {
        throw new Error("Wrong parameter type: " + typeof connection);
      }

      this._connection = connection;
    },
    
    /**
     * Gets a code table by name. The code table will correspond to
     * the currently logged in user's default locale.
     * 
     * Please note the object returned from this method is not updated
     * when code table content changes. In those cases you will need to call
     * this function again to get an updated CodeTable instance. 
     * 
     * @param {String} name Name of the code table to return.
     * 
     * @returns The requested code table or null if such code table
     *    is not loaded.
     */
    getCodeTable: function(name) {
      return this._connection.metadata().codetables()[name];
    },
    
    /**
     * Loads code tables for one or more specified facade method calls.
     * 
     * @param {[curam/cdsl/_base/FacadeMethodCall]} callToGetCodetablesFor
     *    Aray of method calls to load codetables for.
     * 
     * @returns {dojo/Promise::curam/cdsl/types/codetable/CodeTables} Promise
     *    which resolves when the code tables have been loaded. The resolved
     *    value is this instance of the CodeTables API, so that you can continue
     *    with the getCodeTable() method call.
     */
    loadForFacades: function(callsToGetCodetablesFor) {
      var deferred = new Deferred();
      /* Using nested require so that we don't end up with circular module
       * references due to CuramService indirectly requiring CodeTables API.
       */
      require(['curam/cdsl/request/CuramService'], lang.hitch(this,
          function(CuramService) {
            var service = new CuramService(this._connection),
                getCtsMethod = new FacadeMethodCall(
                    "CuramService", "getCodetables",
                    this._getInputStructsForLoadingCodetables(
                        callsToGetCodetablesFor));
    
            service.call([getCtsMethod]).then(
              lang.hitch(this, function(data) {
                deferred.resolve(this);
              }), function(err) {
                deferred.reject(err);
              });
          }));
      
      return deferred;
    },
    
    /**
     * Turn an array of FacadeMethodCall instances into an array of input
     * Structs for the CuramService.getCodetables() call.
     * 
     * @private
     *  
     * @param arrayOfMethodCalls The method calls.
     * @returns {Array} Array of structs.
     */
    _getInputStructsForLoadingCodetables: function(arrayOfMethodCalls) {
      var ret = [];
      for (var i = 0; i < arrayOfMethodCalls.length; i++) {
        ret.push(new Struct({
          service: arrayOfMethodCalls[i].intf(),
          method: arrayOfMethodCalls[i].method()
        }));
      }
      
      return ret;
    }
  });
  
  return CodeTables;
});

},
'curam/cdsl/types/codetable/CodeTableItem':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare'
        ], function(
            declare) {

  /**
   * @name curam.cdsl.types.codetable.CodeTableItem
   * @namespace 
   */
  var CodeTableItem = declare(null,
  /**
   * @lends curam.cdsl.types.codetable.CodeTableItem.prototype
   */
  {
    _code: null,
    
    _desc: null,
    
    _isDefault: null,
    
    /**
     * Creates an instance of code table item.
     * 
     * @param {String} code The code.
     * @param {String} desc The description.
     */
    constructor: function(code, desc) {
      this._code = code;
      this._desc = desc;
      this._isDefault = false;
    },
    
    /**
     * Gets the code.
     * @returns {String} The code.
     */
    getCode: function() {
      return this._code;
    },
    
    /**
     * Gets the description.
     * 
     * @returns {String} The description.
     */
    getDescription: function() {
      return this._desc;
    },
    
    /**
     * Get or set the default flag on this codetable item.
     * @param {boolean} [isDeflt] Flag to specify whether this code table item
     *  is defaul or not.
     */
    isDefault: function(isDeflt) {
      if (typeof isDeflt === 'undefined') {
        return this._isDefault || false;

      } else {
        var oldVal = this._isDefault;
        this._isDefault = isDeflt;
        return oldVal;
      }
    }
  });
  
  return CodeTableItem;
});

},
'curam/widget/AppBannerFilteringSelect':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.mixin
	"dijit/form/FilteringSelect",
	"curam/widget/AppBannerComboBoxMixin"
], function(declare, lang, FilteringSelect, AppBannerComboBoxMixin){

	// module:
	//		curam/widget/AppBannerFilteringSelect

	var CuramAppBannerFilteringSelect = declare("curam.widget.AppBannerFilteringSelect", [FilteringSelect, AppBannerComboBoxMixin], {
	});
	return CuramAppBannerFilteringSelect;
});

},
'curam/GlobalVars':function(){
define(["curam/util"
        ], function() {
  
  var GlobalVars = {
    // popupMappingRepository: Array
    //    stores mapping infor between popup results and widgets
    popupMappingRepository: [],

    // popupMappingLoaded: Array
    //    Mark what mappings have been fully loaded
    popupMappingLoaded: [],
    
    // popupInputs: Array
    //    Can be used to store values as inputs for a popup
    //    used only by the date selector popup currently
    //    also as no jsp tag support
    popupInputs: [],
    
    // currentPopupProps: Object
    currentPopupProps: null,
    
    // currentPopupInstanceName: String
    //    Used to index into the above repositories. The popup page
    //    Javascript codes accesses this variables as
    //    "opener.currentPopupInstance". i.e. before a popup is opened this
    //    variables MUST be set.
    currentPopupInstanceName: "",
    
    // popupWindow: Object
    //    The currently opened popup window instance
    popupWindow: null,
    
    // popupCTCodeMappings: Array
    //    Used to map code table values to page ids  
    popupCTCodeMappings: [],
    
    // popupPropertiesRepository: Array
    popupPropertiesRepository: [],
    
    // POPUP_EMPTY_SPAN_MIN_SIZE: Number
    //    This corresponds to the string set in the StaticPopupTextTag custom tag.
    POPUP_EMPTY_SPAN_MIN_SIZE: 15,
    
    // POPUP_EMPTY_SPAN_CHAR: String
    POPUP_EMPTY_SPAN_CHAR: "\u00A0",
    
    // POPUP_EMPTY_SPAN_VALUE: String
    //    This corresponds to the string set in the StaticPopupTextTag custom tag.
    POPUP_EMPTY_SPAN_VALUE: null,
    
    // replacedButtons: Array
    //    An action control can be displayed at the top and bottom of the 
    //    page and each instance has the same name. gen-jsp.xsl adds a 
    //    call to curam.util.replaceSubmitButton() for each instance of the button. 
    //    The following array tracks which buttons have
    //    already been replaced to ensure it is not done twice.
    replacedButtons: []
  };
  
  var gc = dojo.global.curam;
  dojo.mixin(gc, GlobalVars); 

  gc.POPUP_EMPTY_SPAN_VALUE = curam.util.fillString(
        gc.POPUP_EMPTY_SPAN_CHAR, gc.POPUP_EMPTY_SPAN_MIN_SIZE);
  
  return GlobalVars;
});

},
'curam/html':function(){
/*
 This file provides general html manipulation functions.
*/
define(["curam/define"
        ], function() {
  
  curam.define.singleton("curam.html", {
    splitWithTag: function(value, delim, tagName, fnModifier) {
      // summary: Splits a string value into tokenized elements, then wraps
      //          the specified tag name, or "div" if no tagName is specified.
      //          E.g. calling 
      //            curam.html.splitWithTag("hello\nworld", "\n", "div")
      //          returns
      //            "<div>hello</div><div>world</div>
      //          If fnModifier is speficied, it should be a function to which
      //          each split element is passed, and should return a new value for
      //          that element.
      var splitVal = value.split(delim || "\n");
      
      // If there are no delimiters found, do not wrap any tags around the value.
      if(splitVal.length < 2) {
        return fnModifier ? fnModifier(value) : value;
      }
      var t = (tagName || "div") + ">";
      var tagStart = "<" + t, tagEnd = "</" + t;
      
      if(fnModifier) {
        for(var i = 0; i < splitVal.length; i++) {
          splitVal[i] = fnModifier(splitVal[i]);
        }
      }
      
      // Join the array of tokenized values together with an end and start tag.
      return tagStart + splitVal.join(tagEnd + tagStart) + tagEnd;
    }
  });
  
  return curam.html;
});

},
'dojo/html':function(){
define(["./_base/kernel", "./_base/lang", "./_base/array", "./_base/declare", "./dom", "./dom-construct", "./parser"],
	function(kernel, lang, darray, declare, dom, domConstruct, parser){
	// module:
	//		dojo/html

	// the parser might be needed..

	// idCounter is incremented with each instantiation to allow assignment of a unique id for tracking, logging purposes
	var idCounter = 0;

	var html = {
		// summary:
		//		TODOC

		_secureForInnerHtml: function(/*String*/ cont){
			// summary:
			//		removes !DOCTYPE and title elements from the html string.
			//
			//		khtml is picky about dom faults, you can't attach a style or `<title>` node as child of body
			//		must go into head, so we need to cut out those tags
			// cont:
			//		An html string for insertion into the dom
			//
			return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
		},

		// Deprecated, should use dojo/dom-constuct.empty() directly, remove in 2.0.
		_emptyNode: domConstruct.empty,

		_setNodeContent: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont){
			// summary:
			//		inserts the given content into the given node
			// node:
			//		the parent element
			// content:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes

			// always empty
			domConstruct.empty(node);

			if(cont){
				if(typeof cont == "string"){
					cont = domConstruct.toDom(cont, node.ownerDocument);
				}
				if(!cont.nodeType && lang.isArrayLike(cont)){
					// handle as enumerable, but it may shrink as we enumerate it
					for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0){
						domConstruct.place( cont[i], node, "last");
					}
				}else{
					// pass nodes, documentFragments and unknowns through to dojo.place
					domConstruct.place(cont, node, "last");
				}
			}

			// return DomNode
			return node;
		},

		// we wrap up the content-setting operation in a object
		_ContentSetter: declare("dojo.html._ContentSetter", null, {
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",

			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,

			// extractContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of `<html> <body>` wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.	Root for attribute names to search for.	  If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: kernel._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.	  Only obeyed if parseContent is true.
			startup: true,

			// lifecycle methods
			constructor: function(/*Object*/ params, /*String|DomNode*/ node){
				// summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..

				// the original params are mixed directly into the instance "this"
				lang.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dom.byId( this.node || node );

				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /*Object?*/ params){
				// summary:
				//		front-end to the set-content sequence
				// cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();

				var ret = this.onEnd();

				if(ret && ret.then){
					// Make dojox/html/_ContentSetter.set() return a Promise that resolves when load and parse complete.
					return ret;
				}else{
					// Vanilla dojo/html._ContentSetter.set() returns a DOMNode for back compat.   For 2.0, switch it to
					// return a Deferred like above.
					return this.node;
				}
			},

			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node){
					// can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV

					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},

			empty: function(){
				// summary:
				//		cleanly empty out existing content

				// If there is a parse in progress, cancel it.
				if(this.parseDeferred){
					if(!this.parseDeferred.isResolved()){
						this.parseDeferred.cancel();
					}
					delete this.parseDeferred;
				}

				// destroy any widgets from a previous run
				// NOTE: if you don't want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happening
				if(this.parseResults && this.parseResults.length){
					darray.forEach(this.parseResults, function(w){
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				domConstruct.empty(this.node);
			},

			onBegin: function(){
				// summary:
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties -
				//		including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;

				if(lang.isString(cont)){
					if(this.cleanContent){
						cont = html._secureForInnerHtml(cont);
					}

					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();

				this.content = cont;
				return this.node; // DomNode
			},

			onEnd: function(){
				// summary:
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults and this.parseDeferred if you need those..
					this._parse();
				}
				return this.node; // DomNode
				// TODO: for 2.0 return a Promise indicating that the parse completed.
			},

			tearDown: function(){
				// summary:
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description:
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.parseDeferred;
				delete this.node;
				delete this.content;
			},

			onContentError: function(err){
				return "Error occurred setting content: " + err;
			},

			onExecError: function(err){
				return "Error occurred executing scripts: " + err;
			},

			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we don't consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		and the parse promise in this.parseDeferred
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					darray.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					var self = this;
					this.parseDeferred = parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					}).then(function(results){
							return self.parseResults = results;
						}, function(e){
							self._onError('Content', e, "Error parsing in _ContentSetter#" + this.id);
						});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#" + this.id);
				}
			},

			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		override/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					html._setNodeContent(this.node, errText, true);
				}
			}
		}), // end declare()

		set: function(/*DomNode*/ node, /*String|DomNode|NodeList*/ cont, /*Object?*/ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo/dom-construct.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct..place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo/dom-construct..place does not handle NodeList insertions
			//		dojo/dom-construct.place(cont, node, "only"). dojo/dom-construct.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo/dom-construct.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			// node:
			//		the parent element that will receive the content
			// cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo/NodeList, Array or other enumerable list of nodes
			// params:
			//		Optional flags/properties to configure the content-setting. See dojo/html/_ContentSetter
			// example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//	|	html.set(node, "some string");
			//	|	html.set(node, contentNode, {options});
			//	|	html.set(node, myNode.childNodes, {options});
			if(undefined == cont){
				console.warn("dojo.html.set: no cont argument provided, using empty string");
				cont = "";
			}
			if(!params){
				// simple and fast
				return html._setNodeContent(node, cont, true);
			}else{
				// more options but slower
				// note the arguments are reversed in order, to match the convention for instantiation via the parser
				var op = new html._ContentSetter(lang.mixin(
					params,
					{ content: cont, node: node }
				));
				return op.set();
			}
		}
	};
	lang.setObject("dojo.html", html);

	return html;
});

},
'dojo/Stateful':function(){
define(["./_base/declare", "./_base/lang", "./_base/array", "./when"], function(declare, lang, array, when){
	// module:
	//		dojo/Stateful

return declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	//
	//		The class also provides the functionality to auto-magically manage getters
	//		and setters for object attributes/properties.
	//		
	//		Getters and Setters should follow the format of _xxxGetter or _xxxSetter where 
	//		the xxx is a name of the attribute to handle.  So an attribute of "foo" 
	//		would have a custom getter of _fooGetter and a custom setter of _fooSetter.
	//
	// example:
	//	|	require(["dojo/Stateful", function(Stateful) {
	//	|		var obj = new Stateful();
	//	|		obj.watch("foo", function(){
	//	|			console.log("foo changed to " + this.get("foo"));
	//	|		});
	//	|		obj.set("foo","bar");
	//	|	});

	// _attrPairNames: Hash
	//		Used across all instances a hash to cache attribute names and their getter 
	//		and setter names.
	_attrPairNames: {},

	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		return (apn[name] = {
			s: "_" + name + "Setter",
			g: "_" + name + "Getter"
		});
	},

	postscript: function(/*Object?*/ params){
		// Automatic setting of params during construction
		if (params){ this.set(params); }
	},

	_get: function(name, names){
		// summary:
		//		Private function that does a get based off a hash of names
		// names:
		//		Hash of names of custom attributes
		return typeof this[names.g] === "function" ? this[names.g]() : this[name];
	},
	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		// name:
		//		The property to get.
		// returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		//		this just retrieves the object's property.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful({foo: 3});
		//	|		stateful.get("foo") // returns 3
		//	|		stateful.foo // returns 3
		//	|	});

		return this._get(name, this._getAttrNames(name)); //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		// name:
		//		The property to set.
		// value:
		//		The value to set in the property.
		// returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		//		the property. A programmatic setter may be defined in subclasses.
		// example:
		//	|	require(["dojo/Stateful", function(Stateful) {
		//	|		var stateful = new Stateful();
		//	|		stateful.watch(function(name, oldValue, value){
		//	|			// this will be called on the set below
		//	|		}
		//	|		stateful.set(foo, 5);
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|		stateful.set({
		//	|			foo: "Howdy",
		//	|			bar: 3
		//	|		});
		//	|	});
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)

		// If an object is used, iterate through object
		if(typeof name === "object"){
			for(var x in name){
				if(name.hasOwnProperty(x) && x !="_watchCallbacks"){
					this.set(x, name[x]);
				}
			}
			return this;
		}

		var names = this._getAttrNames(name),
			oldValue = this._get(name, names),
			setter = this[names.s],
			result;
		if(typeof setter === "function"){
			// use the explicit setter
			result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// no setter so set attribute directly
			this[name] = value;
		}
		if(this._watchCallbacks){
			var self = this;
			// If setter returned a promise, wait for it to complete, otherwise call watches immediately
			when(result, function(){
				self._watchCallbacks(name, oldValue, value);
			});
		}
		return this; // dojo/Stateful
	},
	_changeAttrValue: function(name, value){
		// summary:
		//		Internal helper for directly changing an attribute value.
		//
		// name: String
		//		The property to set.
		// value: Mixed
		//		The value to set in the property.
		//
		// description:
		//		Directly change the value of an attribute on an object, bypassing any 
		//		accessor setter.  Also handles the calling of watch and emitting events. 
		//		It is designed to be used by descendant class when there are two values 
		//		of attributes that are linked, but calling .set() is not appropriate.

		var oldValue = this.get(name);
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; // dojo/Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		// name:
		//		Indicates the property to watch. This is optional (the callback may be the
		//		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		//		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		// callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		//		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
						propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							propertyCallbacks[i].call(self, name, oldValue, value);
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);

		// TODO: Remove unwatch in 2.0
		var handle = {};
		handle.unwatch = handle.remove = function(){
			var index = array.indexOf(propertyCallbacks, callback);
			if(index > -1){
				propertyCallbacks.splice(index, 1);
			}
		};
		return handle; //Object
	}

});

});

},
'curam/widget/ComboBox':function(){
/*
 * Copyright 2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dijit/registry",
        "dojo/_base/declare",
        "dojo/on", 
        "dojo/dom", 
        "dojo/text!curam/widget/templates/ComboBox.html",
        "dijit/form/ComboBox",
        "curam/widget/ComboBoxMixin"
        ], function(registry, declare, on, dom, template) {
  
/*
 * Modification History
 * --------------------
   * 10-Mar-2014  AS  [CR00415345] Handled the enter key on open dropdown.
   * 09-Aug-2012 MV  [CR00337714] Load HTML template using the new mechanism. 
   * 01-Nov-2011 MV [CR00289694] Upgrade to Dojo 1.6. Fix code style, comments.
   * 08-Sep-2011 SB [TEC-7931]   Initial version.
   */

  /**
   * @name curam.widget.DropDownBox
   * @namespace Override of the Dojo ComboBox in order to make the Combobox
   *              accessible using screen reader.
   */
  var ComboBox = declare("curam.widget.ComboBox", [dijit.form.ComboBox, curam.widget.ComboBoxMixin],
  /**
   * @lends curam.widget.ComboBox.prototype
   */
  {
    templateString: template,
    // Flag which indicates if the enter key is used on open dropdown
    enterKeyOnOpenDropDown: false,
    
    postCreate : function() {
      // Attached a keyboard event listener so that we can set a flag
      // indicating enter is pressed in open state of dropdown
      on(this.focusNode, "keydown",function(e){
        var widget = registry.byNode(dom.byId("widget_" + e.target.id)); 
        if(e.keyCode == dojo.keys.ENTER && widget._opened) {
          widget.enterKeyOnOpenDropDown = true;
         }
       });
      
      this.inherited(arguments);
    }
  });
  
  return ComboBox;
});

},
'dijit/layout/LayoutContainer':function(){
define([
	"dojo/_base/array",
	"dojo/_base/declare", // declare
	"dojo/dom-class",
	"dojo/dom-style",
	"dojo/_base/lang",
	"../_WidgetBase",
	"./_LayoutWidget",
	"./utils" // layoutUtils.layoutChildren
], function(array, declare, domClass, domStyle, lang, _WidgetBase, _LayoutWidget, layoutUtils){

	// module:
	//		dijit/layout/LayoutContainer

	var LayoutContainer = declare("dijit.layout.LayoutContainer", _LayoutWidget, {
		// summary:
		//		A LayoutContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
		//		that contains a child widget marked region="center" and optionally children widgets marked
		//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
		//		Children along the edges will be laid out according to width or height dimensions. The remaining
		//		space is designated for the center region.
		//
		//		The outer size must be specified on the LayoutContainer node.  Width must be specified for the sides
		//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
		//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
		//		"left" and "right" except that they will be reversed in right-to-left environments.
		//
		//		For complex layouts, multiple children can be specified for a single region.   In this case, the
		//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
		//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
		//		instead of the design attribute to control layout precedence of horizontal vs. vertical panes.
		//
		//		See `LayoutContainer.ChildWidgetProperties` for details on the properties that can be set on
		//		children of a `LayoutContainer`.
		//
		//		If layoutPriority is not set, lays out each child in the natural order the children occur in.
		//		Basically each child is laid out into the "remaining space", where "remaining space" is initially
		//		the content area of this widget, but is reduced to a smaller rectangle each time a child is added.

		// design: String
		//		Which design is used for the layout:
		//
		//		- "headline" (default) where the top and bottom extend the full width of the container
		//		- "sidebar" where the left and right sides extend from top to bottom.
		//
		//		However, a `layoutPriority` setting on child panes overrides the `design` attribute on the parent.
		//		In other words, if the top and bottom sections have a lower `layoutPriority` than the left and right
		//		panes, the top and bottom panes will extend the entire width of the box.
		design: "headline",

		baseClass: "dijitLayoutContainer",

		startup: function(){
			if(this._started){
				return;
			}
			array.forEach(this.getChildren(), this._setupChild, this);
			this.inherited(arguments);
		},

		_setupChild: function(/*dijit/_WidgetBase*/ child){
			// Override _LayoutWidget._setupChild().

			this.inherited(arguments);

			var region = child.region;
			if(region){
				domClass.add(child.domNode, this.baseClass + "Pane");
			}
		},

		_getOrderedChildren: function(){
			// summary:
			//		Return list of my children in the order that I want layoutChildren()
			//		to process them (i.e. from the outside to the inside)

			var wrappers = array.map(this.getChildren(), function(child, idx){
				return {
					pane: child,
					weight: [
						child.region == "center" ? Infinity : 0,
						child.layoutPriority,
						(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
						idx
					]
				};
			}, this);
			wrappers.sort(function(a, b){
				var aw = a.weight, bw = b.weight;
				for(var i = 0; i < aw.length; i++){
					if(aw[i] != bw[i]){
						return aw[i] - bw[i];
					}
				}
				return 0;
			});

			return array.map(wrappers, function(w){ return w.pane; });
		},

		layout: function(){
			layoutUtils.layoutChildren(this.domNode, this._contentBox, this._getOrderedChildren());
		},

		addChild: function(/*dijit/_WidgetBase*/ child, /*Integer?*/ insertIndex){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}
		},

		removeChild: function(/*dijit/_WidgetBase*/ child){
			this.inherited(arguments);
			if(this._started){
				this.layout();
			}

			// Clean up whatever style changes we made to the child pane.
			// Unclear how height and width should be handled.
			domClass.remove(child.domNode, this.baseClass + "Pane");
			domStyle.set(child.domNode, {
				top: "auto",
				bottom: "auto",
				left: "auto",
				right: "auto",
				position: "static"
			});
			domStyle.set(child.domNode, /top|bottom/.test(child.region) ? "width" : "height", "auto");
		}
	});

	LayoutContainer.ChildWidgetProperties = {
		// summary:
		//		These properties can be specified for the children of a LayoutContainer.

		// region: [const] String
		//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
		//		See the `dijit/layout/LayoutContainer` description for details.
		region: '',

		// layoutAlign: [const deprecated] String
		//		Synonym for region, except using "client" instead of "center".  Deprecated; use region instead.
		layoutAlign: '',

		// layoutPriority: [const] Number
		//		Children with a higher layoutPriority will be placed closer to the LayoutContainer center,
		//		between children with a lower layoutPriority.
		layoutPriority: 0
	};

	// Since any widget can be specified as a LayoutContainer child, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	// This is for the benefit of the parser.   Remove for 2.0.  Also, hide from doc viewer.
	lang.extend(_WidgetBase, /*===== {} || =====*/ LayoutContainer.ChildWidgetProperties);

	return LayoutContainer;
});

},
'dojo/dnd/autoscroll':function(){
define(["../_base/lang", "../sniff", "../_base/window", "../dom-geometry", "../dom-style", "../window"],
	function(lang, has, win, domGeom, domStyle, winUtils){

// module:
//		dojo/dnd/autoscroll

var exports = {
	// summary:
	//		Used by dojo/dnd/Manager to scroll document or internal node when the user
	//		drags near the edge of the viewport or a scrollable node
};
lang.setObject("dojo.dnd.autoscroll", exports);

exports.getViewport = winUtils.getBox;

exports.V_TRIGGER_AUTOSCROLL = 32;
exports.H_TRIGGER_AUTOSCROLL = 32;

exports.V_AUTOSCROLL_VALUE = 16;
exports.H_AUTOSCROLL_VALUE = 16;

// These are set by autoScrollStart().
// Set to default values in case autoScrollStart() isn't called. (back-compat, remove for 2.0)
var viewport,
	doc = win.doc,
	maxScrollTop = Infinity,
	maxScrollLeft = Infinity;

exports.autoScrollStart = function(d){
	// summary:
	//		Called at the start of a drag.
	// d: Document
	//		The document of the node being dragged.

	doc = d;
	viewport = winUtils.getBox(doc);

	// Save height/width of document at start of drag, before it gets distorted by a user dragging an avatar past
	// the document's edge
	var html = win.body(doc).parentNode;
	maxScrollTop = Math.max(html.scrollHeight - viewport.h, 0);
	maxScrollLeft = Math.max(html.scrollWidth - viewport.w, 0);	// usually 0
};

exports.autoScroll = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the window, if
	//		necessary
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!
	var v = viewport || winUtils.getBox(doc), // getBox() call for back-compat, in case autoScrollStart() wasn't called
		html = win.body(doc).parentNode,
		dx = 0, dy = 0;
	if(e.clientX < exports.H_TRIGGER_AUTOSCROLL){
		dx = -exports.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - exports.H_TRIGGER_AUTOSCROLL){
		dx = Math.min(exports.H_AUTOSCROLL_VALUE, maxScrollLeft - html.scrollLeft);	// don't scroll past edge of doc
	}
	if(e.clientY < exports.V_TRIGGER_AUTOSCROLL){
		dy = -exports.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - exports.V_TRIGGER_AUTOSCROLL){
		dy = Math.min(exports.V_AUTOSCROLL_VALUE, maxScrollTop - html.scrollTop);	// don't scroll past edge of doc
	}
	window.scrollBy(dx, dy);
};

exports._validNodes = {"div": 1, "p": 1, "td": 1};
exports._validOverflow = {"auto": 1, "scroll": 1};

exports.autoScrollNodes = function(e){
	// summary:
	//		a handler for mousemove and touchmove events, which scrolls the first available
	//		Dom element, it falls back to exports.autoScroll()
	// e: Event
	//		mousemove/touchmove event

	// FIXME: needs more docs!

	var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;

	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in exports._validNodes)){
			var s = domStyle.getComputedStyle(n),
				overflow = (s.overflow.toLowerCase() in exports._validOverflow),
				overflowX = (s.overflowX.toLowerCase() in exports._validOverflow),
				overflowY = (s.overflowY.toLowerCase() in exports._validOverflow);
			if(overflow || overflowX || overflowY){
				b = domGeom.getContentBox(n, s);
				t = domGeom.position(n, true);
			}
			// overflow-x
			if(overflow || overflowX){
				w = Math.min(exports.H_TRIGGER_AUTOSCROLL, b.w / 2);
				rx = e.pageX - t.x;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += win.body().scrollLeft;
				}
				dx = 0;
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
					oldLeft = n.scrollLeft;
					n.scrollLeft = n.scrollLeft + dx;
				}
			}
			// overflow-y
			if(overflow || overflowY){
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				h = Math.min(exports.V_TRIGGER_AUTOSCROLL, b.h / 2);
				ry = e.pageY - t.y;
				if(has("webkit") || has("opera")){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the domGeom.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					ry += win.body().scrollTop;
				}
				dy = 0;
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
					oldTop = n.scrollTop;
					n.scrollTop  = n.scrollTop  + dy;
				}
			}
			if(dx || dy){ return; }
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	exports.autoScroll(e);
};

return exports;

});

},
'curam/cdsl/_base/FacadeMethodCall':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/*
 * Modification History
 * --------------------
 * 26-Sep-2014  MV  [CR00445374] Implement generic data hookpoint.
 */

define(['dojo/_base/declare',
        "dojo/_base/lang",
        'dojo/json',
        'dojo/_base/array'
        ], function(
            declare, lang, json, array) {

  /**
   * @name curam.cdsl.request.FacadeMethodCall
   * @namespace Represents a method of a Curam facade to be called. 
   */
  var FacadeMethodCall = declare(null,
  /**
   * @lends curam.cdsl.request.FacadeMethodCall.prototype
   */
  {
    _intf: null,

    _method: null,

    _structs: null,
    
    _metadata: null,
    
    _options: null,

    /**
     * 
     * Creates an instance.
     *
     * @param {String} intf Name of the server interface to call.
     * @param {String} method Name of the server interface method to call.
     * @param {[curam/cdsl/Struct]} structs Array of Struct object instances
     *     to pass as parameters to the server interface call.
     * @param {Object} options An object containing additional options.
     *     The following options are supported:<pre><code>
     *        {
     *          formatted: true|false,
     *          raw: true|false,
     *          dataAdapter: {
     *            onRequest: {
     *              onItem: function(path, val) { return val; },
     *              onStruct: function(data) {}
     *            },
     *            onResponse: {
     *              onItem: function(path, val) { return val; },
     *              onStruct: function(data) {}
     *            }
     *          }
     *        }</code></pre>
     *     The <code>onRequest</code> functions will be applied to raw data being sent
     *     TO the server, after the CDSL API has processed the data.
     *     The <code>onResponse</code> functions will be applied to raw data being received
     *     FROM the server, before the CDSL API has processed the data.
     *     All of the above functions are optional - you are free to only
     *     include the ones you are interested in using.
     *     <p/>
     *     The <code>onItem</code> function takes two arguments.
     *     The <code>path</codepre> argument is a fully qualified path to the data item
     *     within its Struct. For example:<pre><code>
     *       new Struct({
     *         id: 45  // path == 'id'
     *         nestedStruct: { name: "some name" }  // path == 'nestedStruct.name'
     *         dtls: [
     *           { id: 32 }, // path == 'dtls[0].id'
     *           { id: 33 }  // path == 'dtls[1].id'
     *         ]
     *       })</code></pre>
     *     The <code>val</code> argument contains the current value of the data
     *     item.
     *     The function is expected to return the new value for the data item.
     *     Please note you must always return a value, otherwise the data item
     *     will be undefined. By default you should return the current value.
     *     <p/>
     *     The <code>onStruct</code> function takes one argument which provides access
     *     to the complete contained data. You can examine or modify data
     *     as needed. No return value is expected.
     */
    constructor: function(intf, method, structs, options) {
      if (structs && !lang.isArray(structs)) {
        throw new Error("Unexpected type of the 'structs' argument.");
      }
      
      this._intf = intf;
      this._method = method;
      this._structs = structs ? structs : [];
      this._options = {};
      lang.mixin(this._options, {
        // default values below
        raw: true,
        formatted: false,
        sendCodetables: true,
        dataAdapter: null
      },
      // user specified values below
      options);
    },

    /**
     * @private
     * @param base
     * @returns {String}
     */
    url: function(base) {
      return base + '/' + this._intf + '/' + this._method;
    },
    
    /**
     * @private
     * @param metadata
     */
    _setMetadata: function(metadata) {
      this._metadata = metadata;
    },

    /**
     * @private
     * @returns
     */
    toJson: function() {
      var data = {
        service: this._intf,
        method: this._method,
        data: array.map(this._structs, lang.hitch(this, function(item) {
          item.setDataAdapter(this._options.dataAdapter);
          return item.getData();
        })),
        configOptions: {
          'response-type': this._responseType(),
          'send-codetables': this._sendCodetables()
        }
      };
      
      if (this._metadata && this._metadata.queryOptions) {
        data.queryOptions = this._metadata.queryOptions;
      }
      
      return json.stringify(data);
    },
    
    /**
     * Set or get the value of flag specifying whether server should return
     * formatted data.
     * 
     * The default value is false, which means do not send formatted data.
     *
     * @param {boolean} sendFormatted Specifies whether the server should
     *    return formatted data. If this parameter is not passed at all
     *    the function returns the current value.
     * @returns True if formatted data should be requested, otherwise false.
     *    When used as setter the function returns the old value of the flag.
     */
    formatted: function(sendFormatted) {
      return this._getOrSet(sendFormatted, this._options, 'formatted');
    },
    
    raw: function(sendRaw) {
      return this._getOrSet(sendRaw, this._options, 'raw');
    },
    
    /**
     * @private
     * @returns {String}
     */
    _responseType: function() {
      if (this.raw() && this.formatted()) {
        return 'both';

      } else if (this.raw()) {
        return 'raw';

      } else if (this.formatted()) {
        return 'formatted';
      }
      
      throw new Error(
          'Invalid response type: neither raw nor formatted was requested.');
    },
    
    /**
     * @private
     * @param sendCodetables
     * @returns
     */
    _sendCodetables: function(sendCodetables) {
      return this._getOrSet(sendCodetables, this._options, 'sendCodetables');
    },
    
    /**
     * @private 
     * @param value
     * @param options
     * @param property
     * @returns
     */
    _getOrSet: function(value, options, property) {
      if (typeof value === 'undefined') {
        return options[property];

      } else {
        var oldValue = options[property];
        options[property] = value;
        return oldValue;
      }
    },
    
    /**
     * private
     * @returns {String}
     */
    intf: function() {
      return this._intf;
    },

    /**
     * @private
     * @returns {String}
     */
    method: function() {
      return this._method;
    },
    
    dataAdapter: function(adapter) {
      if (!adapter) {
        return this._options.dataAdapter;
      }
      
      this._options.dataAdapter = adapter;
    }
  });
  
  return FacadeMethodCall;
});

},
'curam/util/ScreenContext':function(){
define(["dojo/_base/declare"], function(declare) {
  
  var CONTEXT_KEYS = {
      DEFAULT_CONTEXT: 112,
      SAMPLE22: 2,
      SAMPLE21: 1,
      SAMPLE13: 4,
      SAMPLE12: 2,
      SAMPLE11: 1,
      EXTAPP: 1048576,
      SMART_PANEL: 262144,
      NESTED_UIM: 131072,
      ORG_TREE: 65536,
      CONTEXT_PANEL: 32768,
      LIST_ROW_INLINE_PAGE: 8192,
      LIST_EVEN_ROW: 16384,
      TAB: 4096,
      TREE: 2048,
      AGENDA: 1024,
      POPUP: 512,
      MODAL: 256,
      HOME: 128,
      HEADER: 64,
      NAVIGATOR: 32,
      FOOTER: 16,
      OVAL: 8,
      RESOLVE: 4,
      ACTION: 2,
      ERROR: 1,
      EMPTY: 0
  };
  
  var CTX_NAMES = [['ERROR', 'ACTION', 'RESOLVE', 'OPT_VALIDATION',
                       'FOOTER', 'NAVIGATOR', 'HEADER',
                       'HOME_PAGE', 'MODAL', 'POPUP', 'AGENDA','TREE', 'TAB', 
                       'LIST_EVEN_ROW', 'LIST_ROW_INLINE_PAGE', 'CONTEXT_PANEL', 
                       'ORG_TREE','NESTED_UIM','SMART_PANEL',
                       'EXTAPP'],
                   ['SAMPLE11', 'SAMPLE12','SAMPLE13'],
                   ['SAMPLE21','SAMPLE22']];
  
  var ScreenContext = declare("curam.util.ScreenContext", null, {
    constructor: function(initialContext){
      // summary:
      //    Sets up the ScreenContext with either the initialContext parameter
      //    or a default context
      
      if (initialContext) {
        
        this.setContext(initialContext);
      } else {
        // What's the point of the OR here? Aren't they the same?
        this.currentContext = [
              CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]];
      }
    },
    
    setContext: function(newContext) {
      // summary:
      //    Sets the context. If null, a default context is used.
      var tmp = this.setup(newContext);
      
      this.currentContext =  
        ((tmp == null) ? 
         ([CONTEXT_KEYS["DEFAULT_CONTEXT"] | CONTEXT_KEYS["DEFAULT_CONTEXT"]]) : (tmp));
    },
  
    addContextBits: function(contextBits, idx) {
      // summary:
      //    Adds context bits to the existing context
      if (!contextBits) {
        return;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        this.currentContext[navig] |= pContext;
      }
      return this.currentContext[navig];
    },
  
    addAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      var navig = (idx)? idx : 0;
      this.currentContext[navig] = 4294967295;
      return this.currentContext[navig];
    },
  
    clear: function(contextBits, idx) {
      // summary:
      //    Clears the given named context bits
      if (!contextBits) {
        this.clearAll();
        return;
      }
      var navig = (idx)? idx : 0;
      if (contextBits == 0) {
        return this.currentContext[navig];
      }
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var clearedBits = this.currentContext[navig] & pContext;
        this.currentContext[navig] ^= clearedBits;
      }
      return this.currentContext[navig];
    },
  
    clearAll: function(idx) {
      // summary:
      //    all in all ranges! if idx == null, all ranges, otherwise - selected
      if (idx) {
        this.currentContext[idx] = 0;
      } else {
        for (var i = 0; i <this.currentContext.length; i++) {
          this.currentContext[i] = 0;
        }
      }
    },
  
    updateStates: function(newContext) {
      this.clear('ERROR|ACTION|RESOLVE');
      this.currentContext[0] = this.currentContext[0] | (newContext & 7);
    },
  
    hasContextBits: function(contextBits, idx) {
      if (!contextBits) {
        return false;
      }
      var navig = (idx) ? idx : 0;
      var pContext = this.parseContext(contextBits);
      if (pContext != null) {
        var merge = this.currentContext[navig] & pContext;
        
        return (merge == pContext);
      }
      return false;
    },
  
    getValue: function() {
      // summary:
      //    Gets the value of the context.
      var outputVal = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        outputVal += this.currentContext[i] + "|";
      }
      return outputVal.substring(0,outputVal.length-1);
    },
  
    toRequestString: function() {
      return "o3ctx=" + this.getValue();
    },
  
    toBinary: function() {
      var binaryStr = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        binaryStr += this.currentContext[i].toString(2) + "|";
      }
      return binaryStr.substring(0,binaryStr.length-1);
    },
  
    toString: function() {
      var accumulatedContext = "";
      for (var i = 0; i < this.currentContext.length; i++) {
        var ctxList = "";
        var j = 0;
        while (j < CTX_NAMES[i].length) {
          if (((this.currentContext[i] >> j) & 1) != 0) {
            ctxList +="," + CTX_NAMES[i][j];
          }
          j++;
        }
        if (ctxList == '') {
          return "{}";
        }
        accumulatedContext += 
          "|" + ctxList.replace(",", "{") + ((ctxList.length == 0)?"" : "}");
      }
      return accumulatedContext.substring(1);
    },
  
    parseContext: function(contextString) {
      var tmpString = contextString.replace(/,/g, "|");
      
      var parts = tmpString.split("|");
      var tmp = isNaN(parts[0]) ? parseInt(CONTEXT_KEYS[parts[0]]) : parts[0];
      
      for(var i = 1; i < parts.length; i++){
        tmp = tmp | (isNaN(parts[i]) ? parseInt(CONTEXT_KEYS[parts[i]]) : parts[i]);
      }

      return (isNaN(tmp) ? null : tmp);
    },
  
    setup: function(stringWithBars) {
      // summary:
      //    Sets up the context using a string delimited by '|'
      if (!stringWithBars) {
        return null;
      }
      var initialArray = ("" + stringWithBars).split("|");
      var resultArray = new Array(initialArray.length);
      
      for (var i = 0; i < initialArray.length; i++) {
        resultArray[i] = 
            this.parseContext(initialArray[initialArray.length - i - 1]);
        resultArray[i] = resultArray[i] | resultArray[i];
        if (!resultArray[i] 
              || isNaN(resultArray[i]) 
              || resultArray[i] > 4294967295) {
          return null;
        }
      }
      return resultArray;
    }
  });
  
  return ScreenContext;
});

},
'dijit/layout/utils':function(){
define([
    "dojo/_base/array", // array.filter array.forEach
    "dojo/dom-class", // domClass.add domClass.remove
    "dojo/dom-geometry", // domGeometry.marginBox
    "dojo/dom-style", // domStyle.getComputedStyle
    "dojo/_base/lang" // lang.mixin, lang.setObject
], function(array, domClass, domGeometry, domStyle, lang){

    // module:
    //    dijit/layout/utils

    function capitalize(word){
      return word.substring(0,1).toUpperCase() + word.substring(1);
    }

    function size(widget, dim){
      // size the child
      var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

    /* CURAM-FIX: addition */
    if (widget.fakeWidget) {
      return;
    }
    /* END CURAM-FIX */


    // record child's size
    if(newSize){
      // if the child returned it's new size then use that
      lang.mixin(widget, newSize);
    }else{
      // otherwise, call getMarginBox(), but favor our own numbers when we have them.
      // the browser lies sometimes
      /* CURAM-FIX: replace following line */
      //  lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
      lang.mixin(widget, domGeometry.getMarginBoxSimple(widget.domNode));
      /* END CURAM-FIX */
    }
  }

    var utils = {
      // summary:
      //    Utility functions for doing layout

      marginBox2contentBox: function(/*DomNode*/ node, /*Object*/ mb){
        // summary:
        //    Given the margin-box size of a node, return its content box size.
        //    Functions like domGeometry.contentBox() but is more reliable since it doesn't have
        //    to wait for the browser to compute sizes.
        var cs = domStyle.getComputedStyle(node);
        var me = domGeometry.getMarginExtents(node, cs);
        var pb = domGeometry.getPadBorderExtents(node, cs);
        return {
          l: domStyle.toPixelValue(node, cs.paddingLeft),
          t: domStyle.toPixelValue(node, cs.paddingTop),
          w: mb.w - (me.w + pb.w),
          h: mb.h - (me.h + pb.h)
        };
      },

      layoutChildren: function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
                        /*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
        // summary:
        //    Layout a bunch of child dom nodes within a parent dom node
        //    container:
        //      parent node
        //    dim:
        //      {l, t, w, h} object specifying dimensions of container into which to place children
        //    children:
        //      An array of Widgets or at least objects containing:
        //
        // - domNode: pointer to DOM node to position
        // - region or layoutAlign: position to place DOM node
        // - resize(): (optional) method to set size of node
        // - id: (optional) Id of widgets, referenced from resize object, below.
        //
        //    The widgets in this array should be ordered according to how they should be laid out
        //    (each element will be processed in order, and take up as much remaining space as needed),
        //    with the center widget last.
        //    changedRegionId:
        //      If specified, the slider for the region with the specified id has been dragged, and thus
        //      the region's height or width should be adjusted according to changedRegionSize
        //    changedRegionSize:
        //      See changedRegionId.

        // copy dim because we are going to modify it
        dim = lang.mixin({}, dim);
        domClass.add(container, "dijitLayoutContainer");

        // Move "client" elements to the end of the array for layout.  a11y dictates that the author
        // needs to be able to put them in the document in tab-order, but this algorithm requires that
        // client be last.    TODO: remove for 2.0, all dijit client code already sends children as last item.
        children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
                     .concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

        /* CURAM-FIX: added next line */
        var retDim = {};

        // set positions/sizes
        array.forEach(children,
          function(child){
            var elm =
              child.domNode,
                pos = (child.region || child.layoutAlign);
            if(!pos){
              throw new Error("No region setting for " + child.id)
            }

            // set elem to upper left corner of unused space; may move it later
            var elmStyle = elm.style;
            elmStyle.left = dim.l+"px";
            elmStyle.top = dim.t+"px";
            elmStyle.position = "absolute";

            domClass.add(elm, "dijitAlign" + capitalize(pos));

            // Size adjustments to make to this child widget
            var sizeSetting = {};

            // Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
            // panes and width adjustment for left/right align panes.
            if(changedRegionId && changedRegionId == child.id){
              sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
            }

            if(pos == "leading"){
              pos = child.isLeftToRight() ? "left" : "right";
            }
            if(pos == "trailing"){
              pos = child.isLeftToRight() ? "right" : "left";
            }

            // set size && adjust record of remaining space.
            // note that setting the width of a <div> may affect its height.
            if(pos == "top" || pos == "bottom"){
              sizeSetting.w = dim.w;
              size(child, sizeSetting);
              dim.h -= child.h;
              if(pos == "top"){
                dim.t += child.h;
              }else{
                elmStyle.top = dim.t + dim.h + "px";
              }
            }else if(pos == "left" || pos == "right"){
              sizeSetting.h = dim.h;
              size(child, sizeSetting);	
              /* CURAM-FIX: addition */		 
			  if(child.isSplitter)
			  {
				//Reset the left attribute to not include the width
				elmStyle.left = dim.l - child.w +"px";
				dim.w += child.w; 
			  } else {
				dim.w -= child.w;  
			  }
              /* END CURAM-FIX */
              if(pos == "left"){
              /* CURAM-FIX: addition */
				if(!child.isSplitter)
				{
					dim.l += child.w;
				}
              /* END CURAM-FIX */
              }else{
              /* CURAM-FIX: addition */
				if(child.isSplitter)
				{
					elmStyle.left = dim.l + dim.w - child.w + "px";
					dim.l += child.w;
				} else {
					elmStyle.left = dim.l + dim.w + "px";
				}
              /* END CURAM-FIX */
              }
            }else if(pos == "client" || pos == "center"){
              size(child, dim);
            }
            /* CURAM-FIX: addition */
            retDim[pos] = {
              w: dim.w,
              h: dim.h
            };
            /* END CURAM-FIX */
        });		
        /* CURAM-FIX: addition next line */
        return retDim;
      }
    };

    lang.setObject("dijit.layout.utils", utils); // remove for 2.0

    return utils;
});

},
'curam/util/FrequencyEditor':function(){
/* Licensed Materials - Property of IBM
 *
 * Copyright IBM Corporation 2012,2014. All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication or disclosure
 * restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Copyright 2001-2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
define(["dojo/dom",
        "dojo/dom-style",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/query",
        "cm/_base/_dom",
        "curam/util",
        "curam/define",
        "curam/debug",
        "dojo/has",
        "dojo/sniff"
        ], function(dom, domStyle, domClass, domAttr, domConstruct, query, cm, util, 
            define, debug, has) {
/*
 * Modification History
 * --------------------
 * 18-Apr-2017  AZ  [RTC 193510] Use dojo.byId instead of registry.byId on
 *                               iOS and Android devices.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                include required bundle.
 * 10-Jul-2013  JY  [CR00391624] Added the missing frequency option from a
 *                  start date.
 * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
 * 12-Nov-2012  JY  [CR00353394] Correct the selection of the radio buttons
 *                  when editing a frequency pattern.
 * 31-Jul-2012  MV  [CR00336202] Migrate to take on Dojo 1.7.3
 * 09-Mar-2011  JY  [CR00309128] Added functions to support the text string
 *                  concatenation.
 * 28-Sep-2011  JY  [CR00288721] Fixed the exception error for the function
 *              setSelectedFreqType() and also refactored this function to
 *              make it easier to be unit tested.
 * 13-Sep-2011  JY  [CR00287363] Fix the validation, radio button
 *                  selection and dropdown related issue.
 * 17-Feb-2011  MV  [CR00253193] Fix dropdown related code.
 * 21-Jan-2011  DG  [CR00243540] Changed "console.log" to "curam.debug.log".
 * 29-Nov-2010 MV [CR00232623] Return initialization status
 *    from the initPage() function.
 * 18-Nov-2010 MV [CR00231655] Connect to DOM events with a function that will
 *    automatically disconnect on page unload.
 * 05-Oct-2010  MV [CR00221605] Allow pressing ENTER key to submit the results.
 * 09-Sep-2010  MV [CR00219675] Fix issue with editing numbers in the dialog.
 *        Rename and move code to the correct namespace.
 */
/**
 * @namespace Utility functions used by the popup editor for a frequency
 *    pattern.
 */
  define.singleton("curam.util.FrequencyEditor", {
  /**
   * Variable used to reorder visual representation of yearly and bi-monthly
   * view.
   */
  CORRECTOR: 1,

  /** Frequency pattern type. */
  DAILY_FREQUENCY: 0,
  /** Frequency pattern type. */
  WEEKLY_FREQUENCY: 1,
  /** Frequency pattern type. */
  MONTHLY_FREQUENCY: 2,
  /** Frequency pattern type. */
  YEARLY_FREQUENCY: 3,
  /** Frequency pattern type. */
  BIMONTHLY_FREQUENCY: 4,
  
  
  /** Frequency pattern dayOfWeekMask bit mask. */
  EVERY_DAY_MASK: 201,
  /** Frequency pattern dayOfWeekMask bit mask. */
  EVERY_WEEKDAY_MASK: 202,
  /** Frequency pattern dayOfWeekMask bit mask. */
  EVERY_WEEKENDDAY_MASK: 203,
  /** Frequency pattern dayOfWeekMask bit mask. */
  MON_MASK: 1,
  /** Frequency pattern dayOfWeekMask bit mask. */
  TUE_MASK: 2,
  /** Frequency pattern dayOfWeekMask bit mask. */
  WED_MASK: 4, 
  /** Frequency pattern dayOfWeekMask bit mask. */
  THU_MASK: 8,
  /** Frequency pattern dayOfWeekMask bit mask. */
  FRI_MASK: 16,
  /** Frequency pattern dayOfWeekMask bit mask. */
  SAT_MASK: 32,
  /** Frequency pattern dayOfWeekMask bit mask. */
  SUN_MASK: 64,

  /** Used in validations. */
  daysInMonth: [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ],

  /*
   * For radio buttons in each layer.
   * NOTE: the numbers represent the order they appear on the layer.
   */
  /** Daily layer. */
  EVERY_DAY: 0,
  /** Daily layer. */
  EVERY_WEEKDAY: 1,
  /** Weekly layer (select only single day). */
  MON: 0,
  /** Weekly layer (select only single day). */
  TUE: 1,
  /** Weekly layer (select only single day). */
  WED: 2,
  /** Weekly layer (select only single day). */
  THU: 3,
  /** Weekly layer (select only single day). */
  FRI: 4,
  /** Weekly layer (select only single day). */
  SAT: 5,
  /** Weekly layer (select only single day). */
  SUN: 6,

  // monthly layer - 3 options
  /** start date */
  START_DATE: 0,
  /** a day number */
  MONTH_DAY_NUM: 1,
  /** a day from a list */
  MONTH_SEL_DAY: 2,
  
  // bi-monthly layer - 2 options
  /** a day number */
  DAY_NUM: 0,
  /** a day from a list */
  SEL_DAY: 1,
  
  //yearly layer, 2 options,
  /** Select month specify day number. */
  SEL_MONTH_DAY_NUM: 0,
  /** Select a day and month from a list. */
  SEL_MONTH_SEL_DAY: 1,
  
  domSelector: ( has("ios") || has("android") ? dojo : dijit ),

  allowableCharsForNumeric: [
    "1", "2", "3", "4", "5", "6",
    "7", "8", "9", "0",
    dojo.keys.LEFT_ARROW,
    dojo.keys.RIGHT_ARROW,
    dojo.keys.DELETE,
    dojo.keys.ENTER,
    dojo.keys.BACKSPACE,
    dojo.keys.END,
    dojo.keys.HOME,
    dojo.keys.TAB,
    dojo.keys.F5
  ],
  
  
  allowableDayString: [
    "32", "33", "34",
    "35", "36"
  ],
                     
  allowableDayOfWeekMask: [
    "201", "202", "203",
    "1", "2", "4",
    "8", "16", "32",
    "64"
  ],
  
  allowableFirstDayStringForBimonthly: [
    "32", "33", "34",
    "35"
  ],
                                      
  allowableSecondDayStringForBimonthly: [
    "33", "34", "35",
    "36"
  ],
                                      
  allowableWeekdayStringForBimonthly: [
    "1", "2", "4",
    "8", "16", "32",
    "64"                          
  ],
  
  allowableMonthString: [
    "1", "2", "3",
    "4", "5", "6", "7",
    "8", "9", "10",
    "11", "12"
  ],
 
  /**
   * "onLoad" handler execute when the page is loaded.
   *
   * @returns True if the dialog is closing, false otherwise.
   */
  initPage: function() {
    var parent = curam.dialog.getParentWindow(window);

    // the form has been activated, do the mappings and close
    if(formActivated == true) {             
      executeOpenerMapping("freq_text", translatedPatternString);
      executeOpenerMapping("freq_data", patternString);
      // dismiss the progress spinner
      curam.util.getTopmostWindow().dojo.publish("/curam/progress/unload");
      curam.dialog.closeModalDialog();
      return false;
    }

    var freq = parent.getPopupInput('initFreq');
    curam.debug.log(debug.getProperty("curam.util.FrequencyEditor.input"), 
                    freq);
    if(!freq || freq == null || freq.length == 0) {
      // if there is no input, default to a daily frequency
      document.theForm.freqType[0].checked = true;
      document.theForm.daily_select_type[
          curam.util.FrequencyEditor.EVERY_DAY].checked = true;
      return true;
    }  

    var freqType = parseInt(freq.charAt(0),10);
    if(freqType == curam.util.FrequencyEditor.DAILY_FREQUENCY) {
      curam.util.FrequencyEditor.setupDailyFrequency(freq);

    } else if(freqType == curam.util.FrequencyEditor.WEEKLY_FREQUENCY) {
      curam.util.FrequencyEditor.setupWeeklyFrequency(freq);  

    } else if(freqType == curam.util.FrequencyEditor.MONTHLY_FREQUENCY) {
      curam.util.FrequencyEditor.setupMonthlyFrequency(freq);

    } else if(freqType == curam.util.FrequencyEditor.YEARLY_FREQUENCY) {
      curam.util.FrequencyEditor.setupYearlyFrequency(freq);

    } else if(freqType == curam.util.FrequencyEditor.BIMONTHLY_FREQUENCY) {
      curam.util.FrequencyEditor.setupBimonthlyFrequency(freq);

    } else {
      alert(errorMsgs.freqPattern);
    }  

    return true;
  },

  /**
   * Exceute when the page is initially loaded, sets the state of the widgets
   * for a daily pattern.
   */
  setupDailyFrequency: function(frequency) {
    var dayOfWeekMask = frequency.substr(4,3);
    
    document.theForm.freqType[
      curam.util.FrequencyEditor.DAILY_FREQUENCY].checked = true;

    
    if(parseInt(dayOfWeekMask,10)
        == curam.util.FrequencyEditor.EVERY_WEEKDAY_MASK) {
      
      document.theForm.daily_select_type[
          curam.util.FrequencyEditor.EVERY_WEEKDAY].checked = true;
    
    } else {
      document.theForm.daily_select_type[
          curam.util.FrequencyEditor.EVERY_DAY].checked = true;
      var numDays = parseInt(frequency.substr(1,3), 10);
      document.theForm.daily_num.value = "" + numDays;
    }
    
  },

  /**
   * Exceute when the page is initially loaded, sets the state of the widgets
   * for a weekly pattern.
   */
  setupWeeklyFrequency: function(frequency) {
    var dayOfWeekMask = parseInt(frequency.substr(4,3),10);
    
    document.theForm.freqType[
      curam.util.FrequencyEditor.WEEKLY_FREQUENCY].checked = true;

    // days of week are represented by powers of 2 in the dayOfWeekMask
    // bit pattern
    if(dayOfWeekMask & curam.util.FrequencyEditor.MON_MASK)
      document.theForm.weekly_select_mon.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.TUE_MASK)
      document.theForm.weekly_select_tue.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.WED_MASK)
      document.theForm.weekly_select_wed.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.THU_MASK)
      document.theForm.weekly_select_thur.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.FRI_MASK)
      document.theForm.weekly_select_fri.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.SAT_MASK)
      document.theForm.weekly_select_sat.checked = true;
    if(dayOfWeekMask & curam.util.FrequencyEditor.SUN_MASK)
      document.theForm.weekly_select_sun.checked = true;
    
    var numWeeks = parseInt(frequency.substr(1,3), 10);
    document.theForm.weekly_num.value = "" + numWeeks;

  },

  /**
   * Execute when the page is initially loaded, sets the state of the widgets
   * for a monthly pattern.
   */
  setupMonthlyFrequency: function(frequency) {
    var interval = parseInt(frequency.substr(1,3),10);
    var dayOfWeekMask = parseInt(frequency.substr(4,3),10);
    var dayOfMonth = parseInt(frequency.substr(7,2),10);
    
    document.theForm.freqType[
      curam.util.FrequencyEditor.MONTHLY_FREQUENCY].checked = true;
    
    if(dayOfMonth == 0) {
      document.theForm.monthlyFreqType[
          curam.util.FrequencyEditor.START_DATE].checked = true;
      document.theForm.monthly0_month_interval.value = interval;
      
    } else if(dayOfMonth <= 31) {
      document.theForm.monthlyFreqType[
          curam.util.FrequencyEditor.MONTH_DAY_NUM].checked = true;
      document.theForm.monthly1_day_num.value = dayOfMonth;
      document.theForm.monthly1_month_interval.value = interval;
    } else {
      document.theForm.monthlyFreqType[
          curam.util.FrequencyEditor.MONTH_SEL_DAY].checked = true;
      
      var theCombo;
      
      if ( has("ios") || has("android") ) {
        // set selected item on the "first, second....last" combox box
        theCombo = dojo.byId("monthly2_select_day_num");
        theCombo.value = dayOfMonth;

       // Set the selected item on the "day, weekday, monday, tuesday..."
       // combo box.
       theCombo = dojo.byId("monthly2_select_day");
       theCombo.value = dayOfWeekMask;
       
      } else {
        // set selected item on the "first, second....last" combox box
        theCombo = dijit.byId("monthly2_select_day_num");
        theCombo.set("value", dayOfMonth);
        
        // Set the selected item on the "day, weekday, monday, tuesday..."
        // combo box.
        theCombo = dijit.byId("monthly_select_day");
        theCombo.set("value", dayOfWeekMask);
      }
      
      document.theForm.monthly2_month_interval.value = interval;
    }
    
  },
  
  /**
   * Execute when the page is initially loaded, sets the state of the widgets
   * for a bimonthly pattern.
   */
  setupBimonthlyFrequency: function(frequency) {
    var secondDay = parseInt(frequency.substr(1,2),10);
    var dayOfWeekMask = parseInt(frequency.substr(4,3),10);
    var firstDay = parseInt(frequency.substr(7,2),10);
    
    document.theForm.freqType[
      curam.util.FrequencyEditor.BIMONTHLY_FREQUENCY 
        - curam.util.FrequencyEditor.CORRECTOR].checked = true;
    
    if(firstDay <= 31) { //checking only one as we cannot have mixed pattern
      document.theForm.bimonthlyFreqType[
          curam.util.FrequencyEditor.DAY_NUM].checked = true;
      document.theForm.bimonthly1_day1_num.value = firstDay;
      document.theForm.bimonthly1_day2_num.value = secondDay;

    } else {
      document.theForm.bimonthlyFreqType[
          curam.util.FrequencyEditor.SEL_DAY].checked = true;
      
      
      var theCombo;
      
      if ( has("ios") || has("android") ) {
        // set selected item on the "first, second....last" 1st combox box
        theCombo = dojo.byId("bimonthly2_select_day1_num");
        theCombo.value = firstDay;

        // set selected item on the "first, second....last" 2nd combox box
       theCombo = dojo.byId("bimonthly2_select_day2_num");
       theCombo.value = secondDay;
       
       // set the selected item on the "day, weekday, monday, tuesday..."
       // combo box.
       theCombo = dojo.byId("bimonthly2_select_weekday");
       theCombo.value = dayOfWeekMask;
       
      } else {
        // set selected item on the "first, second....last" 1st combox box
        theCombo = dijit.byId("bimonthly2_select_day1_num");
        theCombo.set("value", firstDay);
        
        // set selected item on the "first, second....last" 2nd combox box
        theCombo = dijit.byId("bimonthly2_select_day2_num");
        theCombo.set("value", secondDay);
        
        // set the selected item on the "day, weekday, monday, tuesday..."
        // combo box.
        theCombo = dijit.byId("bimonthly2_select_weekday");
        theCombo.set("value", dayOfWeekMask);
      }
      
    }

  },
  
  /**
   * Execute when the page is initially loaded, sets the state of the widgets
   * for a yearly pattern.
   */
  setupYearlyFrequency: function(frequency) {
    var interval = parseInt(frequency.substr(1,3),10);
    var dayOfWeekMask = parseInt(frequency.substr(4,3),10);
    var dayOfMonth = parseInt(frequency.substr(7,2),10);
    
    document.theForm.freqType[
      curam.util.FrequencyEditor.YEARLY_FREQUENCY 
        + curam.util.FrequencyEditor.CORRECTOR].checked = true;
    
    if(dayOfMonth <= 31) {
      document.theForm.yearlyFreqType[
          curam.util.FrequencyEditor.SEL_MONTH_DAY_NUM].checked = true;
      // set the combo box
      var theCombo;
      if ( has("ios") || has("android") ) {
        theCombo = dojo.byId("yearly1_select_month");
        theCombo.value = interval;
      } else {
        theCombo = dijit.byId("yearly1_select_month");
        theCombo.set("value", interval);
      }
      
      document.theForm.yearly1_day_num.value = dayOfMonth;

    } else {
      document.theForm.yearlyFreqType[
          curam.util.FrequencyEditor.SEL_MONTH_SEL_DAY].checked = true;
      
      var theCombo;
      
      if ( has("ios") || has("android") ) {
        // set selected item on the "first, second....last" combox box
        theCombo = dojo.byId("yearly2_select_day_num");
        theCombo.value = dayOfMonth;
  
        // set the selected item on the "day, weekday, monday, tuesday..."
        // combo box.
        theCombo = dojo.byId("yearly2_select_day");
        theCombo.value = dayOfWeekMask;
  
        // set the combo box
        theCombo = dojo.byId("yearly2_select_month");
        theCombo.value = interval;
      } else {
        // set selected item on the "first, second....last" combox box
        theCombo = dijit.byId("yearly2_select_day_num");
        theCombo.set("value", dayOfMonth);
  
        // set the selected item on the "day, weekday, monday, tuesday..."
        // combo box.
        theCombo = dijit.byId("yearly2_select_day");
        theCombo.set("value", dayOfWeekMask);
  
        // set the combo box
        theCombo = dijit.byId("yearly2_select_month");
        theCombo.set("value", interval);
      }
      
    }

  },

  /**
   * Executed when OK is clicked. Creates the 9 character pattern string
   * from the current state of the widgets.
   * Returning false will stop the form submission.
   */
  createPatternString: function() {
    
    var pattern = null;
    var created = false;
    if(document.theForm.freqType[0].checked == true) {
      created = curam.util.FrequencyEditor.createDailyPatternString();
    } else if(document.theForm.freqType[1].checked == true) {
      created = curam.util.FrequencyEditor.createWeeklyPatternString();
    } else if(document.theForm.freqType[2].checked == true) {
      created = curam.util.FrequencyEditor.createMonthlyPatternString();
    } else if(document.theForm.freqType[3].checked == true) {
      created = curam.util.FrequencyEditor.createBimonthlyPatternString();
    } else {
      created = curam.util.FrequencyEditor.createYearlyPatternString();
    }
    
    //create: true; if the data selected in freq pattern 
    //is ready to submit. And Disable the border in the table row.
    //Otherwise, return false.
    if(created) {
      //Disable the row borders to prevent the blinking lines,
      //when submitting the data in frequency pattern.
      curam.util.FrequencyEditor.disableRowBorder();
      return true;
    } else {
      return false;
    }
    
  },

  /**
   * Creates a daily frequency pattern string from the widgets and sets
   * the "patternString" hidden form parameter.
   */
  createDailyPatternString: function() {
    // create the interval and dayOfWeekMask
    var dailyPattern = "0"; 
    if(document.theForm.daily_select_type[
        curam.util.FrequencyEditor.EVERY_DAY].checked == true) {

      var numDays = parseInt(document.theForm.daily_num.value,10);
      if (curam.util.FrequencyEditor.validateDailyPattern(numDays)) {
        dailyPattern += curam.util.FrequencyEditor.doZeroPadding(
            numDays,3); // every n days
        dailyPattern += "000"; //  dayOfWeekMask, not used for this pattern

      } else {
        return false;
      }
    
    } else {
      dailyPattern += "001";  // interval, not used in this pattern,
                              // but must have a valid value according to spec.
      
      // dayOfWeekMask
      dailyPattern += curam.util.FrequencyEditor.EVERY_WEEKDAY_MASK;  
    }
        
    // add the dayOfMonth, always zero for this pattern
    dailyPattern += "00";
    document.theForm.patternString.value = dailyPattern;
    return true;
  },

  /**
   * Validates the daily interval value.
   */
   validateDailyPattern: function(numDays) {
    if(isNaN(numDays) || numDays < 1) {
      alert(errorMsgs.everyDay);
      return false;
    }
    
    return true;    
  },

  /**
   * Creates a weekly frequency pattern string from the widgets and sets
   * the "patternString" hidden form parameter.
   */
   createWeeklyPatternString: function() {
    var weeklyPattern = "1";
    var dayMask = 0;
    
    var numWeeks = parseInt(document.theForm.weekly_num.value,10);
    
    if (curam.util.FrequencyEditor.validateWeeklyPattern(numWeeks)) {
      
      weeklyPattern += curam.util.FrequencyEditor.doZeroPadding(
          numWeeks,3); // every n weeks

      var oneDaySelected = false;

      var checkbox = document.theForm.weekly_select_mon;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_tue;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_wed;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_thur;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_fri;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_sat;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      checkbox = document.theForm.weekly_select_sun;
      if (checkbox.checked == true) {
        oneDaySelected = true;
        dayMask += checkbox.value - 0;
      }
      
      if (!oneDaySelected) {
        alert(errorMsgs.noDaySelected);
        return false;
      }
      if (dayMask > 0) {
        weeklyPattern += curam.util.FrequencyEditor.doZeroPadding(dayMask, 3);  
      }  else {
        weeklyPattern += "000";
      }
      // add the dayOfMonth, always zero for this pattern
      weeklyPattern += "00";

      document.theForm.patternString.value = weeklyPattern;
      
      return true;
    } 
    
    return false;
  },

  /**
   * Validates the Weekly Pattern.
   */
  validateWeeklyPattern: function(numWeeks) {
    if(isNaN(numWeeks) || numWeeks < 1) {
      alert(errorMsgs.everyWeek);
      return false;
    }
    
    return true;    
  },

  /**
   * Creates a weekly frequency pattern string from the widgets and sets
   * the "patternString" hidden form parameter.
   */
  createMonthlyPatternString: function() {
    var monthlyPattern = "2";
    
    if (document.theForm.monthlyFreqType[
        curam.util.FrequencyEditor.START_DATE].checked == true) {
      
      var interval = 
        parseInt(document.theForm.monthly0_month_interval.value, 10);
  
      if(!curam.util.FrequencyEditor.validateMonthlyData(interval)) {
        return false;
      }

      var dayOfMonth = 0; 
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          interval,3); // interval
      monthlyPattern += "000"; // dayOfWeekMask: not used
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          dayOfMonth, 2); // dayOfMonth
      
    } else if (document.theForm.monthlyFreqType[
        curam.util.FrequencyEditor.MONTH_DAY_NUM].checked == true) {

      var interval =
          parseInt(document.theForm.monthly1_month_interval.value, 10);
      var dayOfMonth = parseInt(document.theForm.monthly1_day_num.value, 10);
      if(!curam.util.FrequencyEditor.validateMonthlyData(
          interval, 
          dayOfMonth)) {
        
        return false;
      }
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          interval,3); // interval
      monthlyPattern += "000"; // dayOfWeekMask: not used
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          dayOfMonth, 2); // dayOfMonth

    } else {
      var interval =
          parseInt(document.theForm.monthly2_month_interval.value, 10);
      if(!curam.util.FrequencyEditor.validateMonthlyData(interval)) {
        return false;
      }
      
      /*
       * Validate the string of day and dayOfWeekMask for Monthly Pattern
       */
      var day = 
        curam.util.FrequencyEditor.domSelector.byId("monthly2_select_day_num").value;
      var dayOfWeekMask = 
        curam.util.FrequencyEditor.domSelector.byId("monthly2_select_day").value;
      
      if( !curam.util.FrequencyEditor.validateDayWeekString(
          day, dayOfWeekMask, monthlyPattern) ) {
        return false;
      }
      
      
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          interval,3); //interval
      
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          dayOfWeekMask, 3); // dayOfWeekMask
      
      monthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          day, 2); // dayOfMonth    

    }
    
    document.theForm.patternString.value = monthlyPattern;
    return true;
  },

  /**
   * Basic validation on the interval and dayOfMonth fields of a monthly
   * frequency pattern.
   */
  validateMonthlyData: function(interval,dayOfMonth) {
    if(isNaN(interval) || interval < 1 || interval > 100) {
      alert(errorMsgs.monthNum);
      return false;
    }
    if(dayOfMonth == null)
      return true; // dayOfMonth is not passed to the validate in all cases
    if(isNaN(dayOfMonth) || dayOfMonth < 1 || dayOfMonth > 28) {
      alert(errorMsgs.dayNum);
      return false;
    }
    return true;    
  },
  
  /**
   * Basic validation of the string of day and dayOfWeekMask for
   * frequency pattern.
   */
  validateDayWeekString: function(day, dayOfWeekMask, pattern) {
    
    var days = curam.util.FrequencyEditor.allowableDayString;
    var dayOfWeekMasks = curam.util.FrequencyEditor.allowableDayOfWeekMask;
    var isValidDay = false;
    var isValidDayOfWeekMask = false;
    
    for (var i = 0; i < days.length; i++) {
      
      if ( day == days[i]) {
        isValidDay = true;
        break;
      }
    }
    
    for (var i = 0; i < dayOfWeekMasks.length; i++) {
      
      if ( dayOfWeekMask == dayOfWeekMasks[i]) {
        isValidDayOfWeekMask = true;
        break;
      }
    }
    
    if( isValidDay && isValidDayOfWeekMask ) {
      
      return true;
    } else if ( !isValidDay ) {
      
      if( pattern == "2" ) {
        alert(errorMsgs.dayStringForMonthly);
        
      } else if ( pattern == "3" ) {
        alert(errorMsgs.dayStringForYearly);
        
      } else {
        alert(errorMsgs.dayString);
        
      }
      
      return false;
      
    } else if ( !isValidDayOfWeekMask ) {
      
      if ( pattern == "2" ) {
        alert(errorMsgs.dayOfWeekMaskForMonthly);
        
      } else if ( pattern == "3" ) {
        alert(errorMsgs.dayOfWeekMaskForYearly);
      
      } else {
        alert(errorMsgs.dayOfWeekMask);
        
      }
      
      return false;
      
    }
    
  },
  
  createBimonthlyPatternString: function() {
    var bimonthlyPattern = "4";
    var swapped;
    
    if(document.theForm.bimonthlyFreqType[
        curam.util.FrequencyEditor.DAY_NUM].checked == true) {

      var firstAbs = parseInt(document.theForm.bimonthly1_day1_num.value,10);
      var secondAbs = parseInt(document.theForm.bimonthly1_day2_num.value,10);
      if(!curam.util.FrequencyEditor.validateBimonthlyData(
          firstAbs,secondAbs,null)) {
        return false;
      }
      if (firstAbs > secondAbs) {
        swapped = firstAbs;
        firstAbs = secondAbs;
        secondAbs = swapped;
      }
      bimonthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          secondAbs,2); //interval
      bimonthlyPattern += "0000"; //dayOfWeekMask: not used
      bimonthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          firstAbs,2); //dayOfMonth

    } else {    
      var theCombo = 
        curam.util.FrequencyEditor.domSelector.byId("bimonthly2_select_day1_num");
      var firstRel = theCombo.value;
      
      theCombo = 
        curam.util.FrequencyEditor.domSelector.byId("bimonthly2_select_day2_num");    
      var secondRel = theCombo.value;
      
      theCombo = 
        curam.util.FrequencyEditor.domSelector.byId("bimonthly2_select_weekday");
      var weekday = theCombo.value;
      
      /*
       * validate the day and weekday string for the second bi-monthly
       * frequency pattern
       */
      if(!curam.util.FrequencyEditor.validateBimonthlyDataString(
          firstRel, secondRel, weekday)) {
        return false;
      }
      
      
      if (firstRel > secondRel) {
        swapped = firstRel;
        firstRel = secondRel;
        secondRel = swapped;
      }
      if(!curam.util.FrequencyEditor.validateBimonthlyData(
          firstRel, secondRel, weekday)) {
        return false;
      }
      
      bimonthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          secondRel,2); //interval
      bimonthlyPattern += '0';
      bimonthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          weekday,3); //dayOfWeekMask
      bimonthlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          firstRel,2); //dayOfMonth
    }
    document.theForm.patternString.value = bimonthlyPattern;
    return true; 
  },

  /**
   * Basic validation on the fields of a bi-monthly frequency pattern.
   */
  validateBimonthlyData: function(first,second,weekday) {
    if (weekday != null) { //if second radio button selected
      if (isNaN(weekday) || weekday < 1 || weekday > 64) {
      alert(errorMsgs.weekend);
      return false;
      }
    } else {
      if (isNaN(first) || first < 1 || first > 28
         || isNaN(second) || second < 1 || second > 28) {
          alert(errorMsgs.dayNum);
          return false;
      }
    }
    if (first == second) {
      alert(errorMsgs.dayDiff);
      return false;
    }  
    return true;    
  },
  
  /**
   * Basic validation on the fields of the second bi-monthly frequency pattern.
   */
  validateBimonthlyDataString: function(firstDayString,
      secondDayString, weekdayString) {
    
    var firstDayStrings = 
      curam.util.FrequencyEditor.allowableFirstDayStringForBimonthly;
    var secondDayStrings = 
      curam.util.FrequencyEditor.allowableSecondDayStringForBimonthly;
    var weekdayStrings = 
      curam.util.FrequencyEditor.allowableWeekdayStringForBimonthly;
    var isValidFirstDay = false;
    var isValidSecondDay = false;
    var isValidWeekday = false;
    
    for (var i = 0; i < firstDayStrings.length; i++) {
      
      if ( firstDayString == firstDayStrings[i]) {
        isValidFirstDay = true;
        break;
      }
    }
    
    for (var i = 0; i < secondDayStrings.length; i++) {
      
      if ( secondDayString == secondDayStrings[i]) {
        isValidSecondDay = true;
        break;
      }
    }
    
    for (var i = 0; i < weekdayStrings.length; i++) {
      
      if ( weekdayString == weekdayStrings[i]) {
        isValidWeekday = true;
        break;
      }
    }
    
    if( isValidFirstDay && isValidSecondDay && isValidWeekday ) {
      
      return true;
    } else if ( !isValidFirstDay ) {
      
      alert(errorMsgs.firstDayString);
      return false;
    } else if ( !isValidSecondDay ) {
      
      alert(errorMsgs.secondDayString);
      return false;
    } else if ( !isValidWeekday ) {
      
      alert(errorMsgs.weekend);
      return false;
    }
    
  },

  /**
   * Creates a yearly frequency pattern string from the widgets and sets
   * the "patternString" hidden form parameter.
   */
  createYearlyPatternString: function() {
    var yearlyPattern = "3";
    var theCombo = null;
    
    if(document.theForm.yearlyFreqType[
        curam.util.FrequencyEditor.SEL_MONTH_DAY_NUM].checked == true) {

      theCombo = 
        curam.util.FrequencyEditor.domSelector.byId("yearly1_select_month");

      var monthNumber = theCombo.value;
      yearlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          monthNumber, 3); // interval
        yearlyPattern += "000"; // dayOfWeekMask
      
      /*
       * Validate the string of month for the Yearly Pattern
       */
      if(!curam.util.FrequencyEditor.validateMonthString(monthNumber)) {
        return false;
      }
        
      var dayOfMonth = parseInt(document.theForm.yearly1_day_num.value, 10);
      if(!curam.util.FrequencyEditor.validateYearlyData(
          dayOfMonth, monthNumber)) {
        return false;
      }
      
      yearlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          dayOfMonth, 2); // dayOfMonth

    } else {
      
      /**
       * validate the String of dayOfMonth, dayOfWeekMask and month
       */
      var day = 
        curam.util.FrequencyEditor.domSelector.byId("yearly2_select_day_num").value;
      var dayOfWeekMask = 
        curam.util.FrequencyEditor.domSelector.byId("yearly2_select_day").value;
      var month = 
        curam.util.FrequencyEditor.domSelector.byId("yearly2_select_month").value;
      
      if(!curam.util.FrequencyEditor.validateDayWeekString(
          day, dayOfWeekMask, yearlyPattern) ) {
        return false;
      }
      if(!curam.util.FrequencyEditor.validateMonthString(month)) {
        return false;
      }
      
      yearlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          month, 3); // interval
      
      yearlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          dayOfWeekMask, 3); // dayOfWeekMask
      
      yearlyPattern += curam.util.FrequencyEditor.doZeroPadding(
          day, 2);// dayOfMonth
    }
    document.theForm.patternString.value = yearlyPattern;
    return true;
  },

  /**
   * Basic validation on the dayOfMonth field of a yearly frequency pattern.
   */
  validateYearlyData: function(dayOfMonth,monthNumber) {
    if(isNaN(dayOfMonth) || dayOfMonth < 1
        || dayOfMonth > curam.util.FrequencyEditor.daysInMonth[monthNumber-1]) {
      
      alert(errorMsgs.dayNumAnd + "  "
          + curam.util.FrequencyEditor.daysInMonth[monthNumber-1]);
      return false;
    }
    return true;  
  },
  
  /**
   * Validation of the string of month for the Yearly Pattern
   */
  validateMonthString: function(month) {
    
    var months = curam.util.FrequencyEditor.allowableMonthString;
    
    for (var i = 0; i < months.length; i++) {
      
      if ( month == months[i]) {
        return true;
      }
    }
    
    alert(errorMsgs.monthString);
    return false;
  },

  /**
   * Left pads a string with the specified number of zeros if required.
   */
  doZeroPadding: function(stringValue,numZeros) {
    // allows a stringValue to be passed as a number or string
    var paddedString = "" + stringValue;
    var zerosToAdd = numZeros - paddedString.length;
    for(var i = 0; i < zerosToAdd; i++) {
      paddedString = "0" + paddedString;
    }
    return paddedString;
  },

  /**
   * Set the first level radio button in frequency editor
   * 
   * @param freqType frequecy type
   */
  _setFirstLevelRadioButton: function(freqType) {
    
    var typeRadio = query("input[name='freqType']", 
                                dom.byId("mainForm"))[freqType];
    
    if (typeRadio == null) {
      throw new Error("The radio button for the selected" 
          + " frequency type could not be found!");
    }
    
    if (!typeRadio.checked) {
      //Deselect all radio button in each frequency types
      query("input[type='radio']:checked", 
                 dom.byId("mainForm")).forEach(function(radioNode) {
        radioNode.checked=false;
      });
      
      if(freqType != curam.util.FrequencyEditor.WEEKLY_FREQUENCY) {
        query("input[type='checkbox']:checked", 
                   dom.byId("mainForm")).forEach(function(checkboxNode){
          checkboxNode.checked = false;
        });
      }
      typeRadio.checked = true;
    }
    
  },
  
  /**
   * Set second level radio button in frequency editor
   * 
   * @param widgetOrdomNode widget node or dom node or null
   */
  _setSecondLevelRadioButton: function(widgetOrdomNode) {
    
    //If the widget or dom node is not passed in, it means that there is no
    //checkbox related with the node where this javascript function is invoked.
    //Therefore, stop here.
    if (widgetOrdomNode == undefined) {
      return "undefined";
    }
    
    var thisNode;
    //Check if the parameter value is a widget or a dom node.
    //We ultimately need a node so if it is a widget, get its
    //corresponding dom node.
    if (widgetOrdomNode.domNode) {
      thisNode = widgetOrdomNode.domNode;
    } else {
      thisNode = widgetOrdomNode;
    }
    
    //Check if the current node is a radio button.
    //If it is, this is the required radio button we need to check
    if(thisNode.tagName.toLowerCase() == "input" 
         && domAttr.get(thisNode, "type") == "radio") {
      thisNode.checked = true;
      return "radio node clicked";
    }
    
    //Find the cell that contains the node.
    var tdNode = cm.getParentByType(thisNode, 'TD');
    if (tdNode == null) {
      throw new Error("Exception: The row contains the node should be found"); 
    }
    
    //Find the radio button in the cell
    var radioNode = query("input[type = 'radio']", tdNode)[0];
    
    //Check if the radio button exist in the cell. If not, throw an error. 
    //Otherwse, make the radio button checked regardless of its previous status.
    if (radioNode == null) {
      throw new Error("Exception: The radio node should exist");
    } else {
      radioNode.checked = true;
      return "text input or codetable clicked";
    }
    
  },

  /**
   * Sets the appropriate radio button to be checked.
   */
  setSelectedFreqType: function(freqType, widgetOrdomNode) {
    debug.log("curam.util.FrequencyEditor: " +
      debug.getProperty("curam.util.FrequencyEditor.radio"));
    
    curam.util.FrequencyEditor._setFirstLevelRadioButton(freqType);
    curam.util.FrequencyEditor._setSecondLevelRadioButton(widgetOrdomNode);

  },
  
  /**
   * Set the default selected option for the second level radio
   * button or check box of each frequency pattern.
   */
  setDefaultOption: function(freqType) {
    
    //Deselect all options
    document.theForm.daily_select_type[
        curam.util.FrequencyEditor.EVERY_DAY].checked = false;
    document.theForm.daily_select_type[
        curam.util.FrequencyEditor.EVERY_WEEKDAY].checked = false;
    document.theForm.monthlyFreqType[
        curam.util.FrequencyEditor.DAY_NUM].checked = false;
    document.theForm.monthlyFreqType[
        curam.util.FrequencyEditor.SEL_DAY].checked = false;
    document.theForm.bimonthlyFreqType[
        curam.util.FrequencyEditor.DAY_NUM].checked = false;
    document.theForm.bimonthlyFreqType[
        curam.util.FrequencyEditor.SEL_DAY].checked = false;
    document.theForm.yearlyFreqType[
        curam.util.FrequencyEditor.SEL_MONTH_DAY_NUM].checked = false;
    document.theForm.yearlyFreqType[
        curam.util.FrequencyEditor.SEL_MONTH_SEL_DAY].checked = false;
    
    //Keep the selection status of the checkbox in the Weekly Pattern 
    //if Weekly Pattern is selected,
    //Otherwise deselect these checkbox in the Weekly Pattern
    if( freqType != curam.util.FrequencyEditor.WEEKLY_FREQUENCY ) {
      
      document.theForm.weekly_select_mon.checked = false;
      document.theForm.weekly_select_tue.checked = false;
      document.theForm.weekly_select_wed.checked = false;
      document.theForm.weekly_select_thur.checked = false;
      document.theForm.weekly_select_fri.checked = false;
      document.theForm.weekly_select_sat.checked = false;
      document.theForm.weekly_select_sun.checked = false;
    }
    
    //Set the default option for the selected frequency pattern
    if( freqType == curam.util.FrequencyEditor.DAILY_FREQUENCY ) {
      document.theForm.daily_select_type[
          curam.util.FrequencyEditor.EVERY_DAY].checked = true;
      
    } else if ( freqType == curam.util.FrequencyEditor.WEEKLY_FREQUENCY ) {
      document.theForm.weekly_select_mon.checked = true;
      
    } else if ( freqType == curam.util.FrequencyEditor.MONTHLY_FREQUENCY ) {
      document.theForm.monthlyFreqType[
          curam.util.FrequencyEditor.DAY_NUM].checked = true;
      
    } else if ( freqType == curam.util.FrequencyEditor.BIMONTHLY_FREQUENCY ) {
      document.theForm.bimonthlyFreqType[
          curam.util.FrequencyEditor.DAY_NUM].checked = true;
      
    } else if ( freqType == curam.util.FrequencyEditor.YEARLY_FREQUENCY ) {
      document.theForm.yearlyFreqType[
          curam.util.FrequencyEditor.SEL_MONTH_DAY_NUM].checked = true;
      
    }
  },
  
  /**
   * Logic for checking the keystroke input.
   * 
   * @param keyChar
   * @returns {Boolean}
   */
  _doPosNumbericInputChecker: function(keyChar) {

    if (keyChar == "") {
      return false;
    }
    
    //Load the allowable numeric charactors
    var chars = curam.util.FrequencyEditor.allowableCharsForNumeric;
    
    for (var i = 0; i < chars.length; i++) {
      if (keyChar == chars[i]) {
        return true;
      }
      }
    
    return false;
  },
  
  /**
   * Checks the value of the input is a positive numeric value.
   */
  posNumericInputChecker: function(event) {
    
    event = dojo.fixEvent(event);
    var keyChar = event.keyChar;
    
    var isAllowed = 
      curam.util.FrequencyEditor._doPosNumbericInputChecker(keyChar);
    
    if (!isAllowed) {
      dojo.stopEvent(event);
    }
    
  },

  /**
   * Prepopulates all fields with the digit 1.
   */
  prePopulateTextFields: function(inputs) {
    return function(e) {
      for(var i = 0; i < inputs.length; i++){
        if(!inputs[i].value || inputs[i].value == "") {
          inputs[i].value = 1;
        }
      }
    };
  },

  /**
   * Function to disable the row border by adding an extra
   * specific CSS class "row-no-border"
   */
  disableRowBorder: function() {
    //Find the target rows
    query("form[name='theForm'] table tr").forEach(function(node){
      //Add the "row-no-border" class to the row node
      domClass.add(node, "row-no-border");
    });
  },
  
  /**
   * Add listener enforce numeric entry into the text files.
   */
  addInputListener: function() {
    dojo.ready(function() {
      var textInputs = [];
      query("input[type='text']:not(input.dijitReset)").forEach(
          function(input){
            
        textInputs.push(input);
        curam.util.connect(input, "onkeypress",
            curam.util.FrequencyEditor.posNumericInputChecker);
      });
      
      curam.util.connect(dom.byId("mainForm"), "onsubmit", function(event) {
        curam.util.FrequencyEditor.prePopulateTextFields(textInputs);
      });
    });
  },
  
  /**
   * Function to replace all the '%s' placeholders in the text string
   * gotten from the 'FrequencyPatternSeletor.properties' with the 
   * corresponding dom nodes, e.g. input fields, drop-downs.
   * 
   */
  replacePlaceholderWithDomNode: function() {
    
    query("body#Curam_frequency-editor table tr td.frequency").forEach(
        function(domNode){
          curam.util.FrequencyEditor._parse(domNode);
        });
  },
  
  
  /**
   * Private function to replace all the '%s' placeholders with input fields
   * or dropdowns in a particular frequency type.
   * 
   * @param node  The dom node contains a certain frequency type.
   * @returns {String} The message indicates where the function stops.
   */
  _parse: function(node) {
    
    // Get all nodes that need the replacement inside the 'td' element.
    var elementList = query("> .node-needs-replacement", node);
    var textNode = query("> span", node)[0];
    
    if (textNode == null || textNode == undefined) {
      throw new Error("Exception: Some text string is missing for some certain "
          + "frequency type, please check the 'frequency-editor.jsp' file.");
    }
    
    // Get the text string that needs to be parsed.
    var textString = textNode.innerHTML;
    
    // The regular expression for the placeholder '%1s', '%2s', ...
    // Note: We make an assumption here that the number of placeholders will
    // not be possible to exceed 9.
    var placeholderExp = /%[^%]*%/g;
    
    // Gets all placeholders in the text string. 
    var placeholders = textString.match(placeholderExp);
    
    if (elementList.length == 0 && placeholders == null) {
      
        // Stop here as there is no nodes that need the 
        // replacement in this 'td' node.
        return "No need to parse";    
        
    } else if (elementList.length == 0 && placeholders != null) {
      
      throw new Error("The text string '" 
          + textString
          + "' from the 'FrequencyPatternSelector.properties'" 
          + " should not have any placeholder.");
      
    } else if (elementList.length != 0 && placeholders == null) {
      
      throw new Error("The text string '" 
          + textString
          + "' from the 'FrequencyPatternSelector.properties'" 
          + " should have some placeholders.");
    } 
    
    
    /* The weekly frequency pattern is a special case here,
     * so we handle it separately.
     * 
     */
    if (domClass.contains(node, "weekly-frequency")) {

      // The weekly frequency pattern should have two placeholders.
      if (placeholders.length != 2) {
        throw new Error("The text string '" 
            + textString
            + "' from the 'FrequencyPatternSelector.properties' " 
            + "has the incorrect number of placeholders.");
      }
      
      // There is only one node that needs the replacement inside this TD
      // element, which is the one holds the week interval value.
      var weekIntervalNode = dojo.clone(elementList[0]);
      // Destroy the node from the TD element in the HTML fragment.
      elementList.forEach(function(listNode) {
        domConstruct.destroy(listNode);
      });
      
      // Remove the class name "node-needs-replacement" so we can easily
      // get another class name on this node, which is actually the name
      // of the placeholder this node will replace.
      domClass.remove(weekIntervalNode, "node-needs-replacement");
      var placeholderForWeekIntervalNode = weekIntervalNode.className.match(placeholderExp);
      
      // Get the name of the placeholder for checkboxes
      var placeholderForCheckboxes;
      for (var i=0; i<placeholders.length; i++) {
        if (placeholders[i] != placeholderForWeekIntervalNode ) {
          placeholderForCheckboxes = placeholders[i];
          break;
        }
      }
      
      // Split the text string into two parts using the 
      // "placeholderForCheckboxes" as the delimiter.
      var strArray = textString.split(placeholderForCheckboxes);
      var firstPart = strArray[0];
      var secondPart = strArray[1];
      
      var isInFirstPart;
      if (firstPart.indexOf(placeholderForWeekIntervalNode) != -1) {
        // The placeholder for the week intervale node is in the first part of
        // the text string.
        isInFirstPart = true;
        firstPart = firstPart.replace(placeholderForWeekIntervalNode,
            "<span class='" 
            + placeholderForWeekIntervalNode
            + "'>placeholder</span>");
      } else {
        // In the second part
        isInFirstPart = false;
        secondPart = secondPart.replace(placeholderForWeekIntervalNode,
            "<span class='" 
            + placeholderForWeekIntervalNode 
            + "'>placeholder</span>");
      }
      
      // Replace the placeholder for the week interval node is enough when
      // the string of the second part is empty.
      if (secondPart == "") {
        textNode.innerHTML = firstPart;
        domConstruct.place(weekIntervalNode, 
            query("span." + placeholderForWeekIntervalNode, textNode)[0], 
            "replace");
      } else {
        textNode.innerHTML = firstPart;
        
        // Apart from replacing the placeholder for the week interval node,
        // we also need to place the second part of the text string to
        // another table row following all the checkboxes.
        var whereToPlace = node.parentNode.nextSibling.nextSibling;
        var trNode = domConstruct.create("tr", {"class": "blue"});
        var tdNode = domConstruct.create("td", {
          "class": "bottom"
        }, trNode);
        tdNode.colSpan = "4";
        domStyle.set(tdNode, "paddingLeft", "20px");
        var spanNode = domConstruct.create("span", {
          innerHTML: secondPart
        }, tdNode);
        
        // Place the new created table row.
        domConstruct.place(trNode, whereToPlace, "after");
        
        // Replace the placeholder with the week interval node.
        if (isInFirstPart) {
          domConstruct.place(weekIntervalNode, 
              query("span." + placeholderForWeekIntervalNode, textNode)[0], 
              "replace");
          
        } else {
          domConstruct.place(weekIntervalNode, 
              query("span[class='" + placeholderForWeekIntervalNode + "'", spanNode)[0], 
              "replace");
        }
        
        // Tweaking the styling.
        query("td.day", whereToPlace).forEach(function(tdNode){
          domClass.remove(tdNode, "bottom");
        });
        if(firstPart == "") {
          domClass.remove(node, "top");
        }
        query("th.type", node.parentNode)[0].rowSpan = "4";
        
      }
     
      return "Parsed Successfully"; 
    }
        
    if(elementList.length != placeholders.length) {   
      throw new Error("The text string '" 
          + textString
          + "' from the 'FrequencyPatternSelector.properties' " 
          + "has the incorrect number of placeholders.");
    }
    
    // Clone all the dom nodes that need the replacement,
    // and delete the origial ones from the HTML fragment.
    var elementListStore = dojo.clone(elementList);
    elementList.forEach(domConstruct.destroy);

    
    // Replace all placeholders with the temporary span elements which hold
    // the specified classnames. 
    for (i=0; i<placeholders.length; i++) {
      var placeholder = placeholders[i];
      textString = textString.replace(placeholder,
          "<span class='" + placeholder + "'>placeholder</span>");
    }
    textNode.innerHTML = textString;

    // Loop over all nodes which needs the replacement to 
    // replace all the temporary 'span' element.
    elementListStore.forEach(function(elementNode, i){
      domClass.remove(elementNode, "node-needs-replacement");
      var elementClassName = elementNode.className.match(placeholderExp);
      //var nodeToAdd = query("span span[class='" + elementClassName + "'", node)[0];
      //if (nodeToAdd) {
      //  domConstruct.place(elementNode, nodeToAdd, "replace");
      //}
      domConstruct.place(elementNode, 
          query("span." + elementClassName, node)[0], 
          "replace");
    });
      
    return "Parsed Successfully";
  }

  });
  
  return curam.util.FrequencyEditor;
});
},
'curam/charting':function(){
define([
        "dojo/dom-class",
        "dojo/dom",
        "dojo/ready",
        "cm/_base/_dom",
        "curam/define"],
function(dclass, dom, ready, cmDom, define) {

define.singleton("curam.charting", {
  alignChartWrapper: function(node) {
    ready(function() {
      node = cmDom.getParentByClass(dom.byId(node), "cluster");

      if (node) {
        dclass.add(node,"chart-panel");
      }
   });
 }
});

return curam.charting;

});
},
'curam/cdsl/_base/MetadataRegistry':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare',
        'curam/cdsl/types/codetable/CodeTables',
        'curam/cdsl/types/codetable/CodeTable',        
        'dojo/_base/lang'
        ], function(
            declare, CodeTables, CodeTable, lang) {

  /**
   * @name curam.cdsl.request.MetadataRegistry
   * @namespace 
   */
  var MetadataRegistry = declare(null,
  /**
   * @lends curam.cdsl.request.MetadataRegistry.prototype
   */
  {
    _callEntries: null,

    _codetables: null,
    
    constructor: function() {
      this._callEntries = {};
      this._codetables = {};
    },
    
    /**
     * Sets flags on a method call prior to calling server, based on metadata
     * we hold in cache.
     * 
     * @param methodCall The method call instance to be updated.
     */
    setFlags: function(methodCall) {
      var entryKey = methodCall.intf() + '.' + methodCall.method(),
          notCalledBefore = !this._callEntries[entryKey];

      // only request codetables if we haven't called the method before
      methodCall._sendCodetables(notCalledBefore);
    },
    
    update: function(response) {
      var methodCall = response.request(),
          entryKey = methodCall.intf() + '.' + methodCall.method(),
          callEntry = this._callEntries[entryKey];
      if (!callEntry) {
        callEntry = {};
        this._callEntries[entryKey] = callEntry;
      }
      if (response.hasCodetables()) {
        var data = response.getCodetablesData();
        for (var i = 0; i < data.length; i++) {
          this._codetables[data[i].name] =
              new CodeTable(data[i].name, data[i].defaultCode, data[i].codes);
        }
      }
    },
    
    codetables: function() {
      // TODO: should we clone the array before returning? safer,
      // but adds overhead
      return this._codetables;
    }
  });
  
  return MetadataRegistry;
});

},
'dijit/_FocusMixin':function(){
define([
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

	// module:
	//		dijit/_FocusMixin

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or its descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'curam/util/ui/form/renderer/DateEditRendererFormEventsAdapter':function(){
/*
 * Merative Confidential
 * Merative US L.P. 2022,2023.
 *
 */
define(["dojo/_base/declare", 'dojo/_base/unload', "curam/util/ui/form/renderer/GenericRendererFormEventsAdapter", "curam/util/DatePicker"], 
    function(declare, baseUnload, GenericRendererFormEventsAdapter, DatePicker) {

	/*
	 * Modification History
	 * --------------------
	 * 19-Jan-2023  COC [SPM-126270] Renamed the CuramFormsAPI event.
	 * 14-Nov-2022  BD [SPM125872] Initial version.
	 */

	var DateEditRendererFormEventsAdapter = declare("curam.util.ui.form.renderer.DateEditRendererFormEventsAdapter", GenericRendererFormEventsAdapter,
	 /** @lends curam.util.ui.form.renderer.DateEditRendererFormEventsAdapter */ {

			_unsubscribes: [],

			/**
			 * Initializes the element id, path id and element attributes.
			 * Also, listen the topic curam/modal/component/ready to
			 * set the element value after the component is renderer by SPM-components.
			 * 
			 * @param id  The ID of element on the page.
			 * @param pathID The path ID to the element on the page. 
			 */
			constructor: function(id, pathID) {
				this.elementID = id;
				this.pathID = pathID;
				var subToUpdateElementWithValue = dojo.subscribe("curam/modal/component/ready", this, function() {
					this.element = document.getElementById(this.elementID);
					subToUpdateElementWithValue.remove();
				});
				baseUnload.addOnUnload(function() {
					this._unsubscribes && this._unsubscribes.forEach(function(hh) { hh.remove(); });
				});

			},

			/**
			 * Add change listener for the combobox on the element ID.
			 * The SPM-components renders the combobox and publish the
			 * topic when the combobox value changes. 
			 * 
			 * @param callbackForOnChangeEvent The function to be executed when the
			 * element changes on the page.
			 */
			addChangeListener: function(callbackForOnChangeEvent) {
				var topic = 'curam/util/CuramFormsAPI/formChange/datePicker'.concat(this.getElementID());
				this._unsubscribes.push(window.dojo.subscribe(topic, this, function(datePickerChanged) {
					this.getFormElement().value = datePickerChanged.value;
					callbackForOnChangeEvent();
				}));
			},

			/**
			 * Set the form element value. The Date is renderer by SPM-components.
			 * So, Subscribe the topic to know when the component is ready on the page. 
			 * Then upadte the DatePicker with the new value.
			 * @param value The new value for the element. 
			 */
			setFormElementValue: function(value) {
				var self = this;
				this._unsubscribes.push(dojo.subscribe("curam/modal/component/ready", this,
					function() {
						var datePicker = new DatePicker();
						datePicker.setDate(self.getElementID(), value);
						this.getFormElement().value = value;
					})
				);
			}
		});

	return DateEditRendererFormEventsAdapter;
});
},
'dijit/form/ValidationTextBox':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang",
	"dojo/i18n", // i18n.getLocalization
	"./TextBox",
	"../Tooltip",
	"dojo/text!./templates/ValidationTextBox.html",
	"dojo/i18n!./nls/validate"
], function(declare, kernel, lang, i18n, TextBox, Tooltip, template){

	// module:
	//		dijit/form/ValidationTextBox


	var ValidationTextBox = declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.

		templateString: template,

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		//		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		//		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		//		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: ValidationTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input as well as
		//		formatting options.  See `dijit/form/ValidationTextBox.__Constraints` for details.
		constraints:{},

		// pattern: [extension protected] String|Function(constraints) returning a string.
		//		This defines the regular expression used to validate the input.
		//		Do not add leading ^ or $ characters since the widget adds these.
		//		A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
		//		set('pattern', String|Function).
		pattern: ".*",

		// regExp: Deprecated [extension protected] String.  Use "pattern" instead.
		regExp: "",

		regExpGen: function(/*__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Deprecated.  Use set('pattern', Function) instead.
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit/Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_deprecateRegExp: function(attr, value){
			if(value != ValidationTextBox.prototype[attr]){
				kernel.deprecated("ValidationTextBox id="+this.id+", set('" + attr + "', ...) is deprecated.  Use set('pattern', ...) instead.", "", "2.0");
				this.set('pattern', value);
			}
		},
		_setRegExpGenAttr: function(/*Function*/ newFcn){
			this._deprecateRegExp("regExpGen", newFcn);
			this._set("regExpGen", this._computeRegexp); // backward compat with this.regExpGen(this.constraints)
		},
		_setRegExpAttr: function(/*String*/ value){
			this._deprecateRegExp("regExp", value);
		},

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this._refreshState();
		},

		validator: function(/*anything*/ value, /*__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this._computeRegexp(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.get('constraints'));
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			var invalid = this.invalidMessage == "$_unset_$" ? this.messages.invalidMessage :
				!this.invalidMessage ? this.promptMessage : this.invalidMessage;
			var missing = this.missingMessage == "$_unset_$" ? this.messages.missingMessage :
				!this.missingMessage ? invalid : this.missingMessage;
			return (this.required && this._isEmpty(this.textbox.value)) ? missing : invalid; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && (this._maskValidSubsetError || (isValidSubset && !this._hasBeenBlurred && isFocused))) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", this.state == "Error" ? "true" : "false");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			if(this._created){ // should instead be this._started but that would require all programmatic ValidationTextBox instantiations to call startup()
				this.validate(this.focused);
			}
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(params /*===== , srcNodeRef =====*/){
			// summary:
			//		Create the widget.
			// params: Object|null
			//		Hash of initialization parameters for widget, including scalar values (like title, duration etc.)
			//		and functions, typically callbacks like onClick.
			//		The hash can contain any of the widget's properties, excluding read-only properties.
			// srcNodeRef: DOMNode|String?
			//		If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.

			this.constraints = lang.clone(this.constraints);
			this.baseClass += ' dijitValidationTextBox';
		},

		startup: function(){
			this.inherited(arguments);
			this._refreshState(); // after all _set* methods have run
		},

		_setConstraintsAttr: function(/*__Constraints*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._refreshState();
		},

		_setPatternAttr: function(/*String|Function*/ pattern){
			this._set("pattern", pattern); // don't set on INPUT to avoid native HTML5 validation
			this._refreshState();
		},

		_computeRegexp: function(/*__Constraints*/ constraints){
			// summary:
			//		Hook to get the current regExp and to compute the partial validation RE.

			var p = this.pattern;
			if(typeof p == "function"){
				p = p.call(this, constraints);
			}
			if(p != this._lastRegExp){
				var partialre = "";
				this._lastRegExp = p;
				// parse the regexp and produce a new regexp that matches valid subsets
				// if the regexp is .* then there's no use in matching subsets since everything is valid
				if(p != ".*"){
					p.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
					function(re){
						switch(re.charAt(0)){
							case '{':
							case '+':
							case '?':
							case '*':
							case '^':
							case '$':
							case '|':
							case '(':
								partialre += re;
								break;
							case ")":
								partialre += "|$)";
								break;
							 default:
								partialre += "(?:"+re+"|$)";
								break;
						}
					});
				}
				try{ // this is needed for now since the above regexp parsing needs more test verification
					"".search(partialre);
				}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
					partialre = this.pattern;
					console.warn('RegExp error in ' + this.declaredClass + ': ' + this.pattern);
				} // should never be here unless the original RE is bad or the parsing is bad
				this._partialre = "^(?:" + partialre + ")$";
			}
			return p;
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit/form/TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		},

		destroy: function(){
			Tooltip.hide(this.domNode);	// in case tooltip show when ValidationTextBox (or enclosing Dialog) destroyed
			this.inherited(arguments);
		}
	});

	/*=====
	 ValidationTextBox.__Constraints = {
		 // locale: String
		 //		locale used for validation, picks up value from this widget's lang attribute
		 // _flags_: anything
		 //		various flags passed to pattern function
	 };
	 =====*/

	return ValidationTextBox;
});

},
'curam/util/SessionTimeout':function(){
/*
 * Copyright 2014,2022 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */
 
define(['dojo/dom', 'dojo/dom-construct', 'curam/util',
        'curam/dialog', 'curam/util/external',
        'curam/util/LocalConfig'],
       function(dom, domConstruct, util, dialog, external, localConfig) {
  /*
   * Modification History
   * --------------------
   * 23-Nov-2022  GG  [SPM-119379] Restored correct behaviour when custom page is used as logout page
   *                                in _redirectInternalLogoutWrapper. 
   * 21-Jan-2022  SK  [RTC274885]  Corrected the logic for after a continuing working button click to
   *                   			   match the way Carbon modals are managed. 
   * 01-Jul-2019  GG  [RTC245742]  Replaced timeout Cookie with Session Storage.
   * 23-Aug-2018  BD  [RTC229425]  Included publish to alert when the page will be redirected 
   *                               to the logout page.
   * 11-Jan-2018  SK  [RTC-210729] Code changes to address timeout inconsistency.
   * 02-May-2017  BD  [RTC-192296] Changed  the logout wrapper default used by the internal application.
   * 04-Apr-2017  BD  [RTC-192658] Removed  method isSessionExpiryCookieValid.
   * 03-Apr-2017  BD  [RTC-192547] Changed method displayUserMsgAsParagraphs to fix the paragraphs.
   * 28-Mar-2017  BD  [RTC-188687] Added method isSessionExpiryCookieValid.
   * 23-Feb-2017  BD  [RTC-188234] Added method onContinueButtonClick and _cleanUp.
   * 19-Jan-2017  SO  [RTC-185383] Fix for the browser warning dialog on the session timeout.
   * 11-Jan-2017  BD  [RTC-181931] Updated the logic and the method showSessionExpiredMessage name to.
   * createExpiredSessionMessageHTML name to cover the case when the wrapper is created dinamically. 
   * 01-Nov-2016  BD  [RTC-180045] Updated the session timeout to be used for internal and external
   * application.
   * 29-Sep-2016  BD  [RTC-177790] Managed properties for the session timeout warning.
   * 14-Sep-2016  SK  [RTC-172436] Replaced non-existent 'this' with namespace references
   *                  and simplified displayTimerAndLogout signature.
   * 23-Feb-2015  AZ  [CR00458302] Fix accessibility issues with timer.
   * 28-Jun-2014  BOS [CR00435242] Update the configuration for the expired user
   * message.
   * 03-Jun-2014  BOS [CR00434187] Initial Version.
   */
  /**
   * @name curam.util.SessionTimeout
   * @namespace Checks if and when a timeout warning modal is displayed to a
   * user immediately before their session times out.
   * 
   * This API provides methods for a session timeout warning modal dialog.
   * 
   * It reads a specific session storage that is set by the <code>RequestFilter</code>
   * Servlet and uses the information within that session storage to check if a modal
   * dialog needs to be displayed to the user to warn them that their session is
   * about to timeout.
   * 
   * This API is tightly coupled with the 
   * <code>session-timeout-warning-dialog.jspx</code> and the 
   * <code>RequestFilter.java</code> Servlet.
   * 
   */

  curam.define.singleton("curam.util.SessionTimeout", {
          
        // The identifier of the parameter for the expired message
        _EXPIRED_MESSAGE_KEY:"expiredMessage", 
        
        // The identifier of the default value for the logout page in an internal application.
        _INTERNAL_LOGOUT_WRAPPER:"internal-logout-wrapper", 
        
        // The page identifier for the logout page that will end the session if
        // a user clicks the logout button or the session automatically logs out.
        logoutPageID:"",
        
        // The node that display the user message
        userMessageNode:null,
        
        // The identifier of the node that displays the user message in the modal 
        userMessageNodeID:"userMessage",

        // The identifier of the node that displays the minutes component of time
        minutesCompNodeID:"minutesComp",
        
        // The identifier of the node that displays the seconds component of time
        secondsCompNodeID:"secondsComp",

        // The JSPX file used to display the session timeout warning dialog to the user.
        sessTimeoutWarningJSPXDialog:"session-timeout-warning-dialog.jspx",
        
        // The grace period afforded to the user when taking action within the modal.
        // Defaults to 30 seconds (30000 miliseconds)
        interactionAllowance:3000,
        
        // The frequency of the idle condition check, ms.
        _idleTick:10000,
        
        //The frequency of the expire modal timer update, ms.
        _expiryTick:1000,
        
        // Reference to the shared timeout configuration.
        _cfg:null,
        
        // Idle time counter.
        _idleClock:null,
        
        // Interval allowed without the user interaction with the server,
        // without popping up the session timeout warning dialog.
        idleAllowance:0,
        
        // top window reference.
        tlw:false,
        
        // indicator if the application is external.
        _isExternal:false,
        
        // the configured idle duration, ms
        requiredWarnDurationMs:0,
        
        // the final duration before expiry warning, accounts for the actual data.
        effectiveTimeout:0,
        
        //the remaining countdown until session expiry.
        __remainingCountdown:0,

        /**
         * Initializes/re-initializes the session expiration counter.
         * Called externally when the session expiry warning is enabled to initialize counter,
         * and internally to re-initalize it following new user interaction with the server.
         *  
         */
        checkSessionExpired: function() {
          sto._invalidateIdleClock(true);
          sto._isExternal = sto.tlw.jsScreenContext && sto.tlw.jsScreenContext.hasContextBits("EXTAPP");
          sto._cfg = sto.getTimeoutWarningConfig();
          // share the configuration settings between the top window and expiration modal dialog.
          sto._cfg['isExternal'] = sto._isExternal;
          sto._cfg['tlw'] = sto.tlw;
          if (sto._cfg.bufferingPeriod) {
            sto.interactionAllowance =  sto._cfg.bufferingPeriod * 1000;
          }
          var requiredWarnDurationS = sto._cfg && sto._cfg.timeout;
          sto.requiredWarnDurationMs = requiredWarnDurationS ? requiredWarnDurationS * 1000 : 0;
          sto._idleClock = setInterval(function(){
        	  sto._doCheckExp();
        	  },
        	  sto._idleTick);
        },
        
        /*
         * 'Tick handler number 1'.
         * Executes the actual check to assess if the timeout warning dialog should
         * be displayed to the user.
         */
        _doCheckExp: function() {    	
          var freshSessionExpiryString = '';
        	  if (typeof(Storage) !== "undefined") {
        		    if (sessionStorage.sessionExpiry) {
        		    	freshSessionExpiryString = sessionStorage.sessionExpiry;
        		    } 
        		  }
          if (!sto.previousSessionExpiryString || (sto.previousSessionExpiryString != freshSessionExpiryString)) { // start over
	        sto._validateSessionExpiry(freshSessionExpiryString);
		    return;
          }
	      // invalid SessionStorage or clock stopped.
          if (sto.idleAllowance == 0) {
            return;
          }
	      // continue
          sto.idleAllowance -= sto._idleTick;
          if (sto.idleAllowance <= 0 ) {
           sto._invalidateIdleClock(true);
	       sto._openSessionTimeoutWarningModalDialog(); // open a modal dialog
	     }
	   },

       /**
        * Checks that the Session Storage Expiry String containing data about the session timeout is
        * secure and that its data has not been manipulated maliciously.
        * Resets the count down in case of invalid session storage string.
        * Sets the new count down from the valid session storage values.
        * 
        * @param sessionExpiryString The session storage string to validate.
        */
	   	_validateSessionExpiry:function(sessionExpiryString) {
	      if (sessionExpiryString == null) {
	    	sto._invalidateIdleClock();
		    return;
          }
	      var tokens = sessionExpiryString.split("-", 2);
	      if (tokens && tokens.length == 2) {
	        for (var idx in tokens) {
	          var millisecondsToken = Math.abs(tokens[idx]);
	          if (isNaN(millisecondsToken)) {
	        	sto._invalidateIdleClock();
	            return;
	          }
	          tokens[idx] = millisecondsToken;
	        }
            // idleAllowance=expiryMoment-lastResponseMoment
            sto.idleAllowance = Math.abs(tokens[0] - tokens[1]);
            sto._insertWarnDuration();
	        sto.previousSessionExpiryString = sessionExpiryString;
            return;
          }
	      //session storage string was invalid, skip until valid
	      sto._invalidateIdleClock();
        },
    
        /**
         * Utility method to reset the state.
         * @param stopTimer true if the idleClock needs to be erased.
         */
        _invalidateIdleClock: function(stopTimer) {
          stopTimer && clearInterval(sto._idleClock);
          sto.previousSessionExpiryString = false;
          sto.idleAllowance = 0;
        },

        /**
         * Calculates and sets the countdown interval for the session expiration modal
         * dialog to appear.
         */
        _insertWarnDuration: function() {
          var availableDurationMs = sto.idleAllowance - sto.interactionAllowance - sto._idleTick;
          sto.effectiveTimeout = Math.min(sto.requiredWarnDurationMs, Math.max(availableDurationMs, 0));
          //share the timeout with modal.
          sto._cfg['effectiveTimeout'] = sto.effectiveTimeout;
	      sto.idleAllowance-=(sto.effectiveTimeout); //set up the warning dialog duration
	    },

	    /**
         * Gets the configuration data for the timeout warning.
         * Accounts for different actors accessing the shared configuration
         * (top window or expiry modal).
         * @returns The application configuration for the timeout warning.
         */
        getTimeoutWarningConfig: function() {
          var wdef = sto.tlw || sto._cfg.tlw;
          if (wdef.TIMEOUT_WARNING_CONFIG) {
            return wdef.TIMEOUT_WARNING_CONFIG.timeoutWarning;   
          } else { //fallback when the config is somehow not here.
            return sto.pseudoConfig;
          }
        },
 
        /**
         * Open the session timeout warning modal dialog.
         */
         _openSessionTimeoutWarningModalDialog: function () {
           var size = {width:sto._cfg.width, height:sto._cfg.height};
           if (sto._isExternal) { //external application
             sto.tlw.openModal(sto.sessTimeoutWarningJSPXDialog, size);
           } else { // internal application 
             sto.tlw.dialogOpenerRef = util.showModalDialogWithRef(sto.sessTimeoutWarningJSPXDialog,null,size); 
             // hide the close button.
             sto.tlw.dialogOpenerRef && sto.tlw.dialogOpenerRef._setClosableAttr(false);
           }
         },
     
         /**
          * Initialises the properties to start the count down timer to the user.
          * Called externally by the actual warning modal dialog upon load.
          * 
          * @param stConfig         The session timeout configuration.
          * @param titleNodeID      The identifier of the DOM node containing the dialog title.
          */
          initTimer:function(stConfig, titleNodeID){
            sto._cfg = stConfig; // re-connecting with global config
            sto.__remainingCountdown = stConfig.effectiveTimeout;
            var domMins = dom.byId(sto.minutesCompNodeID),
                 domSecs = dom.byId(sto.secondsCompNodeID);
            sto.expiryCountdown = setInterval(function(){sto._countDown(domMins, domSecs);}, sto._expiryTick);
          },

          /**
           * 'Tick handler number 2'.
           * Processes count down data in the expiry modal dialog.
           * @param domMins     DOM node reference for reflecting remaining minutes.
           * @param domSecs     DOM node reference for reflecting remaining seconds.
           */
          _countDown:function(domMins, domSecs){
            if (sto.__remainingCountdown == 0) {
              sto._stopCountdown();
          	return;
            }
            sto.__remainingCountdown-=sto._expiryTick;
            if (sto.__remainingCountdown <= 0) {
              sto._stopCountdown();
              sto.tlw.curam.util.SessionTimeout.autoLogout();
              dialog.closeModalDialog();
              return;
            }
            var tRemaining = new Date(sto.__remainingCountdown);
            var secs = "" + tRemaining.getSeconds(), sPad = (secs.length == 1) ? '0':'';
            domMins.innerHTML=tRemaining.getMinutes();
            domSecs.innerHTML=sPad + secs;
          },

          /**
           * Stops the interval to execute the timer.
           */
          _stopCountdown:function() {
           sto.__remainingCountdown=0;
           clearInterval(sto.expiryCountdown);
          },
          /**
           * Schedules the redirection following the user confirmation. 
           */
          waitForRedirection: function() {
            dojo.subscribe("/curam/dialog/close", function(){
              sto._redirectToLogoutWrapper();
            });
          },
          /**
           * Schedules the auto-redirection following the timeout. 
           */
          autoLogout: function() {
            dojo.subscribe("/curam/dialog/close", function(){
              sto._redirectLoginWithSessionExpiredMessage();
            });
          },

          /**
           * Redirects the session timeout warning modal to the logout wrapper 
           * defined in the property.
           */
          _redirectToLogoutWrapper : function(){
            sto._cfg.tlw.dojo.publish("curam/redirect/logout");
            var page = sto._cfg.logoutPage || false;
            if (!page) {
              return;
            }
            if (sto._cfg.isExternal) { //an external application
          	sto._cfg.tlw.displayContent({pageID:page,
              	                        param: [{ paramKey: "invalidateSession", paramValue: true}]}); 
            } else { //an internal application
              sto._redirectInternalLogoutWrapper(page); 
            }
          },

          /**
           * Redirects the session timeout warning modal to the logout wrapper 
           * defined in the property.Used by an internal application.
           * This is the internal application handling branch.
           * @param      logoutPage the page id to redirect for logout. 
           */
          _redirectInternalLogoutWrapper : function(logoutPage){
            sto._cfg.tlw.dialogOpenerRef = null;
            //default internal logout wrapper jspx
            if (logoutPage === sto._INTERNAL_LOGOUT_WRAPPER){
              logoutPage += '.jspx?invalidateSession=true';  
              dojo.global.location = jsBaseURL + "/" + logoutPage;
            } else { //configured UIM page
              var parentWindow = dialog.getParentWindow();
              logoutPage += 'Page.do?invalidateSession=true';
              if (parentWindow && parentWindow.location
                    !== sto._cfg.tlw.location) { // if the session timeout happened on a modal.
                dialog.doRedirect(parentWindow, logoutPage, true);
              } else {
                curam.tab.getTabController().handleLinkClick(logoutPage);
              } 
            }
          },

          /**
           * Redirects to the login page with an expired message. 
           */
          _redirectLoginWithSessionExpiredMessage : function(){
            // get the expired user message property.
            var expiredUserMessageTxt =  sto._cfg.expiredUserMessageTxt || "";
            //save the message in the local storage.
            localStorage[sto._EXPIRED_MESSAGE_KEY] = expiredUserMessageTxt;
            sto._redirectToLogoutWrapper();
          },

          /**
           * Execute the steps when the user click on the Continue button.
           */
          resetAndStay: function(){
            var wait4DialogClose = 
          	  sto._cfg.tlw.dojo.subscribe("/curam/dialog/close",
                  function() {
                    if (sto._cfg.tlw.dialogOpenerRef) {
                      var pRef = dialog.getParentWindow(window);
                      pRef && pRef.focus();
                      sto._cfg.tlw.dialogOpenerRef = null;
              	    }
                    //unsubscribing 
                    sto._cfg.tlw.dojo.unsubscribe(wait4DialogClose);
                    sto._stopCountdown();
                    sto.checkSessionExpired();
                    require (['curam/debug'], function(debug){
                      debug.log(debug.getProperty("continueApp"));  
                    });
              });
          },

          /**
           * Checks if the local storage has the expired message 
           * and create the HTML that shows an session expired message on the page.
           */
          createExpiredSessionMessageHTML: function(messageContainerId){ 
            var expiredMessage = localConfig.readOption(sto._EXPIRED_MESSAGE_KEY);
            if (expiredMessage){    
              //get the DOM that contains the message container ID 
              messageContainerDOM = dom.byId(messageContainerId);
              if (messageContainerDOM) {
                var messageDom = "<div id='error-messages-container' class='wrapper-expired-message'>"
              	               + "<ul id='error-messages' class='messages'>"
              	               + "<li class='level-1'><div><span id='message'>"
              	               + expiredMessage
              	               +"</span></div></li></ul></div>"
                domConstruct.place(domConstruct.toDom(messageDom), messageContainerDOM); 
              }
              localConfig.clearOption(sto._EXPIRED_MESSAGE_KEY);
            }
          },
          /**
           * Format the user message and displays it as paragraphs to the user.
           * 
           * @param msg             The user message to be displayed.
           * @param userMessageNode The user message node to be updated.
           */
           displayUserMsgAsParagraphs: function(msg, userMessageNode) {
             var userMessageWithParagraphs = userMessageNode || dom.byId(sto.userMessageNodeID);
             var paragraphTxtArray = msg.replace("\\n","[<p>]").replace("\n","[<p>]").split('[<p>]');
             var fragment = document.createDocumentFragment();
             for (line in paragraphTxtArray) {
               var paragraph = document.createElement("p");
               paragraph.innerHTML = paragraphTxtArray[line];
               fragment.appendChild(paragraph);
             }
             domConstruct.place(fragment, userMessageWithParagraphs);
          },
        });
  
        var sto = curam.util.SessionTimeout;
        sto.tlw = curam.util.getTopmostWindow() || window.top;
        return sto;  
});
},
'curam/codetable-hierarchy':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  Copyright IBM Corporation 2009,2015. All Rights Reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/**
 * Provides the functionality for the code table hierarchies.
 * 
 */

/*
 * Modification History
 * --------------------
 * 20-Nov-2015  AZ  [CR00472692] Rollback CR00465086.
 * 24-Aug-2015  AZ  [CR00465086] Added code-table name as initial display value
 *                              for accessibility. 
 * 11-Apr-2014  MV  [CR00424825] Move to common AJAX request API.
 * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
 *                              include required bundle.
 * 31-Jul-2012 MV [CR00336202] Migrate to take on Dojo 1.7.3
 * 31-Jan-2012 MV [CR00302081] Move away from global context. 
 */

define(["curam/util/Request",
        "curam/debug",
        "dojo/data/ItemFileReadStore",
        "curam/widget/FilteringSelect"], function(curamRequest, debug) {
  
var CodeTableHierarchy = {

  /**
   * This function initialises the codetable hierarchy.
   *
   * An empty option is the blank entry in the drop down. This is always the
   * first item in the drop down.
   *
   * @param noOptionCode the value for an empty option.
   * @param noOptionDesc a name for an empty option.
   * @param ddInfo an array containing pairs of id & ctName, where id is the id
   * of the drop down, and ctName is the name of the codetable associated with
   * this dropdown.
   */
  initLists: function(noOptionCode, noOptionDesc, ddInfo) {
    this.noOptionCode = noOptionCode;
    this.noOptionDesc = noOptionDesc;
    this.ddInfo = ddInfo;

    // this code needs to be executed after all the widgets have been created 
    // on the page, so it is placed in a function an executed by addOnLoad
    // which guarantees the page will be fully loaded before the code is
    // executed.
    this.lists = function(){
      var next = null;
    
      // Iterate in reverse to create a forward-linked list.
      for (var i = ddInfo.length - 1; i >= 0; i--) {
        next = new CodeTableHierarchy.DropDown(
        dijit.byId(ddInfo[i].id), ddInfo[i].ctName,
        noOptionCode, noOptionDesc, next);
    }};

    dojo.addOnLoad(this.lists);
  }, 

  /**
   * This function initialises a drop down in the codetable hierarchy.
   *
   * An empty option is the blank entry in the drop down. This is always the
   * first item in the drop down.
   *
   * @param widgetNode the node of the Dojo widget.
   * @param codeTableName the name of the codetable.
   * @param noOptionCode the value for an empty option.
   * @param noOptionDesc a name for an empty option.
   * @param next the next drop down in the hierarchy.
   */
  DropDown: function(widgetNode, codeTableName, noOptionCode, noOptionDesc, 
    next) {
    this.node = widgetNode.domNode;
    this.widgetNode = widgetNode;      
    this.codeTableName = codeTableName;
    this.noOptionCode = noOptionCode;
    this.noOptionDesc = noOptionDesc;
    this.next = next;
    var _this = this; 

    /**
     * Populates the next drop down in the hierarchy when a value has changed
     * in the previous drop down.     
     */
    this.populate = function() {      
      if(!_this.widgetNode.get("value")){
      _this.resetNext(_this);
      } else if (_this.next != null) {
      _this.resetNext(_this);        
        
        if (_this.widgetNode.get("value") == 0){
          return;
        }
        
        curamRequest.post({
          url: "../servlet/JSONServlet",
          
          handleAs: "text",
          
          preventCache: true,

          load: function(dataitems, evt){
            
            // if there are no codetable items returned, then log a message
            // and return.
            if (dataitems.length < 3){
              curam.debug
                .log(debug.getProperty("curam.codetable-hierarchy.msg.1") 
                  + _this.codeTableName 
                  + debug.getProperty("curam.codetable-hierarchy.msg.2") 
                  + _this.widgetNode.get('value') );
              return;
            }
                      
            // create JavaScript object and add empty item  
            var dataItemsObj = dojo.fromJson(dataitems);
            dataItemsObj.unshift({"value":_this.noOptionCode,"name":""});                        
                   
            var select = dijit.byId(_this.next.widgetNode.id);
                       
            var newStore = new dojo.data.ItemFileReadStore({                
              data: {
                label: "name",
                identifier: "value",              
                items: dataItemsObj}});

             // update the widget with the new store and select the empty item            
             newStore.fetch({           
                onComplete: function(item, request) { 
                select.set("store", newStore);
                select.set("value", _this.noOptionCode);}           
             });            
          },
          
          error: function(error){
            debug.log(error);  
          },
          
          content: {"content": dojo.toJson({
            operation: "getCodeTableSubsetForFilteringSelect",
            args: [_this.codeTableName, _this.widgetNode.get("value")]})}              
        });             
      }
    };

    /**
     * Resets all codetables to the left of the drop down that has changed.
     * 
     * @param dropDown the drop down that has changed
     */
    this.resetNext = function(dropDown) {

      while (dropDown.next != null) {                     
          var dataItemsObj = [];
          dataItemsObj.unshift({"value":dropDown.noOptionCode,
            "name":dropDown.noOptionDesc});                                  
        
          var select = dijit.byId(dropDown.next.widgetNode.id);
          
          var emptyStore = new dojo.data.ItemFileReadStore({                
            data: {
              label: "name",
              identifier: "value",              
              items: dataItemsObj}});
          
          // update the widget with the new store and select the empty item
          emptyStore.fetch({            
            onComplete: function(item, request) { 
              select.set("store", emptyStore);
              select.set('displayedValue', dropDown.noOptionDesc);}});
          
          dropDown = dropDown.next;           
      }      
    };

    if (next != null) {
      dojo.connect(this.widgetNode, "onChange", this.populate);
    } 
  }
};

// Keep the functions in the global scope for backwards compatibility.
// TODO: remove when code calling these functions is updated
dojo.global.CodeTableHierarchy = CodeTableHierarchy;

return CodeTableHierarchy;
});

},
'curam/util/ui/refresh/TabRefreshController':function(){
/*
 * Copyright 2011-2018 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["dojo/_base/declare",
        "curam/inspection/Layer",
        "curam/debug",
        "curam/util/ui/refresh/RefreshEvent"
        ], function(declare, layer, debug) {

  /*
   * Modification History
   * --------------------
   * 23-Aug-2018  BD  [RTC229425]  Included publish to alert when the page is submitted
                                   and when the context is refreshed.
   * 17-Oct-2014  MV  [CR00447421] Ignore very first context panel refresh
   *                               request. Always refresh menu and navigation
   *                               on a tab load.
   * 22-Sep-2014  SK  [CR00445339] Added inspection layer integration.
   * 26-Jun-2013  BOS [CR00390466] Adding requireLocalization to specifically
   *                include required bundle.
   * 07-May-2013  MV  [CR00383012] Fix destroy function to properly
   *    re-initialize members. 
   * 07-Mar-2013  MV  [CR00373496] Fix member variable values handling.
   * 22-Oct-2012  SK  [CR00346419] Now destroys the configuration references
   *                  to avoid memory leak.
   * 09-Oct-2012  BOS [CR00346368] Localized debug messages to console.
   * 04-Jul-2011  MV  [CR00269970] Initial version.
   */

  /**
   * @name curam.util.ui.refresh.TabRefreshController
   * @namespace Manages refreshing of the the tab UI components.
   *
   */
  var TabRefreshController = declare("curam.util.ui.refresh.TabRefreshController", null,
  /**
   * @lends curam.util.ui.refresh.TabRefreshController.prototype
   */
  {
    /** Event name for menu refresh. */
    EVENT_REFRESH_MENU: "/curam/refresh/menu",

    /** Event name for navigation refresh. */
    EVENT_REFRESH_NAVIGATION: "/curam/refresh/navigation",

    /** Event name for context panel refresh. */
    EVENT_REFRESH_CONTEXT: "/curam/refresh/context",

    /** Event name for the main content panel refresh. */
    EVENT_REFRESH_MAIN: "/curam/refresh/main-content",

    /** ID of the related tab widget. */
    _tabWidgetId: null,

    /** The configuration for onsubmit handling. */
    _configOnSubmit: null,

    /** The configuration for onload handling. */
    _configOnLoad: null,

    /** The handler function that performs the actual refresh based on the
     * generated events. */
    _handler: null,

    /**
     * Holds the last submit event to be processed. This is needed because page
     * submits are processed only when the next page loads. It is done for two
     * reasons: a) to make sure any server updates caused by the submit are
     * reflected when the UI is refreshed and b) to avoid double refreshes
     * when they are configured on both one page submit and the next page load.
     * If this is the case the refresh list is optimized and only done once.
     */
    _lastSubmitted: null,

    /**
     * Holds the current refresh event sent to the main content panel. This is
     * used to break potential infinite recursion when we are notified of page
     * events caused by our own refresh event.
     */
    _currentlyRefreshing: null,


    /**
      * The very first context panel refresh will be ignored, if it comes
      * from the main content panel load. This is to make sure we don't load
      * the context panel twice when tab is being opened.
      */
    _ignoreContextRefresh: true,

      /**
      * We need to always refresh menu/nav on tab open regardless
      * the configuration.
      */
    _initialMenuAndNavRefreshDone: false,

    _nullController: null,

    /**
     * Creates an instance of the refresh controller.
     *
     * @param {String} tabWidgetId Id of the tab widget this controller
     *            belongs to.
     * @param {Object} [config] The tab refresh configuration object.
     *            The expected structure is the one output
     *            by curam.util.client.render.component.TabRenderer.
     *            Configuration is optional as some tabs have no associated
     *            refresh configuration. If not provided, the controller will not
     *            be active, i.e. will not send out any refresh events ever.
     */
    constructor: function(tabWidgetId, config) {
      this._configOnSubmit = {};
      this._configOnLoad = {};

      if (!config) {
        // is null controller
        this._nullController = true;
        return;
      }

      this._tabWidgetId = tabWidgetId;

      // Expand the configuration data structure so that it is easily
      // used in the controller.
      dojo.forEach(config.config, dojo.hitch(this, function(item) {
        this._configOnSubmit[item.page] = item.onsubmit;
        this._configOnLoad[item.page] = item.onload;
      }));
      layer.register("curam/util/ui/refresh/TabRefreshController", this);

    },

    /**
     * Notifies the controller of a page submit in the specified context.
     *
     * @param pageId ID of the page that has been submitted.
     * @param context Context in which the page has been submitted. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageSubmitted: function(pageId, context) {
      // create event object - validates the parameters
      new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONSUBMIT, context);
      debug.log("curam.util.ui.refresh.TabRefreshController: " +
          debug.getProperty("curam.util.ui.refresh.TabRefreshController.submit",
                             [pageId, context]));
      dojo.publish("curam/form/submit",[pageId]);
      if (this._configOnSubmit[pageId]) {
        // if we are interested in this submit, record the event
        // it will be processed when a next page loads
        this._lastSubmitted = pageId;
        debug.log("curam.util.ui.refresh.TabRefreshController: "
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "submit.notify"));
      }
    },

    /**
     * Notifies the controller of a page load in the specified context.
     *
     * @param pageId ID of the page that has been loaded.
     * @param context Context in which the page has been loaded. The expected
     *            values for this parameter are defined as constants
     *            in the curam.util.ui.refresh.RefreshEvent class.
     */
    pageLoaded: function(pageId, context) {
      // create event object - also validates the parameters
      var event = new curam.util.ui.refresh.RefreshEvent(
          curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD, context);

      debug.log("curam.util.ui.refresh.TabRefreshController:"
        + debug.getProperty("curam.util.ui.refresh.TabRefreshController.load",
          [pageId, context]));

      // do not react to onload event if it was caused by our refresh event
      // this avoids possible infinite recursion
      if (this._currentlyRefreshing && this._currentlyRefreshing.equals(event)) {
        this._currentlyRefreshing = null;
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + "refresh"));
        return;
      }

      // if a refresh is configured for both previous page submit and next page
      // load we merge the configurations and only refresh once
      var mergedRefreshConfig = {};

      // only support onload event for the main content panel
      if(context == event.SOURCE_CONTEXT_MAIN && this._configOnLoad[pageId]) {
        mergedRefreshConfig = this._configOnLoad[pageId];
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".load.config"));
      }
      // else ->
      // load in other contexts will be only used to dispatch
      // any previous onsubmit event
      if (this._lastSubmitted) {
        // merge the configs if we have both onsubmit and onload
        var cfg = this._configOnSubmit[this._lastSubmitted];
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".submit.config", [this._lastSubmitted]));

        mergedRefreshConfig.details = mergedRefreshConfig.details || cfg.details;
        mergedRefreshConfig.menubar = mergedRefreshConfig.menubar || cfg.menubar;
        mergedRefreshConfig.navigation =
            mergedRefreshConfig.navigation || cfg.navigation;
        mergedRefreshConfig.mainContent =
            mergedRefreshConfig.mainContent || cfg.mainContent;

        this._lastSubmitted = null;
      }

      if (!this._nullController) {
        this._fireRefreshEvents(mergedRefreshConfig, this._ignoreContextRefresh,
            !this._initialMenuAndNavRefreshDone);
      }

      // stop ignoring context refresh after the initial page load
      // in the main content panel and leave it that way
      if (this._ignoreContextRefresh && context == event.SOURCE_CONTEXT_MAIN) {
        this._ignoreContextRefresh = false;
      }

      if (!this._initialMenuAndNavRefreshDone) {
        // initial refresh done, obey the config from now on
        this._initialMenuAndNavRefreshDone = true;
      }
    },

    /**
     * Invokes the refresh handler with events based on the received
     * page load/submit events and refresh configuration.
     *
     * @private
     *
     * @param cfg The relevant configuration fragment.
     */
    _fireRefreshEvents: function(cfg, ignoreContextRefresh, doRefreshMenuNav) {
      var events = [];
      if (cfg.details) {
        if (ignoreContextRefresh) {
          curam.debug.log(
              "curam.util.ui.refresh.TabRefreshController: ignoring the first CONTEXT refresh request");
        } else {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.context"));
        events.push(this.EVENT_REFRESH_CONTEXT + "/" + this._tabWidgetId);
        }
      }else if(!ignoreContextRefresh){
    	  dojo.publish("curam/tab/contextRefresh");
      }
      if (cfg.menubar || doRefreshMenuNav) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.menu"));
        events.push(this.EVENT_REFRESH_MENU + "/" + this._tabWidgetId);
      }
      if (cfg.navigation || doRefreshMenuNav) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.nav"));
        events.push(this.EVENT_REFRESH_NAVIGATION + "/" + this._tabWidgetId);
      }
      if (cfg.mainContent) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
          + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
            + ".refresh.main"));
        // store the refresh event for later use in the infinite recursion
        // breaking code above
        this._currentlyRefreshing = new curam.util.ui.refresh.RefreshEvent(
            curam.util.ui.refresh.RefreshEvent.prototype.TYPE_ONLOAD,
            curam.util.ui.refresh.RefreshEvent.prototype.SOURCE_CONTEXT_MAIN,
            null);
        events.push(this.EVENT_REFRESH_MAIN + "/" + this._tabWidgetId);
      }
      if (events.length > 0) {
        debug.log("curam.util.ui.refresh.TabRefreshController:"
            + debug.getProperty("curam.util.ui.refresh.TabRefreshController"
              + ".refresh.log", [events.length, events]));
        this._handler(events);
      }
    },

    /**
     * Specifies the refresh handler function to be invoked when some tab UI
     * parts should be refreshed.
     *
     * @param {Function} handler A function to be invoked in response to tab UI
     *    refresh events. The function will be passed one parameter
     *    which is an array of refresh event names. The format of the refresh
     *    event names is the following: event_name/tab_widget_id, where
     *    the supported event_names are defined as constants in this class
     *    and tab_widget_id is ID of the tab the events are related to. Please
     *    note that all the events in the array will always refer to the same tab.
     */
    setRefreshHandler: function(handler) {
      this._handler = handler;
    },

    /**
     * Releases any resources related to this controller instance.
     * It is the responsibility of this class' clients to call this function when
     * the tab that owns the controller instance is closed.
     */
    destroy: function() {
      for (prop in this._configOnSubmit) {
        if (this._configOnSubmit.hasOwnProperty(prop)) {
        delete this._configOnSubmit[prop];
      }
      }
      for (prop in this._configOnLoad) {
        if (this._configOnLoad.hasOwnProperty(prop)) {
        delete this._configOnLoad[prop];
      }
      }
      this._configOnSubmit = {};
      this._configOnLoad = {};
      this._handler = null;
      this._lastSubmitted = null;
      this._currentlyRefreshing = null;
    }
  });

  return TabRefreshController;
});

},
'dojo/_base/url':function(){
define(["./kernel"], function(dojo){
	// module:
	//		dojo/url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'curam/widget/SearchMultipleTextBox':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2012,2021. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */

/*
 * Modification History
 * --------------------
 * 10-Jun-2021  FN    [RTC265377] Amending _initializeSmartNavigatorWidget, _givenFocus,
 * _createKeywordTagsContainer, _renderResults, _createResultsList, _createPersonActionRow
 * and _hideSearchBox to fix aria violations.
 * on 'applicationSearchResultListId' and 'resultRowHeaderId' in the SmartNavigator widget.
 * 15-Jan-2021  FN    [RTC265377] Updating aria mark-up for the SmartNavigator widget
 * to make it fully accessible by the screen-reader.
 * 21-Oct-2020  GG    [RTC226839] Removed the wrong locale configuration. 
 * The local will be picked up based on the default dojo.locale 
 * as the rest of the java-script bundles in the application.
 * 24-Oct-2019  CM    [RTC250707] Change name of _onFocus to _givenFocus.
 * Added changes to _onKeyUp to ensure _showSearchHistory isn't called
 * unless backspace or delete is used.
 * 09-Apr-2019  AT    [RTC245862] Pre-navigation hook point added.
 * 25-Jul-2016  GB    Initial Version.
 */

/**
 * @name curam.widget.SearchMultipleTextBox
 * @description Customized dijit.form.TextBox class in order to add extra functionality.
 */
define([ "dojo/query", 
        "dojo/dom-style", 
        "dojo/dom-construct", 
        "dojo/on",
        "dojo/dom-geometry", 
        "dojo/dom-class", 
        "dojo/mouse",          
        "dojo/dom-attr", 
        "dojo/_base/fx", 
        "dojo/_base/lang",
        "dojo/_base/declare",
        "dojo/_base/array",
        "dojo/topic", 
        "dojo/debounce",
        "dojo/Deferred",
        "dojo/keys",
        "curam/date/locale",
        "dojo/has", 
        "dojo/sniff",
        "dojo/text!curam/widget/templates/SearchMultipleTextBox.html",
        "dijit/form/TextBox",
        "curam/util",
        "curam/util/Request", 
        "curam/util/ResourceBundle",
        "curam/ui/UIController",
        "curam/tab",
        "curam/debug",
        "curam/cdsl/connection/SimpleAccess",
        "curam/cdsl/connection/CuramConnection",
        "curam/tab"
		], function(query, 
					domStyle, 
					domConstruct, 
					on, 
					domGeom, 
					domClass, 
					mouse,					 
					domAttr, 
					fx, 
					lang,
					declare,
					arrayUtil,
					topic,
					debounce,
					Deferred,
					keys,
					dateLocale,
					has,
					sniff,
					template,
					TextBox,
					util,
					request, 
					ResourceBundle,
					UIController,
					tab,
					debug,
					simpleAccess,
					curamConnection,
					tab) {
	
			var CuramSearchMultipleTextBox = declare("curam.widget.SearchMultipleTextBox", TextBox,
			
			/**
			 * @lends curam.widget.SearchMultipleTextBox
			 */
			{
               /**
				 * Widget's HTML Template
                */
				templateString : template,
				
	            /**
	             * Check if the quick search is active
	             */
               quickSearch : null,
               hasIos : false,

               /**
				* Check if the quick search is enabled.
		        * Note that the quick search can be enabled but 
                * not active. 
                * This happens when we have the combobox with other search types.
				*/
               hasQuickSearch : null,

               /**
                * Server Calls Handling
                */
               quickSearchXHRPromises : [],
               searchResults : {},
               lastQueryTerm : '',
               spinnerTimeouts : [],
               _simpleAccess : simpleAccess,

               /**
                * Pagination
                */
               personQuantityToEagerLoad : 6,
               paginationStart : 0,
               paginationPageSize : 6,

               /**
                * Cache the checks to see if the destination 
                * page is configured to a valid tab
                */
               pagesMappedToTab : [],
               pagesNotMappedToTab : [],
               pagesMappedToMultipleTabs : [],
               
               /**
                * Cached Data for Keywords list
                */
               availableKeywordsList : null,

               /**
                * List Height Configurations
                */
               menuOpenedComboboxHeight : 72,
               menuOpenedFurtherOptionsHeight : 18,
               menuOpenedFurtherOptionsHeightQuickSearch : 12,
               menuOpenedFurtherOptionsHeightNoCombobox : 18,
               quickSearchMenuOpenedHeight : 29,
               currentOpenedHeight : 29,
               maxItemsHeight : 416,
               maxFlatListHeight : 416,
               closedHeight : null,
               destroyContextMenu : false,
               personInContextMenu : null, 

				/**
				 *  Advanced Quick Search Initializations
				 *
				 *  @constructor
				 */
				constructor : function() {
                   this.inherited(arguments);

                   this.bundle = new ResourceBundle("SmartNavigator");
               },
               
               /**
                * Initialize the SearchMultipleTextBox accordingly to
                * its properties.
                */
               postCreate : function() { 
               	   //Setup connection to endoint 
            	   this._simpleAccess.initConnection(new curamConnection(curam.util.retrieveBaseURL() + '/dataservice'));
            	   this.hasIos = has('ios');
               	
                   //Get the DOM elements and set into instance variables
                   this._queryDOMNodes();

                   domClass.add(this.searchControlsDiv[0], 'multiple-search-banner');
                   if (this.searchOptionsDiv != null && this.searchOptionsDiv.length > 0) {
                       domClass.add(this.searchOptionsDiv[0], 'multiple-search-options');
                   }

                   //Maxlength of the input set to 100
                   this.searchInputField.maxLength = 100;
                   
                   //Hide Widget on blur
                   //MouseDown + MouseUp events to avoid hiding if the user clicks somewhere inside the widget.
                   on(this.applicationSearchDiv[0], 'mousedown', lang.hitch(this, function(evt) {
                   	this.clickedInsideApplicationSearchWidget = this._isElementPartOfApplicationSearch(evt.target);
                   }));
                   on(this.applicationSearchDiv[0], 'mouseup', lang.hitch(this, function(evt) {
                   	this.clickedInsideApplicationSearchWidget = false;
                   })); 
                   if (this.searchOptionsDiv.length > 0) {
                       on(this.searchOptionsDiv[0].firstChild, 'blur',
                           lang.hitch(this, function(evt) {
                               this._hideSearchBoxIfNotFocused(evt);
                           })
                       );
                   }
                   
                   //Register the click event on the Search Icon to perform the search.
                   var onclickFunction = this.searchIcon[0].onclick;
                   this.searchIcon[0].onclick = lang.hitch(this, function(e){
                	   if(!domClass.contains(this.searchIcon[0], 'dijitDisabled')){
                		   if (this.quickSearch) {
                               this._search();
                           }else {
                               onclickFunction(e);
                           }
                       }
                   });
                   
                   
                   //Hide on blur event
                   on(this.searchIcon, 'blur', lang.hitch(this, function(evt) {
                       this._hideSearchBoxIfNotFocused(evt);
                   }));                  

                   //Hide the Widget on click - Only if not using the quick search.
                   on(this.searchIcon, 'click', lang.hitch(this, function(evt) {
                       if(!this.quickSearch){
                           this._hideSearchBox();
                       }
                   }));
                   
                   //Register Events Specific to the Smart Navigator.
                   if(this.hasQuickSearch){
                	   this._initializeSmartNavigatorWidget();
                   } else {
                	   //Smart Navigator disabled
                	   //Set events specifically for when we do not have smart navigator
                	   on(this.searchInputField, "keydown", lang.hitch(this, this._onKeyUp));
                   }
    
               }, 
               
               /**
                * Register the events that are specific to smart navigator only.
                * 
                * Also gets the smart navigator configuration parameters from the facade.
                * 
                * @private
                */
               _initializeSmartNavigatorWidget : function(){
            	 //Subscribe to the combobox on change event
                   //to check if the quick search has been enabled or disabled by selecting other search types.
                   topic.subscribe('curam/application-search/combobox-changed',lang.hitch(this,
                       function(newValue) {
                           if (this.quickSearch != null) {
                               if (newValue.indexOf("smart-navigator|smart-navigator") >= 0) {
                                   this._enableQuickSearch();
                               } else {
                                   this._disableQuickSearch();
                               }
                               this._fixQuickSearchHeight();
                           }
                       }
                   ));
            	   
            	   //Call the server to get the sysadmin properties.
                   //The keyup event is configured in a sysadmin property. 
                   //The debounce time can be configured or disabled.
                   var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'getSearchConfiguration');
        		   this.quickSearchXHRPromises.push(promise);
        		   promise.then( 
        				   // Success Callback
        				   lang.hitch(this, function(data){
        					   var debounceEnabled = false;
        					   if(data[0].debounceTimeout){
        						   var debounceTimeout = parseInt(data[0].debounceTimeout);
        						    
        						   if(!isNaN(debounceTimeout) && debounceTimeout >= 0){
        							   // Set the keyup event for the autocomplete
                	                   // Use of debounce to prevent firing the event on every keystroke.
                	                   on(this.searchInputField, "keydown", 
                	                       debounce(lang.hitch(this, this._onKeyUpAutoComplete), debounceTimeout));
                	                   debounceEnabled = true;
        						   }
        					   }
        					   
        					   if(!debounceEnabled){
        						   on(this.searchInputField, "keydown", lang.hitch(this, this._onKeyUp));
        					   }
        				   }), 
        				   // Error Callback
        				   lang.hitch(this, this._ajaxErrorCallback));
                   
                   on(this.searchInputField, "keyup", lang.hitch(this,function(event){
                	   this._onDownArrowKey(event);
                   })); 
                   
                   on(this.searchInputField, "keydown", lang.hitch(this,function(event) {
                     if (event.keyCode == 8) {
                       var selection = (window.getSelection().toString() === this.searchInputField.value) ? true: false;
                       if (selection) {
                         this._removeAriaOwnsAttributeFromHiddenInfoSpanElement();
                       }
                     }
                   }));

                   on(this.searchIcon, "keyup", lang.hitch(this,function(event){
                	   this._onDownArrowKey(event);
                   }));
                   
                   on(window, 'resize', debounce(lang.hitch(this, function() { 
                	   var searchPopup = query('.application-search-upfront-popup')[0];
                	   if(searchPopup && !has('android') && !has('ios')){
                		   this._hideSearchBox();
                	   }
                   }), 50));
                   on.emit(window, 'resize', {bubbles: true,cancelable: true});
                   
                   //Icon Title
                   this.searchIcon[0].title = this.bundle.getProperty('SmartNavigator.icon.title');

                   //Hide the application search if the user clicks outside the widget.
                   //or hits ESCAPE.
                   on(query('body.curam'), [ 'click', 'touchstart', 'keyup' ],
                       lang.hitch(this, function(evt) {
                       	if(evt.type === 'keyup' && 
                       			evt.keyCode !== keys.ESCAPE){
                       		return;
                       	}  
                       	var escPressed = evt.type === 'keyup'; 
                            
                       	//If user hits the escape key and the contextMenu or Keywords List are opened, 
                       	//it will destroy only them
                       	var contextMenuDestroyed = this._destroyContextMenuIfNecessary(evt.target);
                       	var keywordsListHidden = this._hideKeywordsListIfNecessary(evt.target, escPressed);
                       	var focusOnResultRow = domClass.contains(evt.target, 'appSearchItem');
                       	
                       	if(evt.type === 'keyup'){
                       		//if focus is on a result row and user presses enter
                       		//the focus should go to the Keywords Button
                       		if(focusOnResultRow){
                       		   var button = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
                         	   if(button){
                         		   button.focus();
                         	   }
                       		}else if(!contextMenuDestroyed && 
                       				!keywordsListHidden){
                       			this._hideSearchBox();
                       			
                       			if(this._isElementPartOfApplicationSearch(evt.target)){
                       				this.searchIcon[0].focus();
                       			}
                       		}
                       	}else {
                       		var result = this._isElementPartOfApplicationSearch(evt.target);
                               if (!result) {
                                   this._hideSearchBox();
                               }

                       	}
                       })
                   ); 
               },

               /**
                * Get the DOM elements and set into local variables.
                *
                * @private
                */
               _queryDOMNodes : function() {
                   if (this.searchControlsDiv == null) {
                       this.searchControlsDiv = query(".search-input-controls");
                   }
                   if (this.searchIconDiv == null) {
                       this.searchIconDiv = query(".application-search-anchor-div");
                   }
                   if (this.searchIcon == null) {
                       this.searchIcon = query(".application-search-anchor");
                   }
                   if (this.searchInputField == null) {
                       this.searchInputField = this.focusNode;
                   }
                   if (this.inputNode == null) {
                       this.inputNode = query('.search-input-controls .text')[0];
                   }
                   if (this.applicationSearchDiv == null) {
                       this.applicationSearchDiv = query(".application-search");
                   }
                   if (this.searchOptionsDiv == null) {
                       this.searchOptionsDiv = query(".search-options");
                   }
                   if (this.searchOptionsDiv.length > 0 && this.searchOptionsDivOpenedColor == null) {
                       this.searchOptionsDivOpenedColor = domStyle.get(this.searchOptionsDiv[0], "color");
                   }
                   if (this.searchInputImg == null) {
                       this.searchInputImg = query('.application-search-anchor img');
                   }
                   if (this.quickSearch == null) {
                       this.quickSearch = query('.application-search.quick-search').length > 0;
                   }
                   if (this.hasQuickSearch == null) {
                       this.hasQuickSearch = query('.application-search.has-quick-search').length > 0;
                   }
               },

               /**
                * Hide the search box input.
                * Set it back to its original state when it does not have the focus.
                *
                * @private
                */
               _hideSearchBox : function() {
                   if (this._isSearchInputFieldPopulated()) {
                       domStyle.set(this.searchInputField, "color",
                           domStyle.get(this.applicationSearchDiv[0], "color"));
                   } else {
                       domStyle.set(this.searchInputField, this.originalInputColor);
                   }

                   domClass.remove(this.searchInputField, 'input-placeholder-opened');
                   domClass.add(this.searchInputField, 'input-placeholder-closed');

                   domAttr.remove(this.searchInputField, 'aria-describedby');

                   if (this.searchTextDiv != null &&
                       domStyle.get(this.searchTextDiv[0], 'background-color') != this.backgroundColor) {
                   	domStyle.set(this.searchTextDiv[0], 'background-color', this.backgroundColor);
                       domStyle.set(this.searchControlsDiv[0], 'background-color', this.backgroundColor);
                       domStyle.set(this.searchIconDiv[0], 'background-color', this.backgroundColor);

                       this.searchInputImg[0].src = jsBaseURL + '/themes/curam/images/search--20-on-dark.svg';

                       domClass.remove(this.applicationSearchDiv[0], 'application-search-upfront-popup');

                       if (this.searchOptionsDiv.length > 0) {
                           domStyle.set(this.searchOptionsDiv[0], "display", "none");
                       }

                       if (this.appBannerComboBoxDiv != null
                           && this.appBannerComboBoxDiv.length > 0) {
                           domStyle.set(this.appBannerComboBoxDiv[0], "display", "none");
                       }

                       domStyle.set(this.applicationSearchDiv[0], "height", this.closedHeight + "px");

                       this.applicationSearchDiv.style({
                           left : "0px"
                       });

                       this._hideResultList();
                   }
               },

               /**
                * Check if the target element is part of the application search.
                *
                * Search for the application-search element recursively in all its hierarchy.
                *
                * @param {object} target - event.target object
                * @returns {boolean}
                * @private
                */
               _isElementPartOfApplicationSearch : function(target) {
                   if (target.parentElement != null) {
                       if (domClass.contains(target, 'application-search') ||
                           domClass.contains(target, 'dijitComboBoxMenuPopup')) {
                           return true;
                       } else {
                           return this._isElementPartOfApplicationSearch(target.parentElement);
                       }
                   }
                   return false;
               },

               /**
                * If the application search or any children is not focused, hide the search box.
                *
                * @param {object} evt - onBlur event object.
                * @private
                */
               _hideSearchBoxIfNotFocused : function(evt) {
                   var _self = this;
                   setTimeout(function() {
                       var element = document.activeElement;
                       if(!_self._isElementPartOfContainer(element, 'application-search') && 
                       		!_self.clickedInsideApplicationSearchWidget){
                           _self._hideSearchBox();
						}
                   }, 1);
               },

               /**
                * Set the PlaceHolder of the TextBox Widget.
                *
                * @param {String} v PlaceHolder Text
                * @private
                */
               _setPlaceHolderAttr : function(v) {
                   this.searchInputField = this.domNode.firstChild.firstChild;
                   domAttr.set(this.searchInputField, 'placeholder', v);
               },

               /**
                * Check if the search input field has value
                *
                * @returns {boolean}
                * @private
                */
               _isSearchInputFieldPopulated : function() {
                   return this.searchInputField.value.length > 0;
               },

               /**
                * OnKeyUp event handler.
                *
                * Trigger the autocomplete if quick search is enabled.
                *
                * @param evt
                * @private
                */
               _onKeyUp : function(evt) {
            	   if(evt.keyCode === keys.DOWN_ARROW){
            		   return false;
            	   }
            	   
            	   var enable = this._isSearchInputFieldPopulated();
            	   this._enableOrDisableSearchLink(evt, enable);
            	   
            	   if((evt.keyCode === keys.BACKSPACE || evt.keyCode === keys.DELETE) && 
            			   this.quickSearch && !enable && 
            			   !this._isShowingHistory()){ 
            		   this.lastQueryTerm = '';
                       this._hideDropDown();
                       this._showSearchHistory();
            	   } else {
            		   return false;
            	   }
               },
               
               _onKeyUpAutoComplete : function(evt){
            	   if(evt.keyCode === keys.DOWN_ARROW){
            		   return false;
            	   }
            	   
            	   this._onKeyUp(evt);
            	   
            	   if (evt.target.value.trim() !== this.lastQueryTerm.trim()) {
                       this._doQuickSearch(evt.target.value);
                   }
               },
               
               /**
                * On DOWN_ARROW key navigate to the first result row or the first message.
                * 
                * @param {object} event
                * @private
                */
               _onDownArrowKey : function(event){
            	   if(event.keyCode === keys.DOWN_ARROW){
           			   //Look for tags button
            		   var tagsBtn = query('.appSearchDropDownButton', this.applicationSearchDiv[0]);
            		   if(tagsBtn.length > 0){
            			   tagsBtn[0].focus();
            		   }else {
           				   //look for tags
            			   var tags = query('.appSearchKeywordTag', this.applicationSearchDiv[0]);
            			   if(tags.length > 0){ 
            				   tags[0].focus(); 
            			   }else {
               					//Look for result rows.
            				   var items = query('.appSearchItem:not(.hide)', this.applicationSearchDiv[0]);
            				   if(items.length > 0){
            					   items[0].focus();
            				   }
            			   }
            		   }
            	   }
               },
               
               /**
                * Keywords keyboard navigation when using the DOWN_ARROW
                * 
                * If the focus is on the keywords button, go to the first keyword.
                * 
                * If the focus is on a keyword, go to the next keyword.
                */
               _onKeywordsDownArrowKey : function(event) {
            	   if(event.keyCode === keys.DOWN_ARROW){
            		    
            		   if(domClass.contains(event.target, 'appSearchKeywordsListButton')){
            			   //The focus is on the keywords button, go to the first keyword.
            			   if(this._showingAvailableKeywordsList){
            				   //Focus on the first available keyword.
            				   query('.availableKeyword .keywordTerm', 
            						   this.applicationSearchDiv[0])[0].focus(); 
            			   }else {
                           	   //Keywords list is not displayed. Look for result rows.
		    				   var items = query('.appSearchItem:not(.hide)', this.applicationSearchDiv[0]);
		    				   if(items.length > 0){ 
		    					   items[0].focus();
		    				   }
            			   }
            		   }else {
            			   //The focus is on a keyword, go to the next keyword.
            			   
            			   //1-Try to search the next keyword at the same level (same search target)
            			   var nextKeyword = this._findSiblingElement(event.target, true, 'keywordTerm');
            			   if(nextKeyword){
            				   nextKeyword.focus();
            			   }else {
            				   //2-There's no more keywords for this search target. 
            				   //Try to find keywords for the next search target.
            				   var nextSearchTarget = this._findSiblingElement(
            						   event.target.parentElement.parentElement, 
            						   true, 'availableKeyword');
            				   
            				   if(nextSearchTarget){
            					   nextKeyword = query('.keywordTerm:first-child', nextSearchTarget)[0];
            					   if(nextKeyword){
            						   nextKeyword.focus();
            					   }
            				   }
            				   
            			   }
            			   
            		   }
            	   }
               },
               
               /**
                * Keywords keyboard navigation when using the UP_ARROW
                * 
                * If the focus is on a keyword, go to the next keyword.
                */
               _onKeywordsUpArrowKey : function(event) {
            	   if(event.keyCode === keys.UP_ARROW){
        			   //1-Try to search the next keyword at the same level (same search target)
        			   var nextKeyword = this._findSiblingElement(event.target, false, 'keywordTerm');
        			   if(nextKeyword){
        				   nextKeyword.focus();
        			   }else {
        				   //2-There's no more keywords for this search target. 
        				   //Try to find keywords for the next search target.
        				   var nextSearchTarget = this._findSiblingElement(
        						   event.target.parentElement.parentElement, 
        						   false, 'availableKeyword');
        				   
        				   if(nextSearchTarget){
        					   nextKeyword = query('.keywordTerm:last-child', nextSearchTarget)[0];
        					   if(nextKeyword){
        						   nextKeyword.focus();
        					   }
        				   }
        			   }
            	   }
               },

               /**
                * Perform the search.
                *
                * If the Quick Search is active, the search will be performed using ajax.
                * The results are displayed directly in the Widget.
                *
                * If the Quick Search is not active, the user is redirected to UIM responsible
                * to perform the search.
                *
                * @private
                */
               _search : function () {
                   if(this.quickSearch){
                       this._doQuickSearch(this.searchInputField.value);
                       
                       //If the widget is closed, open it.
                       if(!domClass.contains(this.applicationSearchDiv[0], 'application-search-upfront-popup')){
                       	this._givenFocus();
                       } 
                   }else {
                       curam.util.search('__o3.appsearch.searchText', '__o3.appsearch.searchType');
                       this._hideSearchBox();
                   }
               },

               /**
                * Perform the Quick Search.
                *
                * Call the server using ajax and display the search results in a drop-down list.
                *
                * If no criteria is passed to the search, the search history is displayed.
                * 
                * -Show a Load Spinner while the server is processing the request
                *
                * @param {String} queryTerm - Search criteria
                *
                * @private
                */
               _doQuickSearch : function(queryTerm) { 
                   if (this.quickSearch) {
                       if (queryTerm) {
                		   this.lastQueryTerm = queryTerm;
                           this._resetSearchResults();

                           var query = {
                               term : queryTerm,
                               dateFormat : window.jsDF
                           };
 
                           //Cancel previous server calls if they're still running.
                           if(this.quickSearchXHRPromises.length > 0){
                               this.quickSearchXHRPromises.forEach(function(previousCallPromise){
                                   previousCallPromise.cancel();
                               });
                               this.quickSearchXHRPromises = [];
                           }
                           
                           var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'search', query);
                           this.quickSearchXHRPromises.push(promise);
                           promise.then(
                        		   //Success Callback
                        		   lang.hitch(this, this._searchCallback, queryTerm),
                        		   //Error Callback
                        		   lang.hitch(this, this._ajaxErrorCallback));

                           //Show Loading Spinner while the ajax request is being processed.
                           this._showSpinnerDiv();
                       } else {
                           this.lastQueryTerm = '';
                           this._hideDropDown();
                           this._showSearchHistory();
                       }
                   }
               },

               /**
                * Search History
                *
                * Call the server using ajax and display the history results in a drop-down list.
                *
                * @private
                */
               _showSearchHistory : function() {
                   this._resetSearchResults();

                   //Cancel previous server ajax calls if they're still runing.
                   this._cancelPreviousAjaxCalls();
                   
                   var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'searchUserHistory');
                   this.quickSearchXHRPromises.push(promise);
                   promise.then( 
                   	//Success Callback	
               		lang.hitch(this, this._showSearchHistorySuccessCallback),
                       
                    //Error Callback
               		lang.hitch(this, this._ajaxErrorCallback));
               },
               
               /**
                * Search History Success Callback
                *
                * Receive data from server and display the results.
                *
                * @private
                */
               _showSearchHistorySuccessCallback : function(data) {
          			var history = data[0]._data;
                    this.quickSearchXHRPromises = [];
                    if (history.dtls && history.dtls.length > 0) {
                        var historyList = history.dtls.map(function(detail) {
                            var history = {
                                url : detail.url,
                                icon : detail.icon,
                                preferredTabs : detail.preferredTabs,
                                isModal : detail.isModal
                            };  

                            if (detail.targetValue) {
                                history.action = {
                                    description : detail.targetDescription,
                                    type : detail.targetType
                                }
                            }

                            if (detail.searchConcernRoleName) {
                                history.person = {
                                    concernRoleName : detail.searchConcernRoleName,
                                    dateOfBirth : detail.searchConcernRoleDateOfBirth,
                                    concernRoleId : detail.searchConcernRoleId,
                                    formattedAddress : detail.searchConcernRoleAddress,
                                    restrictedIndOpt : detail.searchConcernRoleRestrictedIndOpt,
                                    personPhotoURL : detail.personPhotoURL, 
                                    items : []
                                }
                            }

                            return history;
                        });

                        //Search Callback to create the Results Drop-down List
                        this._searchCallback('', [{_data : { data : historyList} }], 
                        		this.bundle.getProperty('SmartNavigator.recent.searches'), true);
                    } 
                },

               /**
                * Ajax Error Callback.
                *
                * A Generic Error message is displayed in the Widget.
                *
                * Print out the original error message using curam's debug API.
                *
                * @param {object} err - Server Error Response Object.
                * @returns {Array}
                * @private
                */
               _ajaxErrorCallback : function(err) {
                   if(this.quickSearch && err.name !== 'CancelError'){ 
                       debug.log('Application Search - Smart Navigator Error: ', err);
                       this.quickSearchXHRPromises = [];
                       this._hideSpinnerDiv();
                       if(!domClass.contains(this.applicationSearchDiv[0], 'application-search-upfront-popup')){
                       	this._givenFocus();
                       } 
                       
                       //Gets the message from CDSL infrastructure if available,
                       //Otherwise displays a generic error message.
                       if(err.errors && err.errors[0] && 
                    		   err.errors[0].type && 
                    		   err.errors[0].type === 'error' &&
                    		   err.errors[0].message){  
                    	   this._createMessage(err.errors[0].message);
                       }else {
                    	   this._createMessage(this.bundle.getProperty('SmartNavigator.error'));
                       }
                       
                       this._fixQuickSearchHeight();
                   }

                   return [];
               },

               /**
                * Quick Search Success Callback
                *
                * 1-Get the returned JSON and format it into an object to be easily manipulated.
                *
                * 		From here, every data manipulation is done using the
                * 		formatted object this.searchResults
                *
                * 2-Call the Render Results function to display the items in a drop-down list.
                * 3-Hide the Load Spinner.
                *
                * @param {String} queryTerm
                *            Search Criteria Text used to perform the search.
                * @param {object} data
                *            json returned by the api.
                * @param {String} header
                * 			  optional header text for the result lists.
                * @param {Boolean} isHistory
                * 			  Indicator to display the history details.           
                * @private
                */
               _searchCallback : function(queryTerm, data, header, isHistory) {
               	var response = data[0]._data;
                   var _self = this;
                   _self.quickSearchXHRPromises = [];
                   _self.paginationTotalItems = 0;

                   _self.searchResults = response.data.reduce(
                       function(results, item, index) {
                           item.rendered = false;
                           if (item.person && 
                           		item.person.concernRoleId !== '0') { 
                               results.people.push(item);
                               results.personQueryTerms.push(item.person.terms);
                               results.hasItems = true;
                               _self.paginationTotalItems++;
                               
                               //-62135769600000 == zero date
                               if(item.person.restrictedIndOpt) {
                               	item.person.formattedDateOfBirth = '******';
                               }else if(item.person.dateOfBirth && 
                               		item.person.dateOfBirth.getTime() !== -62135769600000){
                               	item.person.formattedDateOfBirth =  
                               	dateLocale.format(dateLocale.parseDate(item.person.dateOfBirth),{
                               	    selector: "date",
                               	    datePattern : window.jsDF
                               	  }) + ', ' + _self.bundle.getProperty('SmartNavigator.age') + ' ' + _self._getAge(item.person.dateOfBirth);
                               }else {
                               	item.person.formattedDateOfBirth = _self.bundle.getProperty('SmartNavigator.age.not.recorded');
                               }

                               //History search returns a flat list of person/actions
                               if(item.action &&  
                               		item.action.description) {
                                   item.items = [item.action];
                               }else {
                               	item.action = null;
                               }
                           } else if (item.action) {
                           	item.person = null;
                               results.actionsOnly.push(item);
                               results.hasItems = true;
                               _self.paginationTotalItems++;
                           }

                           return results;
                       }, 
                       _self.searchResults);
                   
                   _self.searchResults.messages.info = response.infoMessage;
                   _self.searchResults.header = header;
                   _self.searchResults.isHistory = isHistory;
                   _self.searchResults.keywords = response.keywords || [];
                   _self.searchResults.queryTerm = queryTerm;
                   
                   //Try to load the first people's items if there's keyword and people found.
                   if(_self.searchResults.people.length > 0 && 
                   		_self.searchResults.keywords.length > 0){
                   	var peopleToEagerLoad = _self.searchResults.people.slice(0, this.personQuantityToEagerLoad); 
                   			
	        			_self._loadPeopleItems(peopleToEagerLoad).then(function(){
	        				_self._hideSpinnerDiv();
		                    _self._renderResults();
	        			});
	                    
                   }else { 
                       _self._hideSpinnerDiv();
                       _self._renderResults();
                   }

               },
               
               /**
                * Load all items of a lis of people.
                * 
                * @param {Array} people - Array of person.
                * @returns {object} deferred - Returns a promise.
                * @private
                */
               _loadPeopleItems : function(people){
            	   var deferred = new Deferred();
               	
            	   var peopleDetailsList = '';
            	   var mapConcernRoleItems = {};
               	
            	   people.forEach(function(item){
            		   var personToSerialize = lang.clone(item.person);
					   //Remove URLs to reduce network traffic
            		   personToSerialize.personTabDetailsURL = null;
            		   personToSerialize.personPhotoURL = null;
            		   personToSerialize.personTabDetailsURL = null;
            		   personToSerialize.dateOfBirth = null;
            		   personToSerialize.formattedDateOfBirth = null;
						 
            		   peopleDetailsList += JSON.stringify(personToSerialize) + '@@@';
						
            		   mapConcernRoleItems[personToSerialize.concernRoleId] = [];
            	   });
            	   peopleDetailsList = peopleDetailsList.substring(0, 
            			   peopleDetailsList.lastIndexOf('@@@'));
               	
               		//Cancel previous server ajax calls if they're still runing.
                   this._cancelPreviousAjaxCalls();
                    
                   //Server call
                   var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'searchForTargetsOfPeople', 
               			{ searchQuery : this.searchResults.queryTerm, peopleDetails : peopleDetailsList });
                   this.quickSearchXHRPromises.push(promise);
                   promise.then( 
               		//Success Callback
               		lang.hitch(this,function(mapConcernRoleItems, people, data){
               			var mapConcernRoleItems = data[0].data.reduce(function(map, item, index){
               				map[item.concernRole].push(item);
               				return map;
               			}, mapConcernRoleItems);
               			
               			people.forEach(function(item){
               				item.person.itemsLazyLoad = false;
               				item.person.items = mapConcernRoleItems[item.person.concernRoleId];
               			});
               			
               			deferred.resolve();
               		}, mapConcernRoleItems, people), 
               		
               		//Error Callback
               		lang.hitch(this, this._ajaxErrorCallback));
                   
                   
               	return deferred;
               },

               /**
                * Results Renderer - Check the state of the results and call functions to:
                *
                * 1-Create the results drop-down list
                * 2-Display Keyword tags
                * 3-Show Messages
                * 4-Decide whether the results are displayed as a flat list or break it down into two levels
                *
                * @param {boolean} isKeyboardEvent - Indicator to keyboard navigation.
                * @private
                */
               _renderResults : function(isKeyboardEvent){
                   var _self = this;
                   var searchResultsScreenReadersInfoSpanEl = query('.searchResultsScreenReadersInfo.hidden', this.applicationSearchDiv[0])[0];

                   if(_self.searchResults.hasItems){

                       //Check if the pagination button should be rendered
                       _self.searchResults.moreRecords =
                           _self.paginationTotalItems > _self.paginationStart + _self.paginationPageSize;

                       _self._createResultsList(_self.searchResults.header,
                           _self.searchResults.isHistory,
                           _self.searchResults.keywords);

                       if (this.searchResults.keywords && this.paginationStart === 0) {
                           _self._createKeywordTags(this.searchResults.keywords,
                               this.searchResults.personQueryTerms);
                       }

                       _self._createMessages();

                       // Decide whether the person items should be
                       // rendered within the list
                       // or in a person's context list
                       if (_self.paginationTotalItems <= _self.personQuantityToEagerLoad &&
                           _self._getItemsHeight(true) < _self.maxFlatListHeight) {

                           //All Items should be rendered directly in the list
                           _self._showHiddenResultRows();

                       //Create Person's Context List only if there's any keyword found.    
                       } else if (_self.searchResults.keywords.length > 0) {

                           //Too many items to show in a flat list.
                           //The person's items should be rendered on demand in a drop-down list per person.
                           _self._createPersonItemsContextMenuButton();
                       }

                   } else if(_self.searchResults.queryTerm.length > 2) { 
                	   //Empty results message is displayed only if the user has typed at least 3 characters
                	   //Condition added after the UX Team review.
                       _self._createMessage(_self.bundle.getProperty('SmartNavigator.empty.search'), true, true);
                   } else if (_self.searchResults.queryTerm.length <= 2) {
                     domAttr.remove(searchResultsScreenReadersInfoSpanEl, 'aria-owns');
                   }

                   domClass.add(_self.applicationSearchDiv[0], 'shadow');
                   
                   _self._fixQuickSearchHeight();
                   
                   //If the widget is closed, open it.
                   if(!domClass.contains(this.applicationSearchDiv[0], 'application-search-upfront-popup')){
                	   this._givenFocus();
                   	   this.searchInputField.focus();
                   } 
                    
                   //If Pagination and keyboard navigation, auto focus on the first new item.
                   if(isKeyboardEvent){
                   	var newItems = query('.appSearchNewItem', _self.applicationSearchDiv[0]);
                   	if(newItems.length > 0){
                   		newItems[0].focus();
                   	}
                   }

                   var recentSearchesHeaderSpanEl = query('.appSearchItemSeparatorLabel', this.applicationSearchDiv[0])[0];
                   if (recentSearchesHeaderSpanEl) {
                     domAttr.set(this.searchInputField, 'aria-describedby', 'resultRowHeaderId');
                   } else {
                     domAttr.remove(this.searchInputField, 'aria-describedby');
                   }

                  if (searchResultsScreenReadersInfoSpanEl){
                    var applicationSearchResultListIdEl = query('.appSearchItemsContainer', this.applicationSearchDiv[0])[0];
                    if (applicationSearchResultListIdEl && applicationSearchResultListIdEl.childElementCount > 0) {
                      domAttr.set(searchResultsScreenReadersInfoSpanEl, 'aria-owns', 'applicationSearchResultListId');
                    } else {
                      domAttr.remove(searchResultsScreenReadersInfoSpanEl, 'aria-owns');
                    }
                  }

                   _self._updateSearchResultsScreenReadersInfo();
                   _self._autoScrollToNewItems();
               },

              /**
               * Removes the aria-owns attribute on the span hidden element when the full content of
               * the input element of the Smart Navigator is selected and the backspace key is pressed.
               * 
               * @private
               */
              _removeAriaOwnsAttributeFromHiddenInfoSpanElement: function() {
              
                var searchResultsScreenReadersInfoSpanEl = query('.searchResultsScreenReadersInfo.hidden', this.applicationSearchDiv[0])[0];

                domAttr.remove(searchResultsScreenReadersInfoSpanEl, 'aria-owns');

              },

               /**
                * Create the drop-down list container for the results.
                *
                * Call functions to create the result rows.
                *
                * @private
                */
               _createResultsList : function() {
                   var refNode = query('.appSearchKeywords', this.applicationSearchDiv[0])[0];
                   	
                   var rowsContainer = null;

                   //Check if it is a new search or if the user requested more records from the pagination.
                   if (this.paginationStart === 0) {
                       // It is a New Search:
                       // 1-Destroy the existing list
                       // 2-Create a new rows container.
                       // 3-Add the pagination button if needed.
                       this._destroyResultList();

                       if (this.searchResults.moreRecords) {
                           this._createMoreRecordsRow(refNode);
                       }

                       if (this.searchResults.hasItems) {
                           outerContainer = domConstruct
                               .place('<div class="appSearchItemsOuterContainer" role="presentation" id="applicationSearchResultListId" aria-live="assertive"></div>',
                                   refNode, 'after');
                           rowsContainer = domConstruct
                               .place('<ul class="appSearchItemsContainer" aria-live="assertive"></ul>',
                                   outerContainer, 'last');

                           on(outerContainer, 'scroll',
                               lang.hitch(this, function(event) { 
                            	   //Check if the focus is not inside the context menu before deleting it.
                            	   if (!this._isElementPartOfContainer(document.activeElement, 'appSearchItemContext')) {
                            		   query('.appSearchItemContext', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                                       query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(function(item) {
                                           domClass.remove(item,'clicked');
                                       });
                            	   }
                               }));
                       }
                   } else {
                       //Adding new items using the pagination 
                       //If there isn't more pages, destroy the pagination button.
                       if (!this.searchResults.moreRecords) {
                       		//Set the focus to the input
                    	   this.searchInputField.focus();
                       		
                           query(".moreItems", this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                       }

                       rowsContainer = query('.appSearchItemsContainer', this.applicationSearchDiv[0])[0];
                   }

                   //Count to limit how many items are going to be rendered per page
                   var count = 0;

                   //Create Rows that are not related to a person
                   if (this.searchResults.actionsOnly && this.searchResults.actionsOnly.length > 0) {
                       this.searchResults.actionsOnly.forEach(function(action) {
                           if(count < this.paginationPageSize){
                               if(!action.rendered){
                                   count++;
                               }
                               this._createResultRow(action, rowsContainer, 'Action', this.searchResults.isHistory);
                           }
                       }, this);
                   }

                   //Create the People rows
                   this.searchResults.people.forEach(function(person) {
                       if(count < this.paginationPageSize){
                           if(!person.rendered){
                               count++;
                           }
                           this._createResultRow(person, rowsContainer, 'Person', this.searchResults.isHistory);
                       }
                   }, this);

                   //Add a header to the list
                   if (this.searchResults.header && this.paginationStart === 0) {
                       this._createResultRowHeader(this.searchResults.header);
                   }

                   //Adjust the paddings of the list
                   //When there aren't messages nor keyword tags the paddings should be reduced.
                   if (this.searchResults.hasItems && this.paginationStart === 0) {
                       domClass.remove(this.applicationSearchDiv[0], 'application-search-items-list');
                       domClass.add(this.applicationSearchDiv[0], 'application-search-items-list');
                   }

                   //Check if we need scrollbars
                   //When we have scrollbars, the width of the list and the pagination button need to be adjusted
                   //to fit well on the space we have.
                   var itemsContainer = query('.appSearchItemsOuterContainer', this.applicationSearchDiv[0])[0];
                   if (itemsContainer && itemsContainer.scrollHeight > itemsContainer.clientHeight) {
                       domClass.add(refNode.parentNode, 'hasScrollBars');
                       var moreItemsNode = query(".moreItems", this.applicationSearchDiv[0])[0];
                       if (moreItemsNode) {
                           domStyle.set(moreItemsNode, 'width', rowsContainer.offsetWidth + 'px');
                       }
                   } else {
                       domClass.remove(refNode.parentNode, 'hasScrollBars');
                   }

               },

               /**
                * Create a new Result Row based on its type.
                *
                * @param {object} item - Row Details.
                * @param {object} refNode - DOM Node Reference. The new row will be added after this element.
                * @param {String} type - The type of the row - Values: "Person", "Action" or "Action_Person".
                * @param {boolean} isHistory - Define if it is an history row.
                * @param {boolean} isContextMenu - Context Menu are rows rendered in a separate drop-down list.
                * @private
                */
               _createResultRow : function(item, refNode, type, isHistory, isContextMenu) {
                   if (!item.rendered) {
                       if(isHistory && item.person && item.action) {
                           //These values are not rendered on the screen. No need for internationalization.
                           type = 'Action';
                           item.action.type = 'REQUIRES_PERSON_HISTORY';
                       }
                       var newRow = null;
                       if (type === 'Person') {
                           newRow = this._createPersonRow(item, refNode, type, isHistory, isContextMenu);
                       } else if (type === 'Action') {
                           newRow = this._createActionOnlyRow(item, refNode, isHistory);
                       } else if (type === 'Action_Person') {
                           newRow = this._createPersonActionRow(item, refNode, isHistory, isContextMenu);
                       }
                        
                       if(newRow){
                       	on(newRow, 'blur', lang.hitch(this, function(evt) {
                               this._hideSearchBoxIfNotFocused(evt);
                           }));
                       }
                   }
                   item.rendered = true;
               },

               /**
                * Create a new Person Row.
                *
                * Also call functions to list all related items to the person.
                *
                * @param {object} person - Details of the person.
                * @param {object} refNode - DOM Node Reference. The new row will be added after this element.
                * @param {String} type - The type of the row - Values: "Person", "Action" or "Action_Person".
                * @param {boolean} isHistory - Define if it is an history row.
                * @private
                */
               _createPersonRow : function(person, refNode, type, isHistory) {
                   var itemActiveIndicator = 'active';
                   if (!person.url || person.url.length === 0 || 
                   		person.person.restrictedIndOpt) {
                       itemActiveIndicator = 'inactive'
                   }

                   var isHistoryIndicator = isHistory ? ' appSearchItemHistory ' : '';
                   var newItem = this.paginationStart > 0 ? ' appSearchNewItem ' : '';
                   var isRestrictedPersonClass = person.person.restrictedIndOpt ? ' restrictedPerson ' : '';
                   var nameAriaLabel = isRestrictedPersonClass ? this.bundle.getProperty('SmartNavigator.sensitity.error') : person.person.concernRoleName; 
                   var dobAriaLabel = isRestrictedPersonClass ? '' : person.person.formattedDateOfBirth;
                   var addressAriaLabel = isRestrictedPersonClass ? '' : this.bundle.getProperty('SmartNavigator.address') + ' ' + person.person.formattedAddress;
                   
            	   var content = '<li class="appSearchItem-ListItem person">';
            	   content += '<span tabindex="0" role="button" class="appSearchItem person dijit dijitReset dijitInline dijitLeft' 
                       + 'appBannerComboBox dijitTextBox dijitComboBox dijitValidationTextBox '
                       + itemActiveIndicator
                       + newItem
                       + ' '
                       + isHistoryIndicator
                       + isRestrictedPersonClass
                       + '"'
                       + ' data-concernRole="'
                       + person.person.concernRoleId + '" >';

                   content += '<span class="itemIcon personPhoto" aria-hidden="true">'
                       + '<img draggable="false" alt="Person image" src="' + person.person.personPhotoURL +'" /></span>'  
                       + '<span class="itemDescription">'
                       + '<span class="itemDescFirstLine person" aria-label="' + nameAriaLabel + '" >'
                       + person.person.concernRoleName
                       + '</span>'
                       + '<span class="itemDescSecondLine address" aria-label="' + dobAriaLabel + '">'
                       + person.person.formattedDateOfBirth 
                       + '</span>'
                       + '<span class="itemDescSecondLine address" aria-label="'  
                       + addressAriaLabel + '">'
                       + person.person.formattedAddress
                       + '</span></span>';
                   
                   content += '</span>';
                   content += '</li>'; 

                   var rowNode = domConstruct.toDom(content);
                   if (itemActiveIndicator == 'active') {
                       on(rowNode, ['click', 'keyup'], lang.hitch(this, function(event) {
                           this._onItemClick(event, person, isHistory);
                       }));
                   }
                    
                   on(rowNode, ['keyup'], lang.hitch(this, function(event) {
                       this._onItemKeyNavigation(rowNode, event);
                   }));
                   
                   on(rowNode, ['focus'], lang.hitch(this, function(event) {
                       this._destroyPersonItemsContextMenu(event);
                   }));
                   
                   domConstruct.place(rowNode, refNode, "last");

                   // List all related items to the person
                   if(person.person.items && 
                   		!person.person.restrictedIndOpt){
                   	person.person.items.forEach(function(item, index) {
                           item.person = lang.clone(person.person);
                           item.person.items = [];
                           item.first = (index === 0);
                           item.last = (index === person.person.items.length - 1)
                           this._createResultRow(item, refNode, 'Action_Person', isHistory);
                       }, this);
                   }
                   

                   return rowNode;
               },

               /**
                * Create a new Person Related Item Row.
                *
                * @param {object} item - Person Related Item Details.
                * @param {object} refNode - DOM Node Reference. The new row will be added after this element.
                * @param {boolean} isHistory - Define if it is an history row.
                * @param {boolean} isContextMenu - Context Menu are rows rendered in a separate drop-down list.
                * @private
                */
               _createPersonActionRow : function(item, refNode, isHistory, isContextMenu) {
                   var itemActiveIndicator = 'active';
                   if (!item.url && item.url.length === 0) {
                       itemActiveIndicator = 'inactive'
                   }

                   var first = item.first ? 'first' : '';
                   var last = item.last ? 'last' : '';

                   var historyIndicator = isHistory ? 'appSearchItemHistory' : '';
                   var hide = isContextMenu ? 'contextMenuItem' : 'hide';

                   var content = '<li tabindex="0" role="button" aria-live="assertive" class="appSearchItem appSearchItem-ListItem personAction dijit dijitReset dijitInline dijitLeft'
                       + 'appBannerComboBox dijitTextBox dijitComboBox dijitValidationTextBox  '
                       + hide
                       + ' '
                       + first
                       + ' '
                       + last
                       + ' '
                       + itemActiveIndicator
                       + ' '
                       + historyIndicator + '" ' 
                       //+ 'title="' + item.action.description 
                       + '" >';

                   content += '<div class="personActionItem">';
                   content += '<span class="itemIcon actionPhoto">';

                   if (item.icon) {
                       content += '<img draggable="false" src="' + jsBaseURL + '/' + item.icon + '" alt="Action Icon" />';
                   } else {
                       content += '<span class="actionImage actionEnabled" /></span>';
                   }

                   content += '</span>'
                       + '<span class="itemDescription">'
                       + '<span class="itemDescFirstLine action">'
                       + item.action.description + '</span>'
                       + '</span>';

                   content += '</div>';
                   content += '</li>';

                   var rowNode = domConstruct.toDom(content);
                   if (itemActiveIndicator == 'active') {
                       on(rowNode,['click', 'keyup'], lang.hitch(this, function(event) {
                           this._onItemClick(event, item, isHistory);
                       }));
                   }
                   
                   on(rowNode, ['keyup'], lang.hitch(this, function(event) {
                       this._onItemKeyNavigation(rowNode, event);
                   }));

                   domConstruct.place(rowNode, refNode, "last");
                   return rowNode;
               },

               /**
                * Create a new Row of an item not related to a Person.
                *
                * @param {object} item - Item Details.
                * @param {object} refNode - DOM Node Reference. The new row will be added after this element.
                * @param {boolean} isHistory - Define if it is an history row.
                * @private
                */
               _createActionOnlyRow : function(item, refNode, isHistory) {
                   var itemActiveIndicator = 'active';
                   if (!item.url && item.url.length === 0) {
                       itemActiveIndicator = 'inactive'
                   }

                   var historyIndicator = isHistory ? 'appSearchItemHistory' : '';
                   
                   var title = 'title="';
                   
                   if(item.action.type === 'REQUIRES_PERSON_HISTORY'){
                   	title += item.action.description + ' - ' + item.person.concernRoleName + ' - ' + item.person.formattedDateOfBirth + '"';
                   }else if (item.action.type && item.action.type === 'REQUIRES_PERSON') {
                   	title += item.action.description + '"';
                   }else {
                   	title += item.action.description + '"';
                   }

                   var content = '<li tabindex="0" role="button" class="appSearchItem appSearchItem-ListItem actionOnly dijit dijitReset dijitInline dijitLeft'
                       + 'appBannerComboBox dijitTextBox dijitComboBox dijitValidationTextBox ' 
                       + itemActiveIndicator
                       + ' ' 
                       + historyIndicator + '" ' 
                       //+ title 
                       + '>';

                   if(item.action.type === 'REQUIRES_PERSON_HISTORY'){
                       content += '<span class="itemIcon actionPhoto">';

                       if (item.icon) {
                           content += '<img draggable="false" src="' + jsBaseURL + '/' + item.icon + '" alt="Action Icon" />';
                       } else {
                           content += '<span class="actionImage actionEnabled" /></span>';
                       }

                       content += '</span>'
                           + '<span class="itemDescription">'
                           + '<span class="itemDescFirstLine action">'
                           + item.action.description
                           + '</span>'
                           + '<span class="itemDescSecondLine">'
                           + item.person.concernRoleName
                           + '</span>'
                           + '<span class="itemDescSecondLine">'
                           + item.person.formattedDateOfBirth
                           + '</span>'

                           + '</span>';
                   }else if (item.action.type && item.action.type === 'REQUIRES_PERSON') {
                       content += '<span class="itemIcon actionPhoto">';

                       if (item.icon) {
                           content += '<img draggable="false" src="' + jsBaseURL + '/' + item.icon + '" alt="Action Icon" />';
                       } else {
                           content += '<span class="actionImage actionDisabled" /></span>';
                       }

                       content += '</span>'
                           + '<span class="itemDescription">'
                           + '<span class="itemDescFirstLine action">'
                           + item.action.description
                           + '</span>'
                           + '<span class="itemDescSecondLine infoRequired"> [' +  
                           	this.bundle.getProperty('SmartNavigator.person.required') + 
                           	'] </span>'
                           + '</span>';
                   } else {
                       content += '<span class="itemIcon actionPhoto">';

                       if (item.icon) {
                           content += '<img draggable="false" src="' + jsBaseURL + '/'
                               + item.icon + '" alt="' + 
                               this.bundle.getProperty('SmartNavigator.action.icon') + '" />';
                       } else {
                           content += '<span class="actionImage actionEnabled" /></span>';
                       }

                       content += '</span>'
                           + '<span class="itemDescription">'
                           + '<span class="itemDescSingleLine action">'
                           + item.action.description + '</span>'
                           + '</span>';
                   }

                   content += '</li>';

                   var rowNode = domConstruct.toDom(content);
                   if (itemActiveIndicator == 'active') {
                       on(rowNode, ['click', 'keyup'], lang.hitch(this, function(event) {
                           this._onItemClick(event, item, isHistory);
                       }));
                   }
                   
                   on(rowNode, ['keyup'], lang.hitch(this, function(event) {
                       this._onItemKeyNavigation(rowNode, event);
                   }));
                   on(rowNode, ['focus'], lang.hitch(this, function(event) {
                       this._destroyPersonItemsContextMenu(event);
                   }));

                   domConstruct.place(rowNode, refNode, "last");
                   return rowNode;
               },

               /**
                * Create a button on every person's row item.
                *
                * When the user hovers or clicks on the button, a new drop-down list is displayed
                * containing all the person's items.
                *
                * @private
                */
               _createPersonItemsContextMenuButton : function(){
                   var _self = this; 
                   query('.appSearchItem.person:not(.restrictedPerson):not(.hide)', _self.applicationSearchDiv[0]).forEach(
                       function(item) {
                           if (query('.personItems', item.parentElement).length === 0) {
                        	   
                        	   var noRequirementKeyword = true;
                               _self.searchResults.keywords.forEach(function(keyword) {
                                       if (keyword.type !== "NO_REQUIREMENT") {
                                               noRequirementKeyword = false;
                                       }
                                       
                               });
                               
                               if (noRequirementKeyword) {
                                       return false;
                               }
                               
                        	   var messageProperty = _self.hasIos ? 'SmartNavigator.button.to.toggle.items.ios' :
                        		   'SmartNavigator.button.to.toggle.items'; 

                               //Create the Button in the person's row
                               var personItems = domConstruct.toDom(
                                   '<span tabindex="0" aria-label="' + _self.bundle.getProperty(messageProperty)  
                                   + '" role="button" aria-expanded="false" class="personItems" '
									+ 'data-concernrole="' + item.dataset.concernrole + '">'
									+ '</span>');
                               
                               domConstruct.place(personItems, item, 'after');
                               domClass.add(item, 'hasPersonItemBtn');

                               //Button's OnMouseEnter and OnClick events handler
                               //When hovered/clicked, the person's items drop-down list is displayed.
                               //When clicked, the drop-down list stays opened until the user clicks outside.
                               //When hovered, the drop-down list is destroyed when the mouse is outside the list.
                               on(personItems, [ 'click' ], 
                               		lang.hitch(_self, _self._createPersonItemsContextMenu, item, personItems));
 
                               if(!_self.hasIos){ 
                            	   on(personItems, [ mouse.enter, 'keyup' ], 
                                      		lang.hitch(_self, _self._createPersonItemsContextMenu, item, personItems));
                               }
                               
                               //Destroy if the user hovers outside the person's drop-down list
                               on(personItems, [ mouse.leave ], lang.hitch(_self, _self._destroyPersonItemsContextMenu));
                               on(personItems, [ 'blur' ], function(e) {
                            	   _self._destroyPersonItemsContextMenu(e);
                            	   _self._hideSearchBoxIfNotFocused(e);
                               });
                           }
                       }
                   );
               },

               /**
                *
                * @param event
                * @private
                */
               _createPersonItemsContextMenu : function(item, personItems, event) {
               	   //Accept only Enter or Spacebar keys
                   if(event.type === 'keyup' &&
                       (event.keyCode !== keys.ENTER && event.keyCode !== keys.SPACE)){
                       return
                   }
               	
                   var _self = this;
                   var clickEvent = false; 
                   if (event.type === 'click' || event.type === 'keyup') {
                       clickEvent = true;
                       domClass.add(personItems, 'clicked');
                       event.preventDefault();
                       event.stopPropagation();
                   }
                   
                   //Hide the keywordsList dropdown if it is being displayed
                   if(_self._showingAvailableKeywordsList){
                	   _self._hideAvailableKeywordsList();
                   }

                   //Keep the reference of the current person to check if the user has moved
                   //the mouse to another person's button
                   _self.personInContextMenu = _self.searchResults.people.filter(
                       function(person) {
                           return person.person.concernRoleId === item.dataset.concernrole;
                       }
                   )[0];

                   //Create the drop-down list if it is not present
                   //If there's already a drop-down opened with a mouse click event, do nothing.
                   //If it is an actual clickEvent, the drop-down list is always created.
                   var existingContextMenu = query('.appSearchItemContext', _self.applicationSearchDiv[0])[0];
                   if (!existingContextMenu || !domClass.contains(existingContextMenu, 'clicked') || clickEvent) {
                       domConstruct.destroy(existingContextMenu);
 
                      
                       //If it is a clicked event, the new drop-down should be closed only if the
                       //user clicks outside.
                       if (clickEvent) {
                           query('.personItems.clicked', _self.applicationSearchDiv[0]).forEach(
                               function(personItem) {
                                   if (personItem.dataset.concernrole !==
                                       _self.personInContextMenu.person.concernRoleId) {
                                       domClass.remove(personItem, 'clicked');
                                   }
                               }
                           );
                       }

                       //Create the Drop-down Container
                       var containerRefNode = query('.search-input-controls .text', _self.applicationSearchDiv[0])[0];
                       var itemsContainer = query('.appSearchItemsOuterContainer', _self.applicationSearchDiv[0])[0];
                       var hasScrollsClass = itemsContainer.scrollHeight > itemsContainer.clientHeight ? ' scrollbars ' : '';
                       var clicked = clickEvent ? ' clicked ' : '';
                       var container = domConstruct.toDom('<ul role="status" class="appSearchItemContext'
                           + clicked
                           + hasScrollsClass
                           + '" '
                           + 'style="opacity: 0;" data-concernrole="'
                           + _self.personInContextMenu.person.concernRoleId
                           + '"></ul>');
                       domConstruct.place(container, personItems, 'after');
                       
                       //Set the position to be right next to the person's row.
                       var parentElementPositions = personItems.getBoundingClientRect();
                       domStyle.set(container, 'top', parentElementPositions.top + 'px');
                       var rtlMode = util.isRtlMode(); 
                       if (rtlMode != null) {
                       	domStyle.set(container, 'left', (parentElementPositions.left - 236) + 'px'); 
                       }else {
                       	domStyle.set(container, 'left', (parentElementPositions.left + 40) + 'px');
                       }

                       //Calculate the available screen size and put scrollbars if needed to avoid the drop-down
                       //going off the screen.
                       var screenSize = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                       var listPosition = container.offsetTop;
                       var maxHeight = screenSize - 50 - listPosition;
                       domStyle.set(container, 'max-height', (maxHeight) + 'px');
                       fx.fadeIn({ node : container }).play();

                       //Create the Person Items rows.
                       lang.hitch(_self, _self._createPersonItemsContextMenuRows, _self.personInContextMenu, container)();
                       
                       var containerHeight = domStyle.get(container, 'height');
                       
                       if(containerHeight >= maxHeight){
                    	   domClass.add(container, 'scrollbars');
                       }
                          
                       //Event to keep track of where the mouse/focus is to check if the list should be closed.
                       on(container, [mouse.enter, 'focus' ],
                           function(event) {
                               _self.destroyContextMenu = false;
                           }
                       );
                       
                       //Destroy the container when the mouse/focus leaves the drop-down list.
                       on(container, [mouse.leave, 'blur', 'keyup'], lang.hitch(_self, _self._destroyPersonItemsContextMenu));
                   }

               },

               /**
                *
                * @param event
                * @private
                */
               _destroyPersonItemsContextMenu : function(event) {
               	//Keyup destroys only on ESCAPE keyup.  
            	   if(event.type === 'keyup'){
            		   if(event.keyCode !== keys.ESCAPE &&  
            				   event.keyCode !== keys.LEFT_ARROW && 
            				   event.keyCode !== keys.RIGHT_ARROW){
            			   return;
            		   }
            		   var isRTL = util.isRtlMode();
            		   if(isRTL && event.keyCode === keys.LEFT_ARROW){
            			   return
            		   } else if(!isRTL && event.keyCode === keys.RIGHT_ARROW){
            			   return
            		   }
               		
            		   event.preventDefault();
            		   event.stopPropagation();
            	   }   
               	
                   var _self = this;
                   var itemsToDestroy = query(".appSearchItemContext", _self.applicationSearchDiv[0]);
                   if (itemsToDestroy.length > 0 &&
                       (!domClass.contains(itemsToDestroy[0], 'clicked')) || 
                       	event.type === 'keyup' || event.type === 'focus') {
                	   
                   	   //If pressing ESCAPE or LEFT Arrow, focus back to the person's row.
                	   if(event.type === 'keyup'){
                		   var itemToFocus = null;
                		   query('.appSearchItem').forEach(function(item){
                			   if(item.dataset.concernrole === itemsToDestroy[0].dataset.concernrole){
                				   itemToFocus = item;
                			   }
                		   });
                       	 
                		   if (itemToFocus){
                			   itemToFocus.focus();
                		   }
                	   }
                       
                	   query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(
                			   function(item) {
                				   domClass.remove(item, 'clicked');
                			   }
                	   );
                       
                	   _self.destroyContextMenu = true;
                	   setTimeout(function() {
                           if (_self.destroyContextMenu) {
                               itemsToDestroy.forEach(function(toDestroy) {
                                   fx.fadeOut({
                                       node : toDestroy,
                                       onEnd : function() {
                                           domConstruct.destroy(toDestroy)
                                       }}).play();
                               });
                           }
                       }, 25);
                   }
               },
               
               /**
                * Create the Person Context Menu Items.
                *
                * Person's Items may be lazy loaded. If the items have not been loaded yet,
                * load the items via ajax and then create the rows.
                *
                * @param {object} person - Details of the person.
                * @param {object} container - Context Menu Container Element. The new row will be
                * added inside this element.
                * @private
                */
               _createPersonItemsContextMenuRows : function(person, container){
                   if (person.person.items && 
                   		person.person.items.length > 0) {
                       this._destroyPersonContextSpinningLoader(container);
                       person.person.items.forEach(
                           function(item, index) {
                               item.rendered = false;
                               item.person = lang.clone(person.person);
                               item.person.items = [];
                               item.first = (index === 0);
                               item.last = (index === person.person.items.length - 1)
                               this._createResultRow(item, container, 'Action_Person', false, true);
                           }, this);
                       
                       //iOS only. 
                       //Set the focus to the new items container to support iOS VoiceOver
                       if(this.hasIos){
                    	   container.focus();
                       }
                       
                       //Callback to be overriden
                       if(this.personItemsContextMenuCreationCallback){
                       	this.personItemsContextMenuCreationCallback(container);
                       }
                   } else {
                       if(person.person.itemsLazyLoad){
                           this._createPersonContextSpinningLoader(container);
                           this._loadPeopleItems([person]).then(lang.hitch(this, function(){
                           	this._createPersonItemsContextMenuRows(person, container);
                           }));
                       }else {
                           this._destroyPersonContextSpinningLoader(container);
                           this._createPersonContextNoResultsMessage(container);
                           //Callback to be overriden
                           if(this.personItemsContextMenuCreationCallback){
                           	this.personItemsContextMenuCreationCallback(container);
                           }
                       }
                   }
               },

               /**
                * Add a header to the drop-down list.
                *
                * @param {String} label - The header Title.
                * @param {object} refNode - DOM Node Reference. The new row will be added after this element.
                * @private
                */
               _createResultRowHeader : function(label) {
                   if (label && label.length > 0) {
                   	var refNode = query('.appSearchKeywords', this.applicationSearchDiv[0])[0];
                       var content = '<span class="appSearchItemSeparatorLabel" id="resultRowHeaderId" aria-owns="applicationSearchResultListId" aria-live="assertive">';
                       content += label;
                       content += '</span>';
                       var header = domConstruct.toDom(content);
                       domConstruct.place(header, refNode, "first");
                   }
               },

               /**
                * Display the hidden rows in the drop-down list.
                *
                * When the Result List is created, all the rows are hidden to check
                * whether the result should be displayed as a flat list or just display
                * the people and list the items in a separate context menu.
                *
                * @private
                */
               _showHiddenResultRows : function(){
                   query('.appSearchItem.hide', this.applicationSearchDiv[0]).forEach(
                       function(item) {
                           domClass.remove(item, 'hide');
                       }
                   );
               },

               /**
                * Hide the drop-down list of the quick search.
                *
                * @private
                */
               _hideResultList : function() {
                   query('.appSearchItemsOuterContainer', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, 'display', 'none');
                   });
                   query('.appSearchKeywords', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, 'display', 'none');
                   });
                   
                   if(this._showingAvailableKeywordsList){
                   	this._hideAvailableKeywordsList();
                   }
                   query('.availableKeywordsListContainer', this.applicationSearchDiv[0]).forEach(function(item) {
                       domClass.add(item, 'hide');
                   });
                   query('.appSearchMessage.topMessage', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, 'display', 'none');
                   });

                   query('.moreItems', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, 'display', 'none');
                   });
                   query('.appSearchItemSeparatorLabel', this.applicationSearchDiv[0]).forEach(
                       function(item) {
                           domStyle.set(item, 'display', 'none');
                       }
                   );
                   query('.appSearchItemContext', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(
                       function(item) {
                           domClass.remove(item, 'clicked');
                       }
                   );
               },

               /**
                * Show the drop-down list of the quick search if it is hidden.
                *
                * @private
                */
               _showResultList : function() {
                   var items = query('.appSearchItemsOuterContainer', this.applicationSearchDiv[0]);

                   items.forEach(function(item) {
                       domStyle.set(item, "display", 'block');
                   });

                   if (items.length > 0) {
                       domClass.remove(this.applicationSearchDiv[0], 'application-search-items-list');
                       domClass.add(this.applicationSearchDiv[0], 'application-search-items-list');
                   }

                   query('.appSearchItemSeparatorLabel', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, "display", 'inline-block');
                   });    
                   query('.appSearchKeywords', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, "display", 'block');
                   });
                   query('.appSearchMessage.topMessage', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, "display", 'block');
                   }); 
                   query('.moreItems', this.applicationSearchDiv[0]).forEach(function(item) {
                       domStyle.set(item, "display", 'block');
                   });
                   
                   this._updateSearchResultsScreenReadersInfo(); 

               },

               /**
                * Create the More Records button and add it to the drop-down list.
                *
                * @param {object} refNode - DOM Node Reference. The new row
                * will be added after this element.
                * @returns {object} The MoreRecords Button DOM Element.
                * @private
                */
               _createMoreRecordsRow : function(refNode) {
            	   query('.paginationContainer', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
               	                	
                   var content = '<div role="button" tabindex="0" class="moreItems" aria-label="' + this.bundle.getProperty('SmartNavigator.more.results') 
                   + '">' + this.bundle.getProperty('SmartNavigator.more.results') + '</div>';
                   
                   var container = domConstruct.toDom('<div class="paginationContainer" role="application"></div>');
                   var rowNode = domConstruct.toDom(content);
                    
                   on(rowNode, 'blur', lang.hitch(this, function(evt) {
                       this._hideSearchBoxIfNotFocused(evt);
                   }));
                   
                   on(rowNode, ['focus'], lang.hitch(this, function(event) {
                       this._destroyPersonItemsContextMenu(event);
                   }));

                   on(rowNode, ['click', 'keyup'], lang.hitch(this,function(event) {
                   	var keyEvent = event.type === 'keyup';
                       //Accept only Enter or Spacebar keys
                       if(keyEvent &&
                           (event.keyCode !== keys.ENTER && event.keyCode !== keys.SPACE)){
                           this._onItemKeyNavigation(rowNode, event);  
                           return
                       }
                       
                       this.paginationStart += 6;
                       this._renderResults(keyEvent);
                       
                       //Set the focus back to the field if the user is using the mouse/touch.
                       if(!keyEvent){
                       	this.searchInputField.focus();
                       }
                       
                       event.preventDefault();
                       event.stopPropagation();
                   }));

                   domConstruct.place(container, refNode, "after");
                   return domConstruct.place(rowNode, container, "first");
               },
               
               _createKeywordTagsContainer : function(){
                   var keywordsSection = domConstruct.toDom('<div class="appSearchKeywords" role="application" aria-live="assertive"></div>'); 
                   
                   var comboboxPresentRefNode = this.appBannerComboBoxDiv[0];
                   
                   if(comboboxPresentRefNode){
                   	domConstruct.place(keywordsSection, comboboxPresentRefNode, "before");
                   }else {
                   	domConstruct.place(keywordsSection, this.searchIconDiv[0], "after");
                   }
                   
                   //Available Keywords Button
                   var displayListClass = this._showingAvailableKeywordsList ? 'itemsDisplayed' : '';
                   var availableKeywordsBtn = domConstruct.toDom(
                   		'<span role="button" title="'+this.bundle.getProperty('SmartNavigator.keywords.info')+'" aria-label="' + this.bundle.getProperty('SmartNavigator.keywords.info') 
                   		+ '" tabindex="0" class="appSearchKeywordsListButton ' + displayListClass + '">' 
                   		+ this.bundle.getProperty('SmartNavigator.keywords') + '</span>');
                   domConstruct.place(availableKeywordsBtn, keywordsSection, "first");
                   on(availableKeywordsBtn, ['click', 'keyup'], lang.hitch(this, this._onAvailableKeywordsListButtonClick, keywordsSection));
                   on(availableKeywordsBtn, 'keydown', lang.hitch(this, this._onKeywordsDownArrowKey));
                   
                   on(availableKeywordsBtn, 'blur', lang.hitch(this, function(evt) {
                       this._hideSearchBoxIfNotFocused(evt);
                   }));
                   
                   //Search results counter for screen readers
                   if(!this.searchResultsScreenReadersInfo){
                	   this.searchResultsScreenReadersInfo = domConstruct.toDom('<span class="searchResultsScreenReadersInfo hidden" id="searchResultsScreenReadersInfoId"></span>');
                       domConstruct.place(this.searchResultsScreenReadersInfo, keywordsSection, "last");
                   }
                   
                   
                   this._fixQuickSearchHeight();
               },
               
               /**
                * Hidden field to be read by the screen readers.
                * 
                * It should display the number of items being listed.
                */
               _updateSearchResultsScreenReadersInfo : function(){
            	   if(!this.searchResultsScreenReadersInfo){
            		   this.searchResultsScreenReadersInfo = query('.searchResultsScreenReadersInfo', this.applicationSearchDiv[0])[0];
            	   }
            	   
            	   var numberOfItemsListed = query('.appSearchItem:not(.hide)').length;
            	   
            	   if(this._isShowingHistory()){
            		   
            		   this.searchResultsScreenReadersInfo.innerHTML = this.bundle.getProperty('SmartNavigator.rows.displayed.recent.search', [numberOfItemsListed]);
            	   }else {
            		   this.searchResultsScreenReadersInfo.innerHTML = this.bundle.getProperty('SmartNavigator.rows.displayed', [numberOfItemsListed]);
            	   } 
            	   
               },
               
               _destroyKeywordTagsContainer : function(){
            	   query('.appSearchKeywords', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
            	   this._hideAvailableKeywordsList();
               },

               /**
                * Add a new keyword tag.
                *
                * If there are multiple keyword tags already, the width is checked
                * to see if there's enough space for a new keyword.
                *
                * When there's no space for more tags, they're grouped in a drop-down list
                *
                * Onclick event on tags to destroy itself and delete its related text from the
                * input search criteria.
                *
                * @param keywords
                * @param personQueryTerms
                * @private
                */
               _createKeywordTags : function(keywords, personQueryTerms) {
                   var tagElements = [];
                   var hideTags = false;

                   var keywordsSection = query('.appSearchKeywords', this.applicationSearchDiv[0])[0];
                   var availableKeywordsBtn = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
                   
                   //Max Tags Width Value
                   //Max Width = Row Width (240) - (More Keywords link width)
                   //12 = More Keywords link Expanded Tab Border Size
                   var moreKeywordsBtnTabBordersSize = 12;
                   if(domClass.contains(availableKeywordsBtn, 'itemsDisplayed')){
                   	moreKeywordsBtnTabBordersSize = 0;
                   }
                   var maxWidth = 240 - (availableKeywordsBtn.offsetWidth + moreKeywordsBtnTabBordersSize) ;  
                   
                   if (keywords.length > 0) {
                   	
                   	var keywordsContainer = domConstruct.toDom('<span class="appSearchKeywordsContainer"></span>');
                       domConstruct.place(keywordsContainer, keywordsSection, "last");
                   	
                       keywords.forEach(lang.hitch(this,
                           function(keyword, index, array) {
                               var tagsWidth = query('.appSearchKeywordTag', this.applicationSearchDiv[0]).reduce(
                                   function(width, tag) {
                                       width += parseInt(domStyle.getComputedStyle(tag).width) + 22;
                                       return width;
                                   }, 0);

                               var lastItem = (index === array.length - 1);
                               
                               var tagContent = '<span tabindex="0" role="button" aria-label="' + 
                               this.bundle.getProperty('SmartNavigator.keyword.identified', [keyword.description]) + 
                               '" aria-owns="applicationSearchResultListId" aria-live="assertive" class="appSearchKeywordTag hidden ' + (lastItem ? 'last' : '') + '" ';
                               
                               tagContent += 'data-terms="' + keyword.terms + '" ';
                               tagContent += '>';
                               tagContent += keyword.description;
                               tagContent += '</span>';

                               var tag = domConstruct.toDom(tagContent);
                               domConstruct.place(tag, keywordsContainer, "last");
                               var tagWidth = parseInt(domStyle.getComputedStyle(tag).width);

                               if (tagsWidth + tagWidth > maxWidth) {
                                   hideTags = true;
                               }
                               domStyle.set(keywordsContainer, 'maxWidth', maxWidth + 'px'); 

                               tagElements.push(tag);

                               //Onclick Event - Destroy the tag and
                               //delete its related text from the input search criteria.
                               on(tag, 'click', lang.hitch(this, function(event){
								this._destroyKeywordTag(personQueryTerms, event, true);
								this.searchInputField.focus();
                               	
                               }));
                               on(tag, 'keyup', lang.hitch(this, function(event) {
                               	if(event.keyCode === keys.ENTER || event.keyCode === keys.SPACE){
                               		this._destroyKeywordTag(personQueryTerms, event, true);
                                   	this.searchInputField.focus();
                               	}
                               	this._onItemKeyNavigation(tag, event);
                               }));
                               
                               
                           })
                       ); 

                       tagElements.forEach(function(tag) {
                           domClass.remove(tag, 'hidden');
                       });
                   }
               },

               /**
				 * Tag's Onclick Event - Destroy the tag and
                * delete its related text from the input search criteria.
				 *
                * @param event
                * @private
                */
				_destroyKeywordTag : function(personQueryTerms, event, stopEvent, keywordTerms) {
                   if(event.type === 'keyup' && 
                       (event.keyCode !== keys.ENTER && event.keyCode !== keys.SPACE)){
                       return
                   }
                   
                   if(stopEvent){
	                	event.preventDefault();
	                    event.stopPropagation();
                   }
                   
                   var terms = keywordTerms || event.target.dataset.terms;
                   var sanitizedTerm = terms.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); 
                   var expression = '(\\b)*(' + sanitizedTerm + ')+(\\b)*(\\s)*';
                   var inputValue = this.searchInputField.value;

                   if (personQueryTerms.length > 0) {
                       var values = inputValue.split(personQueryTerms[0]);
                       var init = values[0].replace(new RegExp(expression), '');
                       var end = '';

                       if (values.length > 0) {
                           end = values.slice(1).join('').replace(new RegExp(expression), '');
                       }

                       this.searchInputField.value = (init + personQueryTerms[0] + end).trim();
                   } else {
                       this.searchInputField.value = (inputValue.replace(new RegExp(expression), '')).trim();
                   }
                   
                   if (this.searchInputField.value) {
                	   this._doQuickSearch(this.searchInputField.value);
                   }
               },
               
               /**
			   * Onlick event for the Keywords button.
			   * 
			   * Display a list of all the available keywords
			   *
			   * @param keywordsSection
               * @param event
               * @param neverHide
               * @private
               */
               _onAvailableKeywordsListButtonClick : function(keywordsSection, event, neverHide){
            	   if(event.type === 'keyup' && 
            			   (event.keyCode !== keys.ENTER && event.keyCode !== keys.SPACE)){
            		   return
            	   }
            	   
            	   event.preventDefault();
                   event.stopPropagation();
                   
                   //Close any person context menu if theres one open
                   this._destroyVisibleContextMenu();
                   
                   if(this._showingAvailableKeywordsList && !neverHide){
                	   this._hideAvailableKeywordsList();
                   }else {
                	   if(!this.availableKeywordsList){
                		   var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'listSearchTargets');
                		   this.quickSearchXHRPromises.push(promise);
                		   promise.then( 
                				   // Success Callback
                				   lang.hitch(this, function(data){
                					   this.availableKeywordsList = data[0].dtls;
                					   this._showingAvailableKeywordsList = true;
                					   this._createAvailableKeywordsList(keywordsSection, event.target);
                					   domClass.add(query('.appSearchKeywordsListButton', 
                							   this.applicationSearchDiv[0])[0], 'itemsDisplayed');
                					   this._voiceOverFocusOnFirstKeyword();
                					   
                				   }),  
                				   // Error Callback
                				   lang.hitch(this, this._ajaxErrorCallback));
                	   }else {
                		   this._showAvailableKeywordsList();
                		   this._voiceOverFocusOnFirstKeyword(); 
                	   }
                	   
                   }
               },
               
               /**
 			    * Set the focus to the first available keyword if using an ios device.
                * @private
                */
               _voiceOverFocusOnFirstKeyword : function(){
            	   if(this.hasIos){
        			   keywordTerm = query('.keywordTerm', this.applicationSearchDiv[0])[0];
        			   setTimeout(function(){
        				   keywordTerm.focus();    
        			   }, 400);
            	   }
               },
               
               _createAvailableKeywordsList : function(keywordsSection, keywordsButton){ 
            	   //Main container wider to support the scrollbars
            	   if(!keywordsSection){
            		   keywordsSection = query('.appSearchKeywords', this.applicationSearchDiv[0])[0];
            	   } 
            	   var keywordsListContainer = domConstruct.toDom('<div class="availableKeywordsListContainer"></div>'); 
            	   domConstruct.place(keywordsListContainer, keywordsSection, 'last');
            	    
            	   //If using ios, remove aria-live to support voiceOver
            	   //Otherwise, use aria-live to support JAWS 
            	   var ariaKeywordsListContainer = this.hasIos ? 'aria-hidden=true' : ' aria-live="assertive" ';
            	   
            	   var keywordsListScreenReaderDescription = domConstruct.toDom('<div class="hidden availableKeywordsListDescription" ' + ariaKeywordsListContainer + ' >'
            			   + this.bundle.getProperty('SmartNavigator.keywords.list.description') + '</div>');
            	   domConstruct.place(keywordsListScreenReaderDescription, keywordsListContainer, 'last');
               	
            	   //Set the position to be right next to the person's row.
            	   this._setKeywordsListPosition(keywordsButton, keywordsListContainer);
               	
               	   //Inner container less wide, holding the list with a different background color.
            	   var keywordsListInnerContainer = domConstruct.toDom('<div class="availableKeywordsListInnerContainer"></div>'); 
            	   domConstruct.place(keywordsListInnerContainer, keywordsListContainer, 'last');
               	
               	   //Header
            	   this.availableKeywordsList.forEach(function(keywordItem){
            		   var keywordContainer = domConstruct.toDom('<div class="availableKeyword"></div>');
            		   var keywordTarget = domConstruct.toDom('<span class="keywordTarget" >' + keywordItem.description  + '</span>');
            		   var keywordTerms = domConstruct.toDom('<span class="keywordTerms"></span>');
               			
            		   keywordItem.terms.split(',').forEach(function(term, index, array){
            			   //Decode special characters encoded by the CDSL Infrastructure
            			   var decodedTerm = domConstruct.toDom('<pre>' + term  + '</pre>').innerHTML;

            			   var newLineHTML = (index === array.length - 1) ? '' : ', <br />'; 
            			   var termElement = domConstruct.toDom('<li class="keywordTerm" role="button" aria-label="' +  
            					   this.bundle.getProperty('SmartNavigator.available.keyword', [decodedTerm, keywordItem.description]) +
            					   '" tabindex="0">' + decodedTerm + newLineHTML + '</li>');
            			   on(termElement, ['click', 'keyup'], lang.hitch(this, function(evt){
            				   if(evt.type === 'keyup' && 
            						   (evt.keyCode !== keys.ENTER && evt.keyCode !== keys.SPACE)){
            					   return
            				   }
            				   this.searchInputField.value = this.searchInputField.value.trim() + ' ' + decodedTerm; 
            				   this.searchInputField.focus();
            				   this._hideAvailableKeywordsList();
            				   this._doQuickSearch(this.searchInputField.value);
            			   })); 
            			   
            			   on(termElement, 'keydown', lang.hitch(this, function(event){
            				   this._onKeywordsDownArrowKey(event);
            				   this._onKeywordsUpArrowKey(event);
            			   }));
            			   on(termElement, 'blur', lang.hitch(this, this._hideKeywordsOnBlur));
            			   domConstruct.place(termElement, keywordTerms, 'last');
               		}, this);
               		
               		domConstruct.place(keywordTarget, keywordContainer, 'first');
               		domConstruct.place(keywordTerms, keywordContainer, 'last');
                   	domConstruct.place(keywordContainer, keywordsListInnerContainer, 'last');
               	}, this);
               	
            	   on(keywordsListContainer, 'blur', lang.hitch(this, this._hideKeywordsOnBlur));
            	   return keywordsListContainer;
               },
               
               _setKeywordsListPosition : function(keywordsButton, keywordsListContainer){
            	   //Set the position to be right next to the person's row.
            	   var parentElementPositions = keywordsButton.getBoundingClientRect();
            	   domStyle.set(keywordsListContainer, 'top', (parentElementPositions.top + 10) + 'px');
            	   var rtlMode = util.isRtlMode(); 
            	   if (rtlMode != null) {
            		   domStyle.set(keywordsListContainer, 'left', 65 + 'px'); 
            	   }else {
            		   domStyle.set(keywordsListContainer, 'left', (parentElementPositions.left + 65) + 'px');
            	   }
               },
               
               _hideKeywordsOnBlur : function(event){
            	   if (event.relatedTarget && 
            			   !this._isElementPartOfContainer(event.relatedTarget, 'availableKeywordsListContainer')) {
            		   var button = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
                	   if(button){
                		   button.focus();
                	   } 
            		   this._hideAvailableKeywordsList();
            	   }
               },
               
               _hideAvailableKeywordsList : function(){
            	   var container = query('.availableKeywordsListContainer', this.applicationSearchDiv[0])[0];
            	   if(container){
            		   domClass.add(container, 'hide');
            	   }
               	
            	   var button = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
            	   if(button){
            		   domClass.remove(button, 'itemsDisplayed');
            	   }
               	
            	   this._showingAvailableKeywordsList = false;
            	   this._fixQuickSearchHeight();
               },
               
               _showAvailableKeywordsList  : function(){ 
            	   var keywordsListContainer = query('.availableKeywordsListContainer', this.applicationSearchDiv[0])[0];
            	   var keywordsListButton = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
            	   if(!keywordsListContainer){
            		   keywordsListContainer = this._createAvailableKeywordsList(null, keywordsListButton);
            	   }
				
            	   this._setKeywordsListPosition(keywordsListButton, keywordsListContainer);
            	   domClass.remove(keywordsListContainer, 'hide');
            	   domClass.add(keywordsListButton, 'itemsDisplayed'); 
            	   
            	   //Force the description to be read again by screen readers.
            	   var keywordsListDescription = query('.availableKeywordsListDescription', this.applicationSearchDiv[0])[0];
            	   if(keywordsListDescription){
            		   keywordsListDescription.innerHTML = keywordsListDescription.innerHTML; 
            	   }
				 
            	   this._showingAvailableKeywordsList = true;
            	   this._fixQuickSearchHeight();
               },
               
               /**
                * Check if there's any message to be displayed.
                *
                * @private
                */
               _createMessages : function(){
                   var message = '';
                   var messageElement = null;

                   if(this.searchResults.messages.info){
                   	message = this.searchResults.messages.info;
					}else if(this.searchResults.messages.unmapped.pages.length > 0){
                       message = this.bundle.getProperty('SmartNavigator.no.tabs.configured',
                           [this.searchResults.messages.unmapped.pages.join()]);
                   }else if (this.searchResults.messages.moreThanOneTab.pages.length > 0){
                       message = this.bundle.getProperty('SmartNavigator.more.than.one.tab',
                           [this.searchResults.messages.moreThanOneTab.pages.join()]);
                   }

                   if(message.length > 0){
                       messageElement = this._createMessage(message, true);
                   }
                   
                   return messageElement;
               },

               /**
                * Add a message to the top of the search results drop-down list.
                *
                * @param {String} message
                * @param {boolean} infoMessage - True = info, False = Error
                * @param {boolean} noFocus - True, do not set the focus on the new msg
                * @returns {object} The message's DOM element.
                * @private
                */
               _createMessage : function(message, infoMessage, noFocus){
                   query('.appSearchMessage.topMessage',
                       this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   var hasKeywords = false;
                   if(this.searchResults &&
                       this.searchResults.keywords &&
                       this.searchResults.keywords.length > 0){
                       hasKeywords = true;
                   }

                   var messageType = infoMessage ? ' info ' : ' error ';
                   var messageElement = domConstruct.toDom(
                       "<div role='alert' class='appSearchMessage topMessage " + messageType + "'><span>" +
                       message + 
                       "</span></div>");

                   var nodeRef = query('.appSearchKeywords', this.applicationSearchDiv[0])[0];
                   domConstruct.place(messageElement, nodeRef, "after");

                   on(messageElement, 'blur', lang.hitch(this, function(evt) {
                       this._hideSearchBoxIfNotFocused(evt);
                   }));
                   on(messageElement, ['keyup'], lang.hitch(this, function(event) {
                       this._onItemKeyNavigation(messageElement, event);
                   }));
                   
                   return messageElement;
               },

               /**
                * Check if the user has the destination page configured to a tab.
                *
                * Messages are added to the searchResults when the user doesn't have
                * a proper tab configured to open the URL.
                *
                * Note: The check is done by making an async request to the server.
                * Different Callbacks are called when the user does or doesn't have access.
                *
                * @see this._pageNotMappedToTabErrorCallback
                * @see this._pageMappedToMoreThanOneTabErrorCallback
                * @see this._pageMappedToTabCallback
                *
                * @param {String} url The destination URL.
                * @param {String} page The destination Page description
                *
                * @private
                */
               _isPageMappedToATab : function(url, page, preferredTabs){
                   var deferred = new Deferred();

                   var result = { isMapped : true };

                   var pageRequest = new curam.ui.PageRequest(url);

                   var tabUnmappedCB = lang.hitch(this, this._pageNotMappedToTabErrorCallback,
                       pageRequest.pageID, result, deferred, page);
                   var moreThanOneTabCB = lang.hitch(this, this._pageMappedToMoreThanOneTabErrorCallback,
                       pageRequest.pageID, result, deferred, page);
                   var pageMappedToTabCB = lang.hitch(this, this._pageMappedToTabCallback,
                       pageRequest.pageID, result, deferred);

                   if(arrayUtil.indexOf(this.pagesMappedToTab, pageRequest.pageID) >= 0){
                       pageMappedToTabCB();
                   }else if(arrayUtil.indexOf(this.pagesNotMappedToTab, pageRequest.pageID) >= 0){
                       tabUnmappedCB();
                   }else if(arrayUtil.indexOf(this.pagesMappedToMultipleTabs, pageRequest.pageID) >= 0){
                       moreThanOneTabCB();
                   }else {
                	   var pagePreferredTabs = null;
                	   if(preferredTabs) {
                		   pagePreferredTabs = preferredTabs.split(',').map(function(preferredTab) {
        					   return preferredTab.trim();
        				   });
        			   }

                       var isResolvePage = !curam.ui.UIController.checkResolvePage(
                           pageRequest, pageRequest.forceRefresh, tabUnmappedCB, pagePreferredTabs,
                           moreThanOneTabCB, false, pageMappedToTabCB);

                       if (!isResolvePage) {   
                    	   var callbacks  = {  
                    			   unmappedPageLoader : tabUnmappedCB, 
                    			   preferredTabs : pagePreferredTabs,
                    			   moreThanOneTabMappedCallback : moreThanOneTabCB,
                    			   shouldLoadPage : false, 
                    			   successCallback : pageMappedToTabCB};
                           curam.ui.UIController.checkPage(pageRequest, callbacks);
                       }

                   }

                   return deferred;
               },

               /**
                * Callback called by the function _isPageMappedToATab when the user doesn't have access to the url.
                *
                * Adds an error message to the searchResults.messages object.
                *
                * @param {String} pageID The UIM that the user is trying to access.
                * @param {object} result The results of the check validation.
                * @param {object} deferred The promise initiated in the function _isPageMappedToATab to be resolved.
                * @param {String} page The destination Page description
                * @private
                */
               _pageNotMappedToTabErrorCallback : function(pageID, result, deferred, page){
                   result.isMapped = false;

                   //Cache
                   if(arrayUtil.indexOf(this.pagesNotMappedToTab, pageID) < 0){
                       this.pagesNotMappedToTab.push(pageID);
                   }

                   //Add error message
                   if(arrayUtil.indexOf(this.searchResults.messages.unmapped.pages, page) < 0){
                       this.searchResults.messages.unmapped.pages.push(page);
                   }

                   deferred.resolve(result);
               },

               /**
                * Callback called by the function _isPageMappedToATab when the user has more than one tab
                * configured to the same page. The infrastructure doesn't know which tab to open.
                *
                * Adds an error message to the searchResults.messages object.
                *
                * @param {String} pageID The UIM that the user is trying to access.
                * @param {object} result The results of the check validation.
                * @param {object} deferred The promise initiated in the function _isPageMappedToATab to be resolved.
                * @param {String} page The destination Page description
                * @private
                */
               _pageMappedToMoreThanOneTabErrorCallback : function(pageID, result, deferred, page){
                   result.isMapped = false;

                   //Cache
                   if(arrayUtil.indexOf(this.pagesMappedToMultipleTabs, pageID) < 0){
                       this.pagesMappedToMultipleTabs.push(pageID);
                   }

                   //Add error message
                   if(arrayUtil.indexOf(this.searchResults.messages.moreThanOneTab.pages, page) < 0){
                       this.searchResults.messages.moreThanOneTab.pages.push(page);
                   }

                   deferred.resolve(result);
               },

               /**
                * Callback called by the function _isPageMappedToATab when the user does have
                * a tab configured to open the UIM.
                *
                * Adds an error message to the searchResults.messages object.
                *
                * @param {String} pageID The UIM that the user is trying to access.
                * @param {object} result The results of the check validation.
                * @param {object} deferred The promise initiated in the function _isPageMappedToATab to be resolved.
                * @private
                */
               _pageMappedToTabCallback : function(pageID, result, deferred){
                   result.isMapped = true;

                   //Cache
                   if(arrayUtil.indexOf(this.pagesMappedToTab, pageID) < 0){
                       this.pagesMappedToTab.push(pageID);
                   }

                   deferred.resolve(result);
               },

               /**
                * Add a message to the person's context menu when no items were found.
                *
                * @param {object} parentNode - Context Menu Container DOM Element.
                * @private
                */
               _createPersonContextNoResultsMessage : function(parentNode){
                   var noResultsRow = domConstruct.toDom( 
                       "<div class='appSearchMessage info' tabIndex='0'><span>" +
                       this.bundle.getProperty('SmartNavigator.empty.search') +
                       "</span></div>");

                   domConstruct.place(noResultsRow, parentNode, "last");
               },

               /**
                * Create a Spinner Loader in the Context Menu Drop-down while the items are being loaded.
                *
                * @param {object} parentNode - Context Menu Container DOM Element.
                * @private
                */
               _createPersonContextSpinningLoader : function(parentNode){
                   var spinner = domConstruct.toDom('<div class="contextMenuLoader">' +
                       '<div class="curam-spinner curam-h1 quick-search contextMenu"></div></div>');
                   domConstruct.place(spinner, parentNode, "last");
               },

               /**
                * Destroy Spinner Loader from the Context Menu Drop-down after the server response.
                *
                * @param {object} parentNode - Context Menu Container DOM Element.
                * @private
                */
               _destroyPersonContextSpinningLoader : function(parentNode) {
                   query('.contextMenuLoader', parentNode).forEach(domConstruct.destroy);
               },

               /**
                * Destroy the context menu only if the user has clicked outside the context menu drop-down.
                *
                * @param target - DOM Element the user clicked.
                * @return boolean - Indicator if it has been destroyed.
                * @private
                */
               _destroyContextMenuIfNecessary : function(target) {
            	   var destroyed = false;
            	   var container = query('.appSearchItemContext', this.applicationSearchDiv[0]);
            	   if (container.length > 0) {
            		   if (!this._isElementPartOfContainer(target, 'appSearchItemContext')) {
            			   
            			   //Set the focus on the clicked element.
            			   //If the clicked element is not focusable, set focus on the input field.
            			   if(this._isElementPartOfContainer(target, 'application-search')){
            				   if(target.tabIndex === 0){ 
            					   target.focus();
            				   }else {
            					   this.searchInputField.focus();
            				   }
            			   }
            			   
            			   this._destroyVisibleContextMenu(container);
            			   destroyed = true;
            		   }
            	   }
                   
                   return destroyed;
               },
               
               _destroyVisibleContextMenu : function(container){
            	   if(!container){
            		   container = query('.appSearchItemContext', this.applicationSearchDiv[0]);
            	   }
            	   if (container.length > 0) {
	            	   query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(function(personItem) {
	    				   if (personItem.dataset.concernrole === container[0].dataset.concernrole) {
	    					   domClass.remove(personItem, 'clicked');
	    				   }
	    			   });
	    			   domConstruct.destroy(container[0]);
            	   }
               },
               
               /**
                * Hide the Keywords Info Details only if the user has clicked outside the context menu drop-down.
                *
                * @param target - DOM Element the user clicked.
                * @return boolean - Indicator if it has been hid.
                * @private
                */
               _hideKeywordsListIfNecessary : function(target, escPressed) {
            	   var hidden = false;
            	   var container = query('.availableKeywordsListContainer:not(.hide)', this.applicationSearchDiv[0]);
            	   
                   if (container.length > 0) {
                	   if (escPressed || 
                			   !this._isElementPartOfContainer(target, 'availableKeywordsListContainer')) {
                     	   this._hideAvailableKeywordsList();
                         hidden = true;
                	   }
                	   
                	   if(escPressed){
                    	   var button = query('.appSearchKeywordsListButton', this.applicationSearchDiv[0])[0];
                    	   if(button){
                    		   button.focus();
                    	   }
                       }
                   }
                   
                   return hidden;
               },

               /**
                * Recursively check if the element is the container
                * or if it is a child of the container.
                *
                * @param {object} element - DOM Element to be checked.
                * @param {String} containerName - Container CSS Class name
                * @returns {boolean}
                * @private
                */
               _isElementPartOfContainer : function(element, containerName) {
                   if (element.parentElement != null) {
                       if (domClass.contains(element, containerName)) {
                           return true;
                       } else {
                           return this._isElementPartOfContainer(element.parentElement, containerName);
                       }
                   }
                   return false;
               },

               /**
                * Quick Search Row OnClick Event.
                *
                * -Redirect the user to the Item's related page.
                *
                * -Save the item to the Search History.
                *
                * -Hide the Drop-down list after the redirect.
                *
                * Checks:
                * 1-If the user has a tab configured to open the page before redirect.
                * 2-If the user has more than one tab configured to the same page, check if
                * the preferred tab attribute is set. If there's no preferred tab, a message is shown
                * and the user is not redirected.
                *
                * @param {object} event - OnClick event object.
                * @param {object} item - Item clicked to be saved on the search history.
                * @param {boolean} isHistory
                * @private
                */
               _onItemClick : function(event, item, isHistory) {                	
               	//Accept only Enter or Spacebar keys
               	if(event.type === 'keyup' && 
               			(event.keyCode !== keys.ENTER && 
           					event.keyCode !== keys.SPACE)){
               		return
               	}                    
                   event.preventDefault();
                   event.stopPropagation();

                   var description = null;
                   if(item.action) {
                       description = item.action.description;
                   } else if (item.person) { 
                       description = item.person.concernRoleName;
                   }

                   this._resetSearchMessages();
                   item.url = item.url.replace(/&#38;/g, '&');
                   
                   if(item.isModal){
                   	this._openLinkAndSaveHistory(event, item, isHistory, true);
                   }else {
                   	 this._isPageMappedToATab(item.url, description, item.preferredTabs).then(lang.hitch(this, function(pageMapping){
                   		 this._openLinkAndSaveHistory(event, item, isHistory, false, pageMapping);
                        }));
                   }
                  
               },

               /**
                * Opens the selected link, saves the details to history and hides the drop-down.
                * 
                *  This function also allows an optional custom hook implementation to run
                *  before redirecting. The hook is invoked where SearchMultipleTextBoxHookPoints.preNavigationHook
                *  has been defined. The function subscribes to /smartnavigator/prenavigationhook/completed and
                *  completes on receipt of message by calling _openLinkAndSaveHistoryPostHook. Where the hook
                *  has not been defined then we call directly to _openLinkAndSaveHistoryPostHook.
                *
                * -Redirect the user to the Item's related page.
                *
                * -Save the item to the Search History.
                *
                * -Hide the Drop-down list after the redirect.
                *
                * Checks:
                * 1-If the user has a tab configured to open the page before redirect.
                * 2-If the user has more than one tab configured to the same page, check if
                * the preferred tab attribute is set. If there's no preferred tab, a message is shown
                * and the user is not redirected.
                *
                * @param {object} event - OnClick event object.
                * @param {object} item - Item clicked to be saved on the search history.
                * @param {boolean} isHistory
                * @param {boolean} isModal
                * @param {object} pageMapping
                * @private
                */
               _openLinkAndSaveHistory : function(event, item, isHistory, isModal, pageMapping){
                	
            	 //Destroy the Context Menu if present.
            	 query('.appSearchItemContext', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
				
				 //Redirect the User only if he has a tab configured.
				 var mappedToMoreThanOneTab = this.searchResults.messages.moreThanOneTab.pages.length > 0;
				 if(isModal ||
				   (pageMapping && pageMapping.isMapped) ||
				   (mappedToMoreThanOneTab && item.preferredTabs)){
					   
					   this._hideSearchBox();
					   
                       require(["curam/widget/SearchMultipleTextBoxHookPoints"], lang.hitch(this, function(customHookImpl) {
				   
                       // Hook implementation is optional
                       if (customHookImpl.preNavigationHook){
						
                       // Call to custom hook and only proceed to page nagivation on receipt of completion message
                       var handle = topic.subscribe('/smartnavigator/prenavigationhook/completed', lang.hitch(this,function(){
                         this._openLinkAndSaveHistoryPostHook(event, item, isHistory, isModal, pageMapping);
                           handle.remove();
                         }));
						
                         var data = {url: item.url};
                         if (item.person) {
                           data.concernRoleId = item.person.concernRoleId;
                         }
                         customHookImpl.preNavigationHook(data);
						     
                         } else {
							  
                           // No custom hook impomentation so just continue straight to navigation
                           this._openLinkAndSaveHistoryPostHook(event, item, isHistory, isModal, pageMapping);
                         }
                       })); // end require SearchMultipleTextBoxHookPoints
					 
				   }else {
                     var messageElement = this._createMessages();
                     if(messageElement){
                       messageElement.focus(); 
                     }
                     this._fixQuickSearchHeight();
                   } 
				   
                   //Remove the focus from the personItems
                   query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(function(item) {
                   domClass.remove(item,'clicked');
                 });
               	
               },

               /**
                * Private function provided for _openLinkAndSaveHistory to factor out the common logic
                * that is to be called either after the preNavigationHook completes, or directly if
                * the preNavigationHook has not been defined. See _openLinkAndSaveHistory for details
                *
                * @param {object} event - OnClick event object.
                * @param {object} item - Item clicked to be saved on the search history.
                * @param {boolean} isHistory
                * @param {boolean} isModal
                * @param {object} pageMapping
                * @private
                */
               _openLinkAndSaveHistoryPostHook : function(event, item, isHistory, isModal, pageMapping){
               if(isModal){
    			   tab.getTabController().handleLinkClick(item.url, {});
    		   }else {
    			   var preferredTabs = null;
    			   if(item.preferredTabs) {
    				   preferredTabs = item.preferredTabs.split(',').map(function(preferredTab) {
    					   return preferredTab.trim();
    				   });
    			   }
    			   var uimPageRequest = new curam.ui.PageRequest(item.url);
    			   curam.ui.UIController.handlePageRequest(uimPageRequest, preferredTabs);
    		   }
               
    		   if(!isHistory){
               	
    		   /**
               	 * SimpleAccess Api doesnt accept null attributes.
               	 * We need to delete all null attributes. Take care
               	 * to clone to prevent impacting the original items
               	 * that may be used again to construct the search
               	 * results.
               	 */
    			   var historyItem = lang.clone(item);
    			   delete historyItem.rendered; 
    			   delete historyItem.first; 
    			   delete historyItem.last;
               	
    			   if(!historyItem.action){
    				   delete historyItem.action;
    			   }
    			   if(!historyItem.person){
    				   delete historyItem.person;
    			   }else {
    				   delete historyItem.person.items;
    				   delete historyItem.person.formattedDateOfBirth;
    			   }
    			   var promise = this._simpleAccess.makeRequest('SmartNavigatorFacade', 'saveUserHistoryItem', historyItem);
    			   this.quickSearchXHRPromises.push(promise);
    			   promise.then( 
    					   //Success Callback
    					   function(){}, 
    					   //Error Callback
    					   function(err){
    						   debug.log('Error Saving Search History', err);
    					   });
    		   }
			},
               
               /**
                * Quick Search Row OnKeyUp Event.
                *
                * -Change the focus using the keyboard arrow keys.
                * 
				 * @param {object} row
                * @param {object} event
                * @private
                */
               _onItemKeyNavigation : function(row, event){
            	   if(event.keyCode === keys.DOWN_ARROW){ 
            		   this._onItemDownArrowKey(row, event);
            	   }else if(event.keyCode === keys.UP_ARROW){
            		   this._onItemUpArrowKey(row, event);
            	   }else if(event.keyCode === keys.RIGHT_ARROW){
            		   if(util.isRtlMode()){
            			   this._onItemLeftArrowKey(row, event);
            		   }else {
            			   this._onItemRightArrowKey(row, event);
            		   }
            	   }else if(event.keyCode === keys.LEFT_ARROW){
            		   if(util.isRtlMode()){
            			   this._onItemRightArrowKey(row, event);
            		   }else {
            			   this._onItemLeftArrowKey(row, event);
            		   }
            	   }
               },
               
               /**
                * Quick Search On Item Down Arrow Key Navigation
                * 
				 * @param {object} row
                * @param {object} event
                * @private
                */
               _onItemDownArrowKey : function(row, event){
            	   event.preventDefault();
            	   event.stopPropagation();
               	
               	   //Check if the focus is on the message
            	   if(domClass.contains(event.target, 'topMessage')){
           			   //Set the focus on the first result row.
            		   this._setFocusOnFirstResultRow();
       			    //Check if the focus is on a tag
            	   }else if(domClass.contains(event.target, 'appSearchKeywordTag') || 
        			   domClass.contains(event.target, 'appSearchDropDownButton')){
            		   //Set the focus on the first result row.
        			   this._setFocusOnFirstResultRow();
            	   }else {
           			   //Navigate Through the result rows and pagination button.
            		   var sibling = this._findSiblingElement(row, true, 'appSearchItem-ListItem', 'hide');
            		   if(sibling){
            			   this._focusAppSearchRowItem(sibling);
            		   }else if(!domClass.contains(event.target, 'contextMenuItem') && 
            				   !domClass.contains(event.target, 'appSearchMessage')) {
            			   var paginationButton = query('.moreItems', this.applicationSearchDiv[0]);
            			   if(paginationButton.length > 0){
            				   paginationButton[0].focus();
            			   }
            		   }
            	   }
               },
               
               /**
                * Quick Search On Item UP Arrow Key Navigation
                * 
				 * @param {object} row
                * @param {object} event
                * @private
                */
               _onItemUpArrowKey : function(row, event){
            	   event.preventDefault();
            	   event.stopPropagation();
               	
               	   //If the focus is on a tag, set the focus on the field
            	   if(domClass.contains(event.target, 'appSearchKeywordTag') || 
        			   domClass.contains(event.target, 'appSearchDropDownButton')){
            		   this.searchInputField.focus(); 
            		   return;
            	   }
            	   
            	   var sibling = this._findSiblingElement(row, false, 'appSearchItem-ListItem', 'hide');
            	   if(sibling){
            		   this._focusAppSearchRowItem(sibling);
           		   //If the focus is on the Pagination Button, set the focus to the last item	
            	   }else if(domClass.contains(event.target, 'moreItems')) {
            		   var items = query('.appSearchItem:not(.hide)', this.applicationSearchDiv[0]);
            		   this._focusAppSearchRowItem(items[items.length - 1]);
           		   //Reached the top of the list, set the focus back to the input or message or tag if
            	   //it is not a person's contextMenu subitem
            	   }else if(!domClass.contains(event.target, 'contextMenuItem')) {
       				   //look for tags button
        			   var tagsBtn = query('.appSearchDropDownButton', this.applicationSearchDiv[0]);
        			   if(tagsBtn.length > 0){
        				   tagsBtn[0].focus();
        			   }else {
       					   //Look for tags
        				   var tags = query('.appSearchKeywordTag', this.applicationSearchDiv[0]);
        				   if(tags.length > 0){
        					   tags[0].focus();
        				   }else {
           					   //No tags, buttons or messages. Set it back to the input
        					   this.searchInputField.focus();
        				   }
        			   }
            	   }
               },
               
               /**
                * Quick Search On Item RIGHT Arrow Key Navigation
                * 
				 * @param {object} row
                * @param {object} event
                * @private
                */
               _onItemRightArrowKey : function(row, event){
            	   event.preventDefault();
            	   event.stopPropagation();
               	
               	   //If the focus is on a tag, set the focus on the next tag.
            	   if(domClass.contains(event.target, 'appSearchKeywordTag')){
            		   var nextTag = this._findSiblingElement(event.target, true, 'appSearchKeywordTag');
            		   if(nextTag){
            			   nextTag.focus();
            		   }
            	   }
               	
               	   //Check if the current item has context menu to open
            	   var itemContextMenuButtons = query('.personItems', row);
            	   if(itemContextMenuButtons.length > 0){
               		//Callback to be called after the context menu is created.
            		   this.personItemsContextMenuCreationCallback = function(container){
            			   var items = query('.contextMenuItem', container);
            			   if(items.length > 0){
            				   items[0].focus();
            			   }else {
            				   query('.appSearchMessage', container)[0].focus();
            			   }
               			   //Reset the callback.
            			   this.personItemsContextMenuCreationCallback = null;
            		   }
            		   itemContextMenuButtons[0].click(); 
            	   }
               },
               
               /**
                * Quick Search On Item Left Arrow Key Navigation
                * 
				* @param {object} row 
                * @param {object} event
                * @private
                */
               _onItemLeftArrowKey : function(row, event){
               	//If the focus is on a tag, set the focus on the next tag.
            	   if(domClass.contains(event.target, 'appSearchKeywordTag')){ 
            		   var nextTag = this._findSiblingElement(event.target, false, 'appSearchKeywordTag');
            		   if(nextTag){
            			   nextTag.focus();
            		   }
            	   } 
               },
               
               /**
                * Find the focusable row item and set the focus.
                * 
                * Check if the row is a focusable item.
                * If a row contains a sub-menu button, the focusable item is its child.
                * 
                * @param {object} row
                * @private
                */
               _focusAppSearchRowItem : function(row){ 
    			   if(domClass.contains(row, 'appSearchItem')){
    				   row.focus();
    			   }else {
    				   var itemRow = query('.appSearchItem', row)[0];
    				   if(itemRow){
    					   itemRow.focus();
    				   }
    			   }  
               },
               
               /**
                * Find the sibling element.
                * 
                * @param {object} row - Current Row DOM Element
                * @param {boolean} isNext - Indicator whether we want the next or previous.
                * @param {String} siblingClass - Css class name of the sibling element.
                * @param {String} excludeElementsWithClass - Exclude CSS elements if it contains this class.
                * @return {object} Sibilng row dom element.
                * 
                * @private
                */
               _findSiblingElement : function(row, isNext, siblingClass, excludeElementsWithClass){
            	   var sibling = isNext ? row.nextElementSibling : row.previousElementSibling;
            	   
            	   while(sibling){
            		   if(!domClass.contains(sibling, siblingClass)){ 
            			   return null;
            		   }
       				
            		   if(!excludeElementsWithClass || 
            				   !domClass.contains(sibling, excludeElementsWithClass)){
            			   return sibling;
            		   }
           			
            		   sibling = isNext ? sibling.nextElementSibling : sibling.previousElementSibling;
            	   }
               },
               
               /**
                * Set the focus on the first result row of the list.
                * 
                * @private
                */
               _setFocusOnFirstResultRow : function(){
            	   var items = query('.appSearchItem:not(.hide)', this.applicationSearchDiv[0]);
            	   if(items.length > 0){
            		   items[0].focus();
            	   }
               },

               /**
                * OnPaste Event Handler to call the same functions of the onkeyup event.
                *
                * @param {object} evt - OnPaste event object
                * @private
                */
               _onPaste : function(evt) {
                   var clipboardData = evt.clipboardData || window.clipboardData;
                   var pastedData = clipboardData.getData('Text');
                   var enable = (pastedData && pastedData.length > 0) ||
                       this._isSearchInputFieldPopulated();

                   this._enableOrDisableSearchLink(evt, enable);
               },

               /**
                * onFocus event handler
                *
                * When focused, the widget change its style.
                *
                * If quick search is active, show the drop-down list. If the field is blank,
                * show the search history.
                *
                * @private
                */
               _givenFocus : function() {
            	   var _self = this;
            	   var ua = navigator.userAgent.toLowerCase();
            	   var IEUser = /trident/.test(ua) ? true: false;

                   if (query('.appSearchItemContext', this.applicationSearchDiv[0]).length > 0) {
                       return;
                   }

                   if(!this.spinnerDiv){
                       this._createSpinnerDiv();
                   }

                   if (this.searchTextDiv == null) {
                       this.searchTextDiv = query('.search-input-controls div.dijitInputField', this.applicationSearchDiv[0]);
                   }

                   if (this.originalInputColor == null) {
                       this.originalInputColor = '#152935';
                   }

                   if (this.appBannerComboBoxDiv == null
                       || this.appBannerComboBoxDiv.length == 0) {
                       this.appBannerComboBoxDiv = query(".appBannerComboBox", this.applicationSearchDiv[0]);
                       if (this.appBannerComboBoxDiv == null || this.appBannerComboBoxDiv.length == 0) {
                           this.appBannerComboBoxDiv = query(".multiple-search-banner select", this.applicationSearchDiv[0]);
                           if (this.appBannerComboBoxDiv != null && this.appBannerComboBoxDiv.length > 0) {
                               domClass.add(this.appBannerComboBoxDiv[0], 'appBannerSelect');
                           }
                       }
                   }

                   domStyle.set(this.searchInputField, "color", this.originalInputColor);
                   domClass.remove(this.searchInputField, 'input-placeholder-closed');
                   domClass.add(this.searchInputField, 'input-placeholder-opened');

                   var currentPosition = 0;
                   var rtlMode = util.isRtlMode();
                   if (rtlMode != null) {
                   	currentPosition = domGeom.position(this.searchInputField).x - 46;
                   }else {
                   	currentPosition = domGeom.position(this.searchInputField).x - 10;
                   }

                   if (this.closedHeight == null) {
                       this.closedHeight = domStyle.get(this.applicationSearchDiv[0], 'height');
                   }

                   this.applicationSearchDiv.style({
                       left : currentPosition + "px"
                   });

                   domClass.add(this.applicationSearchDiv[0], 'application-search-upfront-popup');
                   
                   if(this.quickSearch){
                   	if(query('.appSearchKeywords', this.applicationSearchDiv[0]).length === 0){
                   		this._createKeywordTagsContainer();
                   	}
                   }else {
                   	this._destroyKeywordTagsContainer();
                   }

                   var searchFieldHeight = this.quickSearch ? 40 : 100;

                   if (domStyle.get(this.applicationSearchDiv[0], 'height') != searchFieldHeight) {

                       if (this.searchOptionsDiv.length > 0) {
                           domStyle.set(this.searchOptionsDiv[0], "display", "block");
                           domStyle.set(this.searchOptionsDiv[0], "opacity", "0");
                       }

                       if (this.appBannerComboBoxDiv != null
                           && this.appBannerComboBoxDiv.length > 0) {
                           domStyle.set(this.appBannerComboBoxDiv[0], "display", "block");
                       }

                       if (this.searchOptionsDiv != null && this.searchOptionsDiv.length > 0) {
                           var fadeArgs = {
                               node : this.searchOptionsDiv[0]
                           };

                           fx.fadeIn(fadeArgs).play();
                       }
                   }

                   if (this.backgroundColor == null) {
                       this.backgroundColor = domStyle.get(this.searchTextDiv[0], 'background-color');
                   }

                   if (this.searchTextDiv != null &&
                       domStyle.get(this.searchTextDiv[0], 'background-color') != this.searchOptionsDivOpenedColor) {
                	   domStyle.set(this.searchTextDiv[0], "background-color", '#ffffff');
                	   domStyle.set(this.searchControlsDiv[0], "background-color", '#ffffff');
                	   domStyle.set(this.searchIconDiv[0], "background-color", '#ffffff');

                	   this.searchInputImg[0].src = jsBaseURL + '/themes/curam/images/search--20-enabled.svg';
                   }

                   if (this.quickSearch){
                	   
                	   if(!this.focusNode.value && !this._isShowingHistory()) {
	                       this._destroyResultList();
	                       this._hideDropDown();
	                       this._showSearchHistory();
                	   }

                       var recentSearchesHeaderSpanEl = query('.appSearchItemSeparatorLabel', this.applicationSearchDiv[0])[0];
                       if (recentSearchesHeaderSpanEl) {
                         if (IEUser) {
                           domAttr.set(this.searchInputField, "aria-describedby", "applicationSearchResultListId");
                         } else {
                           domAttr.set(this.searchInputField, "aria-describedby", "resultRowHeaderId");
                         }
                       }

            		   this._showResultList();
                   }
                   
                   this._fixQuickSearchHeight();
                   
                   this.searchInputField.focus();
                   setTimeout(function(){
                	   _self.searchInputField.select();
                   }, 5);

                   var resultList = query('.appSearchItemsContainer', this.applicationSearchDiv[0])[0];
                   if (typeof(this.searchInputField) != 'undefined' && this.searchInputField.value.length > 0
                     && typeof(resultList) != 'undefined' && resultList.children.length > 0) {
            	     if (IEUser) {
            		   domAttr.set(this.searchInputField, "aria-describedby", "applicationSearchResultListId");
            		 } else {
            		   domAttr.set(this.searchInputField, "aria-describedby", "searchResultsScreenReadersInfoId");
            		 }
                   }

               },

               /**
                * OnBlur Event handler
                *
                * Reset the widget to its original state.
                *
                * @param {object} evt - onBlur event object
                * @private
                */
               _onBlur : function(evt) {
                   if (!this._isSearchInputFieldPopulated()) {
                       this.searchInputField.value = "";
                   }
                   
                   this._hideSearchBoxIfNotFocused(evt);
               },

               /**
                * Destroy the Quick Search Drop-down List.
                *
                * @private
                */
               _destroyResultList : function() { 
                   query('.appSearchItemsOuterContainer', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.appSearchItemsContainer', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.appSearchItem', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.appSearchItemSeparatorLabel', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.appSearchKeywordTag', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.appSearchMessage.topMessage', this.applicationSearchDiv[0]).forEach(domConstruct.destroy); 
                   query('.appSearchItemContext', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.moreItems', this.applicationSearchDiv[0]).forEach(domConstruct.destroy);
                   query('.personItems.clicked', this.applicationSearchDiv[0]).forEach(function(item) {
                       domClass.remove(item, 'clicked');
                   });

                   domClass.remove(this.applicationSearchDiv[0], 'application-search-items-list');

                   this._fixQuickSearchHeight();

                   domClass.remove(this.applicationSearchDiv[0], 'shadow');
               },
               
               /**
                * Automatically Scroll to the newly created items when the pagination button is clicked.
                *
                * @private
                */
               _autoScrollToNewItems : function(){
                   // Auto scroll to the new items
                   if (this.searchResults.hasItems && this.paginationStart > 0) {
                       var itemsContainer = query('.appSearchItemsOuterContainer', this.applicationSearchDiv[0])[0];
                       itemsContainer.scrollTop = itemsContainer.scrollHeight;

                       query('.appSearchNewItem', this.applicationSearchDiv[0]).forEach(
                           function(item) {
                               fx.animateProperty({
                                   node : item,
                                   duration : 650,
                                   properties : {
                                       opacity : {
                                           start : '.4',
                                           end : '1'
                                       }
                                   }
                               }).play();
                               domClass.remove(item, 'appSearchNewItem');
                           }
                       );
                   }

               },

               /**
                * Calculate the person's age based on his date of birth.
                *
                * @param {String} dob - formatted date.
                * @returns {number}
                * @private
                */
               _getAge : function(dob) {
                   if (dob) {
                       var birthday = dateLocale.parseDate(dob);
                       return parseInt(((Date.now() - birthday) / (31557600000)));
                   }else {
                       return '';
                   }
               },

               /**
                * Adjust the Widget's height based on its items height.
                *
                * @private
                */
               _fixQuickSearchHeight : function(){
                   this.currentOpenedHeight = this._getOpenedMenuHeight();
                   domStyle.set(this.applicationSearchDiv[0], 'height', this.currentOpenedHeight + 'px');
               },

               /**
                * Hide the Quick Search Drop-down List.
                *
                * @private
                */
               _hideDropDown : function() {
                   this._fixQuickSearchHeight();
                   domClass.remove(this.applicationSearchDiv[0], 'shadow');
               },

               /**
                * Check if the Search History is being displayed.
                *
                * @returns {boolean}
                * @private
                */ 
               _isShowingHistory : function() {
                   return query('.appSearchItemHistory', this.applicationSearchDiv[0]).length > 0;
               },

               /**
                * Reset the searchResults object.
                *
                * @private
                */
               _resetSearchResults : function() {
                   this.paginationStart = 0;
                   this._destroyResultList();
                   this.searchResults = {
                       people : [],
                       actionsOnly : [],
                       personQueryTerms : [],
                       messages : {
                       	info : null,
                           unmapped : {
                               pages : []
                           },
                           moreThanOneTab : {
                               pages : []
                           }
                       },
                       hasItems : false
                   };
               },

               /**
                * Clear the searchResults.messages object.
                *
                * @private
                */
               _resetSearchMessages : function(){
                   this.searchResults.messages = {
                   	info : null,
                       unmapped : {
                           pages : []
                       },
                       moreThanOneTab : {
                           pages : []
                       }
                   }
               },

               /**
                * Toggle the Search Button.
                *
                * It should only be enabled when the input text has value.
                *
                * @param {object} evt - OnkeyUp Event Object.
                * @param {boolean} enable - Enable/Disable
                * @private
                */
               _enableOrDisableSearchLink : function(evt, enable) {
                   if (enable && enable === true) {
                       domClass.remove(this.searchIcon[0], 'dijitDisabled');
                       if (evt.keyCode == keys.ENTER) {
                           this._search();
                       }
                   } else {
                       domClass.add(this.searchIcon[0], "dijitDisabled");
                   }
               },

               /**
                * Check if the quick-search is enabled and there's no other
                * search-page configured (Combobox not rendered).
                *
                * @returns {boolean}
                * @private
                */
               _isQuickSearchOnly : function() {
                   var searchOptions = false;
                   var comboboxOptions = false;

                   if (this.searchOptionsDiv != null && this.searchOptionsDiv.length > 0) {
                       searchOptions = true;
                   }

                   if (this.appBannerComboBoxDiv != null && this.appBannerComboBoxDiv.length > 0) {
                       comboboxOptions = true;
                   }

                   return !searchOptions && !comboboxOptions;
               },

               /**
                * Calculate the Height of the Drop-down list items.
                *
                * The maximum height is defined by the variable maxItemsHeight.
                *
                * @param {boolean} countHiddenItems
                * @returns {number} The total height in pixels.
                * @private
                */
               _getItemsHeight : function(countHiddenItems) {
                   var quickSearchOnly = this._isQuickSearchOnly();
                   var criteria = ".appSearchItem:not(.hide):not(.contextMenuItem)";

                   if (countHiddenItems) {
                       criteria = ".appSearchItem";
                   }

                   var height = query(criteria, this.applicationSearchDiv[0]).reduce(
                       function(counter, node) {
                           counter += domStyle.get(node, 'height');
                           counter += domStyle.get(node, 'padding-top');
                           counter += domStyle.get(node, 'padding-bottom');
                           counter += domStyle.get(node, 'margin-top');
                           counter += domStyle.get(node, 'margin-bottom');

                           return counter;
                       },
                       0);

                   if (quickSearchOnly && height > 0) {
                       // Extra height fix needed for the quick-search only
                       height += 3;
                   }

                   if (height > this.maxItemsHeight) {
                       height = this.maxItemsHeight;
                   }

                   return height;
               },

				/**
				 * Calculate the drop-down list height.
				 *
				 * @return {number} Height in pixels.
				 */
               _getOpenedMenuHeight : function() {
                   var height = 0;

                   if (this.searchOptionsDiv != null && this.searchOptionsDiv.length > 0) {
                   	if(this.quickSearch){
                   		height += this.appBannerComboBoxDiv[0] ?  
                   				this.menuOpenedFurtherOptionsHeightQuickSearch :
                   				this.menuOpenedFurtherOptionsHeightNoCombobox;	
                   	}else {
                   		height += this.menuOpenedFurtherOptionsHeight;
                   	}
                   }

                   if (this.appBannerComboBoxDiv != null && this.appBannerComboBoxDiv.length > 0) {
                       height += this.menuOpenedComboboxHeight;
                   } else if (this.quickSearch) {
                       height += this.quickSearchMenuOpenedHeight;
                   }
                    
                   var separatorsHeight = 0;
                   query('.appSearchKeywords', this.applicationSearchDiv[0]).forEach(
                       function(element) {
                       	separatorsHeight += this._calculateElementHeight(element);
                       }, this);

                   separatorsHeight += this._getTopMessagesHeight();
                   
                   separatorsHeight += query('.moreItems', this.applicationSearchDiv[0]).reduce(
                       function(count) {
                           return count += 40;
                       },
                       0);

                   if (query('.appSearchItemsOuterContainer.margin', this.applicationSearchDiv[0]).length > 0) {
                       height += 10;
                   }

                   if (query('.appSearchMessage.topMessage.margin', this.applicationSearchDiv[0]).length > 0) {
                       height += 10;
                   }

                   var itemsHeight = this._getItemsHeight(false);
                   height += itemsHeight + separatorsHeight;
                   
                   //If there's only the (Keywords +) button and nothing more,
                   //Remove Extra Margins
                   var appSearchKeywordsContainerHeight = 27;
                   var keywordsListButtonOnly = height === appSearchKeywordsContainerHeight + this.quickSearchMenuOpenedHeight
                   if(keywordsListButtonOnly){
                   	height -= 5;
                   }
                   
                   domStyle.set(this.applicationSearchDiv[0], 'height', height + 'px');
                   this.currentOpenedHeight = height;
                   
                   

                   return height;
               },

               /**
                * Calculate the height of the drop-down list message.
                *
                * @returns {number} - height in pixels.
                * @private
                */
               _getTopMessagesHeight : function(){
                   var height = 0;

                   query(".appSearchMessage.topMessage", this.applicationSearchDiv[0]).forEach(function(message){
                       height += message.clientHeight + 5;
                   });

                   return height;
               },
               
               _calculateElementHeight : function(element){
           		  var styles = window.getComputedStyle(element);
           		  var margin = parseFloat(styles['marginTop']) +
           		               parseFloat(styles['marginBottom']);

           		  return Math.ceil(element.offsetHeight + margin);
               },

               /**
                * Dinamically enable the Quick Search when the user changes the combobox.
                *
                * @private
                */
               _enableQuickSearch : function() {
                   domClass.add(this.applicationSearchDiv[0], 'quick-search');
                   this.quickSearch = true;
                   if(query('.appSearchKeywords', this.applicationSearchDiv[0]).length === 0){
               		this._createKeywordTagsContainer();
               	}
               },

               /**
                * Dinamically disable the Quick Search when the user changes the combobox.
                *
                * @private
                */
               _disableQuickSearch : function() {
                   this._destroyResultList();
                   domClass.remove(this.applicationSearchDiv[0], 'quick-search');
                   this.quickSearch = false;
                   this._destroyKeywordTagsContainer();
               },

               /**
                * Create the Spinner Loader Infrastructure
                *
                * @private
                */
               _createSpinnerDiv : function(){
                   this.spinnerDiv = domConstruct.toDom('<div class="curam-spinner curam-h1 quick-search hide"></div>');

                   domConstruct.place(this.spinnerDiv, this.searchIconDiv[0], "last");
               },

               /**
                * Show the Spinner Loader to indicate that the request is being processed.
                *
                * @private
                */
               _showSpinnerDiv : function(){
                   this.spinnerTimeouts.push(
                       setTimeout(lang.hitch(this,
                           function(){
                               domStyle.set(this.searchIcon[0], 'display', 'none');
                               domClass.remove(this.spinnerDiv, 'hide');
                           }
                       ), 500)
                   );
               },

               /**
                * Hide the Spinner Loader if it is being shown
                *
                * @private
                */
               _hideSpinnerDiv : function(){
                   this.spinnerTimeouts.forEach(function(timeout){
                       clearTimeout(timeout);
                   });
                   this.spinnerTimeouts = [];

                   domStyle.set(this.searchIcon[0], 'display', 'block');
                   
                   if(this.spinnerDiv){
						domClass.add(this.spinnerDiv, 'hide');
                   }
               },
               
               /**
                * Cancel previous server ajax calls if they're still runing.
                * 
                * @private
                */
               _cancelPreviousAjaxCalls : function(){
                   if(this.quickSearchXHRPromises.length > 0){
                       this.quickSearchXHRPromises.forEach(function(previousCallPromise){
                           previousCallPromise.cancel();
                       });
                       this.quickSearchXHRPromises = [];
                   }
               }

           });

   		return CuramSearchMultipleTextBox;
	});
},
'dijit/form/_ComboBoxMenuMixin':function(){
define([
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/has",
	"dojo/i18n", // i18n.getLocalization
	"dojo/i18n!./nls/ComboBox"
], function(array, declare, domAttr, has, i18n){

	// module:
	//		dijit/form/_ComboBoxMenuMixin

	var ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin" + (has("dojo-bidi") ? "_NoBidi" : ""), null, {
		// summary:
		//		Focus-less menu for internal use in `dijit/form/ComboBox`
		// tags:
		//		private

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this._set("value", value);
			this.onChange(value);
		},

		onClick: function(/*DomNode*/ node){
			if(node == this.previousButton){
				this._setSelectedAttr(null);
				this.onPage(-1);
			}else if(node == this.nextButton){
				this._setSelectedAttr(null);
				this.onPage(1);
			}else{
				this.onChange(node);
			}
		},

		// stubs
		onChange: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user selected an option.
			// tags:
			//		callback
		},

		onPage: function(/*Number*/ /*===== direction =====*/){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._setSelectedAttr(null);
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit/form/FilteringSelect`.

			var menuitem = this._createMenuItem();
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					menuitem.ownerDocument.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&#160;";	// &nbsp;
			}

			return menuitem;
		},

		createOptions: function(results, options, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of items
			// options:
			//		The options to the query function of the store
			//
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			this.items = results;

			// display "Previous . . ." button
			this.previousButton.style.display = (options.start == 0) ? "none" : "";
			domAttr.set(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			array.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				menuitem.setAttribute("item", i);	// index to this.items; use indirection to avoid mem leak
				domAttr.set(menuitem, "id", this.id + i);
				this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			// Try to determine if we should show 'more'...
			if(results.total && !results.total.then && results.total != -1){
				if((options.start + options.count) < results.total){
					displayMore = true;
				}else if((options.start + options.count) > results.total && options.count == results.length){
					// Weird return from a data store, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					// And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(options.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			domAttr.set(this.nextButton, "id", this.id + "_next");
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			var container = this.containerNode;
			while(container.childNodes.length > 2){
				container.removeChild(container.childNodes[container.childNodes.length - 2]);
			}
			this._setSelectedAttr(null);
		},

		highlightFirstOption: function(){
			// summary:
			//		Highlight the first real item in the list (not Previous Choices).
			this.selectFirstNode();
		},

		highlightLastOption: function(){
			// summary:
			//		Highlight the last real item in the list (not More Choices).
			this.selectLastNode();
		},

		selectFirstNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.previousButton){
				this.selectNextNode();
			}
		},

		selectLastNode: function(){
			this.inherited(arguments);
			if(this.getHighlightedOption() == this.nextButton){
				this.selectPreviousNode();
			}
		},

		getHighlightedOption: function(){
			return this.selected;
		}
	});

	if(has("dojo-bidi")){
		ComboBoxMenuMixin = declare("dijit.form._ComboBoxMenuMixin", ComboBoxMenuMixin, {
			_createOption: function(){
				var menuitem = this.inherited(arguments);

				// update menuitem.dir if BidiSupport was required
				this.applyTextDir(menuitem);

				return menuitem;
			}
		});
	}

	return ComboBoxMenuMixin;
});

},
'dijit/Tree':function(){
define([
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/aspect",
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/Deferred", // Deferred
	"dojo/promise/all",
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/errors/create", // createError
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/has",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys", // arrows etc.
	"dojo/_base/lang", // lang.getObject lang.mixin lang.hitch
	"dojo/on", // on(), on.selector()
	"dojo/topic",
	"dojo/touch",
	"dojo/when",
	"./a11yclick",
	"./focus",
	"./registry", // registry.byNode(), registry.getEnclosingWidget()
	"./_base/manager", // manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./_Contained",
	"./_CssStateMixin",
	"./_KeyNavMixin",
	"dojo/text!./templates/TreeNode.html",
	"dojo/text!./templates/Tree.html",
	"./tree/TreeStoreModel",
	"./tree/ForestStoreModel",
	"./tree/_dndSelector",
	"dojo/query!css2"	// needed when on.selector() used with a string for the selector
], function(array, aspect, cookie, declare, Deferred, all,
			dom, domClass, domGeometry, domStyle, createError, fxUtils, has, kernel, keys, lang, on, topic, touch, when,
			a11yclick, focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin, _KeyNavMixin,
			treeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector){

	// module:
	//		dijit/Tree

	function shimmedPromise(/*Deferred|Promise*/ d){
		// summary:
		//		Return a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims
		//		added (TODO: remove those back-compat shims, and this method, for 2.0)

		return lang.delegate(d.promise || d, {
			addCallback: function(callback){
				this.then(callback);
			},
			addErrback: function(errback){
				this.otherwise(errback);
			}
		});
	}

	var TreeNode = declare("dijit._TreeNode", [_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin], {
		// summary:
		//		Single node within a tree.   This class is used internally
		//		by Tree and should not be accessed directly.
		// tags:
		//		private

		// item: [const] Item
		//		the dojo.data entry this tree represents
		item: null,

		// isTreeNode: [protected] Boolean
		//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
		//		should not be accessed directly.
		isTreeNode: true,

		// label: String
		//		Text of this tree node
		label: "",
		_setLabelAttr: function(val){
			this.labelNode[this.labelType == "html" ? "innerHTML" : "innerText" in this.labelNode ?
				"innerText" : "textContent"] = val;
			this._set("label", val);
			if(has("dojo-bidi")){
				this.applyTextDir(this.labelNode);
			}
		},

		// labelType: [const] String
		//		Specifies how to interpret the label.  Can be "html" or "text".
		labelType: "text",

		// isExpandable: [private] Boolean
		//		This node has children, so show the expando node (+ sign)
		isExpandable: null,

		// isExpanded: [readonly] Boolean
		//		This node is currently expanded (ie, opened)
		isExpanded: false,

		// state: [private] String
		//		Dynamic loading-related stuff.
		//		When an empty folder node appears, it is "NotLoaded" first,
		//		then after dojo.data query it becomes "Loading" and, finally "Loaded"
		state: "NotLoaded",

		templateString: treeNodeTemplate,

		baseClass: "dijitTreeNode",

		// For hover effect for tree node, and focus effect for label
		cssStateNodes: {
			rowNode: "dijitTreeRow"
		},

		// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
		_setTooltipAttr: {node: "rowNode", type: "attribute", attribute: "title"},

		buildRendering: function(){
			this.inherited(arguments);

			// set expand icon for leaf
			this._setExpando();

			// set icon and label class based on item
			this._updateItemClasses(this.item);

			if(this.isExpandable){
				this.labelNode.setAttribute("aria-expanded", this.isExpanded);
			}

			//aria-selected should be false on all selectable elements.
			this.setSelected(false);
		},

		_setIndentAttr: function(indent){
			// summary:
			//		Tell this node how many levels it should be indented
			// description:
			//		0 for top level nodes, 1 for their children, 2 for their
			//		grandchildren, etc.

			// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
			var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

			domStyle.set(this.domNode, "backgroundPosition", pixels + " 0px");	// TODOC: what is this for???
			domStyle.set(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

			array.forEach(this.getChildren(), function(child){
				child.set("indent", indent + 1);
			});

			this._set("indent", indent);
		},

		markProcessing: function(){
			// summary:
			//		Visually denote that tree is loading data, etc.
			// tags:
			//		private
			this.state = "Loading";
			this._setExpando(true);
		},

		unmarkProcessing: function(){
			// summary:
			//		Clear markup from markProcessing() call
			// tags:
			//		private
			this._setExpando(false);
		},

		_updateItemClasses: function(item){
			// summary:
			//		Set appropriate CSS classes for icon and label dom node
			//		(used to allow for item updates to change respective CSS)
			// tags:
			//		private
			var tree = this.tree, model = tree.model;
			if(tree._v10Compat && item === model.root){
				// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
				item = null;
			}
			this._applyClassAndStyle(item, "icon", "Icon");
			this._applyClassAndStyle(item, "label", "Label");
			this._applyClassAndStyle(item, "row", "Row");

			this.tree._startPaint(true);		// signifies paint started and finished (synchronously)
		},

		_applyClassAndStyle: function(item, lower, upper){
			// summary:
			//		Set the appropriate CSS classes and styles for labels, icons and rows.
			//
			// item:
			//		The data item.
			//
			// lower:
			//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
			//
			// upper:
			//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
			//
			// tags:
			//		private

			var clsName = "_" + lower + "Class";
			var nodeName = lower + "Node";
			var oldCls = this[clsName];

			this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
			domClass.replace(this[nodeName], this[clsName] || "", oldCls || "");

			domStyle.set(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
		},

		_updateLayout: function(){
			// summary:
			//		Set appropriate CSS classes for this.domNode
			// tags:
			//		private

			// if we are hiding the root node then make every first level child look like a root node
			var parent = this.getParent(),
				markAsRoot = !parent || !parent.rowNode || parent.rowNode.style.display == "none";
			domClass.toggle(this.domNode, "dijitTreeIsRoot", markAsRoot);

			domClass.toggle(this.domNode, "dijitTreeIsLast", !markAsRoot && !this.getNextSibling());
		},

		_setExpando: function(/*Boolean*/ processing){
			// summary:
			//		Set the right image for the expando node
			// tags:
			//		private

			var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
					"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
				_a11yStates = ["*", "-", "+", "*"],
				idx = processing ? 0 : (this.isExpandable ? (this.isExpanded ? 1 : 2) : 3);

			// apply the appropriate class to the expando node
			domClass.replace(this.expandoNode, styles[idx], styles);

			// provide a non-image based indicator for images-off mode
			this.expandoNodeText.innerHTML = _a11yStates[idx];

		},

		expand: function(){
			// summary:
			//		Show my children
			// returns:
			//		Promise that resolves when expansion is complete

			// If there's already an expand in progress or we are already expanded, just return
			if(this._expandDeferred){
				return shimmedPromise(this._expandDeferred);		// dojo/promise/Promise
			}

			// cancel in progress collapse operation
			if(this._collapseDeferred){
				this._collapseDeferred.cancel();
				delete this._collapseDeferred;
			}

			// All the state information for when a node is expanded, maybe this should be
			// set when the animation completes instead
			this.isExpanded = true;
			this.labelNode.setAttribute("aria-expanded", "true");
			if(this.tree.showRoot || this !== this.tree.rootNode){
				this.containerNode.setAttribute("role", "group");
			}
			domClass.add(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "true");
			}

			var wipeIn = fxUtils.wipeIn({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._expandDeferred = new Deferred(function(){
				// Canceller
				wipeIn.stop();
			}));

			aspect.after(wipeIn, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeIn.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		collapse: function(){
			// summary:
			//		Collapse this node (if it's expanded)
			// returns:
			//		Promise that resolves when collapse is complete

			if(this._collapseDeferred){
				// Node is already collapsed, or there's a collapse in progress, just return that Deferred
				return shimmedPromise(this._collapseDeferred);
			}

			// cancel in progress expand operation
			if(this._expandDeferred){
				this._expandDeferred.cancel();
				delete this._expandDeferred;
			}

			this.isExpanded = false;
			this.labelNode.setAttribute("aria-expanded", "false");
			if(this == this.tree.rootNode && this.tree.showRoot){
				this.tree.domNode.setAttribute("aria-expanded", "false");
			}
			domClass.remove(this.contentNode, 'dijitTreeContentExpanded');
			this._setExpando();
			this._updateItemClasses(this.item);

			var wipeOut = fxUtils.wipeOut({
				node: this.containerNode,
				duration: manager.defaultDuration
			});

			// Deferred that fires when expand is complete
			var def = (this._collapseDeferred = new Deferred(function(){
				// Canceller
				wipeOut.stop();
			}));

			aspect.after(wipeOut, "onEnd", function(){
				def.resolve(true);
			}, true);

			wipeOut.play();

			return shimmedPromise(def);		// dojo/promise/Promise
		},

		// indent: Integer
		//		Levels from this node to the root node
		indent: 0,

		setChildItems: function(/* Object[] */ items){
			// summary:
			//		Sets the child items of this node, removing/adding nodes
			//		from current children to match specified items[] array.
			//		Also, if this.persist == true, expands any children that were previously
			//		opened.
			// returns:
			//		Promise that resolves after all previously opened children
			//		have been expanded again (or fires instantly if there are no such children).

			var tree = this.tree,
				model = tree.model,
				defs = [];	// list of deferreds that need to fire before I am complete


			var focusedChild = tree.focusedChild;

			// Orphan all my existing children.
			// If items contains some of the same items as before then we will reattach them.
			// Don't call this.removeChild() because that will collapse the tree etc.
			var oldChildren = this.getChildren();
			array.forEach(oldChildren, function(child){
				_Container.prototype.removeChild.call(this, child);
			}, this);

			// All the old children of this TreeNode are subject for destruction if
			//		1) they aren't listed in the new children array (items)
			//		2) they aren't immediately adopted by another node (DnD)
			this.defer(function(){
				array.forEach(oldChildren, function(node){
					if(!node._destroyed && !node.getParent()){
						// If node is in selection then remove it.
						tree.dndController.removeTreeNode(node);

						// Deregister mapping from item id --> this node and its descendants
						function remove(node){
							var id = model.getIdentity(node.item),
								ary = tree._itemNodesMap[id];
							if(ary.length == 1){
								delete tree._itemNodesMap[id];
							}else{
								var index = array.indexOf(ary, node);
								if(index != -1){
									ary.splice(index, 1);
								}
							}
							array.forEach(node.getChildren(), remove);
						}

						remove(node);

						// Remove any entries involving this node from cookie tracking expanded nodes
						if(tree.persist){
							var destroyedPath = array.map(node.getTreePath(),function(item){
								return tree.model.getIdentity(item);
							}).join("/");
							for(var path in tree._openedNodes){
								if(path.substr(0, destroyedPath.length) == destroyedPath){
									delete tree._openedNodes[path];
								}
							}
							tree._saveExpandedNodes();
						}

						// If we've orphaned the focused node then move focus to the root node
						if(tree.lastFocusedChild && !dom.isDescendant(tree.lastFocusedChild, tree.domNode)){
							delete tree.lastFocusedChild;
						}
						if(focusedChild && !dom.isDescendant(focusedChild, tree.domNode)){
							tree.focus();	// could alternately focus this node (parent of the deleted node)
						}

						// And finally we can destroy the node
						node.destroyRecursive();
					}
				});

			});

			this.state = "Loaded";

			if(items && items.length > 0){
				this.isExpandable = true;

				// Create _TreeNode widget for each specified tree node, unless one already
				// exists and isn't being used (presumably it's from a DnD move and was recently
				// released
				array.forEach(items, function(item){    // MARKER: REUSE NODE
					var id = model.getIdentity(item),
						existingNodes = tree._itemNodesMap[id],
						node;
					if(existingNodes){
						for(var i = 0; i < existingNodes.length; i++){
							if(existingNodes[i] && !existingNodes[i].getParent()){
								node = existingNodes[i];
								node.set('indent', this.indent + 1);
								break;
							}
						}
					}
					if(!node){
						node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							labelType: (tree.model && tree.model.labelType) || "text",
							tooltip: tree.getTooltip(item),
							ownerDocument: tree.ownerDocument,
							dir: tree.dir,
							lang: tree.lang,
							textDir: tree.textDir,
							indent: this.indent + 1
						});
						if(existingNodes){
							existingNodes.push(node);
						}else{
							tree._itemNodesMap[id] = [node];
						}
					}
					this.addChild(node);

					// If node was previously opened then open it again now (this may trigger
					// more data store accesses, recursively)
					if(this.tree.autoExpand || this.tree._state(node)){
						defs.push(tree._expandNode(node));
					}
				}, this);

				// note that updateLayout() needs to be called on each child after
				// _all_ the children exist
				array.forEach(this.getChildren(), function(child){
					child._updateLayout();
				});
			}else{
				this.isExpandable = false;
			}

			if(this._setExpando){
				// change expando to/from dot or + icon, as appropriate
				this._setExpando(false);
			}

			// Set leaf icon or folder icon, as appropriate
			this._updateItemClasses(this.item);

			var def = all(defs);
			this.tree._startPaint(def);		// to reset TreeNode widths after an item is added/removed from the Tree
			return shimmedPromise(def);		// dojo/promise/Promise
		},

		getTreePath: function(){
			var node = this;
			var path = [];
			while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
			}
			path.unshift(this.tree.rootNode.item);

			return path;
		},

		getIdentity: function(){
			return this.tree.model.getIdentity(this.item);
		},

		removeChild: function(/* treeNode */ node){
			this.inherited(arguments);

			var children = this.getChildren();
			if(children.length == 0){
				this.isExpandable = false;
				this.collapse();
			}

			array.forEach(children, function(child){
				child._updateLayout();
			});
		},

		makeExpandable: function(){
			// summary:
			//		if this node wasn't already showing the expando node,
			//		turn it into one and call _setExpando()

			// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

			this.isExpandable = true;
			this._setExpando(false);
		},

		setSelected: function(/*Boolean*/ selected){
			// summary:
			//		A Tree has a (single) currently selected node.
			//		Mark that this node is/isn't that currently selected node.
			// description:
			//		In particular, setting a node as selected involves setting tabIndex
			//		so that when user tabs to the tree, focus will go to that node (only).
			this.labelNode.setAttribute("aria-selected", selected ? "true" : "false");
			domClass.toggle(this.rowNode, "dijitTreeRowSelected", selected);
		},

		focus: function(){
			focus.focus(this.focusNode);
		}
	});

	if(has("dojo-bidi")){
		TreeNode.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && ((this.textDir != textDir) || !this._created)){
					this._set("textDir", textDir);
					this.applyTextDir(this.labelNode);
					array.forEach(this.getChildren(), function(childNode){
						childNode.set("textDir", textDir);
					}, this);
				}
			}
		});
	}

	var Tree = declare("dijit.Tree", [_Widget, _KeyNavMixin, _TemplatedMixin, _CssStateMixin], {
		// summary:
		//		This widget displays hierarchical data from a store.

		baseClass: "dijitTree",

		// store: [deprecated] String|dojo/data/Store
		//		Deprecated.  Use "model" parameter instead.
		//		The store to get data to display in the tree.
		store: null,

		// model: [const] dijit/tree/model
		//		Interface to read tree data, get notifications of changes to tree data,
		//		and for handling drop operations (i.e drag and drop onto the tree)
		model: null,

		// query: [deprecated] anything
		//		Deprecated.  User should specify query to the model directly instead.
		//		Specifies datastore query to return the root item or top items for the tree.
		query: null,

		// label: [deprecated] String
		//		Deprecated.  Use dijit/tree/ForestStoreModel directly instead.
		//		Used in conjunction with query parameter.
		//		If a query is specified (rather than a root node id), and a label is also specified,
		//		then a fake root node is created and displayed, with this label.
		label: "",

		// showRoot: [const] Boolean
		//		Should the root node be displayed, or hidden?
		showRoot: true,

		// childrenAttr: [deprecated] String[]
		//		Deprecated.   This information should be specified in the model.
		//		One ore more attributes that holds children of a tree node
		childrenAttr: ["children"],

		// paths: String[][] or Item[][]
		//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
		//		Since setting the paths may be asynchronous (because of waiting on dojo.data), set("paths", ...)
		//		returns a Promise to indicate when the set is complete.
		paths: [],

		// path: String[] or Item[]
		//		Backward compatible singular variant of paths.
		path: [],

		// selectedItems: [readonly] Item[]
		//		The currently selected items in this tree.
		//		This property can only be set (via set('selectedItems', ...)) when that item is already
		//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
		//		Should generally use `paths` attribute to set the selected items instead.
		selectedItems: null,

		// selectedItem: [readonly] Item
		//		Backward compatible singular variant of selectedItems.
		selectedItem: null,

		// openOnClick: Boolean
		//		If true, clicking a folder node's label will open it, rather than calling onClick()
		openOnClick: false,

		// openOnDblClick: Boolean
		//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
		openOnDblClick: false,

		templateString: treeTemplate,

		// persist: Boolean
		//		Enables/disables use of cookies for state saving.
		persist: false,

		// autoExpand: Boolean
		//		Fully expand the tree on load.   Overrides `persist`.
		autoExpand: false,

		// dndController: [protected] Function|String
		//		Class to use as as the dnd controller.  Specifying this class enables DnD.
		//		Generally you should specify this as dijit/tree/dndSource.
		//		Setting of dijit/tree/_dndSelector handles selection only (no actual DnD).
		dndController: _dndSelector,

		// parameters to pull off of the tree and pass on to the dndController as its params
		dndParams: ["onDndDrop", "itemCreator", "onDndCancel", "checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

		//declare the above items so they can be pulled from the tree's markup

		// onDndDrop: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndDrop()`.
		//		Generally this doesn't need to be set.
		onDndDrop: null,

		itemCreator: null,
		/*=====
		itemCreator: function(nodes, target, source){
			// summary:
			//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
			//		dropped onto the tree.   Developer must override this method to enable
			//		dropping from external sources onto this Tree, unless the Tree.model's items
			//		happen to look like {id: 123, name: "Apple" } with no other attributes.
			//
			//		For each node in nodes[], which came from source, create a hash of name/value
			//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
			// nodes: DomNode[]
			//		The DOMNodes dragged from the source container
			// target: DomNode
			//		The target TreeNode.rowNode
			// source: dojo/dnd/Source
			//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo/dnd/Source
			// returns: Object[]
			//		Array of name/value hashes for each new item to be added to the Tree, like:
			// |	[
			// |		{ id: 123, label: "apple", foo: "bar" },
			// |		{ id: 456, label: "pear", zaz: "bam" }
			// |	]
			// tags:
			//		extension
			return [{}];
		},
		=====*/

		// onDndCancel: [protected] Function
		//		Parameter to dndController, see `dijit/tree/dndSource.onDndCancel()`.
		//		Generally this doesn't need to be set.
		onDndCancel: null,

		/*=====
		checkAcceptance: function(source, nodes){
			// summary:
			//		Checks if the Tree itself can accept nodes from this source
			// source: dijit/tree/dndSource
			//		The source which provides items
			// nodes: DOMNode[]
			//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
			//		source is a dijit/Tree.
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkAcceptance: null,

		/*=====
		checkItemAcceptance: function(target, source, position){
			// summary:
			//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
			// description:
			//		In the base case, this is called to check if target can become a child of source.
			//		When betweenThreshold is set, position="before" or "after" means that we
			//		are asking if the source node can be dropped before/after the target node.
			// target: DOMNode
			//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
			//		Use registry.getEnclosingWidget(target) to get the TreeNode.
			// source: dijit/tree/dndSource
			//		The (set of) nodes we are dropping
			// position: String
			//		"over", "before", or "after"
			// tags:
			//		extension
			return true;	// Boolean
		},
		=====*/
		checkItemAcceptance: null,

		// dragThreshold: Integer
		//		Number of pixels mouse moves before it's considered the start of a drag operation
		dragThreshold: 5,

		// betweenThreshold: Integer
		//		Set to a positive value to allow drag and drop "between" nodes.
		//
		//		If during DnD mouse is over a (target) node but less than betweenThreshold
		//		pixels from the bottom edge, dropping the the dragged node will make it
		//		the next sibling of the target node, rather than the child.
		//
		//		Similarly, if mouse is over a target node but less that betweenThreshold
		//		pixels from the top edge, dropping the dragged node will make it
		//		the target node's previous sibling rather than the target node's child.
		betweenThreshold: 0,

		// _nodePixelIndent: Integer
		//		Number of pixels to indent tree nodes (relative to parent node).
		//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
		//		and calling resize() or startup() on tree after it's in the DOM.
		_nodePixelIndent: 19,

		_publish: function(/*String*/ topicName, /*Object*/ message){
			// summary:
			//		Publish a message for this widget/topic
			topic.publish(this.id, lang.mixin({tree: this, event: topicName}, message || {}));	// publish
		},

		postMixInProperties: function(){
			this.tree = this;

			if(this.autoExpand){
				// There's little point in saving opened/closed state of nodes for a Tree
				// that initially opens all it's nodes.
				this.persist = false;
			}

			this._itemNodesMap = {};

			if(!this.cookieName && this.id){
				this.cookieName = this.id + "SaveStateCookie";
			}

			// Deferred that resolves when all the children have loaded.
			this.expandChildrenDeferred = new Deferred();

			// Promise that resolves when all pending operations complete.
			this.pendingCommandsPromise = this.expandChildrenDeferred.promise;

			this.inherited(arguments);
		},

		postCreate: function(){
			this._initState();

			// Catch events on TreeNodes
			var self = this;
			this.own(
				on(this.containerNode, on.selector(".dijitTreeNode", touch.enter), function(evt){
					self._onNodeMouseEnter(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeNode", touch.leave), function(evt){
					self._onNodeMouseLeave(registry.byNode(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick.press), function(evt){
					self._onNodePress(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", a11yclick), function(evt){
					self._onClick(registry.getEnclosingWidget(this), evt);
				}),
				on(this.containerNode, on.selector(".dijitTreeRow", "dblclick"), function(evt){
					self._onDblClick(registry.getEnclosingWidget(this), evt);
				})
			);

			// Create glue between store and Tree, if not specified directly by user
			if(!this.model){
				this._store2model();
			}

			// monitor changes to items
			this.own(
				aspect.after(this.model, "onChange", lang.hitch(this, "_onItemChange"), true),
				aspect.after(this.model, "onChildrenChange", lang.hitch(this, "_onItemChildrenChange"), true),
				aspect.after(this.model, "onDelete", lang.hitch(this, "_onItemDelete"), true)
			);

			this.inherited(arguments);

			if(this.dndController){
				// TODO: remove string support in 2.0.
				if(lang.isString(this.dndController)){
					this.dndController = lang.getObject(this.dndController);
				}
				var params = {};
				for(var i = 0; i < this.dndParams.length; i++){
					if(this[this.dndParams[i]]){
						params[this.dndParams[i]] = this[this.dndParams[i]];
					}
				}
				this.dndController = new this.dndController(this, params);
			}

			this._load();

			// onLoadDeferred should fire when all commands that are part of initialization have completed.
			// It will include all the set("paths", ...) commands that happen during initialization.
			this.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);

			this.onLoadDeferred.then(lang.hitch(this, "onLoad"));
		},

		_store2model: function(){
			// summary:
			//		User specified a store&query rather than model, so create model from store/query
			this._v10Compat = true;
			kernel.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

			var modelParams = {
				id: this.id + "_ForestStoreModel",
				store: this.store,
				query: this.query,
				childrenAttrs: this.childrenAttr
			};

			// Only override the model's mayHaveChildren() method if the user has specified an override
			if(this.params.mayHaveChildren){
				modelParams.mayHaveChildren = lang.hitch(this, "mayHaveChildren");
			}

			if(this.params.getItemChildren){
				modelParams.getChildren = lang.hitch(this, function(item, onComplete, onError){
					this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
				});
			}
			this.model = new ForestStoreModel(modelParams);

			// For backwards compatibility, the visibility of the root node is controlled by
			// whether or not the user has specified a label
			this.showRoot = Boolean(this.label);
		},

		onLoad: function(){
			// summary:
			//		Called when tree finishes loading and expanding.
			// description:
			//		If persist == true the loading may encompass many levels of fetches
			//		from the data store, each asynchronous.   Waits for all to finish.
			// tags:
			//		callback
		},

		_load: function(){
			// summary:
			//		Initial load of the tree.
			//		Load root node (possibly hidden) and it's children.
			this.model.getRoot(
				lang.hitch(this, function(item){
					var rn = (this.rootNode = this.tree._createTreeNode({
						item: item,
						tree: this,
						isExpandable: true,
						label: this.label || this.getLabel(item),
						labelType: this.model.labelType || "text",
						textDir: this.textDir,
						indent: this.showRoot ? 0 : -1
					}));

					if(!this.showRoot){
						rn.rowNode.style.display = "none";
						// if root is not visible, move tree role to the invisible
						// root node's containerNode, see #12135
						this.domNode.setAttribute("role", "presentation");
						this.domNode.removeAttribute("aria-expanded");
						this.domNode.removeAttribute("aria-multiselectable");

						// move the aria-label or aria-labelledby to the element with the role
						if(this["aria-label"]){
							rn.containerNode.setAttribute("aria-label", this["aria-label"]);
							this.domNode.removeAttribute("aria-label");
						}else if(this["aria-labelledby"]){
							rn.containerNode.setAttribute("aria-labelledby", this["aria-labelledby"]);
							this.domNode.removeAttribute("aria-labelledby");
						}
						rn.labelNode.setAttribute("role", "presentation");
						rn.labelNode.removeAttribute("aria-selected");
						rn.containerNode.setAttribute("role", "tree");
						rn.containerNode.setAttribute("aria-expanded", "true");
						rn.containerNode.setAttribute("aria-multiselectable", !this.dndController.singular);
					}else{
						this.domNode.setAttribute("aria-multiselectable", !this.dndController.singular);
						this.rootLoadingIndicator.style.display = "none";
					}

					this.containerNode.appendChild(rn.domNode);
					var identity = this.model.getIdentity(item);
					if(this._itemNodesMap[identity]){
						this._itemNodesMap[identity].push(rn);
					}else{
						this._itemNodesMap[identity] = [rn];
					}

					rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

					// Load top level children, and if persist==true, all nodes that were previously opened
					this._expandNode(rn).then(lang.hitch(this, function(){
						// Then, select the nodes specified by params.paths[], assuming Tree hasn't been deleted.
						if(!this._destroyed){
							this.rootLoadingIndicator.style.display = "none";
							this.expandChildrenDeferred.resolve(true);
						}
					}));
				}),
				lang.hitch(this, function(err){
					console.error(this, ": error loading root: ", err);
				})
			);
		},

		getNodesByItem: function(/*Item or id*/ item){
			// summary:
			//		Returns all tree nodes that refer to an item
			// returns:
			//		Array of tree nodes that refer to passed item

			if(!item){
				return [];
			}
			var identity = lang.isString(item) ? item : this.model.getIdentity(item);
			// return a copy so widget don't get messed up by changes to returned array
			return [].concat(this._itemNodesMap[identity]);
		},

		_setSelectedItemAttr: function(/*Item or id*/ item){
			this.set('selectedItems', [item]);
		},

		_setSelectedItemsAttr: function(/*Items or ids*/ items){
			// summary:
			//		Select tree nodes related to passed items.
			//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
			//		behavior is undefined. Use set('paths', ...) instead.
			var tree = this;
			return this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function(){
				var identities = array.map(items, function(item){
					return (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);
				});
				var nodes = [];
				array.forEach(identities, function(id){
					nodes = nodes.concat(tree._itemNodesMap[id] || []);
				});
				this.set('selectedNodes', nodes);
			}));
		},

		_setPathAttr: function(/*Item[]|String[]*/ path){
			// summary:
			//		Singular variant of _setPathsAttr
			if(path.length){
				return shimmedPromise(this.set("paths", [path]).then(function(paths){ return paths[0]; }));
			}else{
				// Empty list is interpreted as "select nothing"
				return shimmedPromise(this.set("paths", []).then(function(paths){ return paths[0]; }));
			}
		},

		_setPathsAttr: function(/*Item[][]|String[][]*/ paths){
			// summary:
			//		Select the tree nodes identified by passed paths.
			// paths:
			//		Array of arrays of items or item id's
			// returns:
			//		Promise to indicate when the set is complete

			var tree = this;

			function selectPath(path, nodes){
				// Traverse path, returning Promise for node at the end of the path.
				// The next path component should be among "nodes".
				var nextPath = path.shift();
				var nextNode = array.filter(nodes, function(node){
					return node.getIdentity() == nextPath;
				})[0];
				if(!!nextNode){
					if(path.length){
						return tree._expandNode(nextNode).then(function(){
							return selectPath(path, nextNode.getChildren());
						});
					}else{
						// Successfully reached the end of this path
						return nextNode;
					}
				}else{
					throw new Tree.PathError("Could not expand path at " + nextPath);
				}
			}

			// Let any previous set("path", ...) commands complete before this one starts.
			// TODO for 2.0: make the user do this wait themselves?
			return shimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(function(){
				// We may need to wait for some nodes to expand, so setting
				// each path will involve a Deferred. We bring those deferreds
				// together with a dojo/promise/all.
				return all(array.map(paths, function(path){
					// normalize path to use identity
					path = array.map(path, function(item){
						return lang.isString(item) ? item : tree.model.getIdentity(item);
					});

					if(path.length){
						return selectPath(path, [tree.rootNode]);
					}else{
						throw new Tree.PathError("Empty path");
					}
				}));
			}).then(function setNodes(newNodes){
				// After all expansion is finished, set the selection to last element from each path
				tree.set("selectedNodes", newNodes);
				return tree.paths;
			}));
		},

		_setSelectedNodeAttr: function(node){
			this.set('selectedNodes', [node]);
		},
		_setSelectedNodesAttr: function(nodes){
			// summary:
			//		Marks the specified TreeNodes as selected.
			// nodes: TreeNode[]
			//		TreeNodes to mark.
			this.dndController.setSelection(nodes);
		},


		expandAll: function(){
			// summary:
			//		Expand all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have expanded

			var _this = this;

			function expand(node){
				// Expand the node
				return _this._expandNode(node).then(function(){
					// When node has expanded, call expand() recursively on each non-leaf child
					var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					});

					// And when all those recursive calls finish, signal that I'm finished
					return all(array.map(childBranches, expand));
				});
			}

			return shimmedPromise(expand(this.rootNode));
		},

		collapseAll: function(){
			// summary:
			//		Collapse all nodes in the tree
			// returns:
			//		Promise that resolves when all nodes have collapsed

			var _this = this;

			function collapse(node){
				// Collapse children first
				var childBranches = array.filter(node.getChildren() || [], function(node){
						return node.isExpandable;
					}),
					defs = all(array.map(childBranches, collapse));

				// And when all those recursive calls finish, collapse myself, unless I'm the invisible root node,
				// in which case collapseAll() is finished
				if(!node.isExpanded || (node == _this.rootNode && !_this.showRoot)){
					return defs;
				}else{
					// When node has collapsed, signal that call is finished
					return defs.then(function(){
						return _this._collapseNode(node);
					});
				}
			}

			return shimmedPromise(collapse(this.rootNode));
		},

		////////////// Data store related functions //////////////////////
		// These just get passed to the model; they are here for back-compat

		mayHaveChildren: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function to tell if an item has or may have children.
			//		Controls whether or not +/- expando icon is shown.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			// tags:
			//		deprecated
		},

		getItemChildren: function(/*===== parentItem, onComplete =====*/){
			// summary:
			//		Deprecated.   This should be specified on the model itself.
			//
			//		Overridable function that return array of child items of given parent item,
			//		or if parentItem==null then return top items in tree
			// tags:
			//		deprecated
		},

		///////////////////////////////////////////////////////
		// Functions for converting an item to a TreeNode
		getLabel: function(/*dojo/data/Item*/ item){
			// summary:
			//		Overridable function to get the label for a tree node (given the item)
			// tags:
			//		extension
			return this.model.getLabel(item);	// String
		},

		getIconClass: function(/*dojo/data/Item*/ item, /*Boolean*/ opened){
			// summary:
			//		Overridable function to return CSS class name to display icon
			// tags:
			//		extension
			return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
		},

		getLabelClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getRowClass: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS class name to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns: String
			//		CSS class name
			// tags:
			//		extension
		},

		getIconStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display icon
			// item: dojo/data/Item
			// opened: Boolean
			// returns: Object
			//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
			// tags:
			//		extension
		},

		getLabelStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display label
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
			// tags:
			//		extension
		},

		getRowStyle: function(/*===== item, opened =====*/){
			// summary:
			//		Overridable function to return CSS styles to display row
			// item: dojo/data/Item
			// opened: Boolean
			// returns:
			//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
			// tags:
			//		extension
		},

		getTooltip: function(/*dojo/data/Item*/ /*===== item =====*/){
			// summary:
			//		Overridable function to get the tooltip for a tree node (given the item)
			// tags:
			//		extension
			return "";	// String
		},

		/////////// Keyboard and Mouse handlers ////////////////////


		_onDownArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		down arrow pressed; get next visible node, set focus there

			var nextNode = this._getNext(node);
			if(nextNode && nextNode.isTreeNode){
				this.focusNode(nextNode);
			}
		},

		_onUpArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Up arrow pressed; move to previous visible node

			// if younger siblings
			var previousSibling = node.getPreviousSibling();
			if(previousSibling){
				node = previousSibling;
				// if the previous node is expanded, dive in deep
				while(node.isExpandable && node.isExpanded && node.hasChildren()){
					// move to the last child
					var children = node.getChildren();
					node = children[children.length - 1];
				}
			}else{
				// if this is the first child, return the parent
				// unless the parent is the root of a tree with a hidden root
				var parent = node.getParent();
				if(!(!this.showRoot && parent === this.rootNode)){
					node = parent;
				}
			}

			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_onRightArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Right arrow pressed; go to child node

			// if not expanded, expand, else move to 1st child
			if(node.isExpandable && !node.isExpanded){
				this._expandNode(node);
			}else if(node.hasChildren()){
				node = node.getChildren()[0];
				if(node && node.isTreeNode){
					this.focusNode(node);
				}
			}
		},

		_onLeftArrow: function(/*Event*/ evt, /*TreeNode*/ node){
			// summary:
			//		Left arrow pressed.
			//		If not collapsed, collapse, else move to parent.

			if(node.isExpandable && node.isExpanded){
				this._collapseNode(node);
			}else{
				var parent = node.getParent();
				if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
					this.focusNode(parent);
				}
			}
		},

		focusLastChild: function(){
			// summary:
			//		End key pressed; go to last visible node.

			var node = this._getLast();
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		},

		_getFirst: function(){
			// summary:
			//		Returns the first child.
			// tags:
			//		abstract extension
			return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
		},

		_getLast: function(){
			// summary:
			//		Returns the last descendant.
			// tags:
			//		abstract extension
			var node = this.rootNode;
			while(node.isExpanded){
				var c = node.getChildren();
				if(!c.length){
					break;
				}
				node = c[c.length - 1];
			}
			return node;
		},

		// Tree only searches forward so dir parameter is unused
		_getNext: function(node){
			// summary:
			//		Returns the next descendant, compared to "child".
			// node: Widget
			//		The current widget
			// tags:
			//		abstract extension

			if(node.isExpandable && node.isExpanded && node.hasChildren()){
				// if this is an expanded node, get the first child
				return node.getChildren()[0];		// TreeNode
			}else{
				// find a parent node with a sibling
				while(node && node.isTreeNode){
					var returnNode = node.getNextSibling();
					if(returnNode){
						return returnNode;		// TreeNode
					}
					node = node.getParent();
				}
				return null;
			}
		},

		// Implement _KeyNavContainer.childSelector, to identify which nodes are navigable
		childSelector: ".dijitTreeRow",

		isExpandoNode: function(node, widget){
			// summary:
			//		check whether a dom node is the expandoNode for a particular TreeNode widget
			return dom.isDescendant(node, widget.expandoNode) || dom.isDescendant(node, widget.expandoNodeText);
		},

		_onNodePress: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// Touching a node should focus it, even if you touch the expando node or the edges rather than the label.
			// Especially important to avoid _KeyNavMixin._onContainerFocus() causing the previously focused TreeNode
			// to get focus
			this.focusNode(nodeWidget);
		},

		__click: function(/*TreeNode*/ nodeWidget, /*Event*/ e, /*Boolean*/doOpen, /*String*/func){
			var domElement = e.target,
				isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

			if(nodeWidget.isExpandable && (doOpen || isExpandoClick)){
				// expando node was clicked, or label of a folder node was clicked; open it
				this._onExpandoClick({node: nodeWidget});
			}else{
				this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e });
				this[func](nodeWidget.item, nodeWidget, e);
				this.focusNode(nodeWidget);
			}
			e.stopPropagation();
			e.preventDefault();
		},
		_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnClick, 'onClick');
		},
		_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
			// summary:
			//		Translates double-click events into commands for the controller to process
			this.__click(nodeWidget, e, this.openOnDblClick, 'onDblClick');
		},

		_onExpandoClick: function(/*Object*/ message){
			// summary:
			//		User clicked the +/- icon; expand or collapse my children.
			var node = message.node;

			// If we are collapsing, we might be hiding the currently focused node.
			// Also, clicking the expando node might have erased focus from the current node.
			// For simplicity's sake just focus on the node with the expando.
			this.focusNode(node);

			if(node.isExpanded){
				this._collapseNode(node);
			}else{
				this._expandNode(node);
			}
		},

		onClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onDblClick: function(/*===== item, node, evt =====*/){
			// summary:
			//		Callback when a tree node is double-clicked
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// evt: Event
			//		The event
			// tags:
			//		callback
		},
		onOpen: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is opened
			// item: dojo/data/Item
			// node: TreeNode
			// tags:
			//		callback
		},
		onClose: function(/*===== item, node =====*/){
			// summary:
			//		Callback when a node is closed
			// item: Object
			//		Object from the dojo/store corresponding to this TreeNode
			// node: TreeNode
			//		The TreeNode itself
			// tags:
			//		callback
		},

		_getNextNode: function(node){
			// summary:
			//		Get next visible node

			kernel.deprecated(this.declaredClass + "::_getNextNode(node) is deprecated. Use _getNext(node) instead.", "", "2.0");
			return this._getNext(node);
		},

		_getRootOrFirstNode: function(){
			// summary:
			//		Get first visible node
			kernel.deprecated(this.declaredClass + "::_getRootOrFirstNode() is deprecated. Use _getFirst() instead.", "", "2.0");
			return this._getFirst();
		},

		_collapseNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to collapse the node
			// returns:
			//		Promise that resolves when the node has finished closing

			if(node._expandNodeDeferred){
				delete node._expandNodeDeferred;
			}

			if(node.state == "Loading"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			if(node.isExpanded){
				var ret = node.collapse();

				this.onClose(node.item, node);
				this._state(node, false);

				this._startPaint(ret);	// after this finishes, need to reset widths of TreeNodes

				return ret;
			}
		},

		_expandNode: function(/*TreeNode*/ node){
			// summary:
			//		Called when the user has requested to expand the node
			// returns:
			//		Promise that resolves when the node is loaded and opened and (if persist=true) all it's descendants
			//		that were previously opened too

			if(node._expandNodeDeferred){
				// there's already an expand in progress, or completed, so just return
				return node._expandNodeDeferred;	// dojo/Deferred
			}

			var model = this.model,
				item = node.item,
				_this = this;

			// Load data if it's not already loaded
			if(!node._loadDeferred){
				// need to load all the children before expanding
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				node._loadDeferred = new Deferred();

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						node.setChildItems(items).then(function(){
							node._loadDeferred.resolve(items);
						});
					},
					function(err){
						console.error(_this, ": error loading " + node.label + " children: ", err);
						node._loadDeferred.reject(err);
					}
				);
			}

			// Expand the node after data has loaded
			var def = node._loadDeferred.then(lang.hitch(this, function(){
				var def2 = node.expand();

				// seems like these should delayed until node.expand() completes, but left here for back-compat about
				// when this.isOpen flag gets set (ie, at the beginning of the animation)
				this.onOpen(node.item, node);
				this._state(node, true);

				return def2;
			}));

			this._startPaint(def);	// after this finishes, need to reset widths of TreeNodes

			return def;	// dojo/promise/Promise
		},

		////////////////// Miscellaneous functions ////////////////

		focusNode: function(/* _tree.Node */ node){
			// summary:
			//		Focus on the specified node (which must be visible)
			// tags:
			//		protected

			var scrollLeft = this.domNode.scrollLeft;
			this.focusChild(node);
			this.domNode.scrollLeft = scrollLeft;
		},

		_onNodeMouseEnter: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse is over a node (onmouseenter event),
			//		this is monitored by the DND code
		},

		_onNodeMouseLeave: function(/*dijit/_WidgetBase*/ /*===== node =====*/){
			// summary:
			//		Called when mouse leaves a node (onmouseleave event),
			//		this is monitored by the DND code
		},

		//////////////// Events from the model //////////////////////////

		_onItemChange: function(/*Item*/ item){
			// summary:
			//		Processes notification of a change to an item's scalar values like label
			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				var label = this.getLabel(item),
					tooltip = this.getTooltip(item);
				array.forEach(nodes, function(node){
					node.set({
						item: item, // theoretically could be new JS Object representing same item
						label: label,
						tooltip: tooltip
					});
					node._updateItemClasses(item);
				});
			}
		},

		_onItemChildrenChange: function(/*dojo/data/Item*/ parent, /*dojo/data/Item[]*/ newChildrenList){
			// summary:
			//		Processes notification of a change to an item's children
			var model = this.model,
				identity = model.getIdentity(parent),
				parentNodes = this._itemNodesMap[identity];

			if(parentNodes){
				array.forEach(parentNodes, function(parentNode){
					parentNode.setChildItems(newChildrenList);
				});
			}
		},

		_onItemDelete: function(/*Item*/ item){
			// summary:
			//		Processes notification of a deletion of an item.
			//		Not called from new dojo.store interface but there's cleanup code in setChildItems() instead.

			var model = this.model,
				identity = model.getIdentity(item),
				nodes = this._itemNodesMap[identity];

			if(nodes){
				array.forEach(nodes, function(node){
					// Remove node from set of selected nodes (if it's selected)
					this.dndController.removeTreeNode(node);

					var parent = node.getParent();
					if(parent){
						// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
						parent.removeChild(node);
					}

					// If we've orphaned the focused node then move focus to the root node
					if(this.lastFocusedChild && !dom.isDescendant(this.lastFocusedChild, this.domNode)){
						delete this.lastFocusedChild;
					}
					if(this.focusedChild && !dom.isDescendant(this.focusedChild, this.domNode)){
						this.focus();
					}

					node.destroyRecursive();
				}, this);
				delete this._itemNodesMap[identity];
			}
		},

		/////////////// Miscellaneous funcs

		_initState: function(){
			// summary:
			//		Load in which nodes should be opened automatically
			this._openedNodes = {};
			if(this.persist && this.cookieName){
				var oreo = cookie(this.cookieName);
				if(oreo){
					array.forEach(oreo.split(','), function(item){
						this._openedNodes[item] = true;
					}, this);
				}
			}
		},

		_state: function(node, expanded){
			// summary:
			//		Query or set expanded state for an node
			if(!this.persist){
				return false;
			}
			var path = array.map(node.getTreePath(),function(item){
				return this.model.getIdentity(item);
			}, this).join("/");
			if(arguments.length === 1){
				return this._openedNodes[path];
			}else{
				if(expanded){
					this._openedNodes[path] = true;
				}else{
					delete this._openedNodes[path];
				}
				this._saveExpandedNodes();
			}
		},

		_saveExpandedNodes: function(){
			if(this.persist && this.cookieName){
				var ary = [];
				for(var id in this._openedNodes){
					ary.push(id);
				}
				cookie(this.cookieName, ary.join(","), {expires: 365});
			}
		},

		destroy: function(){
			if(this._curSearch){
				this._curSearch.timer.remove();
				delete this._curSearch;
			}
			if(this.rootNode){
				this.rootNode.destroyRecursive();
			}
			if(this.dndController && !lang.isString(this.dndController)){
				this.dndController.destroy();
			}
			this.rootNode = null;
			this.inherited(arguments);
		},

		destroyRecursive: function(){
			// A tree is treated as a leaf, not as a node with children (like a grid),
			// but defining destroyRecursive for back-compat.
			this.destroy();
		},

		resize: function(changeSize){
			if(changeSize){
				domGeometry.setMarginBox(this.domNode, changeSize);
			}

			// The main JS sizing involved w/tree is the indentation, which is specified
			// in CSS and read in through this dummy indentDetector node (tree must be
			// visible and attached to the DOM to read this).
			// If the Tree is hidden domGeometry.position(this.tree.indentDetector).w will return 0, in which case just
			// keep the default value.
			this._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w || this._nodePixelIndent;

			// resize() may be called before this.rootNode is created, so wait until it's available
			this.expandChildrenDeferred.then(lang.hitch(this, function(){
				// If tree has already loaded, then reset indent for all the nodes
				this.rootNode.set('indent', this.showRoot ? 0 : -1);

				// Also, adjust widths of all rows to match width of Tree
				this._adjustWidths();
			}));
		},

		_outstandingPaintOperations: 0,
		_startPaint: function(/*Promise|Boolean*/ p){
			// summary:
			//		Called at the start of an operation that will change what's displayed.
			// p:
			//		Promise that tells when the operation will complete.  Alternately, if it's just a Boolean, it signifies
			//		that the operation was synchronous, and already completed.

			this._outstandingPaintOperations++;
			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			var oc = lang.hitch(this, function(){
				this._outstandingPaintOperations--;

				if(this._outstandingPaintOperations <= 0 && !this._adjustWidthsTimer && this._started){
					// Use defer() to avoid a width adjustment when another operation will immediately follow,
					// such as a sequence of opening a node, then it's children, then it's grandchildren, etc.
					this._adjustWidthsTimer = this.defer("_adjustWidths");
				}
			});
			when(p, oc, oc);
		},

		_adjustWidths: function(){
			// summary:
			//		Size container to match widest TreeNode, so that highlighting with scrolling works (#13141, #16132)

			if(this._adjustWidthsTimer){
				this._adjustWidthsTimer.remove();
				delete this._adjustWidthsTimer;
			}

			this.containerNode.style.width = "auto";
			this.containerNode.style.width = this.domNode.scrollWidth > this.domNode.offsetWidth ? "auto" : "100%";
		},

		_createTreeNode: function(/*Object*/ args){
			// summary:
			//		creates a TreeNode
			// description:
			//		Developers can override this method to define their own TreeNode class;
			//		However it will probably be removed in a future release in favor of a way
			//		of just specifying a widget for the label, rather than one that contains
			//		the children too.
			return new TreeNode(args);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the previously focused child, or first child.
			//		Some applications may want to change this method to focus the [first] selected child.

			if(this.lastFocusedChild){
				this.focusNode(this.lastFocusedChild);
			}else{
				this.focusFirstChild();
			}
		}
	});

	if(has("dojo-bidi")){
		Tree.extend({
			_setTextDirAttr: function(textDir){
				if(textDir && this.textDir != textDir){
					this._set("textDir", textDir);
					this.rootNode.set("textDir", textDir);
				}
			}
		});
	}

	Tree.PathError = createError("TreePathError");
	Tree._TreeNode = TreeNode;	// for monkey patching or creating subclasses of TreeNode

	return Tree;
});

},
'dijit/form/Button':function(){
define([
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/has", //  1 
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html",
	"../a11yclick"	// template uses ondijitclick
], function(require, declare, domClass, has, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

	// module:
	//		dijit/form/Button

	// Back compat w/1.6, remove for 2.0
	if( 1 ){
		ready(0, function(){
			var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	var Button = declare("dijit.form.Button" + (has("dojo-bidi") ? "_NoBidi" : ""), [_FormWidget, _ButtonMixin], {
		// summary:
		//		Basically the same thing as a normal HTML button, but with special styling.
		// description:
		//		Buttons can display a label, an icon, or both.
		//		A label should always be specified (through innerHTML) or the label
		//		attribute.  It can be hidden via showLabel=false.
		// example:
		// |	<button data-dojo-type="dijit/form/Button" onClick="...">Hello world</button>
		//
		// example:
		// |	var button1 = new Button({label: "hello world", onClick: foo});
		// |	dojo.body().appendChild(button1.domNode);

		// showLabel: Boolean
		//		Set this to true to hide the label text and display only the icon.
		//		(If showLabel=false then iconClass must be specified.)
		//		Especially useful for toolbars.
		//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
		//
		//		The exception case is for computers in high-contrast mode, where the label
		//		will still be displayed, since the icon doesn't appear.
		showLabel: true,

		// iconClass: String
		//		Class to apply to DOMNode in button to make it display an icon
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		baseClass: "dijitButton",

		templateString: template,

		// Map widget attributes to DOMNode attributes.
		_setValueAttr: "valueNode",
		_setNameAttr: function(name){
			// avoid breaking existing subclasses where valueNode undefined.  Perhaps in 2.0 require it to be defined?
			if(this.valueNode){
				this.valueNode.setAttribute("name", name);
			}
		},

		_fillContent: function(/*DomNode*/ source){
			// Overrides _Templated._fillContent().
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			// TODO: remove the method in 2.0, parser will do it all for me
			if(source && (!this.params || !("label" in this.params))){
				var sourceLabel = lang.trim(source.innerHTML);
				if(sourceLabel){
					this.label = sourceLabel; // _applyAttributes will be called after buildRendering completes to update the DOM
				}
			}
		},

		_setShowLabelAttr: function(val){
			if(this.containerNode){
				domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
			}
			this._set("showLabel", val);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.  Use set('label', ...) instead.
			kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		Set the label (text) of the button; takes an HTML string.
			//		If the label is hidden (showLabel=false) then and no title has
			//		been specified, then label is also set as title attribute of icon.
			this.inherited(arguments);
			if(!this.showLabel && !("title" in this.params)){
				this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		}
	});

	if(has("dojo-bidi")){
		Button = declare("dijit.form.Button", Button, {
			_setLabelAttr: function(/*String*/ content){
				this.inherited(arguments);
				if(this.titleNode.title){
					this.applyTextDir(this.titleNode, this.titleNode.title);
				}
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(this._created && this.textDir != textDir){
					this._set("textDir", textDir);
					this._setLabelAttr(this.label); // call applyTextDir on both focusNode and titleNode
				}
			}
		});
	}

	return Button;
});

},
'curam/ui/OpenTabEvent':function(){
/*
 * Copyright 2010 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

/**
 * @name curam.ui.OpenTabEvent
 * @namespace The open tab event.
 */
define(["dojo/_base/declare",
        "curam/ui/PageRequest"
        ], function(declare, PageRequest) {

/*
 * Modification History
 * --------------------
 * 02-May-2012  MK  [CR00323691] Use new Dojo AMD format.
 * 16-Jan-2011  DG  [CR00242400] Removed "requires". Now handled by cdej.js.
 * 03-Dec-2010  DG  [CR00217921] Constructor now takes a TabDescriptor object
 *                    and tabs can request to be opened in the background.
 * 29-Jul-2010  PK  [CR00211736] Moved from tab-app-controller.js to this file.
 */

var OpenTabEvent = declare("curam.ui.OpenTabEvent", null, 
/**
 * @lends curam.ui.OpenTabEvent
 */
{
  /**
   * Create a new event to open a tab. This combines a tab descriptor with a
   * UIM page request. If no UIM page request is provided, one will be derived
   * from the tab descriptor.
   *
   * @param {curam.tab.TabDescriptor} tabDescriptor The objects describing the
   *   tab and it content.
   * @param {curam.ui.PageRequest} uimPageRequest The object representing the
   *   page request.
   * @param {Boolean} openInBackgrond true to open the new tab in the
   *   background. The currently selected tab will remain selected. This is
   *   used when restoring a tab session.
   */
  constructor: function(tabDescriptor, uimPageRequest, openInBackground) {
    this.tabDescriptor = tabDescriptor;
    this.openInBackground = openInBackground ? true : false;
    if (uimPageRequest) {
      this.uimPageRequest = uimPageRequest;
    } else {
      // The request will be reconstructed from the tab descriptor.
      this.uimPageRequest
          = new PageRequest(tabDescriptor, tabDescriptor.isHomePage);
    }
  }
});

return OpenTabEvent;
});

},
'dojo/parser':function(){
define([
	"require", "./_base/kernel", "./_base/lang", "./_base/array", "./_base/config", "./dom", "./_base/window",
		"./_base/url", "./aspect", "./promise/all", "./date/stamp", "./Deferred", "./has", "./query", "./on", "./ready"
], function(require, dojo, dlang, darray, config, dom, dwindow, _Url, aspect, all, dates, Deferred, has, query, don, ready){

	// module:
	//		dojo/parser

	new Date("X"); // workaround for #11279, new Date("") == NaN

	// data-dojo-props etc. is not restricted to JSON, it can be any javascript
	function myEval(text){
		return eval("(" + text + ")");
	}

	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	var extendCnt = 0;
	aspect.after(dlang, "extend", function(){
		extendCnt++;
	}, true);

	function getNameMap(ctor){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = ctor._nameCaseMap, proto = ctor.prototype;

		// Create the map if it's undefined.
		// Refresh the map if a superclass was possibly extended with new methods since the map was created.
		if(!map || map._extendCnt < extendCnt){
			map = ctor._nameCaseMap = {};
			for(var name in proto){
				if(name.charAt(0) === "_"){
					continue;
				}	// skip internal properties
				map[name.toLowerCase()] = name;
			}
			map._extendCnt = extendCnt;
		}
		return map;
	}

	// Map from widget name or list of widget names(ex: "dijit/form/Button,acme/MyMixin") to a constructor.
	var _ctorMap = {};

	function getCtor(/*String[]*/ types, /*Function?*/ contextRequire){
		// summary:
		//		Retrieves a constructor.  If the types array contains more than one class/MID then the
		//		subsequent classes will be mixed into the first class and a unique constructor will be
		//		returned for that array.

		var ts = types.join();
		if(!_ctorMap[ts]){
			var mixins = [];
			for(var i = 0, l = types.length; i < l; i++){
				var t = types[i];
				// TODO: Consider swapping getObject and require in the future
				mixins[mixins.length] = (_ctorMap[t] = _ctorMap[t] || (dlang.getObject(t) || (~t.indexOf('/') &&
					(contextRequire ? contextRequire(t) : require(t)))));
			}
			var ctor = mixins.shift();
			_ctorMap[ts] = mixins.length ? (ctor.createSubclass ? ctor.createSubclass(mixins) : ctor.extend.apply(ctor, mixins)) : ctor;
		}

		return _ctorMap[ts];
	}

	var parser = {
		// summary:
		//		The Dom/Widget parsing package

		_clearCache: function(){
			// summary:
			//		Clear cached data.   Used mainly for benchmarking.
			extendCnt++;
			_ctorMap = {};
		},

		_functionFromScript: function(script, attrData){
			// summary:
			//		Convert a `<script type="dojo/method" args="a, b, c"> ... </script>`
			//		into a function
			// script: DOMNode
			//		The `<script>` DOMNode
			// attrData: String
			//		For HTML5 compliance, searches for attrData + "args" (typically
			//		"data-dojo-args") instead of "args"
			var preamble = "",
				suffix = "",
				argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args")),
				withStr = script.getAttribute("with");

			// Convert any arguments supplied in script tag into an array to be passed to the
			var fnArgs = (argsStr || "").split(/\s*,\s*/);

			if(withStr && withStr.length){
				darray.forEach(withStr.split(/\s*,\s*/), function(part){
					preamble += "with(" + part + "){";
					suffix += "}";
				});
			}

			return new Function(fnArgs, preamble + script.innerHTML + suffix);
		},

		instantiate: function(nodes, mixin, options){
			// summary:
			//		Takes array of nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of DOM nodes
			// mixin: Object?
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object?
			//		An object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returns:
			//		Array of instances.

			mixin = mixin || {};
			options = options || {};

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			var list = [];
			darray.forEach(nodes, function(node){
				var type = dojoType in mixin ? mixin[dojoType] : node.getAttribute(dataDojoType) || node.getAttribute(dojoType);
				if(type){
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					list.push({
						node: node,
						types: types
					});
				}
			});

			// Instantiate the nodes and return the list of instances.
			return this._instantiate(list, mixin, options);
		},

		_instantiate: function(nodes, mixin, options, returnPromise){
			// summary:
			//		Takes array of objects representing nodes, and turns them into class instances and
			//		potentially calls a startup method to allow them to connect with
			//		any children.
			// nodes: Array
			//		Array of objects like
			//	|		{
			//	|			ctor: Function (may be null)
			//	|			types: ["dijit/form/Button", "acme/MyMixin"] (used if ctor not specified)
			//	|			node: DOMNode,
			//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
			//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
			//	|		}
			// mixin: Object
			//		An object that will be mixed in with each node in the array.
			//		Values in the mixin will override values in the node, if they
			//		exist.
			// options: Object
			//		An options object used to hold kwArgs for instantiation.
			//		See parse.options argument for details.
			// returnPromise: Boolean
			//		Return a Promise rather than the instance; supports asynchronous widget creation.
			// returns:
			//		Array of instances, or if returnPromise is true, a promise for array of instances
			//		that resolves when instances have finished initializing.

			// Call widget constructors.   Some may be asynchronous and return promises.
			var thelist = darray.map(nodes, function(obj){
				var ctor = obj.ctor || getCtor(obj.types, options.contextRequire);
				// If we still haven't resolved a ctor, it is fatal now
				if(!ctor){
					throw new Error("Unable to resolve constructor for: '" + obj.types.join() + "'");
				}
				return this.construct(ctor, obj.node, mixin, options, obj.scripts, obj.inherited);
			}, this);

			// After all widget construction finishes, call startup on each top level instance if it makes sense (as for
			// widgets).  Parent widgets will recursively call startup on their (non-top level) children
			function onConstruct(thelist){
				if(!mixin._started && !options.noStart){
					darray.forEach(thelist, function(instance){
						if(typeof instance.startup === "function" && !instance._started){
							instance.startup();
						}
					});
				}

				return thelist;
			}

			if(returnPromise){
				return all(thelist).then(onConstruct);
			}else{
				// Back-compat path, remove for 2.0
				return onConstruct(thelist);
			}
		},

		construct: function(ctor, node, mixin, options, scripts, inherited){
			// summary:
			//		Calls new ctor(params, node), where params is the hash of parameters specified on the node,
			//		excluding data-dojo-type and data-dojo-mixins.   Does not call startup().
			// ctor: Function
			//		Widget constructor.
			// node: DOMNode
			//		This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.
			// mixin: Object?
			//		Attributes in this object will be passed as parameters to ctor,
			//		overriding attributes specified on the node.
			// options: Object?
			//		An options object used to hold kwArgs for instantiation.   See parse.options argument for details.
			// scripts: DomNode[]?
			//		Array of `<script type="dojo/*">` DOMNodes.  If not specified, will search for `<script>` tags inside node.
			// inherited: Object?
			//		Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.
			// returns:
			//		Instance or Promise for the instance, if markupFactory() itself returned a promise

			var proto = ctor && ctor.prototype;
			options = options || {};

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(options.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, options.defaults);
			}
			if(inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else if(has("dom-attributes-specified-flag")){
				// Special processing needed for IE8, to skip a few faux values in attributes[]
				attributes = darray.filter(node.attributes, function(a){
					return a.specified;
				});
			}else{
				// Special path for IE6-7, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*\s*/, "").replace(/\s*>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
							node.getAttribute(lcName) : node.getAttributeNode(lcName).value
					};
				});
			}

			// Hash to convert scoped attribute name (ex: data-dojo17-params) to something friendly (ex: data-dojo-params)
			// TODO: remove scope for 2.0
			var scope = options.scope || dojo._scopeName,
				attrData = "data-" + scope + "-", // typically "data-dojo-"
				hash = {};
			if(scope !== "dojo"){
				hash[attrData + "props"] = "data-dojo-props";
				hash[attrData + "type"] = "data-dojo-type";
				hash[attrData + "mixins"] = "data-dojo-mixins";
				hash[scope + "type"] = "dojoType";
				hash[attrData + "id"] = "data-dojo-id";
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i = 0, item, funcAttrs = [], jsname, extra;
			while(item = attributes[i++]){
				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				switch(hash[lcName] || lcName){
				// Already processed, just ignore
				case "data-dojo-type":
				case "dojotype":
				case "data-dojo-mixins":
					break;

				// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
				case "data-dojo-props":
					extra = value;
					break;

				// data-dojo-id or jsId. TODO: drop jsId in 2.0
				case "data-dojo-id":
				case "jsid":
					jsname = value;
					break;

				// For the benefit of _Templated
				case "data-dojo-attach-point":
				case "dojoattachpoint":
					params.dojoAttachPoint = value;
					break;
				case "data-dojo-attach-event":
				case "dojoattachevent":
					params.dojoAttachEvent = value;
					break;

				// Special parameter handling needed for IE
				case "class":
					params["class"] = node.className;
					break;
				case "style":
					params["style"] = node.style && node.style.cssText;
					break;
				default:
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = getNameMap(ctor);
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a global function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							funcAttrs.push(name);	// prevent "double connect", see #15026
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof _Url) ? (dojo.baseUrl + value) :
								myEval(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Remove function attributes from DOMNode to prevent "double connect" problem, see #15026.
			// Do this as a separate loop since attributes[] is often a live collection (depends on the browser though).
			for(var j = 0; j < funcAttrs.length; j++){
				var lcfname = funcAttrs[j].toLowerCase();
				node.removeAttribute(lcfname);
				node[lcfname] = null;
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = myEval.call(options.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			// Get <script> nodes associated with this widget, if they weren't specified explicitly
			if(!scripts){
				scripts = (ctor && (ctor._noScript || proto._noScript) ? [] : query("> script[type^='dojo/']", node));
			}

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" data-dojo-event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation,
			// and likewise with <script type="dojo/aspect" data-dojo-method="foo">
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var aspects = [],	// aspects to connect after instantiation
				calls = [],		// functions to call after instantiation
				watches = [],  // functions to watch after instantiation
				ons = []; // functions to on after instantiation

			if(scripts){
				for(i = 0; i < scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						method = script.getAttribute(attrData + "method"),
						advice = script.getAttribute(attrData + "advice"),
						scriptType = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(scriptType == "dojo/connect"){
							aspects.push({ method: event, func: nf });
						}else if(scriptType == "dojo/on"){
							ons.push({ event: event, func: nf });
						}else{
							// <script type="dojo/method" data-dojo-event="foo">
							// TODO for 2.0: use data-dojo-method="foo" instead (also affects dijit/Declaration)
							params[event] = nf;
						}
					}else if(scriptType == "dojo/aspect"){
						aspects.push({ method: method, advice: advice, func: nf });
					}else if(scriptType == "dojo/watch"){
						watches.push({ prop: prop, func: nf });
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);

			function onInstantiate(instance){
				// map it to the JS namespace if that makes sense
				if(jsname){
					dlang.setObject(jsname, instance);
				}

				// process connections and startup functions
				for(i = 0; i < aspects.length; i++){
					aspect[aspects[i].advice || "after"](instance, aspects[i].method, dlang.hitch(instance, aspects[i].func), true);
				}
				for(i = 0; i < calls.length; i++){
					calls[i].call(instance);
				}
				for(i = 0; i < watches.length; i++){
					instance.watch(watches[i].prop, watches[i].func);
				}
				for(i = 0; i < ons.length; i++){
					don(instance, ons[i].event, ons[i].func);
				}

				return instance;
			}

			if(instance.then){
				return instance.then(onInstantiate);
			}else{
				return onInstantiate(instance);
			}
		},

		scan: function(root, options){
			// summary:
			//		Scan a DOM tree and return an array of objects representing the DOMNodes
			//		that need to be turned into widgets.
			// description:
			//		Search specified node (or document root node) recursively for class instances
			//		and return an array of objects that represent potential widgets to be
			//		instantiated. Searches for either data-dojo-type="MID" or dojoType="MID" where
			//		"MID" is a module ID like "dijit/form/Button" or a fully qualified Class name
			//		like "dijit/form/Button".  If the MID is not currently available, scan will
			//		attempt to require() in the module.
			//
			//		See parser.parse() for details of markup.
			// root: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object
			//		a kwArgs options object, see parse() for details
			//
			// returns: Promise
			//		A promise that is resolved with the nodes that have been parsed.

			var list = [], // Output List
				mids = [], // An array of modules that are not yet loaded
				midsHash = {}; // Used to keep the mids array unique

			var dojoType = (options.scope || dojo._scopeName) + "Type", // typically "dojoType"
				attrData = "data-" + (options.scope || dojo._scopeName) + "-", // typically "data-dojo-"
				dataDojoType = attrData + "type", // typically "data-dojo-type"
				dataDojoTextDir = attrData + "textdir", // typically "data-dojo-textdir"
				dataDojoMixins = attrData + "mixins";					// typically "data-dojo-mixins"

			// Info on DOMNode currently being processed
			var node = root.firstChild;

			// Info on parent of DOMNode currently being processed
			//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
			//	- parent: pointer to identical structure for my parent (or null if no parent)
			//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
			var inherited = options.inherited;
			if(!inherited){
				function findAncestorAttr(node, attr){
					return (node.getAttribute && node.getAttribute(attr)) ||
						(node.parentNode && findAncestorAttr(node.parentNode, attr));
				}

				inherited = {
					dir: findAncestorAttr(root, "dir"),
					lang: findAncestorAttr(root, "lang"),
					textDir: findAncestorAttr(root, dataDojoTextDir)
				};
				for(var key in inherited){
					if(!inherited[key]){
						delete inherited[key];
					}
				}
			}

			// Metadata about parent node
			var parent = {
				inherited: inherited
			};

			// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
			var scripts;

			// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
			var scriptsOnly;

			function getEffective(parent){
				// summary:
				//		Get effective dir, lang, textDir settings for specified obj
				//		(matching "parent" object structure above), and do caching.
				//		Take care not to return null entries.
				if(!parent.inherited){
					parent.inherited = {};
					var node = parent.node,
						grandparent = getEffective(parent.parent);
					var inherited = {
						dir: node.getAttribute("dir") || grandparent.dir,
						lang: node.getAttribute("lang") || grandparent.lang,
						textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
					};
					for(var key in inherited){
						if(inherited[key]){
							parent.inherited[key] = inherited[key];
						}
					}
				}
				return parent.inherited;
			}

			// DFS on DOM tree, collecting nodes with data-dojo-type specified.
			while(true){
				if(!node){
					// Finished this level, continue to parent's next sibling
					if(!parent || !parent.node){
						break;
					}
					node = parent.node.nextSibling;
					scriptsOnly = false;
					parent = parent.parent;
					scripts = parent.scripts;
					continue;
				}

				if(node.nodeType != 1){
					// Text or comment node, skip to next sibling
					node = node.nextSibling;
					continue;
				}

				if(scripts && node.nodeName.toLowerCase() == "script"){
					// Save <script type="dojo/..."> for parent, then continue to next sibling
					type = node.getAttribute("type");
					if(type && /^dojo\/\w/i.test(type)){
						scripts.push(node);
					}
					node = node.nextSibling;
					continue;
				}
				if(scriptsOnly){
					// scriptsOnly flag is set, we have already collected scripts if the parent wants them, so now we shouldn't
					// continue further analysis of the node and will continue to the next sibling
					node = node.nextSibling;
					continue;
				}

				// Check for data-dojo-type attribute, fallback to backward compatible dojoType
				// TODO: Remove dojoType in 2.0
				var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

				// Short circuit for leaf nodes containing nothing [but text]
				var firstChild = node.firstChild;
				if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
					node = node.nextSibling;
					continue;
				}

				// Meta data about current node
				var current;

				var ctor = null;
				if(type){
					// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate.
					var mixinsValue = node.getAttribute(dataDojoMixins),
						types = mixinsValue ? [type].concat(mixinsValue.split(/\s*,\s*/)) : [type];

					// Note: won't find classes declared via dojo/Declaration or any modules that haven't been
					// loaded yet so use try/catch to avoid throw from require()
					try{
						ctor = getCtor(types, options.contextRequire);
					}catch(e){}

					// If the constructor was not found, check to see if it has modules that can be loaded
					if(!ctor){
						darray.forEach(types, function(t){
							if(~t.indexOf('/') && !midsHash[t]){
								// If the type looks like a MID and it currently isn't in the array of MIDs to load, add it.
								midsHash[t] = true;
								mids[mids.length] = t;
							}
						});
					}

					var childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children

					// Setup meta data about this widget node, and save it to list of nodes to instantiate
					current = {
						types: types,
						ctor: ctor,
						parent: parent,
						node: node,
						scripts: childScripts
					};
					current.inherited = getEffective(current); // dir & lang settings for current node, explicit or inherited
					list.push(current);
				}else{
					// Meta data about this non-widget node
					current = {
						node: node,
						scripts: scripts,
						parent: parent
					};
				}

				// Recurse, collecting <script type="dojo/..."> children, and also looking for
				// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
				// When finished with children, go to my next sibling.
				scripts = childScripts;
				scriptsOnly = node.stopParser || (ctor && ctor.prototype.stopParser && !(options.template));
				parent = current;
				node = firstChild;
			}

			var d = new Deferred();

			// If there are modules to load then require them in
			if(mids.length){
				// Warn that there are modules being auto-required
				if(has("dojo-debug-messages")){
					console.warn("WARNING: Modules being Auto-Required: " + mids.join(", "));
				}
				var r = options.contextRequire || require;
				r(mids, function(){
					// Go through list of widget nodes, filling in missing constructors, and filtering out nodes that shouldn't
					// be instantiated due to a stopParser flag on an ancestor that we belatedly learned about due to
					// auto-require of a module like ContentPane.   Assumes list is in DFS order.
					d.resolve(darray.filter(list, function(widget){
						if(!widget.ctor){
							// Attempt to find the constructor again.   Still won't find classes defined via
							// dijit/Declaration so need to try/catch.
							try{
								widget.ctor = getCtor(widget.types, options.contextRequire);
							}catch(e){}
						}

						// Get the parent widget
						var parent = widget.parent;
						while(parent && !parent.types){
							parent = parent.parent;
						}

						// Return false if this node should be skipped due to stopParser on an ancestor.
						// Since list[] is in DFS order, this loop will always set parent.instantiateChildren before
						// trying to compute widget.instantiate.
						var proto = widget.ctor && widget.ctor.prototype;
						widget.instantiateChildren = !(proto && proto.stopParser && !(options.template));
						widget.instantiate = !parent || (parent.instantiate && parent.instantiateChildren);
						return widget.instantiate;
					}));
				});
			}else{
				// There were no modules to load, so just resolve with the parsed nodes.   This separate code path is for
				// efficiency, to avoid running the require() and the callback code above.
				d.resolve(list);
			}

			// Return the promise
			return d.promise;
		},

		_require: function(/*DOMNode*/ script, /*Object?*/ options){
			// summary:
			//		Helper for _scanAMD().  Takes a `<script type=dojo/require>bar: "acme/bar", ...</script>` node,
			//		calls require() to load the specified modules and (asynchronously) assign them to the specified global
			//		variables, and returns a Promise for when that operation completes.
			//
			//		In the example above, it is effectively doing a require(["acme/bar", ...], function(a){ bar = a; }).

			var hash = myEval("{" + script.innerHTML + "}"), // can't use dojo/json::parse() because maybe no quotes
				vars = [],
				mids = [],
				d = new Deferred();

			var contextRequire = (options && options.contextRequire) || require;

			for(var name in hash){
				vars.push(name);
				mids.push(hash[name]);
			}

			contextRequire(mids, function(){
				for(var i = 0; i < vars.length; i++){
					dlang.setObject(vars[i], arguments[i]);
				}
				d.resolve(arguments);
			});

			return d.promise;
		},

		_scanAmd: function(root, options){
			// summary:
			//		Scans the DOM for any declarative requires and returns their values.
			// description:
			//		Looks for `<script type=dojo/require>bar: "acme/bar", ...</script>` node, calls require() to load the
			//		specified modules and (asynchronously) assign them to the specified global variables,
			//		and returns a Promise for when those operations complete.
			// root: DomNode
			//		The node to base the scan from.
			// options: Object?
			//		a kwArgs options object, see parse() for details

			// Promise that resolves when all the <script type=dojo/require> nodes have finished loading.
			var deferred = new Deferred(),
				promise = deferred.promise;
			deferred.resolve(true);

			var self = this;
			query("script[type='dojo/require']", root).forEach(function(node){
				// Fire off require() call for specified modules.  Chain this require to fire after
				// any previous requires complete, so that layers can be loaded before individual module require()'s fire.
				promise = promise.then(function(){
					return self._require(node, options);
				});

				// Remove from DOM so it isn't seen again
				node.parentNode.removeChild(node);
			});

			return promise;
		},

		parse: function(rootNode, options){
			// summary:
			//		Scan the DOM for class instances, and instantiate them.
			// description:
			//		Search specified node (or root node) recursively for class instances,
			//		and instantiate them. Searches for either data-dojo-type="Class" or
			//		dojoType="Class" where "Class" is a a fully qualified class name,
			//		like `dijit/form/Button`
			//
			//		Using `data-dojo-type`:
			//		Attributes using can be mixed into the parameters used to instantiate the
			//		Class by using a `data-dojo-props` attribute on the node being converted.
			//		`data-dojo-props` should be a string attribute to be converted from JSON.
			//
			//		Using `dojoType`:
			//		Attributes are read from the original domNode and converted to appropriate
			//		types by looking up the Class prototype values. This is the default behavior
			//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
			//		go away in Dojo 2.0.
			// rootNode: DomNode?
			//		A default starting root node from which to start the parsing. Can be
			//		omitted, defaulting to the entire document. If omitted, the `options`
			//		object can be passed in this place. If the `options` object has a
			//		`rootNode` member, that is used.
			// options: Object?
			//		A hash of options.
			//
			//		- noStart: Boolean?:
			//			when set will prevent the parser from calling .startup()
			//			when locating the nodes.
			//		- rootNode: DomNode?:
			//			identical to the function's `rootNode` argument, though
			//			allowed to be passed in via this `options object.
			//		- template: Boolean:
			//			If true, ignores ContentPane's stopParser flag and parses contents inside of
			//			a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
			//			nested inside the ContentPane to work.
			//		- inherited: Object:
			//			Hash possibly containing dir and lang settings to be applied to
			//			parsed widgets, unless there's another setting on a sub-node that overrides
			//		- scope: String:
			//			Root for attribute names to search for.   If scopeName is dojo,
			//			will search for data-dojo-type (or dojoType).   For backwards compatibility
			//			reasons defaults to dojo._scopeName (which is "dojo" except when
			//			multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			//		- propsThis: Object:
			//			If specified, "this" referenced from data-dojo-props will refer to propsThis.
			//			Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
			//		- contextRequire: Function:
			//			If specified, this require is utilised for looking resolving modules instead of the
			//			`dojo/parser` context `require()`.  Intended for use from the widgets-in-template feature of
			//			`dijit._WidgetsInTemplateMixin`.
			// returns: Mixed
			//		Returns a blended object that is an array of the instantiated objects, but also can include
			//		a promise that is resolved with the instantiated objects.  This is done for backwards
			//		compatibility.  If the parser auto-requires modules, it will always behave in a promise
			//		fashion and `parser.parse().then(function(instances){...})` should be used.
			// example:
			//		Parse all widgets on a page:
			//	|		parser.parse();
			// example:
			//		Parse all classes within the node with id="foo"
			//	|		parser.parse(dojo.byId('foo'));
			// example:
			//		Parse all classes in a page, but do not call .startup() on any
			//		child
			//	|		parser.parse({ noStart: true })
			// example:
			//		Parse all classes in a node, but do not call .startup()
			//	|		parser.parse(someNode, { noStart:true });
			//	|		// or
			//	|		parser.parse({ noStart:true, rootNode: someNode });

			// determine the root node and options based on the passed arguments.
			if(rootNode && typeof rootNode != "string" && !("nodeType" in rootNode)){
				// If called as parse(options) rather than parse(), parse(rootNode), or parse(rootNode, options)...
				options = rootNode;
				rootNode = options.rootNode;
			}
			var root = rootNode ? dom.byId(rootNode) : dwindow.body();
			options = options || {};

			var mixin = options.template ? { template: true } : {},
				instances = [],
				self = this;

			// First scan for any <script type=dojo/require> nodes, and execute.
			// Then scan for all nodes with data-dojo-type, and load any unloaded modules.
			// Then build the object instances.  Add instances to already existing (but empty) instances[] array,
			// which may already have been returned to caller.  Also, use otherwise to collect and throw any errors
			// that occur during the parse().
			var p =
				this._scanAmd(root, options).then(function(){
					return self.scan(root, options);
				}).then(function(parsedNodes){
					return self._instantiate(parsedNodes, mixin, options, true);
				}).then(function(_instances){
					// Copy the instances into the instances[] array we declared above, and are accessing as
					// our return value.
					return instances = instances.concat(_instances);
				}).otherwise(function(e){
					// TODO Modify to follow better pattern for promise error management when available
					console.error("dojo/parser::parse() error", e);
					throw e;
				});

			// Blend the array with the promise
			dlang.mixin(instances, p);
			return instances;
		}
	};

	if( 1 ){
		dojo.parser = parser;
	}

	// Register the parser callback. It should be the first callback
	// after the a11y test.
	if(config.parseOnLoad){
		ready(100, parser, "parse");
	}

	return parser;
});

},
'curam/widget/TransferList':function(){
define(["dijit/_Widget",
        "dojo/_base/declare",
        "dojo/dom-class",
        "dojo/dom-attr",
        "dojo/dom-construct",
        "dojo/dom",
        "dojo/query",
        "curam/debug"
        ], function(widget, declare, domClass, domAttr, domConstruct, dom, query, debug) {
  
  var TransferList = declare("curam.widget.TransferList", dijit._Widget, {
    btnNames : ['allRight','toRight','toLeft','allLeft'],
    btnValues : [' ', ' ', ' ', ' '],
    //create an array for all css classes to be added for button
    bntClasses:["allRight","toRight","toLeft","allLeft"], 
    //rightEmptyText was decided to be left as an empty string
    rightEmptyText : "",
    widgetType:"TransferList",
  
    postCreate: function(){
      
      var parentCell = this.domNode.parentNode;
      domClass.add(parentCell, 'transferlistparent');
	  var sibling=query(this.domNode).next()[0];
      
      this.leftList = this.domNode;
      var newTable = domConstruct.create('table', {
        "class" : 'transfer-list', role : "presentation"
      });
      var newBody = domConstruct.create('tbody', {}, newTable);
      var newRow = domConstruct.create('tr', {}, newBody);
      var leftCell = domConstruct.create('td');

      var crtlCell = domConstruct.create('td', {"class" : "controls"});
      var self = this;
      
      function makeCallback(name){
        return function(){
          self.setSelection(name);
          return false;
        };
      }
      //add a class to the button when it is pressed down
      function buttonActive(id){
        return function(){
                domClass.add(dom.byId(id),"active");
                return false;
                };
      }
      //remove the class when it is released
      function buttonBack(id){
        return function(){
                        domClass.remove(dom.byId(id),"active");
                        return false;
                };
      }
      for (j = 0; j<4; j++) {
        var wrapDiv = domConstruct.create('div', {}, crtlCell);
        var titleTextArray = new Array(
          LOCALISED_TRANSFER_LIST_RA, 
          LOCALISED_TRANSFER_LIST_R, 
          LOCALISED_TRANSFER_LIST_L, 
          LOCALISED_TRANSFER_LIST_LA);
        var btn = domConstruct.create('input', {
          type: 'button',
          id: this.btnNames[j] + this.domNode.name,
          value: this.btnValues[j],
          //add css class to the button
          "class":this.bntClasses[j],
          "title":titleTextArray[j]
        }, wrapDiv);
        btn.listtwins=this;
        dojo.connect(btn, "onclick", makeCallback(btn.id));
        //change the arrow image for the button when the button is clicked
        dojo.connect(btn,"onmousedown",buttonActive(btn.id));
        dojo.connect(btn,"onmouseup",buttonBack(btn.id));
        dojo.connect(btn,"onmouseout",buttonBack(btn.id));
        
      }
      var rListCell = document.createElement('td');
      var rList = domConstruct.create('select', {
        id: this.domNode.name,
        name: this.domNode.name,
        title: LOCALISED_TRANSFER_LIST_SELECTED_ITEMS,
        multiple: 'multiple',
        "class": 'selected',
        size: 5
      }, rListCell);
      domAttr.set(this.domNode, {
        name: '__o3ign.' + rList.name,
        id: '__o3ign.' + rList.name,
        "class": 'selected',
        size: 5
      });

      this.rightList = rList;
      
      dojo.connect(this.leftList,"ondblclick",makeCallback('toRight'));
      dojo.connect(this.rightList,"ondblclick",makeCallback('toLeft'));
      
      function makeKeyCallback(name){
        return function(evt){
          if(evt.keyCode==evt.KEY_ENTER){
            self.setSelection(name);
          }
          return false;
        };
        
      }
      
      dojo.connect(this.leftList,"onkeydown",makeKeyCallback('toRight'));
      dojo.connect(this.rightList,"onkeydown",makeKeyCallback('toLeft'));
      
      leftCell.appendChild(this.domNode);
      newRow.appendChild(leftCell);
      newRow.appendChild(crtlCell);
      newRow.appendChild(rListCell);

      if(sibling){
        parentCell.insertBefore(newTable, sibling);
      }else{
        parentCell.appendChild(newTable);
      }
      
      this.setInitialSelection();
      this.adjustEmpties(this.leftList, this.rightList);
	  var form = query(this.domNode).closest("form")[0];
      if(!form){
        debug.log("curam.widget.TransferList " 
          + debug.getProperty("curam.widget.TransferList.msg"));
        return;
      }
      dojo.connect(form, "onsubmit", function(){
        var currentList = self.rightList;
        var listOpts = new Array();
        for (k1=0; k1<currentList.options.length; k1++) {
          listOpts[listOpts.length] = currentList.options[k1];
        }
        currentList.options.length=0;
        for (k2=0; k2<listOpts.length; k2++) {
          listOpts[k2].selected=true;
          currentList.appendChild(listOpts[k2]);
        }
      });
      //add the selectWidthSetting() and auto resize the select
      //box size when resizing the window
      dojo.connect(window, 'onresize', this.selectWidthSetting);
      dojo.addOnLoad(this.selectWidthSetting);

      // Add titles to options based on the option text. To create tool tips.
      var addTooltips = function(list) {
        for (var i = 0; i < list.options.length; i++) {
          if(list.options[i].text) {
            list.options[i].title = list.options[i].text;
          }
        }
      };
      addTooltips(self.leftList);
      addTooltips(self.rightList);

    },
    
   setSelection : function(id){
      var moveAll = (id.indexOf('all')>-1);
      var currentSrc = (id.indexOf('Right')>-1) ? 
                                this.leftList : this.rightList;
      var currentTgt = (id.indexOf('Left')>-1) ? 
                                this.leftList : this.rightList;
      if (currentSrc.options[0] != null
            && currentSrc.options[0].text != this.rightEmptyText) {
        if (currentTgt.options[0] != null
            && (currentTgt.options[0].text == this.rightEmptyText
                //if USE_BLANK=true in UIM, then
                //when moving text string from left selection box to right selection box
                //replace blank string with the text string.
                || currentTgt.options[0].text == "")) {
          currentTgt.options[0] = null;
        }
        this.transferOptions(currentSrc,currentTgt,moveAll);
        this.adjustEmpties(this.leftList, this.rightList);
      }
    },
    setInitialSelection : function(){
      this.transferOptions(this.leftList,this.rightList,false);
    },
    
    adjustEmpties : function(leftList, rightList){
      if (rightList.options.length==0) {
        rightList.options[0]=new Option(this.rightEmptyText, '', false, false);
      }
    },
    transferOptions : function(currentSrc, currentTgt, moveAll) {
      if (currentSrc && currentTgt) {
        var allSelected = new Array();
        dojo.forEach(currentSrc.options, function(opt){
          if (moveAll || opt.selected) {
           allSelected[allSelected.length] = opt;
          }
        });
        this.appendAll(currentTgt, allSelected);
      }
    },
    appendAll : function(aList, children) {
      for (var i=0; i<children.length; i++) {
        children[i].selected=true;
        aList.appendChild(children[i]);
      }
    },
    //fix the width of select box after it is loaded
    selectWidthSetting: function(){
        if(dojo.query(".transfer-list select.selected")){
                    
                dojo.query(".transfer-list select.selected").forEach(function(selectNode){
                        var width = selectNode.parentNode.clientWidth;
                        selectNode.style.width=width + "px";
                });    
        }
    }
  });
  
  return TransferList;
});

},
'dojo/promise/all':function(){
define([
	"../_base/array",
	"../Deferred",
	"../when"
], function(array, Deferred, when){
	"use strict";

	// module:
	//		dojo/promise/all

	var some = array.some;

	return function all(objectOrArray){
		// summary:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected.
		// description:
		//		Takes multiple promises and returns a new promise that is fulfilled
		//		when all promises have been resolved or one has been rejected. If one of
		//		the promises is rejected, the returned promise is also rejected. Canceling
		//		the returned promise will *not* cancel any passed promises.
		// objectOrArray: Object|Array?
		//		The promise will be fulfilled with a list of results if invoked with an
		//		array, or an object of results when passed an object (using the same
		//		keys). If passed neither an object or array it is resolved with an
		//		undefined value.
		// returns: dojo/promise/Promise

		var object, array;
		if(objectOrArray instanceof Array){
			array = objectOrArray;
		}else if(objectOrArray && typeof objectOrArray === "object"){
			object = objectOrArray;
		}

		var results;
		var keyLookup = [];
		if(object){
			array = [];
			for(var key in object){
				if(Object.hasOwnProperty.call(object, key)){
					keyLookup.push(key);
					array.push(object[key]);
				}
			}
			results = {};
		}else if(array){
			results = [];
		}

		if(!array || !array.length){
			return new Deferred().resolve(results);
		}

		var deferred = new Deferred();
		deferred.promise.always(function(){
			results = keyLookup = null;
		});
		var waiting = array.length;
		some(array, function(valueOrPromise, index){
			if(!object){
				keyLookup.push(index);
			}
			when(valueOrPromise, function(value){
				if(!deferred.isFulfilled()){
					results[keyLookup[index]] = value;
					if(--waiting === 0){
						deferred.resolve(results);
					}
				}
			}, deferred.reject);
			return deferred.isFulfilled();
		});
		return deferred.promise;	// dojo/promise/Promise
	};
});

},
'curam/widget/ComboBoxMixin':function(){
/*
 *  Licensed Materials - Property of IBM
 *  
 *  PID 5725-H26
 *  
 *  Copyright IBM Corporation 2006,2015. All rights reserved.
 *  
 *  US Government Users Restricted Rights - Use, duplication or disclosure
 *  restricted by GSA ADP Schedule Contract with IBM Corp.
 */
/**
 * Override of the Dojo ComboBoxMixin module to load a custom ComboBoxMenu module.
 */
define(["dojo/_base/declare",
         "curam/widget/_ComboBoxMenu",
         "dijit/form/ComboBoxMixin"
], function(declare, _ComboBoxMenu){
  
  /*
   * Modification History
   * --------------------
   * 20-Nov-2015 AZ [CR00472692] Initial Version
   */
  /**
   * @name curam.widget.ComboBoxMixin
   * @namespace Override of the Dojo ComboBoxMixin in order to make the ComboBoxMixin
   *              accessible using screen reader.
   */
  var ComboBoxMixin = declare("curam.widget.ComboBoxMixin", dijit.form.ComboBoxMixin, 
  /**
   * @lends curam.widget.ComboBoxMixin.prototype
   */
  {
    dropDownClass: _ComboBoxMenu
  });
  
  return ComboBoxMixin;
});
},
'curam/cdsl/types/codetable/CodeTable':function(){
/*
 * Copyright 2013 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of Curam
 * Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(['dojo/_base/declare',
        './CodeTableItem'
        ], function(
            declare, CodeTableItem) {

  /**
   * @name curam.cdsl.types.codetable.CodeTable
   * @namespace
   *    Note this class represents a code table for one specific locale.
   *    It does not have capability of holding codes for multiple locales.
   */
  var CodeTable = declare(null,
  /**
   * @lends curam.cdsl.types.codetable.CodeTable.prototype
   */
  {
    _name: null,

    _defaultCode: null,
    
    _codes: null,
    
    _items: null,
    
    /**
     * Not intended for direct instantiation by CDSL API users.
     * 
     * @private
     * 
     * @param name
     * @param defaultCode
     * @param codes
     */
    constructor: function(name, defaultCode, codes) {
      this._name = name;
      this._defaultCode = defaultCode;
      this._codes = this._parseCodesIntoObject(codes);
    },
    
    /**
     * Gets all items of this code table.
     * 
     * @returns {[curam/cdsl/types/codetable/CodeTableItem]} Array of items
     *  contained in this code table.
     */
    listItems: function() {
      this._initItems(this._codes, this._defaultCode);

      var ret = [];
      for (code in this._items) {
        ret.push(this._items[code]);
      }
      return ret;
    },
    
    /**
     * @private
     * 
     * @param codesArray
     * @returns {___anonymous1799_1800}
     */
    _parseCodesIntoObject: function(codesArray) {
      var ret = {};
      
      if (codesArray) {
        for (var i = 0; i < codesArray.length; i++) {
          var raw = codesArray[i];
          var code = raw.split(":")[0];
          var desc = raw.slice(code.length + 1);
          ret[code] = desc;
        }
      }
      
      return ret;
    },
    
    /**
     * @private
     * 
     * @param codes
     * @param defaultCode
     */
    _initItems: function(codes, defaultCode) {
      if (!this._items) {
        this._items = {};
        
        for (code in codes) {
          var cti = new CodeTableItem(code, codes[code]);
          cti.isDefault(code === defaultCode);
          this._items[code] = cti;
        }
      }
    },
    
    /**
     * Gets item for the specified code.
     * 
     * @param {String} code The code to get code table item for.
     * @returns {curam/cdsl/types/codetable/CodeTableItem} The requested code
     *  table item or undefined if no such item exists.
     */
    getItem: function(code) {
      this._initItems(this._codes, this._defaultCode);

      return this._items[code];
    }
  });
  
  return CodeTable;
});

},
'curam/debug':function(){
/*
 * Copyright 2009-2011 Curam Software Ltd.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of
 * Curam Software, Ltd. ("Confidential Information"). You shall not disclose
 * such Confidential Information and shall use it only in accordance with the
 * terms of the license agreement you entered into with Curam Software.
 */

define(["curam/define",
        "curam/util/LocalConfig",
        "dojo/ready",
        "dojo/_base/lang",
        "curam/util/ResourceBundle"], function(define, localConfig, ready, lang, resBundle) {
  
  var debugBundle = new resBundle("curam.application.Debug");
  
  /*
   * Modification History
   * --------------------
   * 05-Mar-2014 MV [CR00421036] Move to using LocalConfig. 
   * 27-Feb-2014 MV [CR00419961] Add support for JavaScript debug configuration.
   * 12-Sep-2011  MV  [CR00286500] Fix stack overflow when logging window
   *    objects in IE.
   * 11-May-2011  MV  [CR00265902] Fixed log function invocation.
   * 26-Jan-2011  MV  [CR00244801] Fixed check for DEBUG flag.
   * 21-Jan-2011  DG  [CR00243540] Added note on new way to set DEBUG variable.
   *                    Added copyright. Tidied up formatting.
   * 26-Jun-2010  MV  [CR00204069] Improve to enable passing many number
   *                    of parameters. Enable easier usage by removing class
   *                    declaration and shortening the name.
   * 06-Nov-2009  SC  [CR00172239] Initial Version
   */
  /**
   * Provides a simple logging facility for debug tracing to the JavaScript
   * console.
   */
  define.singleton("curam.debug", {
    /**
     * A logging facility that can be turned on or off using the
     * "curam.trace.javascript" application property. Debug tracing is disabled
     * by default; use your application admin screens to enable it.
     * Any number of parameters can be passed. These are forwarded
     * to the <code>console.log.apply</code> function.
     */
    log: function() {
      //debugger;
      if (curam.debug.enabled()) {
        try {
          var a = arguments;
          if (!dojo.isIE) {
            console.log.apply(console, a);
          
          // the above generic call doesn't work in IE  so the following ugly
          // specific handling must be provided
          } else {
            var numArgs = a.length;
            var sa = curam.debug._serializeArgument;
            switch(numArgs) {
              case 1: console.log(arguments[0]);
              break;
              
              case 2: console.log(a[0], sa(a[1]));
              break;
              
              case 3: console.log(a[0], sa(a[1]), sa(a[2]));
              break;
              
              case 4: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]));
              break;
              
              case 5: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]));
              break;
              
              case 6: console.log(a[0], sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]),
                  sa(a[5]));
              break;
              
              default: console.log("[Incomplete message - " + (numArgs - 5)
                  + " message a truncated] " + a[0],
                  sa(a[1]), sa(a[2]), sa(a[3]), sa(a[4]), sa(a[5]));
            }
          }

        } catch (e) {
          console.log(e);
          // Some problem with the console. Do nothing.
        }
      }
    },
    
    getProperty : function(key, substValues) {
      return debugBundle.getProperty(key, substValues);
    },
    
    /**
     * Make a human readable version of the object to be logged.
     *
     * @param arg The object to be serialized.
     * @returns The human readable version of the object.
     */
    _serializeArgument: function(arg) {
      if (typeof arg != "undefined"
          && typeof arg.nodeType != "undefined"
          && typeof arg.cloneNode != "undefined") { // isNode 
        // DOM nodes can't be serialized using dojo.toJson(), so just return
        // default toString version
        return "" + arg;

      } else if (curam.debug._isWindow(arg)) {
        // window object causes stack overflow for dojo.toJson() so handling 
        // specifically here
        return arg.location.href;

      } else if (curam.debug._isArray(arg)
            && curam.debug._isWindow(arg[0])) { // is array of window objects
        // array of window objects causes stack overflow for dojo.toJson()
        // so handling specifically here
        return "[array of window objects, length " + arg.length + "]";

      } else {
        return dojo.toJson(arg);
      }
    },
    
    /**
     * Recognizes array objects.
     * 
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is array, otherwise false.
     */
    _isArray: function(arg) {
      return typeof arg != "undefined"
          && (dojo.isArray(arg) || typeof arg.length != "undefined");
    },

    /**
     * Recognizes window object.
     *
     * @param arg The object to be checked.
     * @returns {Boolean} True if the argument is a window object,
     *    otherwise false.
     */
    _isWindow: function(arg) {
      // some of the significant properties might be undefined fo closed window
      // so handle this case separately
      var isClosed = typeof arg != "undefined"
        && typeof arg.closed != "undefined" && arg.closed;
      if (isClosed) {
        // it is a closed window
        return true;
      
      } else {
        return typeof arg != "undefined"
            && typeof arg.location != "undefined"
            && typeof arg.navigator != "undefined"
            && typeof arg.document != "undefined"
            && typeof arg.closed != "undefined";
      }
    },
    
    enabled: function() {
      return localConfig.readOption('jsTraceLog', 'false') == 'true';
    },
    
    /**
     * Performs setup of the debug/tracing infrastructure.
     * This is called from the application main page to setup debug.
     *
     * @param {Object} config Configuration data.
     */
    _setup: function(config) {
      localConfig.seedOption('jsTraceLog', config.trace, 'false');
      localConfig.seedOption('ajaxDebugMode', config.ajaxDebug, 'false');
      localConfig.seedOption('asyncProgressMonitor',
          config.asyncProgressMonitor, 'false');
    }
  });
  
  return curam.debug;
});

},
'dijit/TooltipDialog':function(){
define([
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.replace
	"dojo/has",
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"./focus",
	"./layout/ContentPane",
	"./_DialogMixin",
	"./form/_FormMixin",
	"./_TemplatedMixin",
	"dojo/text!./templates/TooltipDialog.html",
	"./main"        // exports methods to dijit global
], function(declare, domClass, has, keys, lang, on, focus, ContentPane, _DialogMixin, _FormMixin, _TemplatedMixin, template, dijit){

	// module:
	//		dijit/TooltipDialog


	var TooltipDialog = declare("dijit.TooltipDialog",
		[ContentPane, _TemplatedMixin, _FormMixin, _DialogMixin], {
			// summary:
			//		Pops up a dialog that appears like a Tooltip

			// title: String
			//		Description of tooltip dialog (required for a11y)
			title: "",

			// doLayout: [protected] Boolean
			//		Don't change this parameter from the default value.
			//		This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
			//		is never a child of a layout container, nor can you specify the size of
			//		TooltipDialog in order to control the size of an inner widget.
			doLayout: false,

			// autofocus: Boolean
			//		A Toggle to modify the default focus behavior of a Dialog, which
			//		is to focus on the first dialog element after opening the dialog.
			//		False will disable autofocusing.  Default: true.
			autofocus: true,

			// baseClass: [protected] String
			//		The root className to use for the various states of this widget
			baseClass: "dijitTooltipDialog",

			// _firstFocusItem: [private readonly] DomNode
			//		The pointer to the first focusable node in the dialog.
			//		Set by `dijit/_DialogMixin._getFocusItems()`.
			_firstFocusItem: null,

			// _lastFocusItem: [private readonly] DomNode
			//		The pointer to which node has focus prior to our dialog.
			//		Set by `dijit/_DialogMixin._getFocusItems()`.
			_lastFocusItem: null,

			templateString: template,

			_setTitleAttr: "containerNode",

			postCreate: function(){
				this.inherited(arguments);
				this.own(on(this.domNode, "keydown", lang.hitch(this, "_onKey")));
			},

			orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner){
				// summary:
				//		Configure widget to be displayed in given position relative to the button.
				//		This is called from the dijit.popup code, and should not be called
				//		directly.
				// tags:
				//		protected

				// Note: intentionally not using dijitTooltip class since that sets position:absolute, which
				// confuses dijit/popup trying to get the size of the tooltip.
				var newC = {
					// Real around node
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft",

					// Positioning "around" a point, ex: mouse position
					"BR-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"BL-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TL-BR": "dijitTooltipAbove dijitTooltipABRight",
					"TR-BL": "dijitTooltipAbove dijitTooltipABLeft"
				}[aroundCorner + "-" + tooltipCorner];

				domClass.replace(this.domNode, newC, this._currentOrientClass || "");
				this._currentOrientClass = newC;

				// Tooltip.orient() has code to reposition connector for when Tooltip is before/after anchor.
				// Not putting here to avoid code bloat, and since TooltipDialogs are generally above/below.
				// Should combine code from Tooltip and TooltipDialog.
			},

			focus: function(){
				// summary:
				//		Focus on first field
				this._getFocusItems();
				focus.focus(this._firstFocusItem);
			},

			onOpen: function(/*Object*/ pos){
				// summary:
				//		Called when dialog is displayed.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected

				this.orient(this.domNode, pos.aroundCorner, pos.corner);

				// Position the tooltip connector for middle alignment.
				// This could not have been done in orient() since the tooltip wasn't positioned at that time.
				var aroundNodeCoords = pos.aroundNodePos;
				if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
					this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
					this.connectorNode.style.left = "";
				}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
					this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
				}

				this._onShow(); // lazy load trigger  (TODO: shouldn't we load before positioning?)
			},

			onClose: function(){
				// summary:
				//		Called when dialog is hidden.
				//		This is called from the dijit.popup code, and should not be called directly.
				// tags:
				//		protected
				this.onHide();
			},

			_onKey: function(/*Event*/ evt){
				// summary:
				//		Handler for keydown events
				// description:
				//		Keep keyboard focus in dialog; close dialog on escape key
				// tags:
				//		private

				if(evt.keyCode == keys.ESCAPE){
					// Use defer to avoid crash on IE, see #10396.  Not sure if this is still needed or not.
					// If this if() wasn't here, presumably dijit/popup would catch the ESCAPE key and close the popup.
					this.defer("onCancel");
					evt.stopPropagation();
					evt.preventDefault();
				}else if(evt.keyCode == keys.TAB){
					var node = evt.target;
					this._getFocusItems();
					if(this._firstFocusItem == this._lastFocusItem){
						evt.stopPropagation();
						evt.preventDefault();
					}else if(node == this._firstFocusItem && evt.shiftKey){
						focus.focus(this._lastFocusItem); // send focus to last item in dialog
						evt.stopPropagation();
						evt.preventDefault();
					}else if(node == this._lastFocusItem && !evt.shiftKey){
						focus.focus(this._firstFocusItem); // send focus to first item in dialog
						evt.stopPropagation();
						evt.preventDefault();
					}else{
						// we want the browser's default tab handling to move focus
						// but we don't want the tab to propagate upwards
						evt.stopPropagation();
					}
				}
			}
		});

	if(has("dojo-bidi")){
		TooltipDialog.extend({
			_setTitleAttr: function(/*String*/ title){
				this.containerNode.title = (this.textDir && this.enforceTextDirWithUcc) ? this.enforceTextDirWithUcc(null, title) : title;
				this._set("title", title);
			},

			_setTextDirAttr: function(/*String*/ textDir){
				if(!this._created || this.textDir != textDir){
					this._set("textDir", textDir);
					if(this.textDir && this.title){
						this.containerNode.title = this.enforceTextDirWithUcc(null, this.title);
					}
				}
			}
		});
	}

	return TooltipDialog;
});

},
'url:curam/widget/templates/AppBannerDropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft appBannerComboBox\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\taria-haspopup=\"true\"\n\tdata-dojo-attach-point=\"_popupStateNode\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner appBannerComboBoxInput' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\n\t/></div\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner appBannerComboBoxArrow\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n></div>\n",
'url:curam/layout/resources/UIMController.html':"<div id=\"uimcontroller_${uid}\" class=\"uimcontroller_${uid} uimController ${classList}\" data-dojo-attach-point=\"uimController\">\n  <div style=\"display:none;\" \n       id=\"uimcontroller_tc_${uid}\" \n       class=\"ipnTabController in-page-nav-tabContainer\"\n       data-dojo-attach-point=\"tabController\" \n       data-dojo-type=\"curam/layout/TabContainer\">\n  </div>\n  <div class=\"contentPanelFrameWrapper\"  \n        data-dojo-attach-point=\"frameWrapper\">\n    <iframe frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\"\n             allowTransparency=\"true\" \n             id=\"${iframeId}\" \n             data-dojo-attach-point=\"frame\"                 \n             class=\"${iframeId} ${iframeClassList}\"\n             iscpiframe=\"${iscpiframe}\"\n             title=\"${title}\" >\n    </iframe>\n  </div> \n</div>",
'url:curam/widget/templates/OptimalBrowserMessage.html':"<div>\n  <div class=\"hidden\"\n       data-dojo-type=\"dojox/layout/ContentPane\"\n       data-dojo-attach-point=\"_optimalMessage\">\n  </div>\n</div>\n",
'url:curam/widget/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\tdata-dojo-attach-point=\"valueNode\" role=\"presentation\" aria-hidden=\"true\"\n/></span>\n",
'url:dijit/form/templates/Select.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tdata-dojo-attach-point=\"_buttonNode,tableNode,focusNode,_popupStateNode\" cellspacing='0' cellpadding='0'\n\trole=\"listbox\" aria-haspopup=\"true\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonContents\" role=\"presentation\"\n\t\t\t><div class=\"dijitReset dijitInputField dijitButtonText\"  data-dojo-attach-point=\"containerNode,textDirNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitValidationContainer\"\n\t\t\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t/></div\n\t\t\t><input type=\"hidden\" ${!nameAttrSetting} data-dojo-attach-point=\"valueNode\" value=\"${value}\" aria-hidden=\"true\"\n\t\t/></td\n\t\t><td class=\"dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer\"\n\t\t\tdata-dojo-attach-point=\"titleNode\" role=\"presentation\"\n\t\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t${_buttonInputDisabled}\n\t\t/></td\n\t></tr></tbody\n></table>\n",
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:dijit/templates/MenuSeparator.html':"<tr class=\"dijitMenuSeparator\" role=\"separator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n",
'url:curam/widget/templates/SearchMultipleTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner searchTextBox input-placeholder-closed\" data-dojo-attach-point='textbox,focusNode'\n\t\t\tdata-dojo-attach-event=\"onFocus:_givenFocus,onblur:_onBlur, onpaste:_onPaste\" autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}' \n\t/></div\n></div>\n",
'url:dijit/templates/TitlePane.html':"<div>\n\t<div data-dojo-attach-event=\"ondijitclick:_onTitleClick, onkeydown:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" data-dojo-attach-point=\"titleBarNode\" id=\"${id}_titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" data-dojo-attach-point=\"focusNode\">\n\t\t\t<span data-dojo-attach-point=\"arrowNode\" class=\"dijitInline dijitArrowNode\" role=\"presentation\"></span\n\t\t\t><span data-dojo-attach-point=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span data-dojo-attach-point=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" data-dojo-attach-point=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" data-dojo-attach-point=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" data-dojo-attach-point=\"containerNode\" role=\"region\" id=\"${id}_pane\" aria-labelledby=\"${id}_titleBarNode\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\" data-dojo-attach-event=\"mouseenter:onMouseEnter,mouseleave:onMouseLeave\"\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n></div>\n",
'url:curam/layout/resources/CuramBaseModal.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\" aria-live=\"assertive\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\n\t\t\t\trole=\"heading\" level=\"2\"></span>\n\t\t<button data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\"\n          data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\"\n          role=\"button\" tabindex=\"0\" aria-label=\"${closeModalText}\" \n          onKeyDown=\"require(['curam/ModalDialog'], function(md) {md.handleTitlebarIconKeydown(event)});\"\n          style=\"visibility: hidden;\">\n      \t\t<img src=\"${buttonCloseIcon}\" alt=\"${closeModalText}\" class=\"button-close-icon-default\"/>\n      \t\t<img src=\"${buttonCloseIconHover}\" alt=\"${closeModalText}\" class=\"button-close-icon-hover\"/>\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">${closeModalText}</span>\n\t    </button>\n\t</div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n\t${!actionBarTemplate}\n</div>\n",
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:__onClick,onkeydown:_onButtonKeyDown\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeydown:_onArrowKeyDown\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t\t\tclass=\"dijitOffScreen\" aria-hidden=\"true\" data-dojo-attach-event=\"onclick:_onClick\"\n\t\t/></td></tr></tbody\n></table>\n",
'url:curam/widget/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTab\" id=\"${id}_tabButtonContainer\">\n  <div role=\"presentation\" class='dijitTabInnerDiv'>\n    <div role=\"presentation\" class='dijitTabContent'>\n\t    <span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t    <div role=\"presentation\" aria-labelledby='${id}'>\n\t\t    <span data-dojo-attach-point='containerNode,focusNode' class='tabLabel' id='${id}'></span>\n\t\t    <button class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t\t        tabindex=\"-1\">\n\t\t\t    <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>Close Tab</span>\n        \t</button>\n      </div>\n    </div>\n  </div>\n</div>\n",
'url:dijit/templates/MenuBarItem.html':"<div class=\"dijitReset dijitInline dijitMenuItem dijitMenuItemLabel\" data-dojo-attach-point=\"focusNode\"\n\t \trole=\"menuitem\" tabIndex=\"-1\">\n\t<span data-dojo-attach-point=\"containerNode,textDirNode\"></span>\n</div>\n",
'url:curam/layout/resources/CuramCarbonModal.html':"<div class=\"spm-component\">  \n   <div id=\"${id}_modal-root\" data-testid=\"${id}_modal-root\" data-dojo-attach-point=\"carbonModalNode\" class=\"bx--modal\" role=\"presentation\">\n        <div data-dojo-attach-point=\"modalContainer\" aria-modal=\"true\" aria-labelledby=\"${id}_modal-heading\" aria-live=\"assertive\" class=\"bx--modal-container\" data-testid=\"${id}_modal-container\" id=\"${id}_modal-container\" role=\"dialog\" tabindex=\"-1\">\n          <div class=\"bx--modal-header bx--modal-header--with-pair-icons\">\n            <h3 class=\"bx--modal-header__heading bx--type-beta\" data-dojo-attach-point=\"titleNode\" id=\"${id}_modal-heading\" data-testid=\"${id}_modal-heading\">\n              ${_title}\n            </h3>\n            <button data-dojo-attach-point=\"helpIcon\" aria-label=\"${helpTitle}\" class=\"bx--modal-help\" data-dojo-attach-event=\"onclick:displayHelp, onkeypress:displayHelp,onkeydown:escapeOnClose,onkeydown:preventBackwardsTabEscFromModal\" data-testid=\"button_modal.help.button.icon\" id=\"${id}_modal-help\" type=\"button\">\n              <svg focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\">\n               <defs><style>.cls-1{fill:none;}</style></defs>\n               <title>${helpTitle}</title>\n               <path d=\"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z\"/>\n               <circle cx=\"16\" cy=\"23.5\" r=\"1.5\"/>\n               <path d=\"M17,8H15.5A4.49,4.49,0,0,0,11,12.5V13h2v-.5A2.5,2.5,0,0,1,15.5,10H17a2.5,2.5,0,0,1,0,5H15v4.5h2V17a4.5,4.5,0,0,0,0-9Z\"/>\n               <rect class=\"cls-1\" width=\"32\" height=\"32\"/>\n             </svg>\n            </button> \n            <button data-dojo-attach-point=\"closeButton\" aria-label=\"${closeTitle}\" class=\"bx--modal-close\" data-dojo-attach-event=\"onclick:hideAndClose,onkeydown:escapeOnClose,onkeydown:preventBackwardsTabEscFromModal\" data-testid=\"button_modal.close.button.icon\" id=\"${id}_modal-button-close\" type=\"button\">\n              <svg aria-hidden=\"true\" class=\"bx--modal-close__icon\" focusable=\"false\" preserveAspectRatio=\"xMidYMid meet\" style=\"will-change: transform;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\">\n                <title>${closeTitle}</title>\n                <path d=\"M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z\"></path>\n              </svg>\n            </button>\n          </div>\n\n          <div class=\"bx--modal-content bx--modal-scroll-content bx--modal-content--with-iframe\" data-dojo-attach-point=\"containerNode\" data-testid=\"${id}_modal-content\" id=\"${id}_modal-content\">\n          </div>\n          <div class=\"bx--modal-content--overflow-indicator\"></div>\n          <div data-dojo-attach-point=\"modalFooter\" class=\"bx--modal-footer\" data-testid=\"${id}_modal-footer\" id=\"${id}_modal-footer\"></div>\n          <span data-dojo-attach-event=\"onkeydown:escapeOnClose,onfocus:preventForwardsTabEscFromModal\" id=\"modal-end_${id}\" tabindex=\"0\"></span>\n        </div>\n    </div>\n</div>",
'url:curam/layout/resources/ModalUIMController.html':"<div id=\"uimcontroller_${uid}\" \n  class=\"uimcontroller_${uid} uimController ${classList}\" \n  data-dojo-attach-point=\"uimController\">\n  <div style=\"display:none;\" \n       id=\"uimcontroller_tc_${uid}\" \n       class=\"ipnTabController in-page-nav-tabContainer\"\n       data-dojo-attach-point=\"tabController\" \n       data-dojo-type=\"curam.layout.TabContainer\">\n  </div>\n  <div class=\"contentPanelFrameWrapper\"\n       data-dojo-attach-point=\"frameWrapper\">\n    <iframe frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\"\n            allowTransparency=\"true\" \n            id=\"${iframeId}\" \n            data-dojo-attach-point=\"frame\"                 \n            class=\"${iframeId} ${iframeClassList}\"\n            iscpiframe=\"${iscpiframe}\"\n            title=\"${title}\" >\n    </iframe>\n    <span onFocus=\"require(['curam/ModalDialog'], function(md) {md.handleFocusAtEnd(event)});\"\n          tabIndex=\"0\" class=\"hidden\" id=\"end-${uid}\" style=\"visibility: hidden;\">${endModalUIMController}</span>\n  </div>\n</div>",
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\"\n\t   cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n",
'url:curam/layout/resources/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer dijitAlignTop\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container dijitAlignClient\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'url:dijit/form/templates/DropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\taria-haspopup=\"true\"\n\tdata-dojo-attach-point=\"_popupStateNode\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\n\t/></div\n></div>\n",
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:dijit/templates/TreeNode.html':"<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\"\n\t\t><span data-dojo-attach-point=\"expandoNode\" class=\"dijitInline dijitTreeExpando\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"></span\n\t\t><span data-dojo-attach-point=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTreeIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span data-dojo-attach-point=\"labelNode,focusNode\" class=\"dijitTreeLabel\" role=\"treeitem\"\n\t\t\t\t   tabindex=\"-1\" aria-selected=\"false\" id=\"${id}_label\"></span>\n\t\t</span\n\t></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeNodeContainer\" role=\"presentation\"\n\t\t style=\"display: none;\" aria-labelledby=\"${id}_label\"></div>\n</div>\n",
'url:dijit/templates/MenuBar.html':"<div class=\"dijitMenuBar dijitMenuPassive\" data-dojo-attach-point=\"containerNode\" role=\"menubar\" tabIndex=\"${tabIndex}\"\n\t ></div>\n",
'url:curam/widget/templates/SearchTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner searchTextBox input-placeholder-closed\" data-dojo-attach-point='textbox,focusNode' data-dojo-attach-event=\"onclick:__onClick,onFocus:__onClick,onblur:__onBlur,onkeyup:__onKeyUp,onpaste:__onPaste\" autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'url:curam/layout/resources/CuramStackButton.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\">\n  <span class=\"dijitReset dijitInline dijitButtonNode\"\n  data-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\">\n    <span class=\"dijitReset dijitStretch dijitButtonContents\" data-dojo-attach-point=\"titleNode,focusNode\"\n    role=\"button\" aria-labelledby=\"${id}_label\">\n      <span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span>\n      <span class=\"dijitReset dijitInline curamButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\"></span>\n      <img alt=\"${imageAltText}\" src=\"${imageDefaultSrc}\" class=\"defaultIcon\">\n      <img alt=\"${imageAltText}\" src=\"${imageHoverSrc}\" class=\"hoverIcon\">\n    </span>\n  </span>\n  <input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" data-dojo-attach-event=\"onclick:_onClick\"\n  tabIndex=\"-1\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"/>\n</span>",
'url:dijit/templates/TooltipDialog.html':"<div role=\"alertdialog\" tabIndex=\"-1\">\n\t<div class=\"dijitTooltipContainer\" role=\"presentation\">\n\t\t<div data-dojo-attach-point=\"contentsNode\" class=\"dijitTooltipContents dijitTooltipFocusNode\">\n\t\t\t<div data-dojo-attach-point=\"containerNode\"></div>\n\t\t\t${!actionBarTemplate}\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTooltipConnector\" role=\"presentation\" data-dojo-attach-point=\"connectorNode\"></div>\n</div>\n",
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode,innerDiv,tabContent\" class=\"dijitTabInner dijitTabContent\">\n\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitTabButtonIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point='containerNode,focusNode' class='tabLabel'></span>\n\t<span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t  role=\"presentation\">\n\t\t<span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t\t\t></span>\n</div>\n",
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\"\n\t\ttabIndex=\"-1\" aria-hidden=\"true\" data-dojo-attach-point=\"valueNode\"\n/></span>\n",
'url:curam/layout/resources/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition} tabStrip-disabled dijitLayoutContainer\"><!-- CURAM-FIX: removed style=\"visibility:hidden, dd the tabStrip-disabled class by default.\" -->\n\t<div data-dojo-type=\"curam.layout._ScrollingTabControllerMenuButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_menuBtn\"\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"Navigation menu\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_leftBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:'Navigation left'\"\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_rightBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:'Navigation right'\"\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper dijitTabContainerTopNone dijitAlignClient' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip dijitTabContainerTop-tabs'></div>\n\t</div>\n</div>",
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition} tabStrip-disabled dijitLayoutContainer\"><!-- CURAM-FIX: removed style=\"visibility:hidden, dd the tabStrip-disabled class by default.\" -->\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_menuBtn\"\n\t\t data-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t data-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"Navigation menu\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_leftBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:'Navigation left'\"\n\t\t data-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t class=\"tabStripButton-${tabPosition}\"\n\t\t id=\"${id}_rightBtn\"\n\t\t data-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:'Navigation right'\"\n\t\t data-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper dijitTabContainerTopNone dijitAlignClient' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeydown:onkeydown'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip dijitTabContainerTop-tabs'></div>\n\t</div>\n</div>",
'url:dijit/templates/Tree.html':"<div role=\"tree\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\n\t<div class=\"dijitTreeExpando dijitTreeExpandoLoading\" data-dojo-attach-point=\"rootLoadingIndicator\"></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\">\n\t</div>\n</div>\n",
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"\n\t\t\t\trole=\"heading\" level=\"1\"></span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabindex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n\t${!actionBarTemplate}\n</div>\n\n",
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span role=\"presentation\" class=\"dijitInline dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,textDirNode\"\n\t\trole=\"presentation\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<span data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<span class=\"dijitInline dijitIcon dijitMenuExpand\"></span>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</span>\n\t</td>\n</tr>\n",
'url:curam/widget/templates/ComboBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n    role=\"listbox\"\n\taria-haspopup=\"true\"\n\tdata-dojo-attach-point=\"_popupStateNode\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"button presentation\" aria-hidden=\"true\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n    ><div class=\"dijitReset dijitInputField dijitInputContainer\" role=\"listbox\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\"\n\t/></div\n></div>\n",
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"focusNode\" role=\"button\">\n  <div role=\"presentation\" class=\"dijitTabInnerDiv\">\n    <div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\">\n\t<span role=\"presentation\" class=\"dijitInline dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n</div>  </div>\n</div>",
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset\" data-dojo-attach-point=\"focusNode\" role=\"${role}\" tabIndex=\"-1\" aria-checked=\"${checked}\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<span class=\"dijitInline dijitIcon dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"></span>\n\t\t<span class=\"dijitMenuItemIconChar dijitCheckedMenuItemIconChar\">${!checkedChar}</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode,textDirNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n",
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:__onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode,_popupStateNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onclick:_onClick\" data-dojo-attach-point=\"valueNode\" aria-hidden=\"true\"\n/></span>\n",
'*now':function(r){r(['dojo/i18n!*preload*dojo/nls/cdej*["ar","ca","cs","da","de","el","en-gb","en-us","es-es","fi-fi","fr-fr","he-il","hu","it-it","ja-jp","ko-kr","nl-nl","nb","pl","pt-br","pt-pt","ru","sk","sl","sv","th","tr","zh-tw","zh-cn","ROOT"]']);}
}});
define("dojo/cdej", [], 1);
